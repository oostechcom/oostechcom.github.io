{"meta":{"title":"oosTech","subtitle":"","description":"","author":"Sam Lee","url":"http://www.oostech.com","root":"/"},"pages":[{"title":"文档分类","date":"2021-02-14T14:35:56.000Z","updated":"2021-02-14T14:35:56.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.oostech.com/categories/index.html","excerpt":"","text":""},{"title":"常用链接","date":"2021-02-17T06:52:07.393Z","updated":"2021-02-17T06:52:07.393Z","comments":true,"path":"links/index.html","permalink":"http://www.oostech.com/links/index.html","excerpt":"","text":""},{"title":"共享白板","date":"2021-02-18T10:25:56.997Z","updated":"2021-02-18T10:25:56.997Z","comments":true,"path":"repository/index.html","permalink":"http://www.oostech.com/repository/index.html","excerpt":"","text":"启动白板"}],"posts":[{"title":"Red Hat Enterprise Linux 8 的新玩意 第6篇 module 的简介及操作示例","slug":"RHEL8_CentOS8_module_introduction","date":"2021-02-19T16:00:00.000Z","updated":"2021-02-19T16:00:00.000Z","comments":false,"path":"2021/02/20/RHEL8_CentOS8_module_introduction/","link":"","permalink":"http://www.oostech.com/2021/02/20/RHEL8_CentOS8_module_introduction/","excerpt":"","text":"1 概述这个文档介绍了在RHEL8.x ，CentOS8.x 上面, 如何对AppStream 软件仓库中的模块进行查询，安装，等操作。适用于Linux 系统的管理人员，维护人员等。 2 软件包介绍从RHEL8,CentOS8 开始，软件包分为两个主要的仓库，BaseOS 和 AppStream。 BaseOS提供了OS 的基础软件包，例如grub2， kernel，lib 等等。这个仓库里面的软件包是以RPM 格式直接提供的。 AppStream提供了用户应用程序，例如http, python, php, gcc 等等。这个仓库里面软件包则是通过两种格式提供，一个是RPM 格式，而另外一个就是module 了。这可能会问，为什么会使用这样的方式来管理呢？ 主要是这样的： 这样可以同时提供多个版本用户应用程序，具有更多灵活性 这样可以方便使用到最新的用户应用程序，便于随时根据需要随时升降级 应用升级，降级不会影响到基础软件包（如通过BaseOS提供的内容） 这样可以把一系列相关的用户应用RPM通过module形式打包起来，通过module来是管理这一系列的应用，减少复杂性。3 AppStraem 中的软件包的打包方式介绍 独立的RPM 格式这个也就是我们所熟知的传统的RPM包的格式了。 Modules 模块的形式Modules 这种方式呢，其实就是把一系列强相关的RPM组合成一个逻辑上的模块单元。 例如httpd 模块（包含了httpd，httpd-devel，mod_http,mod_ss等一系列的RPM）。它这个里面呢，所有的RPM都是同时编译，测试，以及发布的。 所以通过这样的方式，就具有了更好的兼容性，稳定性，以及灵活性。 4 module 的详细介绍module 里面，包含了两个重要的概念， 一个是module的stream， 另外一个就是module的profiles了。 下面我们来仔细看一下 Streams它通过版本来进行管理的，可以理解为module 的版本，比如1.0， 2.0 等等(可以参考下面的例子 Stream的信息)。 可以理解为它是AppStream里面的一个子repo。 最小的单元一系列RPM被放入一个对应的版本的module stream里面。跟着module stream一起发布，更新。 而不同的版本的module stream 可以独立接收到更新。而我们则可以根据需要，通过命令来进行对module stream 启用和禁用或者默认。 启用则说明我们可以使用到这个module stream里面对应的RPM包；相对而言，如果禁用，我们就是无法使用这个module stream里面对应的RPM包了。这样会出现一种现象，比如我的AppStream源里面明明有其中一个版本的RPM， 但是我却无法使用它。这就是因为这个RPM版本对应的module stream被禁用了，因为这个版本的RPM是这个straem的一员，自然也就没法使用它了。而同一个module，同一时间只能有一个启用的stream。而默认情况下，会有一个默认其中的stream， 这样可以不用做任何的动作的情况下就可以使用到默认 stream的RPM包了。同样，module stream 也会与RPM类似有依赖关系。比如下面这个例子，我们可以看到httpd 这个module有两个stream， 2.4和1.0 两个版本。其中 2.4 是启用的stream ，并且是default的。 12345Red Hat Enterprise Linux 8 for x86_64 - AppStream (RPMs)Name Stream Profiles Summaryhttpd 2.4 [d][e] common [d], devel, minimal Apache HTTP Serverhttpd 1.0 common [d], devel, minimal Apache HTTP ServerHint: [d]efault, [e]nabled, [x]disabled, [i]nstalled Profiles它是用过目的来进行管理的，可以理解为module的使用描述。 它描述了对应的使用范围的以及一系列的RPM包，类似development，minimal， 等等；不同的profile里面会包含不用数量的RPM包。比如development profile里面则会包含devel RPM包； 而minimal profile里面则不会包含devel 的RPM包。 所以这样客户更方便我们来根据需要来选择对应的profile 来安装对应module，这样我们安装了我们需要的RPM了。同样，我们也可以有default的profile，这样默认情况下，我们不需要做任何就可以在安装时，使用default的profile了。比如下面这个例子，我们可以看到http的这个module有三个profile，common，devel和minimal。 而common则是default的profile。 12345Red Hat Enterprise Linux 8 for x86_64 - AppStream (RPMs)Name Stream Profiles Summaryhttpd 2.4 [d][e] common [d], devel, minimal Apache HTTP Serverhttpd 2.0 common [d], devel, minimal Apache HTTP ServerHint: [d]efault, [e]nabled, [x]disabled, [i]nstalled 5 module 的操作示例5.1 显示当前系统中可用的 module1# yum module list 示例。 我们可以看到当前系统所有可用的module，它们的stream信息（d=default，e=enabled）。profile信息，描述的等等。 12345678Red Hat Enterprise Linux 8 for x86_64 - AppStream (RPMs)Name Stream Profiles Summarycontainer-tools rhel8 [d][e] common [d] Common tools and dependencies for container runtimescontainer-tools 1.0 common [d] Common tools and dependencies for container runtimescontainer-tools 2.0 common [d] Common tools and dependencies for container runtimesgo-toolset rhel8 [d][e] common [d] Goidm client [d] common [d] RHEL IdM long term support client...... 5.2 显示module详细信息，可以查看模块描述，profile，提供的RPM包等等。1# yum module info module-name 示例。可以看到stream版本，profile，里面包含的包，以及版本的等等。 12345678910111213141516171819202122232425Name : httpdStream : 2.4 [d][e][a]Version : 8000020190405071959Context : 55190bc5Architecture : x86_64Profiles : common [d], devel, minimalDefault profiles : commonRepo : rhel-8-for-x86_64-appstream-rpmsSummary : Apache HTTP ServerDescription : Apache httpd is a powerful, efficient, and extensible HTTP server.Requires : platform:[el8]Artifacts : httpd-0:2.4.37-11.module+el8.0.0+2969+90015743.src : httpd-0:2.4.37-11.module+el8.0.0+2969+90015743.x86_64 : httpd-debuginfo-0:2.4.37-11.module+el8.0.0+2969+90015743.x86_64 : httpd-debugsource-0:2.4.37-11.module+el8.0.0+2969+90015743.x86_64 : httpd-devel-0:2.4.37-11.module+el8.0.0+2969+90015743.x86_64 : httpd-filesystem-0:2.4.37-11.module+el8.0.0+2969+90015743.noarch : httpd-manual-0:2.4.37-11.module+el8.0.0+2969+90015743.noarch : httpd-tools-0:2.4.37-11.module+el8.0.0+2969+90015743.x86_64 : httpd-tools-debuginfo-0:2.4.37-11.module+el8.0.0+2969+90015743.x86_64 : mod_http2-0:1.11.3-2.module+el8.0.0+2969+90015743.src : mod_http2-0:1.11.3-2.module+el8.0.0+2969+90015743.x86_64 : mod_http2-debuginfo-0:1.11.3-2.module+el8.0.0+2969+90015743.x86_64 : mod_http2-debugsource-0:1.11.3-2.module+el8.0.0+2969+90015743.x86_64...... 5.3 显示对应的profile里面的包含那些具体的包。1# yum module info --profile module-name 示例 实现了module的版本，还有其中不同的profile包含了什么包。 1234567891011121314# yum module info --profile httpdName : httpd:2.4:820190206142837:9edba152:x86_64common : httpd : httpd-filesystem : httpd-tools : mod_http2 : mod_ssldevel : httpd : httpd-devel : httpd-filesystem : httpd-toolsminimal : httpd..... 5.4 显示当前module状态，比如里面的enabled，disable等状态。1# yum module list module-name 示例 模块的信息，Stream的信息，default，profile信息等。（注意，如果不在enabled状态，是yum whatprovides 是无法看到对应的rpm的） 1234567# yum module list phpRed Hat Enterprise Linux 8 for x86_64 - AppStream (RPMs)Name Stream Profiles Summaryphp 7.2 [d] common [d], devel, minimal PHP scripting languagephp 7.3 common [d], devel, minimal PHP scripting languagephp 7.4 common [d], devel, minimal PHP scripting languageHint: [d]efault, [e]nabled, [x]disabled, [i]nstalled 5.5 查找那个模块提供了RPM1# yum module provides package 示例 我们查找那个podman RPM 的详细信息 1234567891011121314151617181920# yum module provides podmanpodman-1.0.0-2.git921f98f.module+el8+2784+9a0c1dfe.x86_64Module : container-tools:1.0:820190220135513:20125149:x86_64Profiles : commonRepo : rhel-8-for-x86_64-appstream-rpmsSummary : Common tools and dependencies for container runtimes......podman-1.6.4-23.module+el8.3.0+8377+eff33c85.x86_64Module : container-tools:2.0:8030020201008133618:830d479e:x86_64Profiles : commonRepo : rhel-8-for-x86_64-appstream-rpmsSummary : Common tools and dependencies for container runtimes......podman-1.9.3-2.module+el8.2.1+6867+366c07d6.x86_64Module : container-tools:rhel8:8020120200601155013:ffd2803a:x86_64Profiles : commonRepo : rhel-8-for-x86_64-appstream-rpmsSummary : Common tools and dependencies for container runtimes 5.6 禁用一个对应的module stream1# yum module disable module-name:stream 示例 禁用stream 版本rhel8 的 “container-tools” 1234567891011121314# yum module disable container-tools:rhel8Only module name is required. Ignoring unneeded information in argument: &#39;container-tools:rhel8&#39;Dependencies resolved.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Package Architecture Version Repository Size&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Disabling module profiles: container-tools&#x2F;commonDisabling modules: container-toolsTransaction Summary&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Is this ok [y&#x2F;N]: yComplete! 5.7 启用一个对应的module stream1# yum module enable module-name:stream 示例 启用 stream 版本 2.0 的 “container-tools” （注意，需要先要将原来其中的其他stearm 禁用掉。） 1234567891011# yum module enable container-tools:2.0Dependencies resolved.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Package Architecture Version Repository Size&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Enabling module streams: container-tools 2.0Transaction Summary&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Is this ok [y&#x2F;N]: yComplete! 5.8 安装一个指定的模块1# yum module install module-name 示例 (安装默认的container-tools module stream,如果要安装其他stream则需要将它enable才能安装) 12345678910111213141516171819# yum module install container-toolsLast metadata expiration check: 2:41:25 ago on Sun 08 Nov 2020 09:10:32 AM CST.Dependencies resolved.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Package Arch Version Repository Size&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Upgrading: buildah x86_64 1.15.1-2.module+el8.3.0+8221+97165c3f rhel-8-for-x86_64-appstream-rpms 8.0 M conmon x86_64 2:2.0.20-2.module+el8.3.0+8221+97165c3f rhel-8-for-x86_64-appstream-rpms 49 k.....Transaction Summary&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Install 8 PackagesUpgrade 12 PackagesInstalled:...... toolbox-0.0.8-1.module+el8.3.0+8221+97165c3f.noarchComplete! 5.9 删除一个指定的模块1# yum module remove --all module-name:stream 示例 这样就可以删除之前安装的container-tools的默认的stream 版本了。 1234567891011# yum module remove container-tools:rhel8Dependencies resolved.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Package Architecture Version Repository Size&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Removed: cockpit-podman-18.1-2.module+el8.3.0+8221+97165c3f.noarch crun-0.14.1-2.module+el8.3.0+8221+97165c3f.x86_64.....Complete! 到此，RHEL8.x CentOS8.x 的module 简介及操作示例就介绍完毕了。","categories":[{"name":"Linux 技巧(原创)","slug":"Linux-技巧-原创","permalink":"http://www.oostech.com/categories/Linux-%E6%8A%80%E5%B7%A7-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"K8S 的 kubectl 常用命令","slug":"K8S_kubectl_cheat_sheet","date":"2021-02-18T16:00:00.000Z","updated":"2021-02-18T16:00:00.000Z","comments":false,"path":"2021/02/19/K8S_kubectl_cheat_sheet/","link":"","permalink":"http://www.oostech.com/2021/02/19/K8S_kubectl_cheat_sheet/","excerpt":"","text":"1 查询节点信息 简单的输出1# kubectl get node 使用describe 显示更多信息1# kubectl describe node vm40ckamaster144 输出yaml格式的详细信息1# kubectl get node --output yaml 编辑(可以添加 node-role.kubernetes.io/node: “” 到 label)1# kubectl edit node vm40ckanode145 输出集群的信息1# kubectl config view 2 输出集群信息1# kubectl cluster-info 3 查询所有的namespace1# kubectl get pod --all-namespaces 4 查看指定namespace的pod 状态1# kubectl get pod -n default 5 查看pod的详细信息1# kubectl describe pod coredns-f9fd979d6-x4z5k -n kube-system 6 编辑pod的状态1# kubectl edit pod coredns-f9fd979d6-x4z5k -n kube-system 7 输出pod 的完整信息1# kubectl get pods busybox -o wide 8 看deployment 的信息1# kubectl get deployment -n kube-system 9 检查deployment 的详细信息1# kubectl describe deployment -n kube-system 10 建立、删除namespace12# kubectl create namespace develop# kubectl delete namespaces develop 11 添加一个service，之后就可以通过集群任何一个节点IP+port访问12# kubectl expose pods&#x2F;kubernetes-bootcamp --type&#x3D;&quot;NodePort&quot; --port&#x3D;8080service&#x2F;kubernetes-bootcamp exposed 12 清除一个taints1# kubectl taint node vm40ckamaster144 node-role.kubernetes.io&#x2F;master:NoSchedule- 13 scale out 一个deployment1# kubectl scale deployment&#x2F;coredns --replicas&#x3D;3 -n kube-system","categories":[{"name":"云原生 容器(原创)","slug":"云原生-容器-原创","permalink":"http://www.oostech.com/categories/%E4%BA%91%E5%8E%9F%E7%94%9F-%E5%AE%B9%E5%99%A8-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"Red Hat Enterprise Linux 8 的新玩意 第5篇tigervnc","slug":"configure_tigervnc_on_rhel82","date":"2021-02-18T16:00:00.000Z","updated":"2021-02-18T16:00:00.000Z","comments":false,"path":"2021/02/19/configure_tigervnc_on_rhel82/","link":"","permalink":"http://www.oostech.com/2021/02/19/configure_tigervnc_on_rhel82/","excerpt":"","text":"Red Hat Enterprise Linux 8 的新玩意 第5篇tigervnc 1. 环境 Red Hat Enterprise Linux release 8.2 (Ootpa) 4.18.0-193.el8.x86_64 tigervnc-server-1.10.1-9.el8_3.x86_642. 安装需要的 VNC 组件1# yum install -y tigervnc tigervnc-server 3. 配置vncserver访问的password1# vncpasswd 4. 创建需要的systemd文件 （使用tigervnc-server自带的例子文件就可以了）1# cp &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;vncserver@.service &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;vncserver@\\:1.service 5. 添加需要访问的用户1# echo &quot;:1&#x3D;root&quot; &gt;&gt; &#x2F;etc&#x2F;tigervnc&#x2F;vncserver.users 6. 重新加载daemon然后启动vncserver （可以配置enable）1234# systemctl daemon-reload# systemctl start vncserver@\\:1.service# 可选# systemctl enable vncserver@\\:1.service 附录 1： 配置文件 /usr/lib/systemd/system/vncserver@\\:1.service1234567891011# egrep -v &quot;^#|^$&quot; -r &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;vncserver@\\:1.service[Unit]Description&#x3D;Remote desktop service (VNC)After&#x3D;syslog.target network.target[Service]Type&#x3D;forkingExecStart&#x3D;&#x2F;usr&#x2F;libexec&#x2F;vncsession-start %iPIDFile&#x3D;&#x2F;var&#x2F;run&#x2F;vncsession-%i.pidSELinuxContext&#x3D;system_u:system_r:vnc_session_t:s0[Install]WantedBy&#x3D;multi-user.target 附录 2： 配置文件 /etc/tigervnc/vncserver.users12345678# TigerVNC User assignment## This file assigns users to specific VNC display numbers.# The syntax is &lt;display&gt;&#x3D;&lt;username&gt;. E.g.:## :2&#x3D;andrew# :3&#x3D;lisa:1&#x3D;root 附录 3： 可能会碰到的错误 使用了错误的vncserver@:1.service 文件 （因为cp了原来 RHEL7 的配置文件， 使用tigervnc-server自带的例子文件就可以了）1234567891011# systemctl status vncserver@\\:1.service● vncserver@:1.service - Remote desktop service (VNC) Loaded: loaded (&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;vncserver@:1.service; disabled; vendor preset: disabled) Active: failed (Result: protocol) since Fri 2021-02-19 17:00:12 CST; 5s ago Process: 34992 ExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;runuser -l root -c &#x2F;usr&#x2F;bin&#x2F;vncserver :1 (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS) Process: 34990 ExecStartPre&#x3D;&#x2F;bin&#x2F;sh -c &#x2F;usr&#x2F;bin&#x2F;vncserver -kill :1 &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 || : (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS)Feb 19 17:00:12 rhel82 systemd[1]: Starting Remote desktop service (VNC)...Feb 19 17:00:12 rhel82 systemd[1]: vncserver@:1.service: Can&#39;t open PID file &#x2F;root&#x2F;.vnc&#x2F;rhel82:1.pid (yet?) after start: No such file or di&gt;Feb 19 17:00:12 rhel82 systemd[1]: vncserver@:1.service: Failed with result &#39;protocol&#39;.Feb 19 17:00:12 rhel82 systemd[1]: Failed to start Remote desktop service (VNC). 没有添加vnc用户到 /etc/tigervnc/vncserver.users （增加对应的用户就可以了）1234567891011# systemctl status vncserver@\\:1.service -l● vncserver@:1.service - Remote desktop service (VNC) Loaded: loaded (&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;vncserver@:1.service; disabled; vendor preset: disabled) Active: failed (Result: exit-code) since Fri 2021-02-19 17:09:37 CST; 3s ago Process: 35662 ExecStart&#x3D;&#x2F;usr&#x2F;libexec&#x2F;vncsession-start :1 (code&#x3D;exited, status&#x3D;1&#x2F;FAILURE)Feb 19 17:09:37 rhel82 systemd[1]: Starting Remote desktop service (VNC)...Feb 19 17:09:37 rhel82 vncsession-start[35662]: No user configured for display :1Feb 19 17:09:37 rhel82 systemd[1]: vncserver@:1.service: Control process exited, code&#x3D;exited status&#x3D;1Feb 19 17:09:37 rhel82 systemd[1]: vncserver@:1.service: Failed with result &#39;exit-code&#39;.Feb 19 17:09:37 rhel82 systemd[1]: Failed to start Remote desktop service (VNC).","categories":[{"name":"Linux 技巧(原创)","slug":"Linux-技巧-原创","permalink":"http://www.oostech.com/categories/Linux-%E6%8A%80%E5%B7%A7-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"手动安装 kpatch 编译环境","slug":"kpatch_install_manuall_CN","date":"2021-02-18T16:00:00.000Z","updated":"2021-02-18T16:00:00.000Z","comments":false,"path":"2021/02/19/kpatch_install_manuall_CN/","link":"","permalink":"http://www.oostech.com/2021/02/19/kpatch_install_manuall_CN/","excerpt":"","text":"手动安装 kpatch 编译环境 1. 环境 Red Hat Enterprise Linux 7.6 3.10.0-957.el7.x86_64 ccache-3.3.4-1.el7.x86_64.rpm2. 安装编译依赖的rpm 包1# yum install gcc kernel-devel-$(uname -r) elfutils elfutils-devel pesign yum-utils zlib-devel binutils-devel newt-devel python-devel perl-ExtUtils-Embed audit-libs-devel numactl-devel pciutils-devel bison ncurses-devel gcc-plugin-devel kernel-debuginfo kernel-debuginfo-common gcc-plugin-devel patchutils 3. 创建 ccache， 可以优化编译的速度 （可选步骤，但是建议安装） (ccache represents “compiler cache” which is a tool for the gcc compiler used to compile the same program over and over again with little downtime, While it may take a few seconds longer to compile a program the first time with ccache, subsequent compiles will be much, much faster.)3.1 安装ccache rpm 包1# yum install https:&#x2F;&#x2F;dl.fedoraproject.org&#x2F;pub&#x2F;epel&#x2F;7&#x2F;x86_64&#x2F;Packages&#x2F;c&#x2F;ccache-3.3.4-1.el7.x86_64.rpm 3.2 设置最大可用的cache 大小1# ccache --max-size&#x3D;8G 3.3 修改 gcc 别名，这样在调用gcc的时候就可以使用ccache了123# vi &#x2F;etc&#x2F;profile.d&#x2F;gcc.shalias gcc&#x3D;&quot;ccache gcc&quot;# source &#x2F;etc&#x2F;profile.d&#x2F;gcc.sh 4. 下载kpatch 源代码1# git clone https:&#x2F;&#x2F;github.com&#x2F;dynup&#x2F;kpatch.git 5. 编译安装kpatch源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# make -j2 &amp;&amp; make installmake -C kpatch-buildmake -C kpatchmake[1]: Entering directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kpatch&#39;make[1]: Nothing to be done for &#96;all&#39;.make[1]: Leaving directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kpatch&#39;make -C kmodmake[1]: Entering directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kpatch-build&#39;gcc -MMD -MP -I..&#x2F;kmod&#x2F;patch -Iinsn -Wall -Wsign-compare -g -Werror -c -o create-diff-object.o create-diff-object.cmake[1]: Entering directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kmod&#39;make -C core cleanmake[2]: Entering directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kmod&#x2F;core&#39;rm -f -Rf .*.o.cmd .*.ko.cmd .tmp_versions *.o *.ko *.mod.c \\Module.symversmake[2]: Leaving directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kmod&#x2F;core&#39;make -C coremake[2]: Entering directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kmod&#x2F;core&#39;make -C &#x2F;lib&#x2F;modules&#x2F;3.10.0-957.el7.x86_64&#x2F;build M&#x3D;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kmod&#x2F;core kpatch.kogcc -MMD -MP -I..&#x2F;kmod&#x2F;patch -Iinsn -Wall -Wsign-compare -g -Werror -c -o kpatch-elf.o kpatch-elf.cgcc -MMD -MP -I..&#x2F;kmod&#x2F;patch -Iinsn -Wall -Wsign-compare -g -Werror -c -o lookup.o lookup.cgcc -MMD -MP -I..&#x2F;kmod&#x2F;patch -Iinsn -Wall -Wsign-compare -g -Werror -c -o insn&#x2F;insn.o insn&#x2F;insn.cgcc -MMD -MP -I..&#x2F;kmod&#x2F;patch -Iinsn -Wall -Wsign-compare -g -Werror -c -o insn&#x2F;inat.o insn&#x2F;inat.cgcc -MMD -MP -I..&#x2F;kmod&#x2F;patch -Iinsn -Wall -Wsign-compare -g -Werror -c -o create-klp-module.o create-klp-module.cmake[3]: Entering directory &#96;&#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-957.el7.x86_64&#39;make[3]: warning: jobserver unavailable: using -j1. Add &#96;+&#39; to parent make rule.gcc -MMD -MP -I..&#x2F;kmod&#x2F;patch -Iinsn -Wall -Wsign-compare -g -Werror -c -o create-kpatch-module.o create-kpatch-module.c CC [M] &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kmod&#x2F;core&#x2F;core.ogcc create-diff-object.o kpatch-elf.o lookup.o insn&#x2F;insn.o insn&#x2F;inat.o -lelf -o create-diff-objectgcc create-klp-module.o kpatch-elf.o -lelf -o create-klp-modulegcc create-kpatch-module.o kpatch-elf.o -lelf -o create-kpatch-modulemake[1]: Leaving directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kpatch-build&#39;make -C manmake[1]: Entering directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;man&#39;gzip -c -9 kpatch.1 &gt; kpatch.1.gzgzip -c -9 kpatch-build.1 &gt; kpatch-build.1.gzmake[1]: Leaving directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;man&#39;make -C contribmake[1]: Entering directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;contrib&#39;make[1]: Nothing to be done for &#96;all&#39;.make[1]: Leaving directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;contrib&#39; CC [M] &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kmod&#x2F;core&#x2F;shadow.o LD [M] &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kmod&#x2F;core&#x2F;kpatch.o MODPOST 1 modules CC &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kmod&#x2F;core&#x2F;kpatch.mod.o LD [M] &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kmod&#x2F;core&#x2F;kpatch.komake[3]: Leaving directory &#96;&#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-957.el7.x86_64&#39;make[2]: Leaving directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kmod&#x2F;core&#39;make[1]: Leaving directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kmod&#39;make -C kpatch-build installmake[1]: Entering directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kpatch-build&#39;&#x2F;usr&#x2F;bin&#x2F;install -d &#x2F;usr&#x2F;local&#x2F;libexec&#x2F;kpatch&#x2F;usr&#x2F;bin&#x2F;install create-diff-object create-klp-module create-kpatch-module kpatch-gcc &#x2F;usr&#x2F;local&#x2F;libexec&#x2F;kpatch&#x2F;usr&#x2F;bin&#x2F;install -d &#x2F;usr&#x2F;local&#x2F;bin&#x2F;usr&#x2F;bin&#x2F;install kpatch-build &#x2F;usr&#x2F;local&#x2F;binmake[1]: Leaving directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kpatch-build&#39;make -C kpatch installmake[1]: Entering directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kpatch&#39;&#x2F;usr&#x2F;bin&#x2F;install -d &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;usr&#x2F;bin&#x2F;install kpatch &#x2F;usr&#x2F;local&#x2F;sbinmake[1]: Leaving directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kpatch&#39;make -C kmod installmake[1]: Entering directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kmod&#39;&#x2F;usr&#x2F;bin&#x2F;install -d &#x2F;usr&#x2F;local&#x2F;lib&#x2F;kpatch&#x2F;3.10.0-957.el7.x86_64&#x2F;usr&#x2F;bin&#x2F;install -m 644 core&#x2F;kpatch.ko &#x2F;usr&#x2F;local&#x2F;lib&#x2F;kpatch&#x2F;3.10.0-957.el7.x86_64&#x2F;usr&#x2F;bin&#x2F;install -m 644 core&#x2F;Module.symvers &#x2F;usr&#x2F;local&#x2F;lib&#x2F;kpatch&#x2F;3.10.0-957.el7.x86_64&#x2F;usr&#x2F;bin&#x2F;install -d &#x2F;usr&#x2F;local&#x2F;share&#x2F;kpatch&#x2F;patch&#x2F;usr&#x2F;bin&#x2F;install -m 644 patch&#x2F;* &#x2F;usr&#x2F;local&#x2F;share&#x2F;kpatch&#x2F;patchmake[1]: Leaving directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;kmod&#39;make -C man installmake[1]: Entering directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;man&#39;&#x2F;usr&#x2F;bin&#x2F;install -d &#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;man1&#x2F;usr&#x2F;bin&#x2F;install -m 644 kpatch.1.gz &#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;man1&#x2F;usr&#x2F;bin&#x2F;install -m 644 kpatch-build.1.gz &#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;man1make[1]: Leaving directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;man&#39;make -C contrib installmake[1]: Entering directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;contrib&#39;&#x2F;usr&#x2F;bin&#x2F;install -d &#x2F;usr&#x2F;local&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;usr&#x2F;bin&#x2F;install -m 0644 kpatch.service &#x2F;usr&#x2F;local&#x2F;lib&#x2F;systemd&#x2F;systemsed -i &#39;s~PREFIX~&#x2F;usr&#x2F;local~&#39; &#x2F;usr&#x2F;local&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;kpatch.service&#x2F;usr&#x2F;bin&#x2F;install -d &#x2F;etc&#x2F;init&#x2F;usr&#x2F;bin&#x2F;install -m 0644 kpatch.conf &#x2F;etc&#x2F;initsed -i &#39;s~PREFIX~&#x2F;usr&#x2F;local~&#39; &#x2F;etc&#x2F;init&#x2F;kpatch.confmake[1]: Leaving directory &#96;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;contrib&#39; 6. 检查ccache是否正常工作123456789101112131415# ccache -scache directory &#x2F;root&#x2F;.ccacheprimary config &#x2F;root&#x2F;.ccache&#x2F;ccache.confsecondary config (readonly) &#x2F;etc&#x2F;ccache.confcache hit (direct) 0cache hit (preprocessed) 0cache miss 2cache hit rate 0.00 %called for link 2called for preprocessing 16no input file 75cleanups performed 0files in cache 4cache size 733.2 kBmax cache size 5.0 GB 7. 编译生成kpatch模块 我已经提前修改了内核代码，所以就可以直接生成kpatch了1234567891011121314151617181920212223242526272829303132333435363738# ccache make -j2patch &lt; patchpatching file testmod_drv.cKCFLAGS&#x3D;&quot;-ffunction-sections -fdata-sections&quot; &#x2F;usr&#x2F;bin&#x2F;make -C &#x2F;lib&#x2F;modules&#x2F;3.10.0-957.el7.x86_64&#x2F;build M&#x3D;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;test&#x2F;testmod testmod.komake[1]: Entering directory &#96;&#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-957.el7.x86_64&#39; CC [M] &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;test&#x2F;testmod&#x2F;testmod_drv.o LD [M] &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;test&#x2F;testmod&#x2F;testmod.o MODPOST 1 modules CC &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;test&#x2F;testmod&#x2F;testmod.mod.o LD [M] &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;test&#x2F;testmod&#x2F;testmod.komake[1]: Leaving directory &#96;&#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-957.el7.x86_64&#39;strip --keep-file-symbols -d testmod_drv.ocp testmod_drv.o testmod_drv.o.patchedpatch -R &lt; patchpatching file testmod_drv.cKCFLAGS&#x3D;&quot;-ffunction-sections -fdata-sections&quot; &#x2F;usr&#x2F;bin&#x2F;make -C &#x2F;lib&#x2F;modules&#x2F;3.10.0-957.el7.x86_64&#x2F;build M&#x3D;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;test&#x2F;testmod testmod.komake[1]: Entering directory &#96;&#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-957.el7.x86_64&#39; CC [M] &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;test&#x2F;testmod&#x2F;testmod_drv.o LD [M] &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;test&#x2F;testmod&#x2F;testmod.o MODPOST 1 modules CC &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;test&#x2F;testmod&#x2F;testmod.mod.o LD [M] &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;test&#x2F;testmod&#x2F;testmod.komake[1]: Leaving directory &#96;&#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-957.el7.x86_64&#39;strip --keep-file-symbols -d testmod_drv.ocp testmod_drv.o testmod_drv.o.orig&#x2F;usr&#x2F;bin&#x2F;make -C &#x2F;lib&#x2F;modules&#x2F;3.10.0-957.el7.x86_64&#x2F;build M&#x3D;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;test&#x2F;testmod cleanmake[1]: Entering directory &#96;&#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-957.el7.x86_64&#39; CLEAN &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;test&#x2F;testmod&#x2F;.tmp_versions CLEAN &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;test&#x2F;testmod&#x2F;Module.symversmake[1]: Leaving directory &#96;&#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-957.el7.x86_64&#39;&#x2F;usr&#x2F;bin&#x2F;make -C &#x2F;lib&#x2F;modules&#x2F;3.10.0-957.el7.x86_64&#x2F;build M&#x3D;&#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;test&#x2F;testmod testmod.komake[1]: Entering directory &#96;&#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-957.el7.x86_64&#39; CC [M] &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;test&#x2F;testmod&#x2F;testmod_drv.o LD [M] &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;test&#x2F;testmod&#x2F;testmod.o MODPOST 1 modules CC &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;test&#x2F;testmod&#x2F;testmod.mod.o LD [M] &#x2F;mnt&#x2F;kpatchDemoSam&#x2F;kpatch&#x2F;test&#x2F;testmod&#x2F;testmod.komake[1]: Leaving directory &#96;&#x2F;usr&#x2F;src&#x2F;kernels&#x2F;3.10.0-957.el7.x86_64&#39; 8. 安装测试生成的kpatch模块8.1 确认已经生成12# ls *.kotestmod.ko 8.2 安装kpatch模块123# kpatch install testmod.koinstalling testmod.ko (3.10.0-957.el7.x86_64)Created symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;kpatch.service to &#x2F;usr&#x2F;local&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;kpatch.service. 8.3 确认模块已经安装完毕12345[root@vm2rhel76 (i_am_vm2_rhel76) testmod]# kpatch listLoaded patch modules:Installed patch modules:testmod (3.10.0-957.el7.x86_64) 8.4 卸载kpatch模块12# kpatch uninstall testmod.kouninstalling testmod.ko (3.10.0-957.el7.x86_64)","categories":[{"name":"Linux 技巧(原创)","slug":"Linux-技巧-原创","permalink":"http://www.oostech.com/categories/Linux-%E6%8A%80%E5%B7%A7-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"Linux小玩意之使用 convert2rhel 工具做系统迁移","slug":"public_convert2rhel","date":"2021-02-18T16:00:00.000Z","updated":"2021-02-18T16:00:00.000Z","comments":false,"path":"2021/02/19/public_convert2rhel/","link":"","permalink":"http://www.oostech.com/2021/02/19/public_convert2rhel/","excerpt":"","text":"1. conert2rhel简介1.1 通过conert2rhel工具, 我们可以方便的从 CentOS 直接迁移到 Red Hat Enterprise Linux (RHEL).重要: 在进行convert之前,强烈建议做好相应的备份. 当然,我们也可以联系Red Hat尝试获取支持 2. conert2rhel 迁移的步骤注意: 使用的时候,建议做一个版本的对应. 比如我用CentOS 6.10 迁移到RHEL 6.10 作为一个例子 2.1 在原有的CentOS 6.10 上安装 Fedora EPEL repository1# rpm -ivh https:&#x2F;&#x2F;dl.fedoraproject.org&#x2F;pub&#x2F;epel&#x2F;epel-release-latest-6.noarch.rpm 2.2 安装 convert2rhel 工具.1# yum install -y convert2rhel 2.3 使用RHEL6.10 ISO 作为本地的 repo (我们也可以使用http/ ftp 配合RHEL 6.10搭建的源). 这个例子将 RHEL6.10 的ISO 挂载在”/mnt/iso”下. 并建立一个本地repo 文件.123456# vi &#x2F;etc&#x2F;yum.repos.d&#x2F;rhel-6-server-rpms.repo[rhel-6-server-rpms]name &#x3D; rhel-6-server-rpmsbaseurl &#x3D; file:&#x2F;&#x2F;&#x2F;mnt&#x2F;isoenabled &#x3D; 1gpgcheck &#x3D; 0 2.4 建立完毕, 使用 “yum repolist” 就可以看到我们建立的repo了12345# yum repolist......repo id repo name statusrhel-6-server-rpms rhel-6-server-rpms 0...... 2.5 开始进行系统的迁移2.5.1 执行命令进行系统的迁移 ( “–enablerepo” 参数后面 接我们local repo的源的名字 “rhel-6-server-rpms”). 过程中,会有5次需要确认, 输入”y”的地方. 以安装为 “Desktop, Server Platform Development, X Window System” 的CentOS6.10系统,整个切换大约需要10分钟.12345678910111213141516171819# convert2rhel --disable-submgr --disablerepo &quot;*&quot; --enablerepo rhel-6-server-rpms --debug......WARNING - By continuing you accept this EULA.Continue with the system conversion? [y&#x2F;n]: y...WARNING - The following packages will be removed...Continue with the system conversion? [y&#x2F;n]: y...WARNING - Only packages signed by CentOS are to be reinstalled. Red Hat support won&#39;t be provided for the following third party packages:Continue with the system conversion? [y&#x2F;n]: y...WARNING - The tool allows rollback of any action until this point.WARNING - By continuing all further changes on the system will need to be reverted manually by the user, if necessary.Continue with the system conversion? [y&#x2F;n]: y...WARNING - The convert2rhel is going to force-replace the only kernel installed, which has the same NEVRA as the only available RHEL kernel. If anything goes wrong with such replacement, the system will become unbootable. If you want the convert2rhel to install the RHEL kernel in a safer manner, you can install a different version of kernel first and then run convert2rhel again.Continue with the system conversion? [y&#x2F;n]: y 2.5.2 切换完毕之后,重启加载新的内核. 整个切换的过程就结束了.(简单好用吧 :P)12WARNING - In order to boot the RHEL kernel, restart of the system is needed.[root@localhost ~]#reboot 我们也可以打开下面的链接,找到更多的参考信息.https://access.redhat.com/articles/2360841","categories":[{"name":"Linux 技巧(原创)","slug":"Linux-技巧-原创","permalink":"http://www.oostech.com/categories/Linux-%E6%8A%80%E5%B7%A7-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"当执行 echo \"X\" > /proc/sysrq-trigger 的时候, 这个X究竟有些什么值可以输入?","slug":"sysrq-trigger-operation","date":"2021-02-16T13:00:00.000Z","updated":"2021-02-16T16:00:00.000Z","comments":false,"path":"2021/02/16/sysrq-trigger-operation/","link":"","permalink":"http://www.oostech.com/2021/02/16/sysrq-trigger-operation/","excerpt":"","text":"1 当执行 echo “X” &gt; /proc/sysrq-trigger 的时候, 这个X究竟有些什么值可以输入?1.2 具体定义如下,每一个操作码都对应一个处理函数, “NULL” 就表示发了也白搭:-), 空的,没人干活呀.虽然没人干活,发个提醒还是需要的,所以在message里面能看到类似help的信息).1234567891011121314151617181920212223242526272829303132333435363738static struct sysrq_key_op *sysrq_key_table[36] &#x3D; &#123; &amp;sysrq_loglevel_op, &#x2F;* 0 顾名思义就是设置console的log级别了 其实就是console_loglevel &#x3D; key - &#39;0&#39;;*&#x2F; &amp;sysrq_loglevel_op, &#x2F;* 1 *&#x2F; &amp;sysrq_loglevel_op, &#x2F;* 2 *&#x2F; &amp;sysrq_loglevel_op, &#x2F;* 3 *&#x2F; &amp;sysrq_loglevel_op, &#x2F;* 4 *&#x2F; &amp;sysrq_loglevel_op, &#x2F;* 5 *&#x2F; &amp;sysrq_loglevel_op, &#x2F;* 6 *&#x2F; &amp;sysrq_loglevel_op, &#x2F;* 7 *&#x2F; &amp;sysrq_loglevel_op, &#x2F;* 8 *&#x2F; &amp;sysrq_loglevel_op, &#x2F;* 9 *&#x2F; NULL, &#x2F;* a 不干活,预留的给sparc*&#x2F; &amp;sysrq_reboot_op, &#x2F;* b 就是reboot咯*&#x2F; &amp;sysrq_crash_op, &#x2F;* c 产生一个crash, 是对一个空指针操作来trigger*&#x2F; &amp;sysrq_showlocks_op, &#x2F;* d 根据是否有CONFIG_LOCKDEP定义输出locks*&#x2F; &amp;sysrq_term_op, &#x2F;* e 这个厉害了,发SIGTERM 给所有的用户进程.*&#x2F; &amp;sysrq_moom_op, &#x2F;* f 调用schedule_work来产生一个OOM execution, 最终是调用了out_of_memory函数,这里面就有点复杂了,下篇再总结这个*&#x2F; NULL, &#x2F;* g 预留给kernel的debug用*&#x2F; NULL, &#x2F;* h 预留给帮助用 *&#x2F; &amp;sysrq_kill_op, &#x2F;* i 这个更直接,发SIGKILL给所有的用户进程*&#x2F; &amp;sysrq_thaw_op, &#x2F;* j 通过SysRq来紧急解冻所有的文件系统,前提是有CONFIG_BLOCK内核配置 *&#x2F; &amp;sysrq_SAK_op, &#x2F;* k 如果有CONFIG_VT 这个调用schedule_work 来操作SAK_work 就是Secure Attention Key 了吧*&#x2F; &amp;sysrq_showallcpus_op, &#x2F;* l 如果定义了CONFIG_SMP, 就输出所有的CPU的back trace *&#x2F; &amp;sysrq_showmem_op, &#x2F;* m 输出内存的信息*&#x2F; &amp;sysrq_unrt_op, &#x2F;* n 这个就给所有RT Tasks 设置NICE*&#x2F; NULL, &#x2F;* o 预留,代表off吧.*&#x2F; &amp;sysrq_showregs_op, &#x2F;* p 输出寄存器的值*&#x2F; &amp;sysrq_show_timers_op, &#x2F;* q 输出时钟事件设备以及等待中的hrtimers*&#x2F; &amp;sysrq_unraw_op, &#x2F;* r 将键盘模式设置为系统默认值*&#x2F; &amp;sysrq_sync_op, &#x2F;* s 做一个临时紧急同步用*&#x2F; &amp;sysrq_showstate_op, &#x2F;* t 调用show_state和show_workqueue_state输出当前系统状态*&#x2F; &amp;sysrq_mountro_op, &#x2F;* u 调用emergency_remount做重新紧急remount*&#x2F; NULL, &#x2F;* v 预留给frame buffer*&#x2F; &amp;sysrq_showstate_blocked_op, &#x2F;* w 输出blocked 的信息*&#x2F; NULL, &#x2F;* x 给不同的体系的dump 预留*&#x2F; NULL, &#x2F;* y 给sparc64预留*&#x2F; &amp;sysrq_ftrace_dump_op, &#x2F;* z 把ftrace中存的信息输出.*&#x2F;&#125;; 2 主要的执行过程.2.1 write_sysrq_trigger 调用 __handle_sysrq2.2 __handle_sysrq 调用 __sysrq_get_key_op(key) 获取操作码.2.3 __sysrq_get_key_op(key)通过两个for循环, 找到sysrq_key_table对应操作码2.4 而操作码又有对应的处理函数,然后调用它获取返回值.到此,整个过程也就完成了.","categories":[{"name":"Linux 技巧(原创)","slug":"Linux-技巧-原创","permalink":"http://www.oostech.com/categories/Linux-%E6%8A%80%E5%B7%A7-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"X86 汇编指令大全","slug":"X86_MASN_instructions","date":"2021-02-16T13:00:00.000Z","updated":"2021-02-16T16:00:00.000Z","comments":false,"path":"2021/02/16/X86_MASN_instructions/","link":"","permalink":"http://www.oostech.com/2021/02/16/X86_MASN_instructions/","excerpt":"","text":"X86 汇编指令大全1 数据传输字令1.1 通用数据传送指令.1234567891011121314MOV 传送字或字节.MOVSX 先符号扩展,再传送.MOVZX 先零扩展,再传送.PUSH 把字压入堆栈.POP 把字弹出堆栈.PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈.POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈.PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈.POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈.BSWAP 交换32位寄存器里字节的顺序XCHG 交换字或字节.(至少有一个操作数为寄存器,段寄存器不可作为操作数)CMPXCHG 比较并交换操作数.(第二个操作数必须为累加器AL&#x2F;AX&#x2F;EAX)XADD 先交换再累加.(结果在第一个操作数里)XLAT 字节查表转换.----BX指向一张256字节的表的起点,AL为表的索引值(0-255,即0-FFH);返回AL为查表结果.([BX+AL]-&gt;AL) 1.2 输入输出端口传送指令.12IN I&#x2F;O端口输入. ( 语法: IN 累加器, &#123;端口号│DX&#125; )OUT I&#x2F;O端口输出. ( 语法: OUT &#123;端口号│DX&#125;,累加器 )输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,其范围是 0-65535. 1.3 目的地址传送指令.123456LEA 装入有效地址.例: LEA DX,string ;把偏移地址存到DX.LDS 传送目标指针,把指针内容装入DS.例: LDS SI,string ;把段地址:偏移地址存到DS:SI.LES 传送目标指针,把指针内容装入ES.例: LES DI,string ;把段地址:偏移地址存到ES:DI.LFS 传送目标指针,把指针内容装入FS.例: LFS DI,string ;把段地址:偏移地址存到FS:DI.LGS 传送目标指针,把指针内容装入GS.例: LGS DI,string ;把段地址:偏移地址存到GS:DI.LSS 传送目标指针,把指针内容装入SS.例: LSS DI,string ;把段地址:偏移地址存到SS:DI. 1.4 标志传送指令.123456LAHF 标志寄存器传送,把标志装入AH.SAHF 标志寄存器传送,把AH内容装入标志寄存器.PUSHF 标志入栈.POPF 标志出栈.PUSHD 32位标志入栈.POPD 32位标志出栈. 2 算术运算指令12345678910111213141516171819202122ADD 加法.ADC 带进位加法.INC 加 1.AAA 加法的ASCII码调整.DAA 加法的十进制调整.SUB 减法.SBB 带借位减法.DEC 减 1.NEG 求反(以 0 减之).CMP 比较.(两操作数作减法,仅修改标志位,不回送结果).AAS 减法的ASCII码调整.DAS 减法的十进制调整.MUL 无符号乘法.结果回送AH和AL(字节运算),或DX和AX(字运算),IMUL 整数乘法.结果回送AH和AL(字节运算),或DX和AX(字运算),AAM 乘法的ASCII码调整.DIV 无符号除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算).IDIV 整数除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算).AAD 除法的ASCII码调整.CBW 字节转换为字. (把AL中字节的符号扩展到AH中去)CWD 字转换为双字. (把AX中的字的符号扩展到DX中去)CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去)CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去) 3 逻辑运算指令1234567891011121314151617AND 与运算.OR 或运算.XOR 异或运算.NOT 取反.TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果).SHL 逻辑左移.SAL 算术左移.(&#x3D;SHL)SHR 逻辑右移.SAR 算术右移.(&#x3D;SHR)ROL 循环左移.ROR 循环右移.RCL 通过进位的循环左移.RCR 通过进位的循环右移. 以上八种移位指令,其移位次数可达255次. 移位一次时, 可直接用操作码. 如 SHL AX,1. 移位&gt;1次时, 则由寄存器CL给出移位次数. 如 MOV CL,04 SHL AX,CL 4 串指令12345678910111213141516 DS:SI 源串段寄存器 :源串变址. ES:DI 目标串段寄存器:目标串变址. CX 重复次数计数器. AL&#x2F;AX 扫描值. D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量. Z标志 用来控制扫描或比较操作的结束.MOVS 串传送.( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. )CMPS 串比较.( CMPSB 比较字符. CMPSW 比较字. )SCAS 串扫描.把AL或AX的内容与目标串作比较,比较结果反映在标志位.LODS 装入串.把源串中的元素(字或字节)逐一装入AL或AX中.( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. )STOS 保存串.是LODS的逆过程.REP 当CX&#x2F;ECX&lt;&gt;0时重复.REPE&#x2F;REPZ 当ZF&#x3D;1或比较结果相等,且CX&#x2F;ECX&lt;&gt;0时重复.REPNE&#x2F;REPNZ 当ZF&#x3D;0或比较结果不相等,且CX&#x2F;ECX&lt;&gt;0时重复.REPC 当CF&#x3D;1且CX&#x2F;ECX&lt;&gt;0时重复.REPNC 当CF&#x3D;0且CX&#x2F;ECX&lt;&gt;0时重复. 5 程序转移指令5.1 无条件转移指令 (长转移)123JMP 无条件转移指令CALL 过程调用RET&#x2F;RETF 过程返回. 5.2 条件转移指令 (短转移,-128到+127的距离内)( 当且仅当(SF XOR OF)=1时,OP1&lt;OP2 )1234567891011121314151617181920JA&#x2F;JNBE 不小于或不等于时转移.JAE&#x2F;JNB 大于或等于转移.JB&#x2F;JNAE 小于转移.JBE&#x2F;JNA 小于或等于转移. 以上四条,测试无符号整数运算的结果(标志C和Z).JG&#x2F;JNLE 大于转移.JGE&#x2F;JNL 大于或等于转移.JL&#x2F;JNGE 小于转移.JLE&#x2F;JNG 小于或等于转移. 以上四条,测试带符号整数运算的结果(标志S,O和Z).JE&#x2F;JZ 等于转移.JNE&#x2F;JNZ 不等于时转移.JC 有进位时转移.JNC 无进位时转移.JNO 不溢出时转移.JNP&#x2F;JPO 奇偶性为奇数时转移.JNS 符号位为 &quot;0&quot; 时转移.JO 溢出转移.JP&#x2F;JPE 奇偶性为偶数时转移.JS 符号位为 &quot;1&quot; 时转移. 5.3 循环控制指令(短转移)12345LOOP CX不为零时循环.LOOPE&#x2F;LOOPZ CX不为零且标志Z&#x3D;1时循环.LOOPNE&#x2F;LOOPNZ CX不为零且标志Z&#x3D;0时循环.JCXZ CX为零时转移.JECXZ ECX为零时转移. 5.4 中断指令123INT 中断指令INTO 溢出中断IRET 中断返回 5.5 处理器控制指令123456789101112HLT 处理器暂停, 直到出现中断或复位信号才继续.WAIT 当芯片引线TEST为高电平时使CPU进入等待状态.ESC 转换到外处理器.LOCK 封锁总线.NOP 空操作.STC 置进位标志位.CLC 清进位标志位.CMC 进位标志取反.STD 置方向标志位.CLD 清方向标志位.STI 置中断允许位.CLI 清中断允许位. 6 伪指令1234567DW 定义字(2字节).PROC 定义过程.ENDP 过程结束.SEGMENT 定义段.ASSUME 建立段寄存器寻址.ENDS 段结束.END 程序结束. 7 处理机控制指令：标志处理指令123456789101112CLC 进位位置0指令CMC 进位位求反指令STC 进位位置为1指令CLD 方向标志置1指令STD 方向标志位置1指令CLI 中断标志置0指令STI 中断标志置1指令NOP 无操作HLT 停机WAIT 等待ESC 换码LOCK 封锁 8 浮点运算指令集8.1 控制指令(带9B的控制指令前缀F变为FN时浮点不检查，机器码去掉9B)1234567891011121314151617181920212223FINIT 初始化浮点部件 机器码 9B DB E3FCLEX 清除异常 机器码 9B DB E2FDISI 浮点检查禁止中断 机器码 9B DB E1FENI 浮点检查禁止中断二 机器码 9B DB E0WAIT 同步CPU和FPU 机器码 9BFWAIT 同步CPU和FPU 机器码 D9 D0FNOP 无操作 机器码 DA E9FXCH 交换ST(0)和ST(1) 机器码 D9 C9FXCH ST(i) 交换ST(0)和ST(i) 机器码 D9 C1iiiFSTSW ax 状态字到ax 机器码 9B DF E0FSTSW word ptr mem 状态字到mem 机器码 9B DD mm111mmmFLDCW word ptr mem mem到状态字 机器码 D9 mm101mmmFSTCW word ptr mem 控制字到mem 机器码 9B D9 mm111mmmFLDENV word ptr mem mem到全环境 机器码 D9 mm100mmmFSTENV word ptr mem 全环境到mem 机器码 9B D9 mm110mmmFRSTOR word ptr mem mem到FPU状态 机器码 DD mm100mmmFSAVE word ptr mem FPU状态到mem 机器码 9B DD mm110mmmFFREE ST(i) 标志ST(i)未使用 机器码 DD C0iiiFDECSTP 减少栈指针1-&gt;0 2-&gt;1 机器码 D9 F6FINCSTP 增加栈指针0-&gt;1 1-&gt;2 机器码 D9 F7FSETPM 浮点设置保护 机器码 DB E4 8.2 数据传送指令123456789101112131415161718192021222324252627282930313233343536373839404142FLDZ 将0.0装入ST(0) 机器码 D9 EEFLD1 将1.0装入ST(0) 机器码 D9 E8FLDPI 将π装入ST(0) 机器码 D9 EBFLDL2T 将ln10&#x2F;ln2装入ST(0) 机器码 D9 E9FLDL2E 将1&#x2F;ln2装入ST(0) 机器码 D9 EAFLDLG2 将ln2&#x2F;ln10装入ST(0) 机器码 D9 ECFLDLN2 将ln2装入ST(0) 机器码 D9 EDFLD real4 ptr mem 装入mem的单精度浮点数 机器码 D9 mm000mmmFLD real8 ptr mem 装入mem的双精度浮点数 机器码 DD mm000mmmFLD real10 ptr mem 装入mem的十字节浮点数 机器码 DB mm101mmmFILD word ptr mem 装入mem的二字节整数 机器码 DF mm000mmmFILD dword ptr mem 装入mem的四字节整数 机器码 DB mm000mmmFILD qword ptr mem 装入mem的八字节整数 机器码 DF mm101mmmFBLD tbyte ptr mem 装入mem的十字节BCD数 机器码 DF mm100mmmFST real4 ptr mem 保存单精度浮点数到mem 机器码 D9 mm010mmmFST real8 ptr mem 保存双精度浮点数到mem 机器码 DD mm010mmmFIST word ptr mem 保存二字节整数到mem 机器码 DF mm010mmmFIST dword ptr mem 保存四字节整数到mem 机器码 DB mm010mmmFSTP real4 ptr mem 保存单精度浮点数到mem并出栈 机器码 D9 mm011mmmFSTP real8 ptr mem 保存双精度浮点数到mem并出栈 机器码 DD mm011mmmFSTP real10 ptr mem 保存十字节浮点数到mem并出栈 机器码 DB mm111mmmFISTP word ptr mem 保存二字节整数到mem并出栈 机器码 DF mm011mmmFISTP dword ptr mem 保存四字节整数到mem并出栈 机器码 DB mm011mmmFISTP qword ptr mem 保存八字节整数到mem并出栈 机器码 DF mm111mmmFBSTP tbyte ptr mem 保存十字节BCD数到mem并出栈 机器码 DF mm110mmmFCMOVB ST(0),ST(i) &lt;时传送 机器码 DA C0iiiFCMOVBE ST(0),ST(i) &lt;&#x3D;时传送 机器码 DA D0iiiFCMOVE ST(0),ST(i) &#x3D;时传送 机器码 DA C1iiiFCMOVNB ST(0),ST(i) &gt;&#x3D;时传送 机器码 DB C0iiiFCMOVNBE ST(0),ST(i) &gt;时传送 机器码 DB D0iiiFCMOVNE ST(0),ST(i) !&#x3D;时传送 机器码 DB C1iiiFCMOVNU ST(0),ST(i) 有序时传送 机器码 DB D1iiiFCMOVU ST(0),ST(i) 无序时传送 机器码 DA D1iii 8.3 比较指令12345678910111213141516FCOM ST(0)-ST(1) 机器码 D8 D1FCOMI ST(0),ST(i) ST(0)-ST(1) 机器码 DB F0iiiFCOMIP ST(0),ST(i) ST(0)-ST(1)并出栈 机器码 DF F0iiiFCOM real4 ptr mem ST(0)-实数mem 机器码 D8 mm010mmmFCOM real8 ptr mem ST(0)-实数mem 机器码 DC mm010mmmFICOM word ptr mem ST(0)-整数mem 机器码 DE mm010mmmFICOM dword ptr mem ST(0)-整数mem 机器码 DA mm010mmmFICOMP word ptr mem ST(0)-整数mem并出栈 机器码 DE mm011mmmFICOMP dword ptr mem ST(0)-整数mem并出栈 机器码 DA mm011mmmFTST ST(0)-0 机器码 D9 E4FUCOM ST(i) ST(0)-ST(i) 机器码 DD E0iiiFUCOMP ST(i) ST(0)-ST(i)并出栈 机器码 DD E1iiiFUCOMPP ST(0)-ST(1)并二次出栈 机器码 DA E9FXAM ST(0)规格类型 机器码 D9 E5 8.4 运算指令123456789101112131415161718192021222324252627282930313233343536FADD 把目的操作数 (直接接在指令后的变量或堆栈缓存器) 与来源操作数 (接在目的操作数后的变量或堆栈缓存器) 相加，并将结果存入目的操作数FADDP ST(i),ST 这个指令是使目的操作数加上 ST 缓存器，并弹出 ST 缓存器，而目的操作数必须是堆栈缓存器的其中之一，最后不管目的操作数为何，经弹出一次后，目的操作数会变成上一个堆栈缓存器了FIADD FIADD 是把 ST 加上来源操作数，然后再存入 ST 缓存器，来源操作数必须是字组整数或短整数形态的变数FSUB 减FSUBPFSUBR 减数与被减数互换FSUBRPFISUBFISUBRFMUL 乘FMULPFIMULFDIV 除FDIVPFDIVRFDIVRPFIDIVFIDIVRFCHS 改变 ST 的正负值FABS 把 ST 之值取出，取其绝对值后再存回去。FSQRT 将 ST 之值取出，开根号后再存回去。FSCALE 这个指令是计算 ST*2^ST(1)之值，再把结果存入 ST 里而 ST(1) 之值不变。ST(1) 必须是在 -32768 到 32768 (-215 到 215 )之间的整数，如果超过这个范围计算结果无法确定，如果不是整数 ST(1) 会先向零舍入成整数再计算。所以为安全起见，最好是由字组整数载入到 ST(1) 里。FRNDINT 这个指令是把 ST 的数值舍入成整数，FPU 提供四种舍入方式，由 FPU 的控制字组(control word)中的 RC 两个位决定 RC 舍入控制 00 四舍五入 01 向负无限大舍入 10 向正无限大舍入 11 向零舍去","categories":[{"name":"Linux 代码(原创)","slug":"Linux-代码-原创","permalink":"http://www.oostech.com/categories/Linux-%E4%BB%A3%E7%A0%81-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"ansible的playbook 常用的模块例子","slug":"ansible_playbook_related","date":"2021-02-16T13:00:00.000Z","updated":"2021-02-16T16:00:00.000Z","comments":false,"path":"2021/02/16/ansible_playbook_related/","link":"","permalink":"http://www.oostech.com/2021/02/16/ansible_playbook_related/","excerpt":"","text":"1 copy 复制文件到远端并且备份12345678910111213---- name: a copy test hosts: servera become: yes tasks: - name: task 1 copy: src: &#x2F;tmp&#x2F;testa dest: &#x2F;tmp&#x2F;testa owner: apache group: apache mode: 0755 backup: yes 2 file 建立文件或者文件夹123456789101112---- name: this is file module hosts: servera become: yes tasks: - name: file module, create a file name testdir file: path: &#x2F;tmp&#x2F;testdira state: directory owner: ansible group: ansible mode: 700 3 lineinfile 替换文件内容3.1 如果文件存在12345678910111213---- name: lineinfile test hosts: servera become: yes tasks: - name: task 3 lineinfile lineinfile: dest: &#x2F;tmp&#x2F;sam regexp: &#39;this&#39; line: &#39;hello world&#39; owner: root group: root mode: 0644 3.2 文件不存在 (使用present和create, 变量用引号和大括号 ““)1234567891011121314151617---- name: variables test hosts: servera become: yes vars: word: sam tasks: - name : this is a test lineinfile: path: &#x2F;tmp&#x2F;testaa line: &#39;hello &quot;&#123;&#123; word &#125;&#125;&quot;&#39; state: present create: yes register: result - name: debug debug: var: result 4 shell 命令使用1234567891011---- name: Shell command hosts: servera become: yes tasks: - name: shell test shell: &#39;cat &#x2F;tmp&#x2F;sam&#39; register: result - name: debug debug: var: result 5 stat 检查文件是否存在123456789101112---- name: stat to check if file there hosts: servera become: yes tasks: - name: stat command stat: path: &#x2F;tmp&#x2F;lee register: result - name: debug debug: var: result 6 setup 获取系统信息1234567891011---- name: setup module hosts: servera become: yes tasks: - name: task setup setup: register: result - name: debug debug: var: result 7 setup 配合filter获取主机信息123456789101112131415161718[root@workstation ansible]# ansible servera -m setup -a &quot;filter&#x3D;ansible_default_ipv4&quot;servera | SUCCESS &#x3D;&gt; &#123; &quot;ansible_facts&quot;: &#123; &quot;ansible_default_ipv4&quot;: &#123; &quot;address&quot;: &quot;172.25.250.10&quot;, &quot;alias&quot;: &quot;eth0&quot;, &quot;broadcast&quot;: &quot;172.25.250.255&quot;, &quot;gateway&quot;: &quot;172.25.250.254&quot;, &quot;interface&quot;: &quot;eth0&quot;, &quot;macaddress&quot;: &quot;52:54:00:00:fa:0a&quot;, &quot;mtu&quot;: 1500, &quot;netmask&quot;: &quot;255.255.255.0&quot;, &quot;network&quot;: &quot;172.25.250.0&quot;, &quot;type&quot;: &quot;ether&quot; &#125; &#125;, &quot;changed&quot;: false&#125; 8 Template使用 (建立.j2的template, )8.1 建立 template 档案12# vim playbooks&#x2F;template_hello.j2Hello &quot;&#123;&#123; sam_veriable &#125;&#125;&quot; 8.2 导入template并使用1234567891011---- name: template test hosts: servera become: yes vars: sam_veriable: &quot;Sam&quot; tasks: - name: start template: src: template_hello.j2 dest: &#x2F;tmp&#x2F;template_hello 8.3 直接更改参数1# ansible-playbook playbooks&#x2F;template_hello.yml -e &quot;sam_veriable&#x3D;good&quot; 9 loop的使用12345678910111213141516171819---- name: myloop hosts: servera become: true tasks: - name: install files yum: name: &quot;&#123;&#123; item &#125;&#125;&quot; state: present register: result loop: - httpd - ipmitool #with_items: # - httpd # - ipmitool - name: debug debug: var: result 10 vault的使用10.1 建立加密文件. 这要求输入密码1# ansible-vault create playbooks&#x2F;crypttests.yml 10.2 编辑加密文件. 要求输入密码12# ansible-vault edit playbooks&#x2F;crypttests.ymlVault password: 10.3 更改密码.1# ansible-vault rekey playbooks&#x2F;crypttests.yml 10.4 对文件加密1# ansible-vault encrypt playbooks&#x2F;crypttests.yml 10.5 对文件解密1# ansible-vault decrypt playbooks&#x2F;crypttests.yml 10.6 查看文件1# ansible-vault view playbooks&#x2F;crypt.yml 11 非0状态继续执行, 使用ignore_errors12345678910111213141516171819---- name: ignore copy error hosts: servera become: yes tasks: - name: copy file to dest copy: src: &#x2F;tmp&#x2F;notify-null dest: &#x2F;tmp&#x2F;nofity owner: ansible group: ansible mode: 0644 ignore_errors: true register: result - name: ping node ping: - name: debug debug: var: result 12 notify使用1234567891011121314151617---- name: notify test hosts: servera become: yes tasks: - name: copy a file copy: src: &#x2F;tmp&#x2F;notify dest: &#x2F;tmp&#x2F;notify owner: ansible group: ansible mode: 0755 notify: - echo ok handlers: - name: echo ok shell: &#39;echo ok &gt;&#x2F;tmp&#x2F;ok&#39; 13 tag 使用13.1 编辑12345678910111213141516---- name: production hosts: production become: yes tasks: - name: ping production ping: tags: production- name: backup hosts: backup become: yes tasks: - name: ping backup ping: tags: backup 13.2 执行1# ansible-playbook playbooks&#x2F;mytags.yml -t production 14 block 和rescue (block里面不能使用ignore_errors)12345678910111213141516---- name: inaccess hosts: all become: yes tasks: - name: block strcuture block: - name: block copy get_url: url: http:&#x2F;&#x2F;materials&#x2F;inaccess.html dest: &#x2F;var&#x2F;www&#x2F;html&#x2F;inaccess.html rescue: - lineinfile: path: &#x2F;var&#x2F;www&#x2F;html&#x2F;inaccess.html line: &#39;I did not have access to the url&#39; create: yes 15 when, register 条件运行12345678910111213141516---- name: selectively update files hosts: all become: yes tasks: - name: check if there file there shell: &#39;ls &#x2F;etc&#x2F;ansible_abort.txt&#39; ignore_errors: yes register: result - name: create a file lineinfile: path: &#x2F;etc&#x2F;ansible_abort.txt line: &#39;my node is also &#123;&#123; ansible_hostname &#125;&#125;&#39; create: yes when: result.rc !&#x3D; 0 16 安装role (role 是在galaxy里面使用)16.1 编写galaxy_install.yml文件123---- src: http:&#x2F;&#x2F;materials&#x2F;do407fun.tar.gz name: examfun 16.2 安装role (安装的路径需要ansible.cfg写明 roles_path = /home/ansible/playbooks/roles)1ansible-galaxy install -r playbooks&#x2F;galaxy_install.yml 17 配置log路径1log_path&#x3D; &#x2F;home&#x2F;ansible&#x2F;logs-ansible.log 18 when 和debug使用(加速可以停用 gather_facts: no)1234567891011121314151617---- name: test debug info hosts: servera become: yes gather_facts: no tasks: - name: retrive host name shell: hostname register: result - name: for debug stdout 3 debug: msg: &#39;result.stdout &quot;&#123;&#123; result.stdout &#125;&#125;&quot;&#39; - name: when test file: path: &#x2F;tmp&#x2F;nogood state: touch when: result.stdout &#x3D;&#x3D; &quot;servera.lab.example.com&quot; 19 如何使用ignore_errors 和register (这两个是针对模块或者命令的,所以应该与之平齐)123456789101112---- name: check error hosts: servera become: yes tasks: - name: ignore error lineinfile: path: &#39;&#x2F;tmp&#x2F;this&#39; state: present line: &quot;good day&quot; ignore_errors: yes register: result 20 gather_facts 注意事项(不要设置为no 如果需要setup模块的变量如 ansible_hostname)1gather_facts: yes 21 创建LVM12345# pvcreate &#x2F;dev&#x2F;vda2# vgcreate new_vol_group &#x2F;dev&#x2F;vda1# lvcreate -L2G -n new_logical_volume new_vol_group# gfs_mkfs -plock_nolock -j 1 &#x2F;dev&#x2F;new_vol_group&#x2F;new_logical_volume# mkfs.xfs &#x2F;dev&#x2F;new_vol_group&#x2F;new_logical_volume 22 改password12345[root@workstation ansible]# ansible-vault rekey --ask-vault-pass playbook&#x2F;crypt.ymlVault password:New Vault password:Confirm New Vault password:Rekey successful 23 修改command shell 返回值12345678tasks: - name: run this command and ignore the result shell: &#x2F;usr&#x2F;bin&#x2F;somecommand || &#x2F;bin&#x2F;true或tasks: - name: run this command and ignore the result shell: &#x2F;usr&#x2F;bin&#x2F;somecommand ignore_errors: True 24 ansible 安装galaxy role24.1 从galaxy直接安装1- src: yatesr.timezone 24.2 从指定路径上面获取1- src: https:&#x2F;&#x2F;github.com&#x2F;bennojoy&#x2F;nginx 24.3 从指定路径安装并安装为指定名字12- src: https:&#x2F;&#x2F;github.com&#x2F;bennojoy&#x2F;nginx name: vagrant 25 使用 rhsm_repository 模块12345678- name: Enable a RHSM repository rhsm_repository: name: rhel-7-server-rpms- name: Disable all RHSM repositories rhsm_repository: name: &#39;*&#39; state: disabled 26 使用 redhat_subscription 模块注册系统，并加入对应的pool1234567- name: register RHEL redhat_subscription: state: present username: rhn-support-xili password: changeme pool_ids: 8a85f99c6c8b9588016c8be0f1b50ec1 force_register: yes","categories":[{"name":"Linux 技巧(原创)","slug":"Linux-技巧-原创","permalink":"http://www.oostech.com/categories/Linux-%E6%8A%80%E5%B7%A7-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"Red Hat Enterprise Linux 8 的新玩意 第2篇 之容器工具 buildah","slug":"RHEL8-news-toys-section2-Buildah","date":"2021-02-16T13:00:00.000Z","updated":"2021-02-16T16:00:00.000Z","comments":false,"path":"2021/02/16/RHEL8-news-toys-section2-Buildah/","link":"","permalink":"http://www.oostech.com/2021/02/16/RHEL8-news-toys-section2-Buildah/","excerpt":"","text":"Red Hat Enterprise Linux 8 (RHEL8) 的新玩意 第2篇 之容器工具 buildahbuildah顾名思义,buildah 是一个用来生成,操作OCI (Open Container Initiative) 容器的工具. 那它都有些什么过人之处,要在RHEL8中引入它?让我们来看一下: 可以从无到有生成一个容器镜像; 也可以通过一个镜像来生成一个新的容器镜像 如同 podman 一样,不要daemon 的支持,轻量,快捷. 支持容器,容器镜像的查看 更安全,灵活.生成容器镜像时,可以移除make, gcc, fnd 等编译,开发,生级的工具,使生成容器镜像更稳固 直接挂载一个容器镜像,然后对其进行修改; 或者卸载容器的根文件系统 通过更新一个容器的根文件系统,由它作为基础生成一个新的容器镜像 对本地容器的重命名, 删除一个容器或者一个容器镜像 下面我们来通过一些例子看具体看看buildah的特性 容器的生成1 通过 dockerfile 来生成 (也叫 from scratch ). 编写一个简单的Dockerfile, 生成一个镜像,然后输出 HELLO BUILDAH 12345[root@rhel8 buildahbuild]# cat Dockerfile# This is a test dockerfileFROM docker.io&#x2F;library&#x2F;fedora:29ENTRYPOINT [&quot;&#x2F;usr&#x2F;bin&#x2F;hello_buildah.sh&quot;]RUN echo $&#39;#!&#x2F;bin&#x2F;sh \\n echo &quot; *** HELLO BUILDAH *** &quot;&#39;&gt;&#x2F;usr&#x2F;bin&#x2F;hello_buildah.sh &amp;&amp; chmod +x &#x2F;usr&#x2F;bin&#x2F;hello_buildah.sh 执行命令生成一个容器镜像 1[root@rhel8 buildahbuild]# buildah build-using-dockerfile -t hello_buildah --format oci . 1234567891011121314[root@rhel8 buildahbuild]# buildah build-using-dockerfile -t hello_buildah --format oci .STEP 1: FROM docker.io&#x2F;library&#x2F;fedora:29STEP 2: ENTRYPOINT [&quot;&#x2F;usr&#x2F;bin&#x2F;hello_buildah.sh&quot;]STEP 3: RUN echo $&#39;#!&#x2F;bin&#x2F;sh \\n echo &quot; *** HELLO BUILDAH *** &quot;&#39;&gt;&#x2F;usr&#x2F;bin&#x2F;hello_buildah.sh &amp;&amp; chmod +x &#x2F;usr&#x2F;bin&#x2F;hello_buildah.shSTEP 4: COMMIT containers-storage:[overlay@&#x2F;var&#x2F;lib&#x2F;containers&#x2F;storage+&#x2F;var&#x2F;run&#x2F;containers&#x2F;storage:overlay.override_kernel_check&#x3D;true]localhost&#x2F;hello_buildah:latestGetting image source signaturesSkipping fetch of repeat blob sha256:b7ba3be6a0d6426356fc49f538f0f929ed00e51a0a90906e354a345d46e23a8bCopying blob sha256:01e6ea24a0ce0bbd37204075038d46fb8fc345c2c0bf7b18153d01c361f0b3c7 243 B &#x2F; 243 B [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] 0sCopying config sha256:33fdf51b925a6d02542c94fc3a4bf85a7375e2b039e5592985fdc1ba87498afa 1.12 KiB &#x2F; 1.12 KiB [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] 0sWriting manifest to image destinationStoring signatures--&gt; 33fdf51b925a6d02542c94fc3a4bf85a7375e2b039e5592985fdc1ba87498afa 查看且运行测试我们刚刚生成的容器镜像 12[root@rhel8 buildahbuild]# podman image ls |grep buildahlocalhost&#x2F;hello_buildah latest 33fdf51b925a 13 seconds ago 283 MB 12[root@rhel8 buildahbuild]# podman run hello_buildah *** HELLO BUILDAH *** 2 通过修改运行中的容器来生成一个新的容器镜像 先找到我们想要作为基础的镜像 12[root@rhel8 buildahbuild]# buildah images |grep hello_buildahlocalhost&#x2F;hello_buildah latest 33fdf51b925a May 17, 2019 23:03 283 MB 运行这个容器 12[root@rhel8 buildahbuild]# buildah from hello_buildahhello_buildah-working-container 我们基于这个运行中容器来进行修改. 123[root@rhel8 buildahbuild]# buildah containersCONTAINER ID BUILDER IMAGE ID IMAGE NAME CONTAINER NAME6d075a79f753 * 33fdf51b925a localhost&#x2F;hello_buildah:latest hello_buildah-working-container 挂载这个容器的根文件系统 12[root@rhel8 buildahbuild]# buildah mount 6d075a79f753&#x2F;var&#x2F;lib&#x2F;containers&#x2F;storage&#x2F;overlay&#x2F;72f5d68a6659af57a198d28733baf8f64d279e29d02095ae2ef3d5c8f2cb9a42&#x2F;merged 修改它的内容(使用vi 然后添加 AGAIN) 1[root@rhel8 buildahbuild]# vi &#x2F;var&#x2F;lib&#x2F;containers&#x2F;storage&#x2F;overlay&#x2F;72f5d68a6659af57a198d28733baf8f64d279e29d02095ae2ef3d5c8f2cb9a42&#x2F;merged&#x2F;usr&#x2F;bin&#x2F;hello_buildah.sh 卸载这个容器的根文件 12[root@rhel8 buildahbuild]# buildah unmount 6d075a79f7536d075a79f75303c4a8e58f38ebb2997bd11c8238dda43f1bbc4d3ead97e3db17 提交我们刚刚作出的修改 1234567891011[root@rhel8 buildahbuild]# buildah commit 6d075a79f753 hello_buildah:hello_buildah_againGetting image source signaturesSkipping fetch of repeat blob sha256:b7ba3be6a0d6426356fc49f538f0f929ed00e51a0a90906e354a345d46e23a8bSkipping fetch of repeat blob sha256:f40cea9cee51b2055a9a2db587680e7ad77236c95af1466c8d61e6a5106f1d7dCopying blob sha256:31d09f99841c33a71ad2262826d65ca1e5a07cb153fd160519e6aa90a1dd727b 219 B &#x2F; 219 B [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] 0sCopying config sha256:098b5186345f406c24a02cb18aa4bc26a5ab4e677b7cbd75500ce51a781387a1 1.23 KiB &#x2F; 1.23 KiB [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] 0sWriting manifest to image destinationStoring signatures098b5186345f406c24a02cb18aa4bc26a5ab4e677b7cbd75500ce51a781387a1 运行测试验证 12[root@rhel8 buildahbuild]# podman run localhost&#x2F;hello_buildah:hello_buildah_again *** HELLO BUILDAH AGAIN*** 3 通过 buildah run 生成一个容器镜像 (可以实时定制,比如此添加,删除包,作特殊配置等). 启动一个容器镜像 12[root@rhel8 buildahbuild]# buildah from localhost&#x2F;fedora_29fedora_29-working-container 安装gcc开发包(删除包的操作也类似) 12345[root@rhel8 buildahbuild]# buildah run fedora_29-working-container yum install gcc -yFedora Modular 29 -x86_64 68 kB&#x2F;s | 1.5 MB 00:22Fedora Modular 29 - x86_64 - Updates 246 kB&#x2F;s | 2.4 MB 00:10......Complete! 指定要执行的命令 1[root@rhel8 buildahbuild]# buildah config --cmd &quot;gcc -v&quot; fedora_29-working-container 提交修改 12345678910[root@rhel8 buildahbuild]# buildah commit fedora_29-working-container fedora_29_with_gccGetting image source signaturesSkipping fetch of repeat blob sha256:b7ba3be6a0d6426356fc49f538f0f929ed00e51a0a90906e354a345d46e23a8bCopying blob sha256:bd3948f7d2c959300d42d56af86b97cdfedaf4c9b0268213905dbad7977d4dc1 214.84 MiB &#x2F; 214.84 MiB [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] 10sCopying config sha256:789cb4f453c30271211fbc0a77c0cb913ff16746be2914377e5cba39839d855d 1.09 KiB &#x2F; 1.09 KiB [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] 0sWriting manifest to image destinationStoring signatures789cb4f453c30271211fbc0a77c0cb913ff16746be2914377e5cba39839d855d 运行测试验证 12345678910[root@rhel8 buildahbuild]# podman run fedora_29_with_gccUsing built-in specs.COLLECT_GCC&#x3D;gccCOLLECT_LTO_WRAPPER&#x3D;&#x2F;usr&#x2F;libexec&#x2F;gcc&#x2F;x86_64-redhat-linux&#x2F;8&#x2F;lto-wrapperOFFLOAD_TARGET_NAMES&#x3D;nvptx-noneOFFLOAD_TARGET_DEFAULT&#x3D;1Target: x86_64-redhat-linuxConfigured with: ..&#x2F;configure --enable-bootstrap --enable-languages&#x3D;c,c++,fortran,objc,obj-c++,ada,go,lto --prefix&#x3D;&#x2F;usr --mandir&#x3D;&#x2F;usr&#x2F;share&#x2F;man --infodir&#x3D;&#x2F;usr&#x2F;share&#x2F;info --with-bugurl&#x3D;http:&#x2F;&#x2F;bugzilla.redhat.com&#x2F;bugzilla --enable-shared --enable-threads&#x3D;posix --enable-checking&#x3D;release --enable-multilib --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-gcc-major-version-only --with-linker-hash-style&#x3D;gnu --enable-plugin --enable-initfini-array --with-isl --enable-libmpx --enable-offload-targets&#x3D;nvptx-none --without-cuda-driver --enable-gnu-indirect-function --enable-cet --with-tune&#x3D;generic --with-arch_32&#x3D;i686 --build&#x3D;x86_64-redhat-linuxThread model: posixgcc version 8.3.1 20190223 (Red Hat 8.3.1-2) (GCC) 查看运行中的容器,查看容器镜像 查看运行中的容器 123[root@rhel8 buildahbuild]# buildah containersCONTAINER ID BUILDER IMAGE ID IMAGE NAME CONTAINER NAME3f71cb46good * a80dad1cgood registry.redhat.io&#x2F;rhel8-beta:latest rhel8-beta-working-container 查看容器镜像 12345[root@rhel8 buildahbuild]# buildah imagesIMAGE NAME MAGE TAG IMAGE ID CREATED AT SIZEregistry.redhat.io&#x2F;rhel8-beta latest a80dad1c1953 Nov 14, 2018 02:11 210 MBdocker.io&#x2F;library&#x2F;fedora 29 d09302f77cfc Mar 12, 2019 08:20 283 MBlocalhost&#x2F;hello_buildah latest 33fdf51b925a May 17, 2019 23:03 283 MB 容器的重命名, 删除容器或者删除容器镜像 容器重新命名命令 1# buildah rename 6d075a79f753 localhost&#x2F;hello_buildah_again 查看容器,找出容器ID 123[root@rhel8 buildahbuild]# buildah containersCONTAINER ID BUILDER IMAGE ID IMAGE NAME CONTAINER NAME6d075a79f753 * 33fdf51b925a localhost&#x2F;hello_buildah:latest localhost&#x2F;hello_buildah_again 容器重新命名 1[root@rhel8 buildahbuild]# buildah rename 6d075a79f753 localhost&#x2F;hello_buildah_again 确认 123[root@rhel8 buildahbuild]# buildah containersCONTAINER ID BUILDER IMAGE ID IMAGE NAME CONTAINER NAME6d075a79f753 * 33fdf51b925a localhost&#x2F;hello_buildah:latest localhost&#x2F;hello_buildah_again 容器删除命令 1# buildah rm 6d075a79f753 查看容器,找出容器ID 123[root@rhel8 buildahbuild]# buildah containersCONTAINER ID BUILDER IMAGE ID IMAGE NAME CONTAINER NAME6d075a79f753 * 33fdf51b925a localhost&#x2F;hello_buildah:latest localhost&#x2F;hello_buildah_again 删除容器 12[root@rhel8 buildahbuild]# buildah rm 6d075a79f7536d075a79f75303c4a8e58f38ebb2997bd11c8238dda43f1bbc4d3ead97e3db17 确认 12[root@rhel8 buildahbuild]# buildah containersCONTAINER ID BUILDER IMAGE ID IMAGE NAME CONTAINER NAME 容器镜像删除命令 1# buildah rmi a292528dfb8c 查看镜像,找出镜像ID 12[root@rhel8 buildahbuild]# buildah images |grep -w hello_podmanlocalhost&#x2F;rhel8-beta hello_podman a292528dfb8c May 16, 2019 10:43 210 MB 删除镜像 12[root@rhel8 buildahbuild]# buildah rmi a292528dfb8ce010d561555d180015d6c0d30a3f67fa602ea1ae54628d5666235db42f43433a 确认 1[root@rhel8 buildahbuild]# buildah images |grep -w hello_podman 好, Red Hat Enterprise Linux 8 (RHEL8) 的新玩意 第2篇 之容器工具 buildah. 想要了解更多? 可以参考 man buildah 和 buildah -h想要亲手玩一下新玩具? 请随时去 https://www.redhat.com 下载最新的 REHL 8 咯 也欢迎关注 addos 微信公众号获取更多的,有意思的新玩具 :-)","categories":[{"name":"Linux 技巧(原创)","slug":"Linux-技巧-原创","permalink":"http://www.oostech.com/categories/Linux-%E6%8A%80%E5%B7%A7-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"Linux Audit 的使用规则 （可以把这些规则加入到audit.rules里面）","slug":"audit_simple_rules","date":"2021-02-16T13:00:00.000Z","updated":"2021-02-16T16:00:00.000Z","comments":false,"path":"2021/02/16/audit_simple_rules/","link":"","permalink":"http://www.oostech.com/2021/02/16/audit_simple_rules/","excerpt":"","text":"1。 可以针对关键文件进行审计。比如：12345678-w &#x2F;etc&#x2F;passwd -p wa -k passwd-w &#x2F;etc&#x2F;shadow -p wa -k shadow-w &#x2F;etc&#x2F;ssh&#x2F;sshd_config -p wa -k sshd-w &#x2F;etc&#x2F;ssh&#x2F;ssh_config -p wa -k ssh-w &#x2F;etc&#x2F;crontab -p wa -k crontab-w &#x2F;etc&#x2F;hosts -p wa -k hosts-w &#x2F;etc&#x2F;hosts.allow -p wa -k hosts-allow-w &#x2F;etc&#x2F;hosts.deny -p wa -k hosts-deny 2。 可以针对用户命令进行审计。比如：12-a exit,always -F arch&#x3D;b64 -S execve -k exec-a exit,always -F arch&#x3D;b32 -S execve -k exec 3。 可以针对特定的系统调用进行审计。比如：123456-a exit,always -F arch&#x3D;b32 -S kill -k kill_rule-a exit,always -F arch&#x3D;b64 -S kill -k kill_rule-a exit,always -F arch&#x3D;b32 -S settimeofday -k time_rule-a exit,always -F arch&#x3D;b64 -S settimeofday -k time_rule-a exit,always -F arch&#x3D;b32 -S clock_settime -k time_rule-a exit,always -F arch&#x3D;b64 -S clock_settime -k time_rule 4 关于logs，为了防止由于大量的自动脚本运行产生的审计日志频繁flush到磁盘，导致磁盘使用率过高（特别是没有cache直接落盘的RAID卡）。 如果出现此类情况，可以修改flush模式为NONE。可以通过编辑audit配置文件/etc/audit/auditd.conf进行配置，修改如下选项：1flush &#x3D; NONE","categories":[{"name":"Linux 技巧(原创)","slug":"Linux-技巧-原创","permalink":"http://www.oostech.com/categories/Linux-%E6%8A%80%E5%B7%A7-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"Red Hat Enterprise Linux 8 的新玩意 第1 篇之容器工具 podman","slug":"RHEL8-news-toys-section1-podman","date":"2021-02-16T13:00:00.000Z","updated":"2021-02-16T16:00:00.000Z","comments":false,"path":"2021/02/16/RHEL8-news-toys-section1-podman/","link":"","permalink":"http://www.oostech.com/2021/02/16/RHEL8-news-toys-section1-podman/","excerpt":"","text":"Red Hat Enterprise Linux 8 (RHEL8) 的新玩意 第1篇 之容器工具 podmanpodmanpodman 用于操作容器和镜像. 它轻量化,抛弃了后台的daemon, 配合其底层的runc应用; 实现了与docker相同的功能比如pull, push, build, run, commit, tag等等,可用来代替 docker daemon 以及docker 命令行; 同时又拥有其扩展以及不同点: 通过参数-a 或者 --all 来实现对容器,容器镜像的快速清理. 比如, podman rm --all 或者 podman rmi --all podman 支持登陆功能, 可以通过登陆 Red Hat 镜像资源来获取 Red Hat 官方容器镜像. (访问Red Hat 镜像资源, 需要通过有效的Red Hat账户来登陆.) Red Hat 官方镜像资源 registry.redhat.io; Red Hat 维护的第三方资源 registry.connect.redhat.com 登入: 1#podman login -u rhn-support-goodluck https:&#x2F;&#x2F;registry.redhat.io 登出: 1#podman logout https:&#x2F;&#x2F;registry.redhat.io docker 容器的存储路径在 /var/lib/docker 而 podman 则使用 /var/lib/containers 说了这么多,我们还是来具体看看 podman 的一些常用的命令比如 pull, run, build , commit;同时也可以使用 podman -h 来了解更多的命令1 podman pull 这个命令可以用来从HUB上将需要的镜像拷贝到本地. 比如将 rhel8-beta 镜像从Red Hat 官方的 registry.redhat.io 拷贝到本地.(记得先login哦)1podman pull registry.redhat.io&#x2F;rhel8-beta 12345678[root@goodluck~]#podman pull registry.redhat.io&#x2F;rhel8-betaTrying to pull registry.redhat.io&#x2F;rhel8-beta...Getting image source signaturesCopying blob 619051b1good: 66.48 MiB &#x2F; 66.48 MiB [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] 56sCopying blob 386105aegood: 1.33 KiB &#x2F; 1.33 KiB [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] 56sCopying config a80dad1cgood: 6.33 KiB &#x2F; 6.33 KiB [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] 0sWriting manifest to image destinationStoring signaturesa80dad1c19537b0961e485dfa0a43fbe3c0a71cec2cca32d3264e087e396good 比如将 fedora:29 镜像从 docker.io 拷贝到本地.1podman pull docker.io&#x2F;library&#x2F;fedora:29 1234567[root@goodluck~]#podman pull docker.io&#x2F;library&#x2F;fedora:29Trying to pull docker.io&#x2F;library&#x2F;fedora:29...Getting image source signaturesCopying blob 01eb0781good: 85.81 MiB &#x2F; 85.81 MiB [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] 17sCopying config d09302f7good: 1.97 KiB &#x2F; 1.97 KiB [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] 0sWriting manifest to image destinationStoring signaturesd09302f77cfcc3e867829d80ff47f9e7738ffef69730d54ec44341a9fb1dgood 2 podman run 等同于 docker run, 通过一个容器镜像来启动一个进程(容器), 它拥有独立的文件系统,独立网络和其维护的进程树等等 比如以交互模式来执行一个 RHEL 8 beta 容器1podman run -it registry.redhat.io&#x2F;rhel8-beta&#x2F;rhel &#x2F;bin&#x2F;bash 123456789[root@goodluck~]#podman run -it registry.redhat.io&#x2F;rhel8-beta&#x2F;rhel &#x2F;bin&#x2F;bashbash-4.4# cat &#x2F;etc&#x2F;redhat-releaseRed Hat Enterprise Linux release 8.0 Beta (Ootpa)bash-4.4# uname -aLinux 2b225eeecc44 4.18.0-80.el8.x86_64 #1 SMP Wed Mar 13 12:02:46 UTC 2019 x86_64 x86_64 x86_64 GNU&#x2F;Linuxbash-4.4# echo &quot;hello podman :-)&quot;hello podman :-)bash-4.4# exitexit 小Tips: 如果启动过程中看到类似的信息,可以将 selinux 设置为 permissive1&#x2F;bin&#x2F;bash: error while loading shared libraries: libc.so.6: cannot change memory protections 3 podman build 生成容器镜像,有两种方法来生成容器镜像 通过 Dockerfile 来生成一个新的容器镜像我们需要编写一个 Dockerfile ;例子, 我们以 rhel8-beta 为基础, 让容器启动时,执行我们的 hello_podman.sh12345[root@goodluck~]# cat Dockerfile# This is a test dockerfileFROM registry.redhat.io&#x2F;rhel8-beta:latestENTRYPOINT [&quot;&#x2F;usr&#x2F;bin&#x2F;hello_podman.sh&quot;]RUN echo $&#39;#!&#x2F;bin&#x2F;sh \\n echo &quot; *** HELLO PODMAN *** &quot;&#39;&gt;&#x2F;usr&#x2F;bin&#x2F;hello_podman.sh &amp;&amp; chmod +x &#x2F;usr&#x2F;bin&#x2F;hello_podman.sh 以 hello_podman 为镜像的 tag 生成一个新的容器镜像12345678[root@goodluck~]# podman build -t rhel8-beta:hello_podman .STEP 1: FROM registry.redhat.io&#x2F;rhel8-beta:latestSTEP 2: ENTRYPOINT [&quot;&#x2F;usr&#x2F;bin&#x2F;hello_podman.sh&quot;]--&gt; Using cache e010d561555d180015d6c0d30a3f67fa602ea1ae54628d5666235db42f43goodSTEP 3: FROM e010d561555d180015d6c0d30a3f67fa602ea1ae54628d5666235db42f43goodSTEP 4: RUN echo $&#39;#!&#x2F;bin&#x2F;sh \\n echo &quot; *** HELLO PODMAN *** &quot;&#39;&gt;&#x2F;usr&#x2F;bin&#x2F;hello_podman.sh &amp;&amp; chmod +x &#x2F;usr&#x2F;bin&#x2F;hello_podman.sh--&gt; Using cache a292528dfb8c1477419904d19dce108e3d2c105c6efbf0fd677d1dd47fe7goodSTEP 5: COMMIT rhel8-beta:hello_podman 执行验证我们的镜像12[root@goodluck~]# podman run rhel8-beta:hello_podman *** HELLO PODMAN *** 通过修改一个运行中的容器来生成一个新的容器镜像首先,我们执行一个容器并作相应的修改例子和logs1234[root@goodluck~]# podman run -it registry.redhat.io&#x2F;rhel8-beta &#x2F;bin&#x2F;bashbash-4.4# echo $&#39;#!&#x2F;bin&#x2F;sh \\n echo &quot; *** HELLO PODMAN AGAIN*** &quot;&#39;&gt;&#x2F;usr&#x2F;bin&#x2F;hello_podman_again.sh &amp;&amp; chmod +x &#x2F;usr&#x2F;bin&#x2F;hello_podman_again.shbash-4.4# exitexit 找出刚刚执行且修改过的容器ID123[root@goodluck~]# podman ps -lCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES8dfd64dfgood registry.redhat.io&#x2F;rhel8-beta&#x2F;rhel:latest &#x2F;bin&#x2F;bash About a minute ago Exited (0) About a minute ago frosty_bhabha 通过 commit 基于刚刚的容器镜像,以 hello_podman_again 为 tag 生成一个新的容器镜像.123456789[root@goodluck~]# podman commit 8dfd64dfgood rhel8-beta:hello_podman_againGetting image source signaturesSkipping blob fba35a2dgood (already present): 200.01 MiB &#x2F; 200.01 MiB [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] 0sSkipping blob 848ae511good (already present): 10.00 KiB &#x2F; 10.00 KiB [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] 0sCopying blob aed58d13good: 5.50 KiB &#x2F; 5.50 KiB [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] 0sCopying config 4036a262good: 3.12 KiB &#x2F; 3.12 KiB [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;] 0sWriting manifest to image destinationStoring signatures4036a262d1c54477cc8f5014bcb57be323b408c31c78f35a7f6b198a4f6agood 执行验证我们的镜像12[root@goodluck~]# podman run rhel8-beta:hello_podman_again &#x2F;usr&#x2F;bin&#x2F;hello_podman_again.sh *** HELLO PODMAN AGAIN*** 使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。这种黑箱镜像的维护工作是非常痛苦的 4. 使用inspect 查看容器详细信息1# podman inspect 8dfd64dfgood 5. 使用logs 查看信息1# podman logs -f 8dfd64dfgood 6. 停止一个容器1# podman stop 8dfd64dfgood 7. 查看一个容器的文件系统的改动1# podman diff 8dfd64dfgood 8 查看镜像，容器，卷 占用的空间大小12345# podman system dfTYPE TOTAL ACTIVE SIZE RECLAIMABLEImages 57 4 57.3GB 57.3GB (99%)Containers 5 0 1.36GB 1.36GB (100%)Local Volumes 2 1 9.31MB 9.31MB (100%) 9 启动一个容器 -d 已 deamon的形式执行， -p host的端口：容器的端口（格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…]EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker/podman run -P 时，会自动随机映射 EXPOSE 的端口。要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。） 注： 容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。 123456[root@sam Python-3.4.10]# podman run --rm --name webserver -d -p 8888:80 nginx5d8a68f639dcdfea6e0a74a4916973b44b2babb0b3998bc0ec1c71f55c99b648[root@sam Python-3.4.10]# podman psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES5d8a68f639dc docker.io&#x2F;library&#x2F;nginx:latest nginx -g daemon o... 11 seconds ago Up 11 seconds ago 0.0.0.0:8888-&gt;80&#x2F;tcp webserver[root@sam Python-3.4.10]# 10 进入刚刚的容器 (也可以使用attach， 但是注意的，如果exit之后，容器也会终止， 使用exec则不会终止)1# podman exec -it webserver bash 11 使用diff看里面文件的修改1# podman diff webserver 12 查看修改的历史（–no-trunc 现实完整命令）1# podman history registry.redhat.io&#x2F;rhel7:7.8-crash-v2 13 导出本地镜像1# docker export 7691a814370e &gt; ubuntu.tar 14 一次清除所有在推出状态的容器1# podman container prune 15 仓库服务器12[Registry 注册服务器地址] [仓库名] [镜像名字]registry.access.redhat.com&#x2F;rhosp13&#x2F;openstack-nova-compute 16 查找镜像可以使用search1# podman search centos 17 通过使用docker-registry建立本地镜像仓库（这将使用官方的 registry 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 /var/lib/registry 目录下。你可以通过 -v 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 /opt/data/registry 目录。）17.1 创建好私有仓库之后，就可以使用 podman tag 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 127.0.0.1:500012# podman run -d -p 5000:5000 --restart&#x3D;always --name registry registry# podman run -d -p 5000:5000 -v &#x2F;opt&#x2F;data&#x2F;registry:&#x2F;var&#x2F;lib&#x2F;registry registry 17.2 使用podman tag来对tag的设置使用 podman tag 将 ubuntu:latest 这个镜像标记为 127.0.0.1:5000/ubuntu:latest。格式为 podman tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG] 1# podman tag ubuntu:latest 127.0.0.1:5000&#x2F;ubuntu:latest 18 创建一个数据卷1# podman volume create sam-volume 19 查看一个数据卷1# podman volume ls 20 查看一个数据卷的详细信息1# podman volume inspect sam-volume 21 如果需要在删除容器的时候，也删除数据卷1# podman rm -v 22 清理无主的数据卷1# podman volume prune 23 挂载一个主机目录作为数据卷 (使用 –mount 标记可以指定挂载一个本地主机的目录到容器中去). 上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，(以前使用 -v 参数时如果本地目录不存在 podman 会自动为你创建一个文件夹，现在使用 –mount 参数时如果本地目录不存在，podman 会报错。)1# podman run --name sampinta --mount type&#x3D;bind,source&#x3D;&#x2F;root&#x2F;Pictures,target&#x3D;&#x2F;opt&#x2F; localhost&#x2F;pinta_filezilla:v3 24 挂载一个本地主机文件作为数据卷1# podman run --name sampinta --mount type&#x3D;bind,source&#x3D;&#x2F;tmp&#x2F;history,target&#x3D;&#x2F;root&#x2F;.bash_history localhost&#x2F;pinta_filezilla:v3 25 映射指定端口以及针对IP的端口（-p 标记可以多次使用来绑定多个端口）25.1 主机的6000端口与容器的5000端口映射1podman run -d -p 6000:5000 registry.redhat.io&#x2F;rhel7 25.2 主机的IP上的6000端口与容器的5000端口映射1podman run -d -p 127.0.0.1:6000:5000 registry.redhat.io&#x2F;rhel7 25.3 主机的任意端口与容器的5000端口映射1podman run -d -p 127.0.0.1::5000 registry.redhat.io&#x2F;rhel7 25.4 主机的IP的6000端口与容器的5000端口通过UDP映射1podman run -d -p 127.0.0.1:6000:5000&#x2F;udp reg-p 标记可以多次使用来绑定多个端口istry.redhat.io&#x2F;rhel7 25.5 查看端口映射配置1podman port nostalgic_morse 6000 26 容器互联，我们也可以通过“podman network” 类命令实现 (可以通过使用–dns=DNS_IP指定 容器需要的DNS地址)26.1 创建一个新的网络 （-d指定网络的类型，有overlay，bridge。 其中 overlay 网络类似与 “swarm mode”）1podman network create -d bridge test-net 26.2 运行一个容器并且连接到test-net1podman run -it --rm --name ubi2-test-net --network test-net registry.redhat.io&#x2F;rhel7:7.8-crash-v2 sh 27 如果容器需要访问外部网络，需要使用1net.ipv4.ip_forward &#x3D; 1 28 podman ps 显示全的命令12docker ps -a --no-truncpodman ps -a --no-trunc 27 （TO BE VERIFIED）多个容器互联，推荐docker compose21 (TO BE VERIFIED) 启动一个挂在数据卷的容器（在用 podman run 命令的时候，使用 –mount 标记来将 数据卷 挂载到容器里。在一次 podman run 中可以挂载多个 数据卷。下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录）1$ podman run -d -P --name web --mount source&#x3D;sam-volume,target&#x3D;&#x2F;webapp bash -p 标记可以多次使用来绑定多个端口 好, Red Hat Enterprise Linux 8 (RHEL8) 的新玩意 第1篇 之容器工具 podman 就介绍完毕了. 想要了解更多? 可以参考 man podman 和 podman -h想要亲手玩一下新玩具? 请随时去 https://www.redhat.com 下载最新的 REHL 8 咯 也可以关注 AddOS 微信公众号获取更多的,有意思的新玩具 :-)","categories":[{"name":"Linux 技巧(原创)","slug":"Linux-技巧-原创","permalink":"http://www.oostech.com/categories/Linux-%E6%8A%80%E5%B7%A7-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"Red Hat Enterprise Linux 8 的新玩意 第3篇 之容器工具 skopeo, podman-docker","slug":"RHEL8-news-toys-section3-skopeo_podman-docker","date":"2021-02-16T13:00:00.000Z","updated":"2021-02-16T16:00:00.000Z","comments":false,"path":"2021/02/16/RHEL8-news-toys-section3-skopeo_podman-docker/","link":"","permalink":"http://www.oostech.com/2021/02/16/RHEL8-news-toys-section3-skopeo_podman-docker/","excerpt":"","text":"Red Hat Enterprise Linux 8 (RHEL8) 的新玩意 第3篇 之容器工具 skopeo, podman-dockerskopeo名字挺奇怪,这个是用来做什么的呢? 这个其实是一个容器镜像的拷贝工具, 它可以将容器镜像在容器 registeries中拷贝. 而同时它具有对容器镜像的签名认证功能.让我们来看看它的基本用法. 搜索容器镜像 比如我们可以从docker.io 上面来搜索fredora 的镜像1234567891011121314151617181920212223242526272829303132333435[root@vm3_rhel8 ~]# skopeo inspect docker:&#x2F;&#x2F;docker.io&#x2F;fedora&#123; &quot;Name&quot;: &quot;docker.io&#x2F;library&#x2F;fedora&quot;, &quot;Digest&quot;: &quot;sha256:2a60898a6dd7da9964b0c59fedcf652e24bfff04142e5488f793c9e8156afd33&quot;, &quot;RepoTags&quot;: [ &quot;20&quot;, &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;25&quot;, &quot;26-modular&quot;, &quot;26&quot;, &quot;27&quot;, &quot;28&quot;, &quot;29&quot;, &quot;30&quot;, &quot;31&quot;, &quot;branched&quot;, &quot;heisenbug&quot;, &quot;latest&quot;, &quot;modular&quot;, &quot;rawhide&quot; ], &quot;Created&quot;: &quot;2019-03-12T00:20:38.300667849Z&quot;, &quot;DockerVersion&quot;: &quot;18.06.1-ce&quot;, &quot;Labels&quot;: &#123; &quot;maintainer&quot;: &quot;Clement Verna \\u003ccverna@fedoraproject.org\\u003e&quot; &#125;, &quot;Architecture&quot;: &quot;amd64&quot;, &quot;Os&quot;: &quot;linux&quot;, &quot;Layers&quot;: [ &quot;sha256:01eb078129a0d03c93822037082860a3fefdc15b0313f07c6e1c2168aef5401b&quot; ]&#125; 拷贝镜像 (TO BE CONTINUE )1","categories":[{"name":"Linux 技巧(原创)","slug":"Linux-技巧-原创","permalink":"http://www.oostech.com/categories/Linux-%E6%8A%80%E5%B7%A7-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"oom \"out_of_memory\" implementatoin 介绍","slug":"oom out_of_memory implementatoin_CHN","date":"2021-02-16T13:00:00.000Z","updated":"2021-02-16T16:00:00.000Z","comments":false,"path":"2021/02/16/oom out_of_memory implementatoin_CHN/","link":"","permalink":"http://www.oostech.com/2021/02/16/oom%20out_of_memory%20implementatoin_CHN/","excerpt":"","text":"oom “out_of_memory” implementatoin 介绍.注意,这里是基于内核 kernel-3.10.0-957.el7 (RHEL7.6) 1 OOM logs大概长什么样(这里使用手动触发OOM作为例子).1.1 例子 112Sep 15 23:08:48 XYZ kernel: SysRq : Manual OOM executionSep 15 23:08:48 XYZ kernel: Purging GPU memory, 29 pages freed, 30133 pages still pinned. 1.2 例子 2123456789Sep 15 23:38:48 XYZ kernel: SysRq : Manual OOM executionSep 15 23:38:48 XYZ kernel: kworker&#x2F;5:0 invoked oom-killer: gfp_mask&#x3D;0xd0, order&#x3D;0,Sep 15 23:38:48 XYZ kernel: Workqueue: events moom_callbackSep 15 23:38:48 XYZ kernel: Call Trace:Sep 15 23:38:48 XYZ kernel: [&lt;ffffffffa7161dc1&gt;] dump_stack+0x19&#x2F;0x1bSep 15 23:38:48 XYZ kernel: [&lt;ffffffffa715c7ea&gt;] dump_header+0x90&#x2F;0x229Sep 15 23:38:48 XYZ kernel: [&lt;ffffffffa6bba274&gt;] oom_kill_process+0x254&#x2F;0x3d0Sep 15 23:38:48 XYZ kernel: [&lt;ffffffffa6bbaab6&gt;] out_of_memory+0x4b6&#x2F;0x4f0Sep 15 23:38:48 XYZ kernel: [&lt;ffffffffa6e61f0d&gt;] moom_callback+0x4d&#x2F;0x50 2 看一下OOM的out_of_memory函数. 它主要分了7步,先看简化的代码,之后看具体介绍:12345678910111213141516171819202122232425262728293031void out_of_memory(struct zonelist *zonelist, gfp_t gfp_mask, int order, nodemask_t *nodemask, bool force_kill)&#123;... blocking_notifier_call_chain(&amp;oom_notify_list, 0, &amp;freed); if (freed &gt; 0) return;... if (fatal_signal_pending(current) || current-&gt;flags &amp; PF_EXITING) &#123; set_thread_flag(TIF_MEMDIE); return; &#125;... check_panic_on_oom(constraint, gfp_mask, order, mpol_mask); if (sysctl_oom_kill_allocating_task &amp;&amp; current-&gt;mm &amp;&amp; !oom_unkillable_task(current, NULL, nodemask) &amp;&amp; current-&gt;signal-&gt;oom_score_adj !&#x3D; OOM_SCORE_ADJ_MIN) &#123;... oom_kill_process(current, gfp_mask, order, 0, totalpages, NULL, nodemask, &quot;Out of memory (oom_kill_allocating_task)&quot;); goto out; &#125; p &#x3D; select_bad_process(&amp;points, totalpages, mpol_mask, force_kill);... if (!p) &#123; dump_header(NULL, gfp_mask, order, NULL, mpol_mask); panic(&quot;Out of memory and no killable processes...\\n&quot;); &#125;... oom_kill_process(p, gfp_mask, order, points, totalpages, NULL, nodemask, &quot;Out of memory&quot;);out:... schedule_timeout_killable(1);&#125; 第一, 如果出现oom, 先去处理通知链oom_notify_list的回调函数,如果内存回收成功(表现为freed大于0),则直接返回,然后快乐的收工了.1blocking_notifier_call_chain(&amp;oom_notify_list, 0, &amp;freed); 第二, 如果当前进程current(是一个thread_info结构)正在等待SIGKILL或者正在退出,设置进程标记为”TIF_MEMDIE”(代表进程由于OOM,目前正在关闭), 然后直接返回, 然后快乐的收工了.1if (fatal_signal_pending(current) || current-&gt;flags &amp; PF_EXITING) 第三, 限于NUMA场景(x86_64基本都是了,我们也可以看到内核配了CONFIG_NUMA=y). 如果配置了vm.panic_on_oom=1 (或者其他非0值,比如2)出现OOM, 系统就panic了(注意,RHEL8内核作了加强,如果是由于sysrq-trigger的,就不panic了). panic之后也就没的玩了,被迫收工.1check_panic_on_oom(constraint, gfp_mask, order, mpol_mask); 第四, 如果配置了vm.oom_kill_allocating_task=1,而且当前进程不是内核进程,也不是1号init进程,而且有内存可以释放, 并且进程的oom_score_adj不是-1000;总而言之,就是这个进程具备被kill的条件, 那就把它kill掉. 然后快乐的收工了.1if (sysctl_oom_kill_allocating_task &amp;&amp; current-&gt;mm &amp;&amp;!oom_unkillable_task(current, NULL, nodemask) &amp;&amp; current-&gt;signal-&gt;oom_score_adj !&#x3D; OOM_SCORE_ADJ_MIN) 第五, 如果跑到了这里,那就要花点心思选一个分数最高的进程来kill了. 基本的要点就是每个任务的rss，页表和交换空间使用的RAM的比例, 谁totalpages多, 那就越危险了 (因为totalpages的值会算到得分里面去D, 如果是root用户的进程,会给额外3%的折扣,root就是牛呀.), 如果找到就kill掉它,然后也可以收工了.1select_bad_process(&amp;points, totalpages, mpol_mask, force_kill); 第六, 这一步和第七是二选一的. 如果还没找到可以kill的进程,那就倒霉了. 输出信息之后就等系统panic了.没的玩了,被迫收工1panic(&quot;Out of memory and no killable processes...\\n&quot;); 第七, 这一步和第六是二选一的. 如果找到可以kill的进程,kill掉它.将进程设置为TASK_KILLABLE, 然后等待1个jiffies,那就全部打完收工咯.12oom_kill_process(p, gfp_mask, order, points, totalpages, NULL,nodemask, &quot;Out of memory&quot;);schedule_timeout_killable(1); 3 再来补充一下前面提到的oom_notify_list的通知链.3.1 内核为OOM定义了一个oom_notify_list通知链.1static BLOCKING_NOTIFIER_HEAD(oom_notify_list); 3.2 一些希望在OOM时,收到内核通知的, 就先把自己注册到通知链 (目前virtio_balloon和i915注册到了oom_notify_list通知链里面,所以出现OOM, 会先在通知链里面找这两个敢死队员:P). 如果出现OOM, 就先去通知链去找已经注册好的回调函数. 这也就是为什么我们能看到第1个OOM的log,而没有出现更多的OOM logs. virtio_balloon1vb-&gt;nb.notifier_call &#x3D; virtballoon_oom_notify; i9151i915-&gt;mm.oom_notifier.notifier_call &#x3D; i915_gem_shrinker_oom;","categories":[{"name":"Linux 技巧(原创)","slug":"Linux-技巧-原创","permalink":"http://www.oostech.com/categories/Linux-%E6%8A%80%E5%B7%A7-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"openvswitch 系列第一篇 简介及基本数据结构","slug":"openvswitch_section1_brief_and_struct","date":"2021-02-16T13:00:00.000Z","updated":"2021-02-16T16:00:00.000Z","comments":false,"path":"2021/02/16/openvswitch_section1_brief_and_struct/","link":"","permalink":"http://www.oostech.com/2021/02/16/openvswitch_section1_brief_and_struct/","excerpt":"","text":"openvswitch 系列第一篇 简介及基本数据结构 1. openvswitch1.1 基本描述datapath为ovs内核模块，负责执行数据交换，也就是把从接收端口收到的数据包在流表中进行匹配，并执行匹配到的动作。内核中可以实现多个datapath(可以理解为桥,就是我们用ovs-vsctl看到的br0/br1之类), 一个datapath类似一个物理交换机,它可以对应多个vport(vport类似物理交换机的端口概念)。一个datapth关联一个flow table，一个flow table包含多个条目，每个条目包括两个内容：一个是flow的 match/key; 另一个是对应的action. 最常见的action是在不同vport中进行转发。 当一个数据报到达vport, 内核首先将它的flow key解析出来,之后在内核模块datapath的flow cache (大小为(sizeof(struct sw_flow)+ (nr_cpu_ids * sizeof(struct flow_stats ) = ( 1248 + 68 )=1296, 根据系统实际的CUP的数量多少会稍有不同)中的flow table中查找. 如果找到匹配的flow 规则,则去执行对应的action. 如果没有找到匹配的flow规则,则将数据报通过netlink的方式发送到用户空间的ovs-vswitchd处理,而用户空间的流表空间(65536)大的多,所以匹配到的几率也更高,通过在用户空间查找,并执行对应的action;如果找到,会通过netlink把用户空间的流表推送到datapath的flow cache中,后续的报文就可以直接在内核态处理.如果最后还是没有找到,那就使用默认的流表规则(丢掉这个包,或者其他). 用户空间有两个进程组成：ovs-vswitchd和ovsdb-server。ovsdb-server保存了ovs-vswitchd的配置信息，ovsdb通常是一个文件, 并且保存在文件系统中，通常来说是/etc/openvswitch/conf.dbovs-vswitchd是一个daemon，北向与Controller通过OpenFlow协议通信.南向与openvswitch内核模块通过netlink通信.东西向过OVSDB协议与ovsdb-server通信. 1.2 openvswitch 内核模块示例12345678# lsmod |grep openvswitchopenvswitch 114793 3nf_nat_ipv6 14131 1 openvswitchnf_defrag_ipv6 35104 2 openvswitch,nf_conntrack_ipv6nf_nat_ipv4 14115 2 openvswitch,iptable_natnf_nat 26787 4 openvswitch,nf_nat_ipv4,nf_nat_ipv6,nf_nat_masquerade_ipv4nf_conntrack 133095 8 openvswitch,nf_nat,nf_nat_ipv4,nf_nat_ipv6,xt_conntrack,nf_nat_masquerade_ipv4,nf_conntrack_ipv4,nf_conntrack_ipv6libcrc32c 12644 4 xfs,openvswitch,nf_nat,nf_conntrack 1.3 通过openvswitch实现的bridge示例12# ovs-vsctl list-brbr0 1.4 通过openvswitch实现的bridge里面的voprt示例123# ovs-vsctl list-ports br0vport1vport2 1.5 通过openvswitch实现的bridge和vport的整体概览.1234567891011121314# ovs-vsctl show173a48d6-dbd3-420d-9433-384c437451a8 Bridge &quot;br0&quot; fail_mode: secure Port &quot;br0&quot; Interface &quot;br0&quot; type: internal Port &quot;vport1&quot; Interface &quot;vport1&quot; type: internal Port &quot;vport2&quot; Interface &quot;vport2&quot; type: internal ovs_version: &quot;2.0.0&quot; 1.6 流表示例123# ovs-ofctl dump-flows br0NXST_FLOW reply (xid&#x3D;0x4): cookie&#x3D;0x0, duration&#x3D;24.784s, table&#x3D;0, n_packets&#x3D;0, n_bytes&#x3D;0, idle_age&#x3D;24, ip,nw_src&#x3D;200.200.200.0 actions&#x3D;drop 2. 相对应的结构体示例2.1 datapath的代码描述 (datapath 类似数据通路,其实是bridge的抽象)1234567891011struct datapath &#123; struct rcu_head rcu; &#x2F;&#x2F; RCU回调, 用来负责推迟延迟销毁datapath struct list_head list_node; &#x2F;&#x2F; datapath链表,主要用来把datapath连接起来. struct flow_table table; &#x2F;&#x2F; datapath里面的流表 struct hlist_head *ports; &#x2F;&#x2F; datapath里面的Switch ports. 是以哈希表的形式表示. %OVSP_LOCAL 这个端口一直在datapath建立的时候就存在. 用 ovs_mutex 和 RCU 来进行锁保护. struct dp_stats_percpu __percpu *stats_percpu; &#x2F;&#x2F; Pre-CPU的datapath状态信息 possible_net_t net; &#x2F;&#x2F; datapat的网络命名空间的引用. u32 user_features; &#x2F;&#x2F; datapath用户所具有的能力. u32 max_headroom; &#x2F;&#x2F;留给datapath里面的所有vports使用的最大headroom. struct hlist_head *meters; &#x2F;&#x2F; datapath的meters, 参数之类.&#125;; 2.2 vport的代码描述1234567891011struct vport &#123; struct net_device *dev; &#x2F;&#x2F; 指向net_device的指针 struct datapath *dp; &#x2F;&#x2F; 指向这个port所在datapath的指针,表示该端口是属于哪个datapath的 struct vport_portids __rcu *upcall_portids; &#x2F;&#x2F;通过RCU机制保护的结构 &#39;struct vport_portids&#39; u16 port_no; &#x2F;&#x2F;在datapath里面所有端口数组的索引,唯一标识该端口.因为一个datapath上有多个端口，而这些端口都是用哈希链表来存储的，所以这是链表元素（里面没有数据，只有next和prev前驱后继指针，数据部分就是vport结构体中的其他成员） struct hlist_node hash_node; &#x2F;&#x2F;在设备hash表里面的元素 struct hlist_node dp_hash_node; &#x2F;&#x2F;在datapath的hash表里面的元素 const struct vport_ops *ops; &#x2F;&#x2F; 指向操作函数的指针,结构体里面存放了很多操作函数的函数指针 struct list_head detach_list; &#x2F;&#x2F;用来在net-exit调用时撤销vport的链表 struct rcu_head rcu; &#x2F;&#x2F;撤销datapath的RCU 回调函数头&#125;; 2.3 流表flow_table (有五部分组成,一个是流表,另外是流表的实例,流表的内容,流表的key值,流表操作集和)2.3.1 流表12345678struct flow_table &#123; &#x2F;&#x2F; 流表 struct table_instance __rcu *ti; &#x2F;&#x2F; 具体流表实例 struct table_instance __rcu *ufid_ti; &#x2F;&#x2F;包含unique flow identifier的流实例, struct list_head mask_list; &#x2F;&#x2F; 链表用来串联整个流表 (一般配合container_of使用来获取结构体的头指针) unsigned long last_rehash; &#x2F;&#x2F; 会初始化为当前的jiffies. 用来计间用 unsigned int count; &#x2F;&#x2F; 具体流表的个数, ovs_flow_tbl_init流表初始化时,会置为0 unsigned int ufid_count; &#x2F;&#x2F; 具体unique flow identifier流表的个数,ovs_flow_tbl_init流表初始化时,会置为0&#125;; 2.3.2 流表的具体实例12345678struct table_instance &#123; &#x2F;&#x2F;流表的具体实例 struct flex_array *buckets; &#x2F;&#x2F;哈希桶地址指针. 具体的流表项, 主要是方便处理.(真实的流表应该在这里面) unsigned int n_buckets; &#x2F;&#x2F; 哈希桶个数 struct rcu_head rcu;&#x2F;&#x2F; 操作(撤销?)流表的RCU 回调函数头 int node_ver; &#x2F;&#x2F;node_ver的存在使得我们可以控制sw_flow的哪个hlist_node链入到bucket中 u32 hash_seed; &#x2F;&#x2F;哈希算法需要的种子 bool keep_flows;&#x2F;&#x2F;是否保留流表项&#125;; 2.3.3 流表里面所具体保存的内容1234567891011121314struct sw_flow &#123; &#x2F;&#x2F; 流表里面所具体保存的内容. struct rcu_head rcu; &#x2F;&#x2F; rcu保护机制 (撤销流表项的RCU 回调函数头) struct &#123; struct hlist_node node[2]; &#x2F;&#x2F; 两个节点指针，用来链接作用，前驱后继指针 u32 hash; &#x2F;&#x2F; hash值 &#125; flow_table, ufid_table; &#x2F;&#x2F; 为两种流表各定义对应的结构. int stats_last_writer; &#x2F;&#x2F; 最近一个CPU写操作的ID struct sw_flow_key key; &#x2F;&#x2F; 流表中的key值, 这个是个关键东东了,关系到报文要匹配那些流表key struct sw_flow_id id; &#x2F;&#x2F; 流表自身的ID struct cpumask cpu_used_mask; &#x2F;&#x2F; 也是流表中的key struct sw_flow_mask *mask; &#x2F;&#x2F; 要匹配的mask结构体 struct sw_flow_actions __rcu *sf_acts; &#x2F;&#x2F; 相应的action动作. 使用了rcu机制保护的. struct flow_stats __rcu *stats[]; &#x2F;* 数据流的状态,每一个CPU上都有,第一个是流建立的时候, 其余的是在获取stats[0].lock锁之后,根据需求分配. 使用了rcu机制保护的.&#125;; 2.3.4 流表中的key值，主要是保存数据包中协议相关信息，这是报文要进行流表匹配的关键结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687struct sw_flow_key &#123; u8 tun_opts[IP_TUNNEL_OPTS_MAX]; u8 tun_opts_len; struct ip_tunnel_key tun_key; &#x2F;&#x2F; 隧道的封装key. struct &#123; u32 priority; &#x2F;&#x2F; 包的Qos优先级 u32 skb_mark; &#x2F;&#x2F; skb包的标记 u16 in_port; &#x2F;&#x2F; 包进入的端口号或者DP_MAX_PORTS &#125; __packed phy; &#x2F;&#x2F; Safe when right after &#39;tun_key&#39;. u8 mac_proto; &#x2F;&#x2F; 链路层协议, 比如 Ethernet, ATM 等等 u8 tun_proto; &#x2F;&#x2F; 封装协议, 比如GRE, VXLAN 等等 u32 ovs_flow_hash; &#x2F;&#x2F; Datapath 所计算出的 hash 值 u32 recirc_id; &#x2F;&#x2F; 转发的ID Recirculation ID. struct &#123; u8 src[ETH_ALEN]; &#x2F;&#x2F; Ethernet源mac地址 u8 dst[ETH_ALEN]; &#x2F;&#x2F; Ethernet目的mac地址 struct vlan_head vlan; &#x2F;&#x2F; vlan 的信息, 802.1q or 802.1ad 类型 以及vlan id struct vlan_head cvlan; &#x2F;&#x2F; vlan 的信息给Conntrack用的, 802.1q or 802.1ad 类型 以及vlan id __be16 type; &#x2F;&#x2F; 以太网帧类型 &#125; eth; &#x2F;&#x2F; 2 层的. 数据链路层的匹配信息. u8 ct_state; &#x2F;&#x2F; Conntrack的状态,有或者没有 u8 ct_orig_proto; &#x2F;&#x2F;Conntrack 的原始路径的ip协议. 其实用来表示有没有包含original direction key 内容. union &#123; struct &#123; __be32 top_lse; &#x2F;* top label stack entry *&#x2F; &#125; mpls; struct &#123; u8 proto; &#x2F;&#x2F; IP包协议类型 TCP：6；UDP：17；ARP操作码类型用低8位表示 u8 tos; &#x2F;&#x2F; IP包服务类型 u8 ttl; &#x2F;&#x2F; IP包生存时间，经过多少跳路由 u8 frag; &#x2F;&#x2F; 网桥中的OVS_FRAG_TYPE_*标记 &#125; ip; &#x2F;&#x2F; 3 层的. ip 层的匹配信息. &#125;; u16 ct_zone; &#x2F;&#x2F; 追踪连接状态区 struct &#123; __be16 src; &#x2F;&#x2F; TCP&#x2F;UDP&#x2F;SCTP的源端口，应用层发送数据的端口 __be16 dst; &#x2F;&#x2F; TCP&#x2F;UDP&#x2F;SCTP的目的端口，也是指应用层传输数据端口 __be16 flags; &#x2F;&#x2F; TCP 的标记 &#125; tp; &#x2F;&#x2F; 4 层的. 传输层的匹配信息 union &#123; struct &#123; struct &#123; __be32 src; &#x2F;&#x2F; IP源地址 __be32 dst; &#x2F;&#x2F; IP目的地址 &#125; addr; &#x2F;&#x2F; IP 的信息 union &#123; struct &#123; __be32 src; &#x2F;&#x2F; Conntrack IP源地址 __be32 dst; &#x2F;&#x2F; Conntrack IP目的地址 &#125; ct_orig; &#x2F;&#x2F; 追踪连接的原始目的区域 struct &#123; u8 sha[ETH_ALEN]; &#x2F;&#x2F; ARP的源Mac地址 u8 tha[ETH_ALEN]; &#x2F;&#x2F; ARP的目的Mac地址 &#125; arp; &#x2F;&#x2F; arp 的信息 &#125;; &#125; ipv4; &#x2F;&#x2F; IPv4 的信息 struct &#123; struct &#123; struct in6_addr src; &#x2F;&#x2F; IPv6 源地址 struct in6_addr dst; &#x2F;&#x2F; IPv6 目的地址 &#125; addr; &#x2F;&#x2F; IPv6 的IP层信息 __be32 label; &#x2F;&#x2F; IPv6 流的标示 union &#123; struct &#123; struct in6_addr src; &#x2F;&#x2F; Conntrack IP源地址 struct in6_addr dst; &#x2F;&#x2F; Conntrack IP目的地址 &#125; ct_orig; &#x2F;&#x2F; 追踪连接的原始目的区域 struct &#123; struct in6_addr target; &#x2F;&#x2F; Neighbor Discovery 目标地址 u8 sll[ETH_ALEN]; &#x2F;&#x2F; Neighbor Discovery 源链接层地址 u8 tll[ETH_ALEN]; &#x2F;&#x2F; Neighbor Discovery 目标接层地址 &#125; nd; &#x2F;&#x2F;Neighbor Discovery (ND) protocol 是一个IPV6 的协议. 主机或者路由使用ND协议去侦测邻居的链路层地址,在必要的时候,可以及时清除无效的cache &#125;; &#125; ipv6; &#x2F;&#x2F; IPV6 信息. struct ovs_key_nsh nsh; &#x2F;&#x2F; 网络服务头 &#125;; struct &#123; &#x2F;&#x2F; Connection tracking fields 连接监测的信息, CT主要用来做网络连接状态的识别. OVS2.5版本开始支持. 涉及到有状态的防火墙和无状态的防火墙.Openstack则从M版开始，使用OVS的新特性，来实现“有状态防火墙”中的“Security Group”功能 struct &#123; __be16 src; &#x2F;* CT orig tuple tp src port. 连接监测源端口.用于“有状态防火墙”的流识别 __be16 dst; &#x2F;* CT orig tuple tp dst port. 连接监测目的端口.用于“有状态防火墙”的流识别 &#125; orig_tp; u32 mark; struct ovs_key_ct_labels labels; &#x2F;&#x2F; 这个是个32bit联合体,作为一个labels &#125; ct; &#x2F;&#x2F; Connection tracking, 报文进来可能会先进入这里,如果有的话, 然后匹配自身的流表之后再去匹配datapath的流表,再之后执行action.&#125; __aligned(BITS_PER_LONG&#x2F;8); &#x2F;&#x2F; 主要是用来做数据对齐用的. 考虑到存取的效率, 在64bit机器上,就是8字节对齐 2.3.5 流表项操作, 也就是能对流表做些什么操作.123456struct sw_flow_actions &#123; struct rcu_head rcu; &#x2F;&#x2F; 要操作流表,肯定要个rcu来加锁同步了. size_t orig_len; &#x2F;&#x2F; 来自 flow_cmd_new netlink actions 操作的长度 u32 actions_len; &#x2F;&#x2F; 操作的长度. struct nlattr actions[]; &#x2F;&#x2F;流表项的操作集合,这个是一个netlink的结构,一个就是数据包的长度,一个就是类型.&#125;; 到此,第一部分就介绍完毕了. 后续会有网桥的操作,vport的操作,数据报的处理等等的介绍…","categories":[{"name":"网络 OVS(原创)","slug":"网络-OVS-原创","permalink":"http://www.oostech.com/categories/%E7%BD%91%E7%BB%9C-OVS-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"openvswitch 系列第二篇 API接口","slug":"openvswitch_sesstion2_API_interface","date":"2021-02-16T13:00:00.000Z","updated":"2021-02-16T16:00:00.000Z","comments":false,"path":"2021/02/16/openvswitch_sesstion2_API_interface/","link":"","permalink":"http://www.oostech.com/2021/02/16/openvswitch_sesstion2_API_interface/","excerpt":"","text":"openvswitch 系列第二篇 API接口 1. openvswitch1.1 基本描述datapath为ovs内核模块，负责执行数据交换，也就是把从接收端口收到的数据包在流表中进行匹配，并执行匹配到的动作。内核中可以实现多个datapath(可以理解为桥,就是我们用ovs-vsctl看到的br0/br1之类), 一个datapath类似一个物理交换机,它可以对应多个vport(vport类似物理交换机的端口概念)。一个datapth关联一个flow table，一个flow table包含多个条目，每个条目包括两个内容：一个是flow的 match/key; 另一个是对应的action. 最常见的action是在不同vport中进行转发。 当一个数据报到达vport, 内核首先将它的flow key解析出来,之后在内核模块datapath的flow cache (大小为(sizeof(struct sw_flow)+ (nr_cpu_ids * sizeof(struct flow_stats ) = ( 1248 + 68 )=1296, 根据系统实际的CUP的数量多少会稍有不同)中的flow table中查找. 如果找到匹配的flow 规则,则去执行对应的action. 如果没有找到匹配的flow规则,则将数据报通过netlink的方式发送到用户空间的ovs-vswitchd处理,而用户空间的流表空间(65536)大的多,所以匹配到的几率也更高,通过在用户空间查找,并执行对应的action;如果找到,会通过netlink把用户空间的流表推送到datapath的flow cache中,后续的报文就可以直接在内核态处理.如果最后还是没有找到,那就使用默认的流表规则(丢掉这个包,或者其他). 用户空间有两个进程组成：ovs-vswitchd和ovsdb-server。ovsdb-server保存了ovs-vswitchd的配置信息,ovsdb通常是一个文件,并且保存在文件系统中,通常来说是/etc/openvswitch/conf.dbovs-vswitchd是一个daemon,北向与Controller通过OpenFlow协议通信.南向与openvswitch内核模块通过netlink通信.东西向过OVSDB协议与ovsdb-server通信. 2 openvswitch API的分类在Linux中,可以使用Netlink来实现用户空间与内核的通信.而openvswitch也正是使用了netlink机制,使用其中的generic netlink来用来实现通信. openvswitch一共有4大类API: datapath, virtual port, flow, 和packet. 通常在使用这些时,我们需要CAP_NET_ADMIN的权限. 2.1 datapath API有5种对应的操作NEW ,DEL,GET,SET和UNSPEC(预留的,现在不用).通过这些命令,用户可以建立,删除,查询和修改datapath.定义为枚举类型,其实对应过来也就是操作码与数字的键值对.enum ovs_datapath_cmd { OVS_DP_CMD_UNSPEC, OVS_DP_CMD_NEW, OVS_DP_CMD_DEL, OVS_DP_CMD_GET, OVS_DP_CMD_SET}; 2.1.1 OVS_DP_CMD_NEWOVS_DP_CMD_NEW通过static int ovs_dp_cmd_new(struct sk_buff *skb, struct genl_info *info)实现.当执行NEW操作的时候,ovs_dp_cmd_new 函数会被调用,此函数用于建立一个datapath. 2.1.2 OVS_DP_CMD_DELOVS_DP_CMD_DEL通过static int ovs_dp_cmd_del(struct sk_buff *skb, struct genl_info info)实现.当执行DEL操作的时候,ovs_dp_cmd_del函数会被调用,此函数用于删除一个datapath. 至于删除哪一个datapath的信息则是由info获取的. 2.1.3 OVS_DP_CMD_GETOVS_DP_CMD_GET通过static int ovs_dp_cmd_get(struct sk_buff *skb, struct genl_info info)实现.当执行GET操作的时候,ovs_dp_cmd_get函数会被调用.通过从info获取到的信息,最终通过调用ovs_dp_cmd_fill_info实现并通过genlmsg_reply返回. 2.1.4 OVS_DP_CMD_SETOVS_DP_CMD_SET通过static int ovs_dp_cmd_set(struct sk_buff *skb, struct genl_info *info)实现.当执行SET操作的时候,ovs_dp_cmd_set函数会被调用.然后通过调用ovs_dp_change来进行属性的修改. 2.2 virtual port API有5种对应的操作NEW,DEL,GET,SET和UNSPEC(预留的,现在不用).通过这些命令,用户可以建立,删除,查询和修改vport.定义为枚举类型,其实对应过来也就是操作码与数字的键值对.enum ovs_vport_cmd { OVS_VPORT_CMD_UNSPEC, OVS_VPORT_CMD_NEW, OVS_VPORT_CMD_DEL, OVS_VPORT_CMD_GET, OVS_VPORT_CMD_SET}; 2.2.1 OVS_VPORT_CMD_NEWOVS_VPORT_CMD_NEW通过static int ovs_vport_cmd_new(struct sk_buff *skb, struct genl_info info)实现.当执行NEW操作的时候,ovs_vport_cmd_new函数会被调用,然后给从info获取到的datapath信息,给指定的datapath新建指定的端口. 2.2.2 OVS_VPORT_CMD_DELOVS_VPORT_CMD_DEL通过static int ovs_vport_cmd_del(struct sk_buff *skb, struct genl_info info)实现.当执行DEL操作的时候,ovs_vport_cmd_del函数会被调用,然后从info中获取到指定的ports进行删除操作. 2.2.3 OVS_VPORT_CMD_GETOVS_VPORT_CMD_GET通过static int ovs_vport_cmd_get(struct sk_buff *skb, struct genl_info info)实现.当执行GET操作的时候,ovs_vport_cmd_get函数会被调用,然后从info获取到指定端口的信息后,最后通过genlmsg_reply返回. 2.2.4 OVS_VPORT_CMD_SETOVS_VPORT_CMD_SET通过static int ovs_vport_cmd_set(struct sk_buff *skb, struct genl_info info)实现.当执行SET操作的时候,ovs_vport_cmd_set函数会被调用,然后从info获取到指定的端口,然后调用ovs_vport_set_options来更新对应的vport属性. 2.3 flow API有5种对应的操作NEW,DEL,GET,SET和UNSPEC(预留的,现在不用).通过这些命令,用户可以建立,删除,查询和修改flow.定义为枚举类型,其实对应过来也就是操作码与数字的键值对.enum ovs_flow_cmd { OVS_FLOW_CMD_UNSPEC, OVS_FLOW_CMD_NEW, OVS_FLOW_CMD_DEL, OVS_FLOW_CMD_GET, OVS_FLOW_CMD_SET}; 2.3.1 OVS_FLOW_CMD_NEWOVS_FLOW_CMD_NEW通过static int ovs_flow_cmd_new(struct sk_buff *skb, struct genl_info *info)实现.当执行NEW操作的时候,ovs_flow_cmd_new会被调用然后一系列函数会被调用,比如ovs_flow_alloc,ovs_flow_tbl_insert,等等. 因为建立流表需要判断action是否有效,流表是否重复,而且还需要涉及同步加锁解锁等等. 2.3.2 OVS_FLOW_CMD_DELOVS_FLOW_CMD_DEL通过static int ovs_flow_cmd_del(struct sk_buff *skb, struct genl_info info)实现.当执行DEL操作的时候,ovs_flow_cmd_del会被调用,然后通过info获取对应属性,找到对应datapath,对应的流表uuid,然后通过ovs_flow_tbl_remove,ovs_flow_free等等将对应流表删除.当然了,这个过程也得加锁解锁. 2.3.3 OVS_FLOW_CMD_GETOVS_FLOW_CMD_GET通过static int ovs_flow_cmd_get(struct sk_buff *skb, struct genl_info info)实现.当执行GET操作的时候,ovs_flow_cmd_get会被调用,然后通过info获取对应属性,找到对应datapath,对应的流表uuid最后通过ovs_flow_cmd_build_info获取到需要的信息,并返回. 2.3.4 OVS_FLOW_CMD_SETOVS_FLOW_CMD_SET通过static int ovs_flow_cmd_set(struct sk_buff *skb, struct genl_info info)实现.当执行SET操作的时候,ovs_flow_cmd_set会被调用,然后通过info获取对应属性,找到对应datapath,对应的流表uuid,最后调用一系列函数,如ovsl_dereference更新action,用ovs_flow_stats_clear清除对应状态等等.当然,这个过程也得加锁解锁. 2.4 packet API有4种对应的操作MISS,ACTION,EXECUTE和和UNSPEC(预留的,现在不用),用于与用户空间应用进行数据包交互(发送,接收).定义为枚举类型,其实对应过来也就是操作码与数字的键值对.enum ovs_packet_cmd { OVS_PACKET_CMD_UNSPEC, OVS_PACKET_CMD_MISS, /* 内核发向用户空间, 流表没有命中 / OVS_PACKET_CMD_ACTION, / 内核发向用户空间, OVS_ACTION_ATTR_USERSPACE的操作. / OVS_PACKET_CMD_EXECUTE / 用户空间命令,给对应的packet执行指定的动作 */}; 2.4.1 OVS_PACKET_CMD_MISS内核函数ovs_dp_process_packet在处理datapath的packet的时候,如果出现流表没有匹配的话,ovs_flow_stats_update, u64_stats_update_begin等函数就会被调用,然后对应的datapath计数器会被更新. 2.4.2 OVS_PACKET_CMD_ACTION内核函数output_userspace通过初始化结构dp_upcall_indo将OVS_PACKET_CMD_ACTION传进去,然后调用ovs_dp_updacall实现对用户空间OVS_ACTION_ATTR_USERSPACE的操作. 2.4.3 OVS_PACKET_CMD_EXECUTEOVS_PACKET_CMD_EXECUTE通过static int ovs_packet_cmd_execute(struct sk_buff *skb, struct genl_info *info)实现. 当执行EXECUTE操作的时候,其实就是packet的发送(转发)过程. 一系列内核函数会被使用, __dev_alloc_skb建立一个skb, 通过ovs_flow_alloc建立一个sw_flow, 以及使用ovs_execute_actions来执行这个发送操作. 3 OVS在Openshift和OpenStack的使用.3.1 Openshift在使用OVS时,并不是直接调用上面介绍到的API接口,而是使用OVS封装好的二进制工具比如ovs-appctl”,”ovs-dpctl”,”ovs-ofctl”,”ovs-vsctl”之类,通过”golang”调用的. 例子如下:1234567func (ovsif *ovsExec) AddPort(port string, ofportRequest int, properties ...string) (int, error) &#123; args :&#x3D; []string&#123;&quot;--may-exist&quot;, &quot;add-port&quot;, ovsif.bridge, port&#125; if ofportRequest &gt; 0 || len(properties) &gt; 0 &#123; args &#x3D; append(args, &quot;--&quot;, &quot;set&quot;, &quot;Interface&quot;, port) &lt;truncated&gt; _, err :&#x3D; ovsif.exec(OVS_VSCTL, args...) &lt;truncated&gt; 3.2 OpenStack在使用OVS时,同样也不是直接调用上面介绍到的API接口,而是使用OVS封装好的二进制工具比如ovs-appctl”,”ovs-dpctl”,”ovs-ofctl”,”ovs-vsctl”之类,通过”python”调用的.例子如下:1234567891011121314class LinuxOVSInterfaceDriver(LinuxNetInterfaceDriver):&lt;truncated&gt; _ovs_vsctl([&#39;--&#39;, &#39;--may-exist&#39;, &#39;add-port&#39;, bridge, dev, &#39;--&#39;, &#39;set&#39;, &#39;Interface&#39;, dev, &#39;type&#x3D;internal&#39;, &#39;--&#39;, &#39;set&#39;, &#39;Interface&#39;, dev, &#39;external-ids:iface-id&#x3D;%s&#39; % dev, &#39;--&#39;, &#39;set&#39;, &#39;Interface&#39;, dev, &#39;external-ids:iface-status&#x3D;active&#39;, &#39;--&#39;, &#39;set&#39;, &#39;Interface&#39;, dev, &#39;external-ids:attached-mac&#x3D;%s&#39; % mac_address])&lt;truncated&gt; _execute(&#39;ovs-ofctl&#39;, &#39;add-flow&#39;, bridge, &#39;priority&#x3D;1,actions&#x3D;drop&#39;, run_as_root&#x3D;True) 4 到此,openvswitch的API就是简要地介绍完毕了.","categories":[{"name":"网络 OVS(原创)","slug":"网络-OVS-原创","permalink":"http://www.oostech.com/categories/%E7%BD%91%E7%BB%9C-OVS-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"ovs-vsctl简明用户手册(基于版本openvswitch-2.11.0-4.el7.x86_64)","slug":"ovs-vsctl_usage-guide-CHN","date":"2021-02-16T13:00:00.000Z","updated":"2021-02-16T16:00:00.000Z","comments":false,"path":"2021/02/16/ovs-vsctl_usage-guide-CHN/","link":"","permalink":"http://www.oostech.com/2021/02/16/ovs-vsctl_usage-guide-CHN/","excerpt":"","text":"ovs-vsctl简明用户手册(基于版本openvswitch-2.11.0-4.el7.x86_64)ovs-vsctl 是一个用户命令行界面,可以用来操作ovs-vswitchd这个后台程序 1#&#x2F;usr&#x2F;share&#x2F;openvswitch&#x2F;scripts&#x2F;ovs-ctl start 1 操作虚拟网桥的命令.1.1 初始化OVS数据库 (这个命令没有输出)1# ovs-vsctl init 例子1# ovs-vsctl init 1.2 输出当前OVS的状态, 比如你可以看到OVS网桥,端口(port),接口(interface)和对应的类型.1# ovs-vsctl show 例子12345678# ovs-vsctl showBridge &quot;samlee_br1&quot; Port &quot;samlee_br1&quot; Interface &quot;samlee_br1&quot; type: internal Port &quot;ens12&quot; Interface &quot;ens12&quot;ovs_version: &quot;2.11.0&quot; 1.3 重新启动OVS网桥 (这个命令没有输出)1# ovs-vsctl emer-reset 例子1# ovs-vsctl emer-reset 1.4 创建一个OVS网桥 (这个命令没有输出)1# ovs-vsctl add-br BRIDGE_NAME 例子 (add a bridge, named samlee_br1)1# ovs-vsctl add-br samlee_br1 1.5 通过OVS父网桥创建一个桥中桥,并配上VLAN号(这个命令没有输出)1# ovs-vsctl add-br BRIDGE_NAME PARENT_BR_NAME VLAN 例子1# ovs-vsctl add-br samlee_fake_br1 samlee_br1 200 1.6 删除OVS网桥并同时删除附在上面的端口与接口(这个命令没有输出)1# ovs-vsctl del-br BRIDGE_NAME 例子1# ovs-vsctl del-br tobedeleted_br1 1.7 列出所有OVS网桥的名字1# ovs-vsctl list-br 例子123# ovs-vsctl list-brsamlee_br1samlee_fake_br1 1.8 查询指定的OVS网桥是否存在,存在返回0,否则返回2(这个命令没有输出,我们通过echo来获得输出)1# ovs-vsctl br-exists BRIDGE_NAME 例子12# ovs-vsctl br-exists samlee_br1 ; echo $?0 12# ovs-vsctl br-exists samlee_br2 ; echo $?2 1.9 查看指定的VLAN在那个OVS网桥上面(这个命令输出VLAN ID)1# ovs-vsctl br-to-vlan BRIDGE_NAME 例子12# ovs-vsctl br-to-vlan samlee_fake_br1200 1.10 查看指定OVS网桥的父网桥名字(这个命令会输出父网桥的名字)1# ovs-vsctl br-to-parent BRIDGE_NAME 例子12# ovs-vsctl br-to-parent samlee_fake_br1samlee_br1 1.11 给指定的OVS网桥设置键值对; 这些键值对可以用来给指定OVS网桥作为标示(这个命令没有输出)1# ovs-vsctl BRIDGE_NAME KEY VALUE 例子1# ovs-vsctl br-set-external-id samlee_fake_br1 priority 3 1.12 清除指定OVS网桥的键值对(这个命令没有输出)1# ovs-vsctl br-set-external-id BRIDGE_NAME KEY 例子1ovs-vsctl br-set-external-id samlee_fake_br1 priority 1.13 输出指定OVS网桥的键值对的值 (这个命令输出键值)1# ovs-vsctl br-get-external-id BRIDGE_NAME KEY 例子12# ovs-vsctl br-get-external-id samlee_fake_br1 priority3 1.14 输出指定OVS网桥的键值对 (这个命令输出键值对)1# ovs-vsctl br-get-external-id BRIDGE_NAME 例子12# ovs-vsctl br-get-external-id samlee_fake_br1priority&#x3D;3 2 端口操作命令(注意:默认每一个OVS网桥都有一个与之同名的端口, 一个聚合端口(bond)被看做一个端口) 2.1 列出指定OVS网桥上面的所有的端口(这个命令将输出端口的名字)1# ovs-vsctl list-ports BRIDGE_NAME 例子12# ovs-vsctl list-ports samlee_br1ens12 2.2 给指定的OVS网桥添加一个端 (这个命令没有输出)1# ovs-vsctl add-port BRIDGE_NAME PORT 例子1# ovs-vsctl add-port samlee_br1 ens12 2.3 给指定的OVS网桥添加一个聚合端口(bond)并且将指定的接口加入聚合端口(这个命令没有输出)1# ovs-vsctl add-bond BRIDGE_NAME PORT_NAME IFACE... 例子1# ovs-vsctl add-bond samlee_br1 sam_bond0 ens11 ens12 2.4 查看指定聚合端口(bond)的参数(这个命令将输出端口的参数) 1# ovs-appctl bond&#x2F;show BOND_PORT 例子123456789101112131415# ovs-appctl bond&#x2F;show sam_bond0 ---- sam_bond0 ----bond_mode: active-backupbond may use recirculation: no, Recirc-ID : -1bond-hash-basis: 0updelay: 0 msdowndelay: 0 mslacp_status: offlacp_fallback_ab: falseactive slave mac: 52:54:00:cf:9f:59(ens12)slave ens11: enabled may_enable: trueslave ens12: enabled active slave may_enable: true 2.5 从指定的OVS网桥上删除指定的端口(这个命令没有输出)1# ovs-vsctl del-port [BRIDGE_NAME] PORT 例子1# ovs-vsctl del-port samlee_br1 ens12 2.6 通过指定端口查询它所在的OVS网桥(这个命令将输出网桥的名字)1# ovs-vsctl port-to-br PORT 例子12# ovs-vsctl port-to-br ens12samlee_br1 2.7 给端口指定一个接口类型, 类型可以是常规类型,内部类型,对接类型和隧道类型(这个命令没有输出)1# ovs-vsctl set Interface PORT_NAME type&#x3D;TYPE_NAME 例子1# ovs-vsctl set Interface samlee_br1 type&#x3D;internal TBD 2.8 给指定OVS网桥添加一个隧道. 隧道的类型可以是gre或者vxlan(比如,给网桥samlee_br1添加一个名字为samlee_tunnel的隧道.并且指定这个隧道的端口,接口名字为samlee_tunnel. 并且给接口指定IP地址. 其中vxlan的默认端口号是4789). (这个命令没有输出)1# ovs-vsctl add-port BRIDGE_NAME PORT_NAME -- set Interface INTERFACE_NAME type&#x3D;TUNNEL_TYPE options:remote_ip&#x3D;IPADDRESS 例子1# ovs-vsctl add-port samlee_br1 samlee_tunnel -- set Interface samlee_tunnel type&#x3D;gre options:remote_ip&#x3D;200.200.200.200 1# ovs-vsctl add-port samlee_br1 samlee_vxlan -- set Interface samlee_vxlan type&#x3D;vxlan options:remote_ip&#x3D;100.100.100.100 options:dst_port&#x3D;4789 3 接口操作命令(注意: 一个聚合端口(bond)包含多个接口): 3.1 列出指定OVS网桥上面的所有接口(这个命令将输出接口的名字)1# ovs-vsctl list-ifaces BRIDGE_NAME 例子12# ovs-vsctl list-ifaces samlee_br1ens12 3.2 输出指定接口所在的OVS网桥(这个将输出网桥的名字)1# ovs-vsctl iface-to-br IFACE 例子12# ovs-vsctl iface-to-br ens12samlee_br1 4 控制OVS网桥的相关命令. ovs-vswitchd这个后台程序可以实现对OVS网桥,OVS交换机的本地管理. 同时,它也可以支持符合Open-Flow规范的外部Open‐Flow控制器的远程管理. 如果这个外部的Open‐Flow控制器失效,会造成OVS网桥和OVS交换机的丢包. 但是我们可以通过相应的配置来避免此类情况. 我们可以将fail-mode模式设置为standalone或者是secure. 在standalone模式下面,如果Open‐Flow控制器失效,在一个指定的时间间隔内,重试3次都没有收到Open‐Flow控制器的数据包,ovs-vswitchd这个后台程序将会重新接管,并以本地模式运行,此时OVS网桥和OVS交换机将不受影响. 而如果设置为secure模式,在Open‐Flow控制器失效时,ovs-vswitchd这个后台程序将不会重新接管, 而此时OVS网桥和OVS交换机将受到影响 4.1 查询当前OVS网桥的Open‐Flow控制器(这个命令将输出Open‐Flow控制器的名字)1# ovs-vsctl get-controller BRIDGE_NAME 例子12# ovs-vsctl get-controller samlee_br1tcp:127.0.0.1:6633 4.2 删除当前OVS网桥的Open‐Flow控制器(这个命令没有输出)1# ovs-vsctl del-controller BRIDGE_NAME 例子1# ovs-vsctl del-controller samlee_br1 4.3 指定当前OVS网桥的Open‐Flow控制器 (这个命令没有输出)1# ovs-vsctl set-controller BRIDGE_NAME TARGET... 例子1# ovs-vsctl set-controller samlee_br1 tcp:127.0.0.1:6633 4.4 查询当前OVS网桥的Open‐Flow控制器的失效模式(这个命令将输出Open‐Flow控制器失效模式的名字)1# ovs-vsctl get-fail-mode BRIDGE_NAME 例子12# ovs-vsctl get-fail-mode samlee_br1standalone 4.5 删除当前OVS网桥的Open‐Flow控制器的失效模式 (这个命令没有输出)1# ovs-vsctl del-fail-mode BRIDGE_NAME 例子1# ovs-vsctl del-fail-mode samlee_br1 4.6 设置当前OVS网桥的Open‐Flow控制器的失效模式 (这个命令没有输出)1# ovs-vsctl set-fail-mode BRIDGE_NAME FAIL_MODE_NAME 例子1# ovs-vsctl set-fail-mode samlee_br1 standalone 5 OVS交换机的命令: 5.1 重新启动ovs交换机 (这个命令没有输出)1# ovs-vsctl emer-reset 例子1# ovs-vsctl emer-reset 好, ovs-vsctl简明用户手册(基于版本openvswitch-2.11.0-4.el7.x86_64)就介绍完毕了. 想要了解更多?也欢迎关注 addos 微信公众号获取更多 :-)","categories":[{"name":"网络 OVS(原创)","slug":"网络-OVS-原创","permalink":"http://www.oostech.com/categories/%E7%BD%91%E7%BB%9C-OVS-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"Red Hat Enterprise Linux 8 的新玩意 第4篇 通过`grub`配置Kernel启动参数","slug":"RHEL8-news-toys-section4_Kernel_cmdline","date":"2021-02-16T13:00:00.000Z","updated":"2021-02-16T16:00:00.000Z","comments":false,"path":"2021/02/16/RHEL8-news-toys-section4_Kernel_cmdline/","link":"","permalink":"http://www.oostech.com/2021/02/16/RHEL8-news-toys-section4_Kernel_cmdline/","excerpt":"","text":"Red Hat Enterprise Linux 8 (RHEL8) 的新玩意 第4篇 通过grub配置Kernel启动参数内核启动参数, 简单的说就是可以给内核传递参数，并且用于控制内核行为方式. 1 通常来说我们有3种方式可以给内核传递参数1.1 在编译内核时侯,添加我们要的参数1.2 内核启动时通过boootloader添加,比如通过gurb或者uboot (arm或者ppc平台)1.3 在系统运行的时候,通过修改/proc和/sys里面对应的文件.2 这里, 我们讲第二项(内核启动时通过boootloader添加,比如通过gurb或者uboot); 通常来说我们可以通过直接修改/boot/grub2/grub.cfg文件来现实.但是我们看到,在RHEL8上面,/boot/grub2/grub.cfg居然没有我们熟悉linux /boot/vmlinuz-xxx.x86_64 root=UUID=xxx的条目. 这是什么回事,比如我们要重定向串口输出,添加console=ttyS0,115200n8这个参数要加到什么地方?不要紧,让我们先来看看\\boot下面都有些什么文件.3 查看启动目录/boot/的内容, 我们知道系统是启动这个内核vmlinuz-4.18.0-80.el8.x86_64123456[root@vm3_rhel8 ~]# cd &#x2F;boot&#x2F; &amp;&amp; lsconfig-4.18.0-80.el8.x86_64 initramfs-4.18.0-80.el8.x86_64kdump.imgefi loadergrub2 System.map-4.18.0-80.el8.x86_64initramfs-0-rescue-54d1217dfdda4592a9e30059e470cf24.img vmlinuz-0-rescue-54d1217dfdda4592a9e30059e470cf24initramfs-4.18.0-80.el8.x86_64.img vmlinuz-4.18.0-80.el8.x86_64 4 知道了系统内核vmlinuz-4.18.0-80.el8.x86_64的名字,我们来找找有配置它的地方,来grub一下123[root@vm3_rhel8 boot]# grep -n &quot;vmlinuz-4.18.0-80.el8.x86_64&quot; -r .&#x2F;.&#x2F;loader&#x2F;entries&#x2F;54d1217dfdda4592a9e30059e470cf24-4.18.0-80.el8.x86_64.conf:3:linux &#x2F;boot&#x2F;vmlinuz-4.18.0-80.el8.x86_64.&#x2F;.vmlinuz-4.18.0-80.el8.x86_64.hmac:1:54d1217dfdda4592a9e30059e470cf24 &#x2F;boot&#x2F;vmlinuz-4.18.0-80.el8.x86_64 5 好了, 我们找到了相关的文件./loader/entries/54d1217dfdda4592a9e30059e470cf24-4.18.0-80.el8.x86_64.conf, 那就来看看里面都有些什么cat一下.123456789title Red Hat Enterprise Linux (4.18.0-80.el8.x86_64) 8.0 (Ootpa)version 4.18.0-80.el8.x86_64linux &#x2F;boot&#x2F;vmlinuz-4.18.0-80.el8.x86_64initrd &#x2F;boot&#x2F;initramfs-4.18.0-80.el8.x86_64.img $tuned_initrdoptions $kernelopts $tuned_paramsid rhel-20190313123447-4.18.0-80.el8.x86_64grub_users $grub_usersgrub_arg --unrestrictedgrub_class kernel.&#x2F;loader&#x2F;entries&#x2F;54d1217dfdda4592a9e30059e470cf24-4.18.0-80.el8.x86_64.conf 6 有熟悉的面孔吧,看起来我们可以在这配置内核的参数,而且变量kernelopts似乎是对应的启动参数.123[root@vm3_rhel8 boot]# grep -n &quot;kernelopts&quot; -r .&#x2F;.&#x2F;grub2&#x2F;grubenv:3:kernelopts&#x3D;root&#x3D;UUID&#x3D;06246343-6949-4824-a96f-6ce27ff92cd5 ro crashkernel&#x3D;auto.&#x2F;loader&#x2F;entries&#x2F;54d1217dfdda4592a9e30059e470cf24-0-rescue.conf:5:options $kernelopts 7 它在这里定义,那我们就直接编辑添加我们需要的内核参数就好了.改一下,变成这样.1.&#x2F;grub2&#x2F;grubenv:3:kernelopts&#x3D;root&#x3D;UUID&#x3D;06246343-6949-4824-a96f-6ce27ff92cd5 ro crashkernel&#x3D;auto console&#x3D;ttyS0,115200n8 console&#x3D;tty0 8 深入一些,那这个options $kernelopts 又是怎么就能传递到内核去的呢?8.1 小Tips,先来打开个debug开关. 我们可以添加set debug=blscfg(grub会通过函数grub_dprintf输出对应的debug消息)到文件/boot/grub2/grub.cfg; 然后注意把启动设置到一个不存在menu(比如set pager=1). 这样的话,gurb就会因为找不到启动项而停住,那我们就可以看到输出呢. 另外多说一句,还有这些模块可以用来调试(有兴趣可以试试看).12&quot;acpi&quot;,&quot;ahci&quot;,&quot;arcdisk&quot;,&quot;archelp&quot;,&quot;ata&quot;,&quot;atkeyb&quot;,&quot;badram&quot;,&quot;blscfg&quot;,&quot;bootp&quot;,&quot;bsd&quot;,&quot;btrfs&quot;,&quot;chain&quot;,&quot;cros&quot;,&quot;crypt&quot;,&quot;cryptodisk&quot;,&quot;devalias&quot;,&quot;disk&quot;,&quot;diskfilter&quot;,&quot;dl&quot;,&quot;dns&quot;,&quot;drivemap&quot;,&quot;efi&quot;,&quot;efidisk&quot;,&quot;efiemu&quot;,&quot;efiemu&quot;,&quot;system_table,&quot;efinet&quot;,&quot;efinetfs&quot;,&quot;ehci&quot;,&quot;elf&quot;,&quot;exfat&quot;,&quot;expand&quot;,&quot;fb&quot;,&quot;fdtbus&quot;,&quot;fixvideo&quot;,&quot;font&quot;,&quot;fs&quot;,&quot;fw_path&quot;,&quot;geli&quot;,&quot;gpt&quot;,&quot;hostdisk&quot;,&quot;init&quot;,&quot;keystatus&quot;,&quot;linux&quot;,&quot;loader&quot;,&quot;luks&quot;,&quot;memdisk&quot;,&quot;menu&quot;,&quot;mmap&quot;,&quot;modules&quot;,&quot;multiboot_loader&quot;,&quot;nativedisk&quot;,&quot;net&quot;,&quot;ohci&quot;,&quot;partition&quot;,&quot;pata&quot;,&quot;play&quot;,&quot;tempo&quot;pmtimer&quot;,&quot;reiserfs&quot;,&quot;reiserfs_blocktype&quot;,&quot;reiserfs_tree&quot;,&quot;relocator&quot;,&quot;scripting&quot;,&quot;scsi&quot;,&quot;secureboot&quot;,&quot;serial&quot;,&quot;syslinux&quot;,&quot;tftp&quot;,&quot;ubootdisk&quot;,&quot;uhci&quot;,&quot;usb&quot;,&quot;usb_keyboard&quot;,&quot;usbms&quot;,&quot;video&quot;,&quot;xen&quot;,&quot;xen_loader&quot;,&quot;xnu&quot;,&quot;zfs&quot;, 8.2 通过查看grub的debug输出. 看到了options $kernelopts在grub启动时被调用了,所以对应的内核参数也被导入了.1commands&#x2F;blscfg.c:135: new keyval at 0xbfe42aa0:options:$kernelopts $tuned_params 8.3 再深入一些,那options $kernelopts具体又是怎么调进去的呢?好办,快速瞄个代码(呵呵,这就是开源的优势之一; 想知道内幕,下个代码瞄瞄). 通过查阅代码,grub里面的与之对应的函数大概流程如下,都简明易懂,就不多解析咯.123451. GRUB_MOD_INIT(blscfg) &#x2F;&#x2F; gurb在启动时,初始化&#39;blscfg&#39;2. grub_cmd_blscfg (grub_extcmd_context_t ctxt UNUSED,int argc UNUSED,char **args UNUSED) &#x2F;&#x2F; 命令的实现3. find_entry (struct find_entry_info *info) &#x2F;&#x2F; 查找启动列表4. read_entry (const char *filename,const struct grub_dirhook_info *dirhook_info UNUSED,void *data) &#x2F;&#x2F; 找到就将列表读出来5. bls_add_keyval(struct bls_entry *entry, char *key, char *val) &#x2F;&#x2F; 把列表里面参数解析并添加 9 到此,内核启动时通过boootloader添加启动参数就结束了. 多说一句,grub2-mkconfig命令也可以有类似功能.好, Red Hat Enterprise Linux 8 (RHEL8) 的新玩意 第4篇 通过grub配置Kernel启动参数就介绍完了. 想要了解更多? 可以参考 GRUB Manual 或者源代码.想要亲手玩一下新玩具? 请随时去 https://www.redhat.com 下载最新的 REHL 8 也欢迎关注 addos 微信公众号获取更多的,有意思的新玩具 :-)","categories":[{"name":"Linux 技巧(原创)","slug":"Linux-技巧-原创","permalink":"http://www.oostech.com/categories/Linux-%E6%8A%80%E5%B7%A7-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"查阅rpm的依赖关系","slug":"rpm-relationship","date":"2021-02-16T13:00:00.000Z","updated":"2021-02-16T16:00:00.000Z","comments":false,"path":"2021/02/16/rpm-relationship/","link":"","permalink":"http://www.oostech.com/2021/02/16/rpm-relationship/","excerpt":"","text":"查阅rpm的依赖关系1 使用RPM命令可以列出目标包所依赖的所有包，如下123456789101112131415161718192021222324252627282930[root@sam Packages]# rpm -qR vim-enhanced&#x2F;bin&#x2F;shconfig(vim-enhanced) &#x3D; 2:8.0.1763-15.el8libacl.so.1()(64bit)libacl.so.1(ACL_1.0)(64bit)libc.so.6()(64bit)libc.so.6(GLIBC_2.11)(64bit)libc.so.6(GLIBC_2.14)(64bit)libc.so.6(GLIBC_2.15)(64bit)libc.so.6(GLIBC_2.2.5)(64bit)libc.so.6(GLIBC_2.28)(64bit)libc.so.6(GLIBC_2.3)(64bit)libc.so.6(GLIBC_2.3.4)(64bit)libc.so.6(GLIBC_2.4)(64bit)libdl.so.2()(64bit)libdl.so.2(GLIBC_2.2.5)(64bit)libgpm.so.2()(64bit)libm.so.6()(64bit)libm.so.6(GLIBC_2.2.5)(64bit)libpthread.so.0()(64bit)libpthread.so.0(GLIBC_2.2.5)(64bit)libselinux.so.1()(64bit)libtinfo.so.6()(64bit)rpmlib(CompressedFileNames) &lt;&#x3D; 3.0.4-1rpmlib(FileDigests) &lt;&#x3D; 4.6.0-1rpmlib(PayloadFilesHavePrefix) &lt;&#x3D; 4.0-1rpmlib(PayloadIsXz) &lt;&#x3D; 5.2-1rtld(GNU_HASH)vim-common &#x3D; 2:8.0.1763-15.el8which 2 查还没有安装的12345678910111213[root@sam Packages]# rpm -qpR &#x2F;tmp&#x2F;iso2&#x2F;Packages&#x2F;vim-common-7.4.160-5.el7.x86_64.rpm&#x2F;bin&#x2F;shconfig(vim-common) &#x3D; 2:7.4.160-5.el7libc.so.6()(64bit)libc.so.6(GLIBC_2.2.5)(64bit)libc.so.6(GLIBC_2.3)(64bit)libc.so.6(GLIBC_2.3.4)(64bit)rpmlib(CompressedFileNames) &lt;&#x3D; 3.0.4-1rpmlib(FileDigests) &lt;&#x3D; 4.6.0-1rpmlib(PayloadFilesHavePrefix) &lt;&#x3D; 4.0-1rtld(GNU_HASH)vim-filesystemrpmlib(PayloadIsXz) &lt;&#x3D; 5.2-1 3 要下载一个 RPM 包而不安装，可以使用叫做’yumdownloader’的工具，下面我们先安装yumdownloader：现在我们来检查一个未安装的RPM包的依赖关系(本例使用 tcpdump)。首先，我们使用yumdownloader把tcpdump的RPM包下载下来 1[root@sam Packages]# yumdownloader --destdir&#x3D;. tcpdump 4 显示目标包所依赖的包：(为让repoquery正常的工作，需要保持网络的畅通，应为repoquery需要在Yum库中查找信息)1[root@sam Packages]# repoquery --requires --resolve &lt;package-name&gt; 5 只需运行rpmreaper就可以看到RPM包的依赖关系：rpmrepater会向用户显示已安装包的列表，你可以使用上/下箭头来滚动屏幕。 你可以在指定包上使用”r”键来显示其依赖关系，循环在指定包上按下”r”键可以展示出余下的信息。 “L”标志的意思是说这个包是一片“孤叶”，意思说说没有任何包依赖它。 “o”标志是说这个包是整个依赖链的中间部分。 按下”b”键会显示其他依赖于该包的其他包。 6 还有一个办法是使用rpmdep工具 rpmdep是一个命令行工具，可以显示已安装包的完整包依赖关系图。该工具会分析RPM包的依赖性，从完整的排完序的拓扑图中摘取部分包的信息，形成列表展示给用户。该工具的输出结果可以直接使用到Dotty（可视化展示工具）中去。 在Fedora中安装rpmdep和dotty：rpmdep.pl -dot gzip.dot gzip$ dot -Tpng -o output.png gzip.dot 12345678910111213141516171819202122232425262728# yes &quot;N&quot; | yum remove pciutils&lt;&lt;truncated..&gt;&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Package Arch Version Repository Size&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Removing: pciutils x86_64 3.5.1-3.el7 @anaconda&#x2F;7.6 196 kRemoving for dependencies: gnome-boxes x86_64 3.28.5-2.el7 @anaconda&#x2F;7.6 5.5 M libguestfs x86_64 1:1.38.2-12.el7_6.2 @rhel-7-server-rpms 4.3 M libguestfs-tools-c x86_64 1:1.38.2-12.el7_6.2 @rhel-7-server-rpms 19 M libguestfs-winsupport x86_64 7.2-2.el7 @rhel-7-server-rpms 2.2 M libibverbs x86_64 17.2-3.el7 @anaconda&#x2F;7.6 677 k librdmacm x86_64 17.2-3.el7 @anaconda&#x2F;7.6 122 k libvirt-daemon-kvm x86_64 4.5.0-10.el7 @anaconda&#x2F;7.6 0.0 open-vm-tools x86_64 10.2.5-3.el7 @anaconda&#x2F;7.6 2.1 M open-vm-tools-desktop x86_64 10.2.5-3.el7 @anaconda&#x2F;7.6 431 k pciutils-devel x86_64 3.5.1-3.el7 @rhel-7-server-optional-rpms 77 k qemu-kvm x86_64 10:1.5.3-160.el7 @anaconda&#x2F;7.6 5.8 M rdma-core x86_64 17.2-3.el7 @anaconda&#x2F;7.6 105 k virt-p2v-maker x86_64 1:1.38.2-12.el7_6.2 @rhel-7-server-rpms 226 k virt-v2v x86_64 1:1.38.2-12.el7_6.2 @rhel-7-server-rpms 18 MTransaction Summary&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Remove 1 Package (+14 Dependent packages)&lt;&lt;truncated..&gt;&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112[root@vm2rhel76 (i_am_vm2_rhel76) ~]# rpm -q --whatrequires pciutilsrdma-core-17.2-3.el7.x86_64open-vm-tools-10.2.5-3.el7.x86_64pciutils-devel-3.5.1-3.el7.x86_64L 5.5M ┌*&lt; gnome-boxes 3.28.5-2.el7.x86_64 4.3M ├*&lt; libguestfs 1.38.2-12.el7_6.2.x86_64 19.1M ├*&lt; libguestfs-tools-c 1.38.2-12.el7_6.2.x86_64 2.2M ├*&lt; libguestfs-winsupport 7.2-2.el7.x86_64 678K ├*&lt; libibverbs 17.2-3.el7.x86_64 122K ├*&lt; librdmacm 17.2-3.el7.x86_64 0K ├*&lt; libvirt-daemon-kvm 4.5.0-10.el7.x86_64 2.1M ├*&lt; open-vm-tools 10.2.5-3.el7.x86_64 L 432K ├*&lt; open-vm-tools-desktop 10.2.5-3.el7.x86_64 L 77K ├*&lt; pciutils-devel 3.5.1-3.el7.x86_64 5.8M ├*&lt; qemu-kvm 1.5.3-160.el7.x86_64 106K ├*&lt; rdma-core 17.2-3.el7.x86_64 L 227K ├*&lt; virt-p2v-maker 1.38.2-12.el7_6.2.x86_64 L 17.5M ├*&lt; virt-v2v 1.38.2-12.el7_6.2.x86_64 196K pciutils 3.5.1-3.el7.x86_64 2.1M ┌─&lt; open-vm-tools 10.2.5-3.el7.x86_64 L 77K ├─&lt; pciutils-devel 3.5.1-3.el7.x86_64 106K ├─&lt; rdma-core 17.2-3.el7.x86_64[root@vm2rhel76 (i_am_vm2_rhel76) ~]# rpmdep.pl -depending pciutils pciutils is needed by gnome-boxes,libguestfs,libguestfs-tools-c,libguestfs-winsupport,libibverbs,librdmacm,libvirt-daemon-kvm,open-vm-tools,open-vm-tools-desktop,pciutils-devel,qemu-kvm,rdma-core,virt-p2v-maker,virt-v2v[root@vm2rhel76 (i_am_vm2_rhel76) ~]# # rpmdep.pl -depending -dot pciutils.dot pciutils &amp;&amp; dot -Tpng pciutils.dot -o pciutils.png[root@vm2rhel76 (i_am_vm2_rhel76) ~]# repoquery --alldeps --whatrequires pciutilsdpdk-tools-0:2.0.0-8.el7.x86_64dpdk-tools-0:2.2.0-2.el7.x86_64dpdk-tools-0:2.2.0-3.el7.x86_64dpdk-tools-0:16.11.2-4.el7.x86_64dpdk-tools-0:17.11-7.el7.x86_64dpdk-tools-0:17.11-11.el7.x86_64dpdk-tools-0:17.11-13.el7.x86_64dpdk-tools-0:17.11-15.el7.x86_64dpdk-tools-0:18.11-2.el7_6.x86_64dpdk-tools-0:18.11-3.el7_6.x86_64dpdk-tools-0:18.11-4.el7_6.x86_64dpdk-tools-0:18.11.2-1.el7.x86_64facter-0:2.4.1-1.el7.x86_64hw-probe-0:1.4-12.el7.noarchinsights-client-0:3.0.3-8.el7.noarchinsights-client-0:3.0.3-9.el7_5.noarchinsights-client-0:3.0.6-2.el7_6.noarchinxi-0:3.0.35-1.el7.noarchleapp-repository-deps-0:0.7.0-5.el7_6.noarchleapp-repository-deps-0:0.8.1-2.el7_6.noarchlibguestfs-1:1.32.7-3.el7_3.2.x86_64libguestfs-1:1.32.7-3.el7_3.3.x86_64libguestfs-rescue-1:1.36.3-6.el7.x86_64libguestfs-rescue-1:1.36.3-6.el7_4.2.x86_64libguestfs-rescue-1:1.36.3-6.el7_4.3.x86_64libguestfs-rescue-1:1.36.10-6.el7.x86_64libguestfs-rescue-1:1.36.10-6.el7_5.2.x86_64libguestfs-rescue-1:1.38.2-12.el7.x86_64libguestfs-rescue-1:1.38.2-12.el7_6.1.x86_64libguestfs-rescue-1:1.38.2-12.el7_6.2.x86_64libguestfs-rescue-1:1.40.2-5.el7.x86_64libguestfs-rescue-1:1.40.2-5.el7_7.1.x86_64open-vm-tools-0:10.1.5-3.el7.x86_64open-vm-tools-0:10.1.10-3.el7.x86_64open-vm-tools-0:10.1.10-3.el7_5.1.x86_64open-vm-tools-0:10.2.5-3.el7.x86_64open-vm-tools-0:10.3.0-2.el7.x86_64pciutils-devel-0:3.2.1-4.el7.i686pciutils-devel-0:3.2.1-4.el7.x86_64pciutils-devel-0:3.5.1-1.el7.i686pciutils-devel-0:3.5.1-1.el7.x86_64pciutils-devel-0:3.5.1-2.el7.i686pciutils-devel-0:3.5.1-2.el7.x86_64pciutils-devel-0:3.5.1-3.el7.i686pciutils-devel-0:3.5.1-3.el7.x86_64qt-settings-0:19-23.4.el7.noarchqt-settings-0:19-23.5.el7.noarchqt-settings-0:19-23.7.el7.noarchqt-settings-0:19-23.8.el7.noarchqt-settings-0:19-23.9.el7.noarchrdma-0:7.3_4.7_rc2-5.el7.noarchrdma-0:7.3_4.7_rc2-6.el7_3.noarchrdma-core-0:13-7.el7.i686rdma-core-0:13-7.el7.x86_64rdma-core-0:15-6.el7.i686rdma-core-0:15-6.el7.x86_64rdma-core-0:15-7.el7_5.i686rdma-core-0:15-7.el7_5.x86_64rdma-core-0:17.2-3.el7.i686rdma-core-0:17.2-3.el7.x86_64rdma-core-0:22.1-3.el7.i686rdma-core-0:22.1-3.el7.x86_64redhat-access-insights-0:1.0.4-0.el7_1.noarchredhat-access-insights-0:1.0.6-0.el7.noarchredhat-access-insights-0:1.0.11-0.el7.noarchredhat-access-insights-0:1.0.13-2.el7.noarchsalt-0:2015.5.10-2.el7.noarchtlp-0:1.1-1.el7.noarch[root@vm2rhel76 (i_am_vm2_rhel76) ~]#","categories":[{"name":"Linux 技巧(原创)","slug":"Linux-技巧-原创","permalink":"http://www.oostech.com/categories/Linux-%E6%8A%80%E5%B7%A7-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"在RHEL8.2 上面快速搭建 etherpad","slug":"setup_etherpad_on_rhel","date":"2021-02-16T13:00:00.000Z","updated":"2021-02-16T16:00:00.000Z","comments":false,"path":"2021/02/16/setup_etherpad_on_rhel/","link":"","permalink":"http://www.oostech.com/2021/02/16/setup_etherpad_on_rhel/","excerpt":"","text":"1 Etherpad 是什么呢？ 官网的介绍Etherpad is a highly customizable open source online editor providing collaborative editing in really real-time.Etherpad 维基百科Etherpad（曾用名EtherPad）是一个基于Web的在线文档协作工具。多个用户可以通过Etherpad同时编写一个文本文档，并看到所有的参与者的实时编辑。每个参与者的文本使用不同的颜色标记。在软件的侧边栏还有一个聊天框。 2 在RHEL上面快速搭建 Etherpad2.1 先在RHEL上面安装 nodejs1# yum install nodejs -y 2.2 把etherpad 下载回来（用git最方便了）1# git clone git:&#x2F;&#x2F;github.com&#x2F;ether&#x2F;etherpad-lite.git etherpad-lite 2.3 进入etherpad-lite的目录1# cd etherpad-lite&#x2F;bin&#x2F; 2.4 直接执行 run.sh (我直接使用root执行，所以要额外输入Etherpad rocks my socks )123456789101112131415161718192021222324252627282930313233343536373839404142# .&#x2F;run.shYou shouldn&#39;t start Etherpad as root!Please type &#39;Etherpad rocks my socks&#39; (or restart with the &#39;--root&#39;argument) if you still want to start it as root:&gt; Etherpad rocks my socksCopy the settings template to settings.json...Ensure that all dependencies are up to date... If this is the first time you have run Etherpad please be patient.&gt; wd@1.12.1 install &#x2F;mnt&#x2F;etherpad-lite&#x2F;src&#x2F;node_modules&#x2F;wd&gt; node scripts&#x2F;build-browser-scriptsadded 680 packages in 25.323sClearing minified cache...Starting Etherpad...[2021-02-17 20:36:20.263] [DEBUG] console - Running on Node v10.23.1 (minimum required Node version: 10.17.0)[2021-02-17 20:36:20.291] [INFO] console - All relative paths will be interpreted relative to the identified Etherpad base dir: &#x2F;mnt&#x2F;etherpad-lite[2021-02-17 20:36:20.293] [INFO] console - Random string used for versioning assets: 6726ee68[2021-02-17 20:36:20.295] [DEBUG] AbsolutePaths - Relative path &quot;settings.json&quot; can be rewritten to &quot;&#x2F;mnt&#x2F;etherpad-lite&#x2F;settings.json&quot;[2021-02-17 20:36:20.296] [DEBUG] AbsolutePaths - Relative path &quot;credentials.json&quot; can be rewritten to &quot;&#x2F;mnt&#x2F;etherpad-lite&#x2F;credentials.json&quot;[2021-02-17 20:36:20.320] [INFO] console - settings loaded from: &#x2F;mnt&#x2F;etherpad-lite&#x2F;settings.json[2021-02-17 20:36:20.321] [INFO] console - No credentials file found in &#x2F;mnt&#x2F;etherpad-lite&#x2F;credentials.json. Ignoring.[2021-02-17 20:36:20.323] [INFO] console - Using skin &quot;colibris&quot; in dir: &#x2F;mnt&#x2F;etherpad-lite&#x2F;src&#x2F;static&#x2F;skins&#x2F;colibris[2021-02-17 20:36:20.324] [INFO] console - Session key file &quot;&#x2F;mnt&#x2F;etherpad-lite&#x2F;SESSIONKEY.txt&quot; not found. Creating with random contents.[2021-02-17 20:36:20.325] [WARN] console - DirtyDB is used. This is not recommended for production. File location: &#x2F;mnt&#x2F;etherpad-lite&#x2F;var&#x2F;dirty.db[2021-02-17 20:36:20.949] [INFO] server - Starting Etherpad...[2021-02-17 20:36:21.155] [INFO] runNpm - Executing command: npm ls --long --json --depth&#x3D;0[2021-02-17 20:36:21.587] [INFO] runNpm - npm --version: 6.14.11[2021-02-17 20:36:25.547] [INFO] runNpm - Successfully ran command: npm ls --long --json --depth&#x3D;0[2021-02-17 20:36:26.208] [INFO] APIHandler - Api key file &quot;&#x2F;mnt&#x2F;etherpad-lite&#x2F;APIKEY.txt&quot; not found. Creating with random contents.[2021-02-17 20:36:26.403] [INFO] server - Installed plugins:[2021-02-17 20:36:26.406] [INFO] console - Report bugs at https:&#x2F;&#x2F;github.com&#x2F;ether&#x2F;etherpad-lite&#x2F;issues[2021-02-17 20:36:26.407] [INFO] console - Your Etherpad version is 1.8.8 (8ef0860)[2021-02-17 20:36:29.553] [INFO] http - HTTP server listening for connections[2021-02-17 20:36:29.554] [INFO] console - You can access your Etherpad instance at http:&#x2F;&#x2F;0.0.0.0:9001&#x2F;[2021-02-17 20:36:29.554] [WARN] console - Admin username and password not set in settings.json. To access admin please uncomment and edit &quot;users&quot; in settings.json[2021-02-17 20:36:29.554] [WARN] console - Etherpad is running in Development mode. This mode is slower for users and less secure than production mode. You should set the NODE_ENV environment variable to production by using: export NODE_ENV&#x3D;production[2021-02-17 20:36:29.555] [INFO] server - Etherpad is running......[2021-02-17 20:37:52.738] [INFO] Minify - Compress JS file js&#x2F;ace.js.[2021-02-17 20:37:53.298] [INFO] access - [CREATE] pad:ossTechPad socket:-uGaEi5dyAJi7iptAAAA IP:150.150.150.1 authorID:a.R9kht2nlTzuKSrsf......[2021-02-17 20:38:04.554] [INFO] Minify - Compress JS file js&#x2F;ace.js. 2.5 在可以连接到这个主机的机器上 打开比如 “http://150.150.150.30:9001/”，然后就可以使用了","categories":[{"name":"Linux 技巧(原创)","slug":"Linux-技巧-原创","permalink":"http://www.oostech.com/categories/Linux-%E6%8A%80%E5%B7%A7-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"基于 UBI 容器化 Etherpad 并且运行在RHEL8上","slug":"container_etherpad","date":"2021-02-16T13:00:00.000Z","updated":"2021-02-16T16:00:00.000Z","comments":false,"path":"2021/02/16/container_etherpad/","link":"","permalink":"http://www.oostech.com/2021/02/16/container_etherpad/","excerpt":"","text":"1 建立Dockerfile 文件 （考虑到安全稳定性，这里基于UBI镜像，为了安全起见，可以不要使用root）123456FROM registry.redhat.io&#x2F;ubi8&#x2F;ubiLABEL maintainer&#x3D;&quot;oosTech.com&quot;RUN yum -y install nodejs npm git iproute &amp;&amp; git clone git:&#x2F;&#x2F;github.com&#x2F;ether&#x2F;etherpad-lite.git etherpad-liteWORKDIR &#x2F;etherpad-liteEXPOSE 9001CMD [ &quot;&#x2F;etherpad-lite&#x2F;bin&#x2F;run.sh&quot; , &quot;--root&quot;] 2 创建容器1# podman build -t etherpad:v1 . 3 容器镜像建立完毕，直接运行容器 （这样就可以本机的9001端口访问到etherpad了）1# podman run -d -p 9001:9001 localhost&#x2F;etherpad:v1","categories":[{"name":"Linux 技巧(原创)","slug":"Linux-技巧-原创","permalink":"http://www.oostech.com/categories/Linux-%E6%8A%80%E5%B7%A7-%E5%8E%9F%E5%88%9B/"}],"tags":[]},{"title":"Linux 实用小代码，基于stat 来显示文件的metadata","slug":"simple-linux-code-to-show-the-file-metadata","date":"2021-02-15T13:00:00.000Z","updated":"2021-02-16T16:00:00.000Z","comments":false,"path":"2021/02/15/simple-linux-code-to-show-the-file-metadata/","link":"","permalink":"http://www.oostech.com/2021/02/15/simple-linux-code-to-show-the-file-metadata/","excerpt":"","text":"Simple Linux code based on stat to display file metadataIf you want to know the metadata of a file in Linux system, you can check the detail below. 如果你想了解关于Linux 文件的元数据信息,欢迎继续阅读此文. 1 There is a system call named stat which can retrive the metadata of a file; so we can write a simple code to use it to get the file metatda. 我们可以通过写一段简单的代码来使用系统调用 stat, 然后执行它来获取到文件的元数据信息.1.1 let’ check the struct stat first; so that we can know what info we can retrive by this system call. 首先看一下用到结构体,这样就可以知道可以从中得到一些什么元数据信息.123456789101112131415struct stat &#123; dev_t st_dev; &#x2F;* ID of device containing file - 存储此文件的设备ID, 随后可以通过major,minor 解析*&#x2F; ino_t st_ino; &#x2F;* inode number - inode 号码, 可以理解为索引节点*&#x2F; mode_t st_mode; &#x2F;* file type and mode(detail below) - 文件的类型以及读,写,执行权限(下面st_mode有详细的描述)*&#x2F; nlink_t st_nlink; &#x2F;* number of hard links - 文件对应的硬链接数 *&#x2F; uid_t st_uid; &#x2F;* user ID of owner - 文件的用户ID*&#x2F; gid_t st_gid; &#x2F;* group ID of owner - 文件的组ID *&#x2F; dev_t st_rdev; &#x2F;* device ID (if special file) - 文件的设备ID, 针对一些特殊的文件(设备文件),比如块,字符等设备*&#x2F; off_t st_size; &#x2F;* total size, in bytes - 文件的大小,以byte为单位*&#x2F; blksize_t st_blksize; &#x2F;* blocksize for filesystem I&#x2F;O - 文件在文件系统所占块大小*&#x2F; blkcnt_t st_blocks; &#x2F;* number of 512B blocks allocated - 分配的磁盘块,已一个block为512Bytes*&#x2F; struct timespec st_atim; &#x2F;* time of last access - 文件最近的访问时间 *&#x2F; struct timespec st_mtim; &#x2F;* time of last modification - 文件最近的修改时间*&#x2F; struct timespec st_ctim; &#x2F;* time of last status change - 文件最近的状态变化时间*&#x2F;&#125; 1.2 The file type and mode (st_mode); total 16 bit, the lowest 12bit represent file priviledge and the highest 4 bit represent file type. 文件类型和权限存储在 st_mode 字段中, 其中的低12位储存了对应的文件权限,而高4位则储存了对应文件类型.1.2.1 st_mode file type 文件类型1234567S_IFSOCK socket 套接字文件S_IFLNK symbolic link 字符链接文件S_IFREG regular file 常规文件S_IFBLK block device 块设备文件S_IFDIR directory 文件夹S_IFCHR character device 字符文件S_IFIFO FIFO FIFO文件 1.2.1 st_mode file mode 文件权限1234567891011Owner (also known as user): The permissions granted to the owner of the file. 这个文件的用户的对应权限.Group: The permissions granted to users who are members of the file’s group. 这个文件的用户组的对应权限Other: The permissions granted to everyone else. 这个文件的其他用户的对应权限Read: The contents of the file may be read. 读权限, 表明文件可以被对应的用户读取.Write: The contents of the file may be changed.写权限,表明文件可以被对应的用户写入.Execute: The file may be executed. In order to execute a script file, both read and execute permissions are required. 执行权限, 表明文件可以被对应的用户执行.如果对于要执行脚本文件来说,读和执行权限是必须的. 2 Let’s have a quick check against file metadata which displayed by demo app, 快速的通过我们写的例子应用来看一下文件的元数据.2.1 display the character device file 获取字符设备文件的信息.1234567891011121314151617[root@sam samapplications]# filemetadata &#x2F;dev&#x2F;ttyS0&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; File Metadata &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Directory: &#x2F;dev&#x2F;ttyS0File type: Character deviceDevice containing: major&#x3D;0 minor&#x3D;5inode number: 1146Mode: rw-rw----Device number (st_rdev): major&#x3D;4; minor&#x3D;64Number of (hard) links: 1Ownership: UID&#x3D;0 GID&#x3D;18File size: 0 bytes : 0 KBI&#x2F;O block size: 4096 bytesNumber of (512B) blocks allocated: 0Last file access: Sat Jun 15 19:45:34 2019Last file modification: Sat Jun 15 19:45:34 2019Last status change: Sat Jun 15 19:45:34 2019&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 2.2 display block device file; 获取块设备文件的信息1234567891011121314151617[root@sam samapplications]# filemetadata &#x2F;dev&#x2F;nvme0n1p2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; File Metadata &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Directory: &#x2F;dev&#x2F;nvme0n1p2File type: Block deviceDevice containing: major&#x3D;0 minor&#x3D;5inode number: 15059Mode: rw-rw----Device number (st_rdev): major&#x3D;259; minor&#x3D;2Number of (hard) links: 1Ownership: UID&#x3D;0 GID&#x3D;6File size: 0 bytes : 0 KBI&#x2F;O block size: 4096 bytesNumber of (512B) blocks allocated: 0Last file access: Sat Jun 15 19:45:34 2019Last file modification: Sat Jun 15 19:45:34 2019Last status change: Sat Jun 15 19:45:34 2019&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 2.3 display regular file; 获取常规文件的信息1234567891011121314151617181920212223242526272829303132[root@sam samapplications]# filemetadata &#x2F;tmp&#x2F;rhel-server-7.3-x86_64-dvd.iso&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; File Metadata &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Directory: &#x2F;tmp&#x2F;rhel-server-7.3-x86_64-dvd.isoFile type: Regular fileDevice containing: major&#x3D;259 minor&#x3D;2inode number: 1137863993Mode: rw-r--r--Number of (hard) links: 1Ownership: UID&#x3D;107 GID&#x3D;107File size: 3793747968 bytes : 3704832 KBI&#x2F;O block size: 4096 bytesNumber of (512B) blocks allocated: 7409672Last file access: Sat Jun 15 19:45:50 2019Last file modification: Sun Apr 28 09:11:51 2019Last status change: Sat Jun 1 21:35:50 2019&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;[root@sam samapplications]# filemetadata &#x2F;tmp&#x2F;metadata-link&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; File Metadata &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Directory: &#x2F;tmp&#x2F;metadata-linkFile type: Symbolic (soft) linkDevice containing: major&#x3D;0 minor&#x3D;40inode number: 287970Mode: rwxrwxrwxNumber of (hard) links: 1Ownership: UID&#x3D;0 GID&#x3D;0File size: 8 bytes : 0 KBI&#x2F;O block size: 4096 bytesNumber of (512B) blocks allocated: 0Last file access: Sat Jun 15 21:58:29 2019Last file modification: Sat Jun 15 21:58:24 2019Last status change: Sat Jun 15 21:58:24 2019&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 3 Source code of filemetadata 我们可以通过源代码看它的具体实现.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&#x2F;* * Draft by Sam at 06-16-2019 * show the metadata of a file * *&#x2F;#include &lt;sys&#x2F;stat.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;&#x2F;* display the file permision * mode_t(file type and mode) of statBuffer as a parameter * *&#x2F;void disFilePerm(mode_t filePerm)&#123; char userR &#x3D; 0, userW &#x3D; 0, userX &#x3D; 0; char groupR &#x3D; 0, groupW &#x3D; 0, groupX &#x3D; 0; char otherR &#x3D; 0, otherW &#x3D; 0, otherX &#x3D; 0; userR &#x3D; (filePerm &amp; S_IRUSR) ? &#39;r&#39; : &#39;-&#39;; userW &#x3D; (filePerm &amp; S_IWUSR) ? &#39;w&#39; : &#39;-&#39;; userX &#x3D; (filePerm &amp; S_IXUSR) ? &#39;x&#39; : &#39;-&#39;; groupR &#x3D; (filePerm &amp; S_IRGRP) ? &#39;r&#39; : &#39;-&#39;; groupW &#x3D; (filePerm &amp; S_IWGRP) ? &#39;w&#39; : &#39;-&#39;; groupX &#x3D; (filePerm &amp; S_IXGRP) ? &#39;x&#39; : &#39;-&#39;; otherR &#x3D; (filePerm &amp; S_IROTH) ? &#39;r&#39; : &#39;-&#39;; otherW &#x3D; (filePerm &amp; S_IWOTH) ? &#39;w&#39; : &#39;-&#39;; otherX &#x3D; (filePerm &amp; S_IXOTH) ? &#39;x&#39; : &#39;-&#39;; printf(&quot;Mode:\\t\\t\\t\\t\\t%c%c%c%c%c%c%c%c%c\\n&quot;,userR,userW,userX,groupR,groupW,groupX,otherR,otherW,otherX);&#125;&#x2F;* * display the stat buffer * the pointer of statBuffer as parameter * *&#x2F;void displayStatInfo(struct stat *statBuffer, const char *filepath)&#123; printf(&quot;\\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; File Metadata &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\\n\\n&quot;); &#x2F;* print the file type *&#x2F; printf(&quot;Directory:\\t\\t\\t\\t%s\\n&quot;,filepath); printf(&quot;File type:\\t\\t\\t\\t&quot;); switch (statBuffer-&gt;st_mode &amp; S_IFMT) &#123; case S_IFREG: printf(&quot;Regular file\\n&quot;); break; case S_IFDIR: printf(&quot;Directory\\n&quot;); break; case S_IFCHR: printf(&quot;Character device\\n&quot;); break; case S_IFBLK: printf(&quot;Block device\\n&quot;); break; case S_IFLNK: printf(&quot;Symbolic (soft) link\\n&quot;); break; case S_IFIFO: printf(&quot;FIFO or pipe\\n&quot;); break; case S_IFSOCK: printf(&quot;Socket\\n&quot;); break; default: printf(&quot;Unknown file type\\n&quot;); break; &#125; printf(&quot;Device containing:\\t\\t\\tmajor&#x3D;%ld minor&#x3D;%ld\\n&quot;,(long) major(statBuffer-&gt;st_dev), (long) minor(statBuffer-&gt;st_dev)); printf(&quot;inode number:\\t\\t\\t\\t%ld\\n&quot;, (long) statBuffer-&gt;st_ino); disFilePerm(statBuffer-&gt;st_mode); if (S_ISCHR(statBuffer-&gt;st_mode) || S_ISBLK(statBuffer-&gt;st_mode))&#123; printf(&quot;Device number (st_rdev):\\t\\tmajor&#x3D;%ld; minor&#x3D;%ld\\n&quot;,(long) major(statBuffer-&gt;st_rdev), (long) minor(statBuffer-&gt;st_rdev)); &#125; printf(&quot;Number of (hard) links:\\t\\t\\t%ld\\n&quot;, (long) statBuffer-&gt;st_nlink); printf(&quot;Ownership:\\t\\t\\t\\tUID&#x3D;%ld GID&#x3D;%ld\\n&quot;, (long) statBuffer-&gt;st_uid, (long) statBuffer-&gt;st_gid); printf(&quot;File size:\\t\\t\\t\\t%lld bytes : %lld KB\\n&quot;, (long long) statBuffer-&gt;st_size, statBuffer-&gt;st_size&#x2F;1024); printf(&quot;I&#x2F;O block size:\\t\\t\\t\\t%ld bytes\\n&quot;, (long) statBuffer-&gt;st_blksize); printf(&quot;Number of (512B) blocks allocated:\\t%lld\\n&quot;, (long long) statBuffer-&gt;st_blocks); printf(&quot;Last file access:\\t\\t\\t%s&quot;, ctime(&amp;statBuffer-&gt;st_atime)); printf(&quot;Last file modification:\\t\\t\\t%s&quot;, ctime(&amp;statBuffer-&gt;st_mtime)); printf(&quot;Last status change:\\t\\t\\t%s&quot;, ctime(&amp;statBuffer-&gt;st_ctime)); printf(&quot;\\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\\n\\n&quot;); &#125; &#x2F;* * return data * 1 for Invalid patameters * 2 for lstat error * 0 for sucess * *&#x2F;int main(int argc, char *argv[])&#123; struct stat statBuffer; if (argc !&#x3D; 2 || argv[1] &#x3D;&#x3D; NULL)&#123; printf(&quot;Usage: filemetadata &lt;FILENAME&gt; \\n&quot;); return 1; &#125; &#x2F;* just use lstat to show the info; because lstat() is identical to stat(), except that if pathname is a symbolic link, then it returns information about the link * itself, not the file that it refers to. *&#x2F; if (lstat(argv[1], &amp;statBuffer) &#x3D;&#x3D; -1)&#123; perror(&quot;filemetadata&quot;); return 2; &#125; displayStatInfo(&amp;statBuffer, argv[1]); return 0; &#125; Ok, we know the Metadata of a file via stat system call as discripted above; you can please try the code and modify to study more about that.到此为止,我们初步了解了Linux 文件的元数据大概有些什么信息,以及如何通过stat系统调用来获取它们. 如果向要深入了解,可以尝试修改上面的代码并编译看能否取更有意思的输出. To know more? you can follow my wechat public account ADVANZONE.想要了解更多? 欢迎关注 Addos 微信公众号获取更多的,有意思的玩意咯 :-)","categories":[{"name":"Linux 代码(原创)","slug":"Linux-代码-原创","permalink":"http://www.oostech.com/categories/Linux-%E4%BB%A3%E7%A0%81-%E5%8E%9F%E5%88%9B/"}],"tags":[]}],"categories":[{"name":"Linux 技巧(原创)","slug":"Linux-技巧-原创","permalink":"http://www.oostech.com/categories/Linux-%E6%8A%80%E5%B7%A7-%E5%8E%9F%E5%88%9B/"},{"name":"云原生 容器(原创)","slug":"云原生-容器-原创","permalink":"http://www.oostech.com/categories/%E4%BA%91%E5%8E%9F%E7%94%9F-%E5%AE%B9%E5%99%A8-%E5%8E%9F%E5%88%9B/"},{"name":"Linux 代码(原创)","slug":"Linux-代码-原创","permalink":"http://www.oostech.com/categories/Linux-%E4%BB%A3%E7%A0%81-%E5%8E%9F%E5%88%9B/"},{"name":"网络 OVS(原创)","slug":"网络-OVS-原创","permalink":"http://www.oostech.com/categories/%E7%BD%91%E7%BB%9C-OVS-%E5%8E%9F%E5%88%9B/"}],"tags":[]}