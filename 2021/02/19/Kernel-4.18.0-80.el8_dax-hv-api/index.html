<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-4.18.0-80.el8_dax-hv-api | oosTech.com</title>
  <meta name="description" content="Excerpt from UltraSPARC Virtual Machine SpecificationCompiled from version 3.0.20+15Publication date 2017-09-25 08:21Copyright Â© 2008, 2015 Oracle and&#x2F;or its affiliates. All rights reserved.Extracted">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-4.18.0-80.el8_dax-hv-api">
<meta property="og:url" content="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_dax-hv-api/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="Excerpt from UltraSPARC Virtual Machine SpecificationCompiled from version 3.0.20+15Publication date 2017-09-25 08:21Copyright Â© 2008, 2015 Oracle and&#x2F;or its affiliates. All rights reserved.Extracted">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-18T16:00:00.000Z">
<meta property="article:modified_time" content="2021-02-18T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_dax-hv-api/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-4.18.0-80.el8_dax-hv-api" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-4.18.0-80.el8_dax-hv-api
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/02/19/Kernel-4.18.0-80.el8_dax-hv-api/" class="article-date">
	 published: <time datetime="2021-02-18T16:00:00.000Z" itemprop="datePublished">2021-02-19</time>
	</a>
</span>

        
	<a href="/2021/02/19/Kernel-4.18.0-80.el8_dax-hv-api/" class="article-date">
	   updated: <time datetime="2021-02-18T16:00:00.000Z" itemprop="dateUpdated">2021-02-19</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/02/19/Kernel-4.18.0-80.el8_dax-hv-api/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>Excerpt from UltraSPARC Virtual Machine Specification<br>Compiled from version 3.0.20+15<br>Publication date 2017-09-25 08:21<br>Copyright Â© 2008, 2015 Oracle and/or its affiliates. All rights reserved.<br>Extracted via “pdftotext -f 547 -l 572 -layout sun4v_20170925.pdf”<br>Authors:<br>     Charles Kunzman<br>     Sam Glidden<br>     Mark Cianchetti</p>
<p>Chapter 36. Coprocessor services<br>        The following APIs provide access via the Hypervisor to hardware assisted data processing functionality.<br>        These APIs may only be provided by certain platforms, and may not be available to all virtual machines<br>        even on supported platforms. Restrictions on the use of these APIs may be imposed in order to support<br>        live-migration and other system management activities.</p>
<p>36.1. Data Analytics Accelerator<br>        The Data Analytics Accelerator (DAX) functionality is a collection of hardware coprocessors that provide<br>        high speed processoring of database-centric operations. The coprocessors may support one or more of<br>        the following data query operations: search, extraction, compression, decompression, and translation. The<br>        functionality offered may vary by virtual machine implementation.</p>
<pre><code>    The DAX is a virtual device to sun4v guests, with supported data operations indicated by the virtual device
    compatibilty property. Functionality is accessed through the submission of Command Control Blocks
    (CCBs) via the ccb_submit API function. The operations are processed asynchronously, with the status
    of the submitted operations reported through a Completion Area linked to each CCB. Each CCB has a
    separate Completion Area and, unless execution order is specifically restricted through the use of serial-
    conditional flags, the execution order of submitted CCBs is arbitrary. Likewise, the time to completion
    for a given CCB is never guaranteed.

    Guest software may implement a software timeout on CCB operations, and if the timeout is exceeded, the
    operation may be cancelled or killed via the ccb_kill API function. It is recommended for guest software
    to implement a software timeout to account for certain RAS errors which may result in lost CCBs. It is
    recommended such implementation use the ccb_info API function to check the status of a CCB prior to
    killing it in order to determine if the CCB is still in queue, or may have been lost due to a RAS error.

    There is no fixed limit on the number of outstanding CCBs guest software may have queued in the virtual
    machine, however, internal resource limitations within the virtual machine can cause CCB submissions
    to be temporarily rejected with EWOULDBLOCK. In such cases, guests should continue to attempt
    submissions until they succeed; waiting for an outstanding CCB to complete is not necessary, and would
    not be a guarantee that a future submission would succeed.

    The availablility of DAX coprocessor command service is indicated by the presence of the DAX virtual
    device node in the guest MD (Section 8.24.17, âDatabase Analytics Accelerators (DAX) virtual-device
    nodeâ).
</code></pre>
<p>36.1.1. DAX Compatibility Property<br>        The query functionality may vary based on the compatibility property of the virtual device:</p>
<p>36.1.1.1. “ORCL,sun4v-dax” Device Compatibility<br>        Available CCB commands:</p>
<pre><code>    â¢ No-op/Sync

    â¢ Extract

    â¢ Scan Value

    â¢ Inverted Scan Value

    â¢ Scan Range


                                                 509
</code></pre>
<p>                                             Coprocessor services</p>
<pre><code>    â¢ Inverted Scan Range

    â¢ Translate

    â¢ Inverted Translate

    â¢ Select

    See Section 36.2.1, âQuery CCB Command Formatsâ for the corresponding CCB input and output formats.

    Only version 0 CCBs are available.
</code></pre>
<p>36.1.1.2. “ORCL,sun4v-dax-fc” Device Compatibility<br>        “ORCL,sun4v-dax-fc” is compatible with the “ORCL,sun4v-dax” interface, and includes additional CCB<br>        bit fields and controls.</p>
<p>36.1.1.3. “ORCL,sun4v-dax2” Device Compatibility<br>        Available CCB commands:</p>
<pre><code>    â¢ No-op/Sync

    â¢ Extract

    â¢ Scan Value

    â¢ Inverted Scan Value

    â¢ Scan Range

    â¢ Inverted Scan Range

    â¢ Translate

    â¢ Inverted Translate

    â¢ Select

    See Section 36.2.1, âQuery CCB Command Formatsâ for the corresponding CCB input and output formats.

    Version 0 and 1 CCBs are available. Only version 0 CCBs may use Huffman encoded data, whereas only
    version 1 CCBs may use OZIP.
</code></pre>
<p>36.1.2. DAX Virtual Device Interrupts<br>        The DAX virtual device has multiple interrupts associated with it which may be used by the guest if<br>        desired. The number of device interrupts available to the guest is indicated in the virtual device node of the<br>        guest MD (Section 8.24.17, âDatabase Analytics Accelerators (DAX) virtual-device nodeâ). If the device<br>        node indicates N interrupts available, the guest may use any value from 0 to N - 1 (inclusive) in a CCB<br>        interrupt number field. Using values outside this range will result in the CCB being rejected for an invalid<br>        field value.</p>
<pre><code>    The interrupts may be bound and managed using the standard sun4v device interrupts API (Chapter 16,
    Device interrupt services). Sysino interrupts are not available for DAX devices.
</code></pre>
<p>36.2. Coprocessor Control Block (CCB)<br>        CCBs are either 64 or 128 bytes long, depending on the operation type. The exact contents of the CCB<br>        are command specific, but all CCBs contain at least one memory buffer address. All memory locations</p>
<pre><code>                                                  510
</code></pre>
<p>                                    Coprocessor services</p>
<p>referenced by a CCB must be pinned in memory until the CCB either completes execution or is killed<br>via the ccb_kill API call. Changes in virtual address mappings occurring after CCB submission are not<br>guaranteed to be visible, and as such all virtual address updates need to be synchronized with CCB<br>execution.</p>
<p>All CCBs begin with a common 32-bit header.</p>
<p>Table 36.1. CCB Header Format<br>Bits          Field Description<br>[31:28]       CCB version. For API version 2.0: set to 1 if CCB uses OZIP encoding; set to 0 if the CCB<br>              uses Huffman encoding; otherwise either 0 or 1. For API version 1.0: always set to 0.<br>[27]          When API version 2.0 is negotiated, this is the Pipeline Flag [512]. It is reserved in<br>              API version 1.0<br>[26]          Long CCB flag [512]<br>[25]          Conditional synchronization flag [512]<br>[24]          Serial synchronization flag<br>[23:16]       CCB operation code:<br>               0x00        No Operation (No-op) or Sync<br>               0x01        Extract<br>               0x02        Scan Value<br>               0x12        Inverted Scan Value<br>               0x03        Scan Range<br>               0x13        Inverted Scan Range<br>               0x04        Translate<br>               0x14        Inverted Translate<br>               0x05        Select<br>[15:13]       Reserved<br>[12:11]       Table address type<br>               0b’00       No address<br>               0b’01       Alternate context virtual address<br>               0b’10       Real address<br>               0b’11       Primary context virtual address<br>[10:8]        Output/Destination address type<br>               0b’000      No address<br>               0b’001      Alternate context virtual address<br>               0b’010      Real address<br>               0b’011      Primary context virtual address<br>               0b’100      Reserved<br>               0b’101      Reserved<br>               0b’110      Reserved<br>               0b’111      Reserved<br>[7:5]         Secondary source address type</p>
<pre><code>                                        511
</code></pre>
<p>                                    Coprocessor services</p>
<p>Bits           Field Description<br>                0b’000       No address<br>                0b’001       Alternate context virtual address<br>                0b’010       Real address<br>                0b’011       Primary context virtual address<br>                0b’100       Reserved<br>                0b’101       Reserved<br>                0b’110       Reserved<br>                0b’111       Reserved<br>[4:2]          Primary source address type<br>                0b’000       No address<br>                0b’001       Alternate context virtual address<br>                0b’010       Real address<br>                0b’011       Primary context virtual address<br>                0b’100       Reserved<br>                0b’101       Reserved<br>                0b’110       Reserved<br>                0b’111       Reserved<br>[1:0]          Completion area address type<br>                0b’00        No address<br>                0b’01        Alternate context virtual address<br>                0b’10        Real address<br>                0b’11        Primary context virtual address</p>
<p>The Long CCB flag indicates whether the submitted CCB is 64 or 128 bytes long; value is 0 for 64 bytes<br>and 1 for 128 bytes.</p>
<p>The Serial and Conditional flags allow simple relative ordering between CCBs. Any CCB with the Serial<br>flag set will execute sequentially relative to any previous CCB that is also marked as Serial in the same<br>CCB submission. CCBs without the Serial flag set execute independently, even if they are between CCBs<br>with the Serial flag set. CCBs marked solely with the Serial flag will execute upon the completion of the<br>previous Serial CCB, regardless of the completion status of that CCB. The Conditional flag allows CCBs<br>to conditionally execute based on the successful execution of the closest CCB marked with the Serial flag.<br>A CCB may only be conditional on exactly one CCB, however, a CCB may be marked both Conditional<br>and Serial to allow execution chaining. The flags do NOT allow fan-out chaining, where multiple CCBs<br>execute in parallel based on the completion of another CCB.</p>
<p>The Pipeline flag is an optimization that directs the output of one CCB (the “source” CCB) directly to<br>the input of the next CCB (the “target” CCB). The target CCB thus does not need to read the input from<br>memory. The Pipeline flag is advisory and may be dropped.</p>
<p>Both the Pipeline and Serial bits must be set in the source CCB. The Conditional bit must be set in the<br>target CCB. Exactly one CCB must be made conditional on the source CCB; either 0 or 2 target CCBs<br>is invalid. However, Pipelines can be extended beyond two CCBs: the sequence would start with a CCB<br>with both the Pipeline and Serial bits set, proceed through CCBs with the Pipeline, Serial, and Conditional<br>bits set, and terminate at a CCB that has the Conditional bit set, but not the Pipeline bit.</p>
<pre><code>                                         512
</code></pre>
<p>                                               Coprocessor services</p>
<pre><code>      The input of the target CCB must start within 64 bytes of the output of the source CCB or the pipeline flag
      will be ignored. All CCBs in a pipeline must be submitted in the same call to ccb_submit.

      The various address type fields indicate how the various address values used in the CCB should be
      interpreted by the virtual machine. Not all of the types specified are used by every CCB format. Types
      which are not applicable to the given CCB command should be indicated as type 0 (No address). Virtual
      addresses used in the CCB must have translation entries present in either the TLB or a configured TSB
      for the submitting virtual processor. Virtual addresses which cannot be translated by the virtual machine
      will result in the CCB submission being rejected, with the causal virtual address indicated. The CCB
      may be resubmitted after inserting the translation, or the address may be translated by guest software and
      resubmitted using the real address translation.
</code></pre>
<p>36.2.1. Query CCB Command Formats<br>36.2.1.1. Supported Data Formats, Elements Sizes and Offsets<br>          Data for query commands may be encoded in multiple possible formats. The data query commands use a<br>          common set of values to indicate the encoding formats of the data being processed. Some encoding formats<br>          require multiple data streams for processing, requiring the specification of both primary data formats (the<br>          encoded data) and secondary data streams (meta-data for the encoded data).</p>
<p>36.2.1.1.1. Primary Input Format</p>
<pre><code>      The primary input format code is a 4-bit field when it is used. There are 10 primary input formats available.
      The packed formats are not endian neutral. Code values not listed below are reserved.

      Code        Format                              Description
      0x0         Fixed width byte packed             Up to 16 bytes
      0x1         Fixed width bit packed              Up to 15 bits (CCB version 0) or 23 bits (CCB version
                                                      1); bits are read most significant bit to least significant bit
                                                      within a byte
      0x2         Variable width byte packed          Data stream of lengths must be provided as a secondary
                                                      input
      0x4         Fixed width byte packed with run Up to 16 bytes; data stream of run lengths must be
                  length encoding                  provided as a secondary input
      0x5         Fixed width bit packed with run Up to 15 bits (CCB version 0) or 23 bits (CCB version
                  length encoding                 1); bits are read most significant bit to least significant bit
                                                  within a byte; data stream of run lengths must be provided
                                                  as a secondary input
      0x8         Fixed width byte packed with Up to 16 bytes before the encoding; compressed stream
                  Huffman (CCB version 0) or bits are read most significant bit to least significant bit
                  OZIP (CCB version 1) encoding within a byte; pointer to the encoding table must be
                                                provided
      0x9         Fixed width bit packed with Up to 15 bits (CCB version 0) or 23 bits (CCB version
                  Huffman (CCB version 0) or 1); compressed stream bits are read most significant bit to
                  OZIP (CCB version 1) encoding least significant bit within a byte; pointer to the encoding
                                                table must be provided
      0xA         Variable width byte packed with Up to 16 bytes before the encoding; compressed stream
                  Huffman (CCB version 0) or bits are read most significant bit to least significant bit
                  OZIP (CCB version 1) encoding within a byte; data stream of lengths must be provided as
                                                  a secondary input; pointer to the encoding table must be
                                                  provided


                                                    513
</code></pre>
<p>                                               Coprocessor services</p>
<pre><code>      Code        Format                              Description
      0xC         Fixed width byte packed with        Up to 16 bytes before the encoding; compressed stream
                  run length encoding, followed by    bits are read most significant bit to least significant bit
                  Huffman (CCB version 0) or          within a byte; data stream of run lengths must be provided
                  OZIP (CCB version 1) encoding       as a secondary input; pointer to the encoding table must
                                                      be provided
      0xD         Fixed width bit packed with         Up to 15 bits (CCB version 0) or 23 bits(CCB version 1)
                  run length encoding, followed by    before the encoding; compressed stream bits are read most
                  Huffman (CCB version 0) or          significant bit to least significant bit within a byte; data
                  OZIP (CCB version 1) encoding       stream of run lengths must be provided as a secondary
                                                      input; pointer to the encoding table must be provided

      If OZIP encoding is used, there must be no reserved bytes in the table.
</code></pre>
<p>36.2.1.1.2. Primary Input Element Size</p>
<pre><code>      For primary input data streams with fixed size elements, the element size must be indicated in the CCB
      command. The size is encoded as the number of bits or bytes, minus one. The valid value range for this
      field depends on the input format selected, as listed in the table above.
</code></pre>
<p>36.2.1.1.3. Secondary Input Format</p>
<pre><code>      For primary input data streams which require a secondary input stream, the secondary input stream is
      always encoded in a fixed width, bit-packed format. The bits are read from most significant bit to least
      significant bit within a byte. There are two encoding options for the secondary input stream data elements,
      depending on whether the value of 0 is needed:

      Secondary           Input Description
      Format Code
      0                          Element is stored as value minus 1 (0 evalutes to 1, 1 evalutes
                                 to 2, etc)
      1                          Element is stored as value
</code></pre>
<p>36.2.1.1.4. Secondary Input Element Size</p>
<pre><code>      Secondary input element size is encoded as a two bit field:

      Secondary Input Size Description
      Code
      0x0                        1 bit
      0x1                        2 bits
      0x2                        4 bits
      0x3                        8 bits
</code></pre>
<p>36.2.1.1.5. Input Element Offsets</p>
<pre><code>      Bit-wise input data streams may have any alignment within the base addressed byte. The offset, specified
      from most significant bit to least significant bit, is provided as a fixed 3 bit field for each input type. A
      value of 0 indicates that the first input element begins at the most significant bit in the first byte, and a
      value of 7 indicates it begins with the least significant bit.

      This field should be zero for any byte-wise primary input data streams.


                                                    514
</code></pre>
<p>                                              Coprocessor services</p>
<p>36.2.1.1.6. Output Format</p>
<pre><code>      Query commands support multiple sizes and encodings for output data streams. There are four possible
      output encodings, and up to four supported element sizes per encoding. Not all output encodings are
      supported for every command. The format is indicated by a 4-bit field in the CCB:

       Output Format Code        Description
       0x0                       Byte aligned, 1 byte elements
       0x1                       Byte aligned, 2 byte elements
       0x2                       Byte aligned, 4 byte elements
       0x3                       Byte aligned, 8 byte elements
       0x4                       16 byte aligned, 16 byte elements
       0x5                       Reserved
       0x6                       Reserved
       0x7                       Reserved
       0x8                       Packed vector of single bit elements
       0x9                       Reserved
       0xA                       Reserved
       0xB                       Reserved
       0xC                       Reserved
       0xD                       2 byte elements where each element is the index value of a bit,
                                 from an bit vector, which was 1.
       0xE                       4 byte elements where each element is the index value of a bit,
                                 from an bit vector, which was 1.
       0xF                       Reserved
</code></pre>
<p>36.2.1.1.7. Application Data Integrity (ADI)</p>
<pre><code>      On platforms which support ADI, the ADI version number may be specified for each separate memory
      access type used in the CCB command. ADI checking only occurs when reading data. When writing data,
      the specified ADI version number overwrites any existing ADI value in memory.

      An ADI version value of 0 or 0xF indicates the ADI checking is disabled for that data access, even if it is
      enabled in memory. By setting the appropriate flag in CCB_SUBMIT (Section 36.3.1, âccb_submitâ) it is
      also an option to disable ADI checking for all inputs accessed via virtual address for all CCBs submitted
      during that hypercall invocation.

      The ADI value is only guaranteed to be checked on the first 64 bytes of each data access. Mismatches on
      subsequent data chunks may not be detected, so guest software should be careful to use page size checking
      to protect against buffer overruns.
</code></pre>
<p>36.2.1.1.8. Page size checking</p>
<pre><code>      All data accesses used in CCB commands must be bounded within a single memory page. When addresses
      are provided using a virtual address, the page size for checking is extracted from the TTE for that virtual
      address. When using real addresses, the guest must supply the page size in the same field as the address
      value. The page size must be one of the sizes supported by the underlying virtual machine. Using a value
      that is not supported may result in the CCB submission being rejected or the generation of a CCB parsing
      error in the completion area.


                                                   515
</code></pre>
<p>                                               Coprocessor services</p>
<p>36.2.1.2. Extract command</p>
<pre><code>    Converts an input vector in one format to an output vector in another format. All input format types are
    supported.

    The only supported output format is a padded, byte-aligned output stream, using output codes 0x0 - 0x4.
    When the specified output element size is larger than the extracted input element size, zeros are padded to
    the extracted input element. First, if the decompressed input size is not a whole number of bytes, 0 bits are
    padded to the most significant bit side till the next byte boundary. Next, if the output element size is larger
    than the byte padded input element, bytes of value 0 are added based on the Padding Direction bit in the
    CCB. If the output element size is smaller than the byte-padded input element size, the input element is
    truncated by dropped from the least significant byte side until the selected output size is reached.

    The return value of the CCB completion area is invalid. The ânumber of elements processedâ field in the
    CCB completion area will be valid.

    The extract CCB is a 64-byte âshort formatâ CCB.

    The extract CCB command format can be specified by the following packed C structure for a big-endian
    machine:


              struct extract_ccb &#123;
                     uint32_t header;
                     uint32_t control;
                     uint64_t completion;
                     uint64_t primary_input;
                     uint64_t data_access_control;
                     uint64_t secondary_input;
                     uint64_t reserved;
                     uint64_t output;
                     uint64_t table;
              &#125;;


    The exact field offsets, sizes, and composition are as follows:

     Offset         Size            Field Description
     0              4               CCB header (Table 36.1, âCCB Header Formatâ)
     4              4               Command control
                                    Bits        Field Description
                                    [31:28]     Primary Input Format (see Section 36.2.1.1.1, âPrimary Input
                                                Formatâ)
                                    [27:23]     Primary Input Element Size (see Section 36.2.1.1.2, âPrimary
                                                Input Element Sizeâ)
                                    [22:20]     Primary Input Starting Offset (see Section 36.2.1.1.5, âInput
                                                Element Offsetsâ)
                                    [19]        Secondary Input Format (see Section 36.2.1.1.3, âSecondary
                                                Input Formatâ)
                                    [18:16]     Secondary Input Starting Offset (see Section 36.2.1.1.5, âInput
                                                Element Offsetsâ)


                                                   516
</code></pre>
<p>                        Coprocessor services</p>
<p>Offset   Size   Field Description<br>                Bits         Field Description<br>                [15:14]      Secondary Input Element Size (see Section 36.2.1.1.4,<br>                             âSecondary Input Element Sizeâ<br>                [13:10]      Output Format (see Section 36.2.1.1.6, âOutput Formatâ)<br>                [9]          Padding Direction selector: A value of 1 causes padding bytes<br>                             to be added to the left side of output elements. A value of 0<br>                             causes padding bytes to be added to the right side of output<br>                             elements.<br>                [8:0]        Reserved<br>8        8      Completion<br>                Bits         Field Description<br>                [63:60]      ADI version (see Section 36.2.1.1.7, âApplication Data<br>                             Integrity (ADI)â)<br>                [59]         If set to 1, a virtual device interrupt will be generated using<br>                             the device interrupt number specified in the lower bits of this<br>                             completion word. If 0, the lower bits of this completion word<br>                             are ignored.<br>                [58:6]       Completion area address bits [58:6]. Address type is<br>                             determined by CCB header.<br>                [5:0]        Virtual device interrupt number for completion interrupt, if<br>                             enabled.<br>16       8      Primary Input<br>                Bits         Field Description<br>                [63:60]      ADI version (see Section 36.2.1.1.7, âApplication Data<br>                             Integrity (ADI)â)<br>                [59:56]      If using real address, these bits should be filled in with the<br>                             page size code for the page boundary checking the guest wants<br>                             the virtual machine to use when accessing this data stream<br>                             (checking is only guaranteed to be performed when using API<br>                             version 1.1 and later). If using a virtual address, this field will<br>                             be used as as primary input address bits [59:56].<br>                [55:0]       Primary input address bits [55:0]. Address type is determined<br>                             by CCB header.<br>24       8      Data Access Control<br>                Bits         Field Description<br>                [63:62]      Flow Control<br>                             Value      Description<br>                             0b’00      Disable flow control<br>                             0b’01      Enable flow control (only valid with “ORCL,sun4v-<br>                                        dax-fc” compatible virtual device variants)<br>                             0b’10      Reserved<br>                             0b’11      Reserved<br>                [61:60]      Reserved (API 1.0)</p>
<pre><code>                            517
</code></pre>
<p>                       Coprocessor services</p>
<p>Offset   Size   Field Description<br>                Bits        Field Description<br>                            Pipeline target (API 2.0)<br>                            Value      Description<br>                            0b’00      Connect to primary input<br>                            0b’01      Connect to secondary input<br>                            0b’10      Reserved<br>                            0b’11      Reserved<br>                [59:40]     Output buffer size given in units of 64 bytes, minus 1. Value of<br>                            0 means 64 bytes, value of 1 means 128 bytes, etc. Buffer size is<br>                            only enforced if flow control is enabled in Flow Control field.<br>                [39:32]     Reserved<br>                [31:30]     Output Data Cache Allocation<br>                            Value      Description<br>                            0b’00      Do not allocate cache lines for output data stream.<br>                            0b’01      Force cache lines for output data stream to be<br>                                       allocated in the cache that is local to the submitting<br>                                       virtual cpu.<br>                            0b’10      Allocate cache lines for output data stream, but allow<br>                                       existing cache lines associated with the data to remain<br>                                       in their current cache instance. Any memory not<br>                                       already in cache will be allocated in the cache local<br>                                       to the submitting virtual cpu.<br>                            0b’11      Reserved<br>                [29:26]     Reserved<br>                [25:24]     Primary Input Length Format<br>                            Value      Description<br>                            0b’00      Number of primary symbols<br>                            0b’01      Number of primary bytes<br>                            0b’10      Number of primary bits<br>                            0b’11      Reserved<br>                [23:0]      Primary Input Length<br>                            Format                      Field Value<br>                            # of primary symbols        Number of input elements to process,<br>                                                        minus 1. Command execution stops<br>                                                        once count is reached.<br>                            # of primary bytes          Number of input bytes to process,<br>                                                        minus 1. Command execution stops<br>                                                        once count is reached. The count is<br>                                                        done before any decompression or<br>                                                        decoding.<br>                            # of primary bits           Number of input bits to process,<br>                                                        minus 1. Command execution stops</p>
<pre><code>                           518
</code></pre>
<p>                                                Coprocessor services</p>
<pre><code>    Offset          Size           Field Description
                                    Bits         Field Description
                                                 Format                     Field Value
                                                                            once count is reached. The count is
                                                                            done before any decompression or
                                                                            decoding, and does not include any
                                                                            bits skipped by the Primary Input
                                                                            Offset field value of the command
                                                                            control word.
    32              8              Secondary Input, if used by Primary Input Format. Same fields as Primary
                                   Input.
    40              8              Reserved
    48              8              Output (same fields as Primary Input)
    56              8              Symbol Table (if used by Primary Input)
                                    Bits         Field Description
                                    [63:60]      ADI version (see Section 36.2.1.1.7, âApplication Data
                                                 Integrity (ADI)â)
                                    [59:56]      If using real address, these bits should be filled in with the
                                                 page size code for the page boundary checking the guest wants
                                                 the virtual machine to use when accessing this data stream
                                                 (checking is only guaranteed to be performed when using API
                                                 version 1.1 and later). If using a virtual address, this field will
                                                 be used as as symbol table address bits [59:56].
                                    [55:4]       Symbol table address bits [55:4]. Address type is determined
                                                 by CCB header.
                                    [3:0]        Symbol table version
                                                 Value     Description
                                                 0         Huffman encoding. Must use 64 byte aligned table
                                                           address. (Only available when using version 0 CCBs)
                                                 1         OZIP encoding. Must use 16 byte aligned table
                                                           address. (Only available when using version 1 CCBs)
</code></pre>
<p>36.2.1.3. Scan commands</p>
<pre><code>    The scan commands search a stream of input data elements for values which match the selection criteria.
    All the input format types are supported. There are multiple formats for the scan commands, allowing the
    scan to search for exact matches to one value, exact matches to either of two values, or any value within
    a specified range. The specific type of scan is indicated by the command code in the CCB header. For the
    scan range commands, the boundary conditions can be specified as greater-than-or-equal-to a value, less-
    than-or-equal-to a value, or both by using two boundary values.

    There are two supported formats for the output stream: the bit vector and index array formats (codes 0x8,
    0xD, and 0xE). For the standard scan command using the bit vector output, for each input element there
    exists one bit in the vector that is set if the input element matched the scan criteria, or clear if not. The
    inverted scan command inverts the polarity of the bits in the output. The most significant bit of the first
    byte of the output stream corresponds to the first element in the input stream. The standard index array
    output format contains one array entry for each input element that matched the scan criteria. Each array



                                                     519
</code></pre>
<p>                                       Coprocessor services</p>
<p>entry is the index of an input element that matched the scan criteria. An inverted scan command produces<br>a similar array, but of all the input elements which did NOT match the scan criteria.</p>
<p>The return value of the CCB completion area contains the number of input elements found which match<br>the scan criteria (or number that did not match for the inverted scans). The ânumber of elements processedâ<br>field in the CCB completion area will be valid, indicating the number of input elements processed.</p>
<p>These commands are 128-byte âlong formatâ CCBs.</p>
<p>The scan CCB command format can be specified by the following packed C structure for a big-endian<br>machine:</p>
<pre><code>     struct scan_ccb         &#123;
            uint32_t         header;
            uint32_t         control;
            uint64_t         completion;
            uint64_t         primary_input;
            uint64_t         data_access_control;
            uint64_t         secondary_input;
            uint64_t         match_criteria0;
            uint64_t         output;
            uint64_t         table;
            uint64_t         match_criteria1;
            uint64_t         match_criteria2;
            uint64_t         match_criteria3;
            uint64_t         reserved[5];
     &#125;;
</code></pre>
<p>The exact field offsets, sizes, and composition are as follows:</p>
<p>Offset         Size            Field Description<br>0              4               CCB header (Table 36.1, âCCB Header Formatâ)<br>4              4               Command control<br>                               Bits         Field Description<br>                               [31:28]      Primary Input Format (see Section 36.2.1.1.1, âPrimary Input<br>                                            Formatâ)<br>                               [27:23]      Primary Input Element Size (see Section 36.2.1.1.2, âPrimary<br>                                            Input Element Sizeâ)<br>                               [22:20]      Primary Input Starting Offset (see Section 36.2.1.1.5, âInput<br>                                            Element Offsetsâ)<br>                               [19]         Secondary Input Format (see Section 36.2.1.1.3, âSecondary<br>                                            Input Formatâ)<br>                               [18:16]      Secondary Input Starting Offset (see Section 36.2.1.1.5, âInput<br>                                            Element Offsetsâ)<br>                               [15:14]      Secondary Input Element Size (see Section 36.2.1.1.4,<br>                                            âSecondary Input Element Sizeâ<br>                               [13:10]      Output Format (see Section 36.2.1.1.6, âOutput Formatâ)<br>                               [9:5]        Operand size for first scan criteria value. In a scan value<br>                                            operation, this is one of two potential extact match values.<br>                                            In a scan range operation, this is the size of the upper range</p>
<pre><code>                                           520
</code></pre>
<p>                        Coprocessor services</p>
<p>Offset   Size   Field Description<br>                Bits         Field Description<br>                             boundary. The value of this field is the number of bytes in the<br>                             operand, minus 1. Values 0xF-0x1E are reserved. A value of<br>                             0x1F indicates this operand is not in use for this scan operation.<br>                [4:0]        Operand size for second scan criteria value. In a scan value<br>                             operation, this is one of two potential extact match values.<br>                             In a scan range operation, this is the size of the lower range<br>                             boundary. The value of this field is the number of bytes in the<br>                             operand, minus 1. Values 0xF-0x1E are reserved. A value of<br>                             0x1F indicates this operand is not in use for this scan operation.<br>8        8      Completion (same fields as Section 36.2.1.2, âExtract commandâ)<br>16       8      Primary Input (same fields as Section 36.2.1.2, âExtract commandâ)<br>24       8      Data Access Control (same fields as Section 36.2.1.2, âExtract commandâ)<br>32       8      Secondary Input, if used by Primary Input Format. Same fields as Primary<br>                Input.<br>40       4      Most significant 4 bytes of first scan criteria operand. If first operand is less<br>                than 4 bytes, the value is left-aligned to the lowest address bytes.<br>44       4      Most significant 4 bytes of second scan criteria operand. If second operand<br>                is less than 4 bytes, the value is left-aligned to the lowest address bytes.<br>48       8      Output (same fields as Primary Input)<br>56       8      Symbol Table (if used by Primary Input). Same fields as Section 36.2.1.2,<br>                âExtract commandâ<br>64       4      Next 4 most significant bytes of first scan criteria operand occuring after the<br>                bytes specified at offset 40, if needed by the operand size. If first operand<br>                is less than 8 bytes, the valid bytes are left-aligned to the lowest address.<br>68       4      Next 4 most significant bytes of second scan criteria operand occuring after<br>                the bytes specified at offset 44, if needed by the operand size. If second<br>                operand is less than 8 bytes, the valid bytes are left-aligned to the lowest<br>                address.<br>72       4      Next 4 most significant bytes of first scan criteria operand occuring after the<br>                bytes specified at offset 64, if needed by the operand size. If first operand<br>                is less than 12 bytes, the valid bytes are left-aligned to the lowest address.<br>76       4      Next 4 most significant bytes of second scan criteria operand occuring after<br>                the bytes specified at offset 68, if needed by the operand size. If second<br>                operand is less than 12 bytes, the valid bytes are left-aligned to the lowest<br>                address.<br>80       4      Next 4 most significant bytes of first scan criteria operand occuring after the<br>                bytes specified at offset 72, if needed by the operand size. If first operand<br>                is less than 16 bytes, the valid bytes are left-aligned to the lowest address.<br>84       4      Next 4 most significant bytes of second scan criteria operand occuring after<br>                the bytes specified at offset 76, if needed by the operand size. If second<br>                operand is less than 16 bytes, the valid bytes are left-aligned to the lowest<br>                address.</p>
<pre><code>                            521
</code></pre>
<p>                                               Coprocessor services</p>
<p>36.2.1.4. Translate commands</p>
<pre><code>    The translate commands takes an input array of indicies, and a table of single bit values indexed by those
    indicies, and outputs a bit vector or index array created by reading the tables bit value at each index in
    the input array. The output should therefore contain exactly one bit per index in the input data stream,
    when outputing as a bit vector. When outputing as an index array, the number of elements depends on the
    values read in the bit table, but will always be less than, or equal to, the number of input elements. Only
    a restricted subset of the possible input format types are supported. No variable width or Huffman/OZIP
    encoded input streams are allowed. The primary input data element size must be 3 bytes or less.

    The maximum table index size allowed is 15 bits, however, larger input elements may be used to provide
    additional processing of the output values. If 2 or 3 byte values are used, the least significant 15 bits are
    used as an index into the bit table. The most significant 9 bits (when using 3-byte input elements) or single
    bit (when using 2-byte input elements) are compared against a fixed 9-bit test value provided in the CCB.
    If the values match, the value from the bit table is used as the output element value. If the values do not
    match, the output data element value is forced to 0.

    In the inverted translate operation, the bit value read from bit table is inverted prior to its use. The additional
    additional processing based on any additional non-index bits remains unchanged, and still forces the output
    element value to 0 on a mismatch. The specific type of translate command is indicated by the command
    code in the CCB header.

    There are two supported formats for the output stream: the bit vector and index array formats (codes 0x8,
    0xD, and 0xE). The index array format is an array of indicies of bits which would have been set if the
    output format was a bit array.

    The return value of the CCB completion area contains the number of bits set in the output bit vector,
    or number of elements in the output index array. The ânumber of elements processedâ field in the CCB
    completion area will be valid, indicating the number of input elements processed.

    These commands are 64-byte âshort formatâ CCBs.

    The translate CCB command format can be specified by the following packed C structure for a big-endian
    machine:


             struct translate_ccb &#123;
                    uint32_t header;
                    uint32_t control;
                    uint64_t completion;
                    uint64_t primary_input;
                    uint64_t data_access_control;
                    uint64_t secondary_input;
                    uint64_t reserved;
                    uint64_t output;
                    uint64_t table;
             &#125;;


    The exact field offsets, sizes, and composition are as follows:


    Offset          Size             Field Description
    0               4                CCB header (Table 36.1, âCCB Header Formatâ)


                                                    522
</code></pre>
<p>                        Coprocessor services</p>
<p>Offset   Size   Field Description<br>4        4      Command control<br>                Bits         Field Description<br>                [31:28]      Primary Input Format (see Section 36.2.1.1.1, âPrimary Input<br>                             Formatâ)<br>                [27:23]      Primary Input Element Size (see Section 36.2.1.1.2, âPrimary<br>                             Input Element Sizeâ)<br>                [22:20]      Primary Input Starting Offset (see Section 36.2.1.1.5, âInput<br>                             Element Offsetsâ)<br>                [19]         Secondary Input Format (see Section 36.2.1.1.3, âSecondary<br>                             Input Formatâ)<br>                [18:16]      Secondary Input Starting Offset (see Section 36.2.1.1.5, âInput<br>                             Element Offsetsâ)<br>                [15:14]      Secondary Input Element Size (see Section 36.2.1.1.4,<br>                             âSecondary Input Element Sizeâ<br>                [13:10]      Output Format (see Section 36.2.1.1.6, âOutput Formatâ)<br>                [9]          Reserved<br>                [8:0]        Test value used for comparison against the most significant bits<br>                             in the input values, when using 2 or 3 byte input elements.<br>8        8      Completion (same fields as Section 36.2.1.2, âExtract commandâ<br>16       8      Primary Input (same fields as Section 36.2.1.2, âExtract commandâ<br>24       8      Data Access Control (same fields as Section 36.2.1.2, âExtract commandâ,<br>                except Primary Input Length Format may not use the 0x0 value)<br>32       8      Secondary Input, if used by Primary Input Format. Same fields as Primary<br>                Input.<br>40       8      Reserved<br>48       8      Output (same fields as Primary Input)<br>56       8      Bit Table<br>                Bits         Field Description<br>                [63:60]      ADI version (see Section 36.2.1.1.7, âApplication Data<br>                             Integrity (ADI)â)<br>                [59:56]      If using real address, these bits should be filled in with the<br>                             page size code for the page boundary checking the guest wants<br>                             the virtual machine to use when accessing this data stream<br>                             (checking is only guaranteed to be performed when using API<br>                             version 1.1 and later). If using a virtual address, this field will<br>                             be used as as bit table address bits [59:56]<br>                [55:4]       Bit table address bits [55:4]. Address type is determined by<br>                             CCB header. Address must be 64-byte aligned (CCB version<br>                             0) or 16-byte aligned (CCB version 1).<br>                [3:0]        Bit table version<br>                             Value      Description<br>                             0          4KB table size<br>                             1          8KB table size</p>
<pre><code>                             523
</code></pre>
<p>                                              Coprocessor services</p>
<p>36.2.1.5. Select command<br>        The select command filters the primary input data stream by using a secondary input bit vector to determine<br>        which input elements to include in the output. For each bit set at a given index N within the bit vector,<br>        the Nth input element is included in the output. If the bit is not set, the element is not included. Only a<br>        restricted subset of the possible input format types are supported. No variable width or run length encoded<br>        input streams are allowed, since the secondary input stream is used for the filtering bit vector.</p>
<pre><code>    The only supported output format is a padded, byte-aligned output stream. The stream follows the same
    rules and restrictions as padded output stream described in Section 36.2.1.2, âExtract commandâ.

    The return value of the CCB completion area contains the number of bits set in the input bit vector. The
    &quot;number of elements processed&quot; field in the CCB completion area will be valid, indicating the number
    of input elements processed.

    The select CCB is a 64-byte âshort formatâ CCB.

    The select CCB command format can be specified by the following packed C structure for a big-endian
    machine:


              struct select_ccb &#123;
                     uint32_t header;
                     uint32_t control;
                     uint64_t completion;
                     uint64_t primary_input;
                     uint64_t data_access_control;
                     uint64_t secondary_input;
                     uint64_t reserved;
                     uint64_t output;
                     uint64_t table;
              &#125;;


    The exact field offsets, sizes, and composition are as follows:

     Offset        Size            Field Description
     0             4               CCB header (Table 36.1, âCCB Header Formatâ)
     4             4               Command control
                                   Bits        Field Description
                                   [31:28]     Primary Input Format (see Section 36.2.1.1.1, âPrimary Input
                                               Formatâ)
                                   [27:23]     Primary Input Element Size (see Section 36.2.1.1.2, âPrimary
                                               Input Element Sizeâ)
                                   [22:20]     Primary Input Starting Offset (see Section 36.2.1.1.5, âInput
                                               Element Offsetsâ)
                                   [19]        Secondary Input Format (see Section 36.2.1.1.3, âSecondary
                                               Input Formatâ)
                                   [18:16]     Secondary Input Starting Offset (see Section 36.2.1.1.5, âInput
                                               Element Offsetsâ)
                                   [15:14]     Secondary Input Element Size (see Section 36.2.1.1.4,
                                               âSecondary Input Element Sizeâ


                                                  524
</code></pre>
<p>                                               Coprocessor services</p>
<pre><code>    Offset         Size            Field Description
                                   Bits         Field Description
                                   [13:10]      Output Format (see Section 36.2.1.1.6, âOutput Formatâ)
                                   [9]          Padding Direction selector: A value of 1 causes padding bytes
                                                to be added to the left side of output elements. A value of 0
                                                causes padding bytes to be added to the right side of output
                                                elements.
                                   [8:0]        Reserved
    8              8               Completion (same fields as Section 36.2.1.2, âExtract commandâ
    16             8               Primary Input (same fields as Section 36.2.1.2, âExtract commandâ
    24             8               Data Access Control (same fields as Section 36.2.1.2, âExtract commandâ)
    32             8               Secondary Bit Vector Input. Same fields as Primary Input.
    40             8               Reserved
    48             8               Output (same fields as Primary Input)
    56             8               Symbol Table (if used by Primary Input). Same fields as Section 36.2.1.2,
                                   âExtract commandâ
</code></pre>
<p>36.2.1.6. No-op and Sync commands<br>        The no-op (no operation) command is a CCB which has no processing effect. The CCB, when processed<br>        by the virtual machine, simply updates the completion area with its execution status. The CCB may have<br>        the serial-conditional flags set in order to restrict when it executes.</p>
<pre><code>    The sync command is a variant of the no-op command which with restricted execution timing. A sync
    command CCB will only execute when all previous commands submitted in the same request have
    completed. This is stronger than the conditional flag sequencing, which is only dependent on a single
    previous serial CCB. While the relative ordering is guaranteed, virtual machine implementations with
    shared hardware resources may cause the sync command to wait for longer than the minimum required
    time.

    The return value of the CCB completion area is invalid for these CCBs. The ânumber of elements
    processedâ field is also invalid for these CCBs.

    These commands are 64-byte âshort formatâ CCBs.

    The no-op CCB command format can be specified by the following packed C structure for a big-endian
    machine:


             struct nop_ccb &#123;
                    uint32_t header;
                    uint32_t control;
                    uint64_t completion;
                    uint64_t reserved[6];
             &#125;;


    The exact field offsets, sizes, and composition are as follows:

    Offset         Size            Field Description
    0              4               CCB header (Table 36.1, âCCB Header Formatâ)


                                                   525
</code></pre>
<p>                                          Coprocessor services</p>
<pre><code>   Offset        Size          Field Description
   4             4             Command control
                               Bits        Field Description
                               [31]        If set, this CCB functions as a Sync command. If clear, this
                                           CCB functions as a No-op command.
                               [30:0]      Reserved
   8             8             Completion (same fields as Section 36.2.1.2, âExtract commandâ
   16            46            Reserved
</code></pre>
<p>36.2.2. CCB Completion Area<br>       All CCB commands use a common 128-byte Completion Area format, which can be specified by the<br>       following packed C structure for a big-endian machine:</p>
<pre><code>            struct completion_area &#123;
                   uint8_t status_flag;
                   uint8_t error_note;
                   uint8_t rsvd0[2];
                   uint32_t error_values;
                   uint32_t output_size;
                   uint32_t rsvd1;
                   uint64_t run_time;
                   uint64_t run_stats;
                   uint32_t elements;
                   uint8_t rsvd2[20];
                   uint64_t return_value;
                   uint64_t extra_return_value[8];
            &#125;;


   The Completion Area must be a 128-byte aligned memory location. The exact layout can be described
   using byte offsets and sizes relative to the memory base:

   Offset        Size          Field Description
   0             1             CCB execution status
                               0x0                  Command not yet completed
                               0x1                  Command ran and succeeded
                               0x2                  Command ran and failed (partial results may be been
                                                    produced)
                               0x3                  Command ran and was killed (partial execution may
                                                    have occurred)
                               0x4                  Command was not run
                               0x5-0xF              Reserved
   1             1             Error reason code
                               0x0                  Reserved
                               0x1                  Buffer overflow


                                              526
</code></pre>
<p>                                      Coprocessor services</p>
<p>Offset          Size           Field Description<br>                                0x2                 CCB decoding error<br>                                0x3                 Page overflow<br>                                0x4-0x6             Reserved<br>                                0x7                 Command was killed<br>                                0x8                 Command execution timeout<br>                                0x9                 ADI miscompare error<br>                                0xA                 Data format error<br>                                0xB-0xD             Reserved<br>                                0xE                 Unexpected hardware error (Do not retry)<br>                                0xF                 Unexpected hardware error (Retry is ok)<br>                                0x10-0x7F           Reserved<br>                                0x80                Partial Symbol Warning<br>                                0x81-0xFF           Reserved<br>2               2              Reserved<br>4               4              If a partial symbol warning was generated, this field contains the number<br>                               of remaining bits which were not decoded.<br>8               4              Number of bytes of output produced<br>12              4              Reserved<br>16              8              Runtime of command (unspecified time units)<br>24              8              Reserved<br>32              4              Number of elements processed<br>36              20             Reserved<br>56              8              Return value<br>64              64             Extended return value</p>
<p>The CCB completion area should be treated as read-only by guest software. The CCB execution status<br>byte will be cleared by the Hypervisor to reflect the pending execution status when the CCB is submitted<br>successfully. All other fields are considered invalid upon CCB submission until the CCB execution status<br>byte becomes non-zero.</p>
<p>CCBs which complete with status 0x2 or 0x3 may produce partial results and/or side effects due to partial<br>execution of the CCB command. Some valid data may be accessible depending on the fault type, however,<br>it is recommended that guest software treat the destination buffer as being in an unknown state. If a CCB<br>completes with a status byte of 0x2, the error reason code byte can be read to determine what corrective<br>action should be taken.</p>
<p>A buffer overflow indicates that the results of the operation exceeded the size of the output buffer indicated<br>in the CCB. The operation can be retried by resubmitting the CCB with a larger output buffer.</p>
<p>A CCB decoding error indicates that the CCB contained some invalid field values. It may be also be<br>triggered if the CCB output is directed at a non-existent secondary input and the pipelining hint is followed.</p>
<p>A page overflow error indicates that the operation required accessing a memory location beyond the page<br>size associated with a given address. No data will have been read or written past the page boundary, but<br>partial results may have been written to the destination buffer. The CCB can be resubmitted with a larger<br>page size memory allocation to complete the operation.</p>
<pre><code>                                          527
</code></pre>
<p>                                            Coprocessor services</p>
<pre><code>   In the case of pipelined CCBs, a page overflow error will be triggered if the output from the pipeline source
   CCB ends before the input of the pipeline target CCB. Page boundaries are ignored when the pipeline
   hint is followed.

   Command kill indicates that the CCB execution was halted or prevented by use of the ccb_kill API call.

   Command timeout indicates that the CCB execution began, but did not complete within a pre-determined
   limit set by the virtual machine. The command may have produced some or no output. The CCB may be
   resubmitted with no alterations.

   ADI miscompare indicates that the memory buffer version specified in the CCB did not match the value
   in memory when accessed by the virtual machine. Guest software should not attempt to resubmit the CCB
   without determining the cause of the version mismatch.

   A data format error indicates that the input data stream did not follow the specified data input formatting
   selected in the CCB.

   Some CCBs which encounter hardware errors may be resubmitted without change. Persistent hardware
   errors may result in multiple failures until RAS software can identify and isolate the faulty component.

   The output size field indicates the number of bytes of valid output in the destination buffer. This field is
   not valid for all possible CCB commands.

   The runtime field indicates the execution time of the CCB command once it leaves the internal virtual
   machine queue. The time units are fixed, but unspecified, allowing only relative timing comparisons
   by guest software. The time units may also vary by hardware platform, and should not be construed to
   represent any absolute time value.

   Some data query commands process data in units of elements. If applicable to the command, the number of
   elements processed is indicated in the listed field. This field is not valid for all possible CCB commands.

   The return value and extended return value fields are output locations for commands which do not use
   a destination output buffer, or have secondary return results. The field is not valid for all possible CCB
   commands.
</code></pre>
<p>36.3. Hypervisor API Functions<br>36.3.1. ccb_submit<br>       trap#             FAST_TRAP<br>       function#         CCB_SUBMIT<br>       arg0              address<br>       arg1              length<br>       arg2              flags<br>       arg3              reserved<br>       ret0              status<br>       ret1              length<br>       ret2              status data<br>       ret3              reserved</p>
<pre><code>   Submit one or more coprocessor control blocks (CCBs) for evaluation and processing by the virtual
   machine. The CCBs are passed in a linear array indicated by address. length indicates the size of
   the array in bytes.


                                                 528
</code></pre>
<p>                                      Coprocessor services</p>
<p>The address should be aligned to the size indicated by length, rounded up to the nearest power of<br>two. Virtual machines implementations may reject submissions which do not adhere to that alignment.<br>length must be a multiple of 64 bytes. If length is zero, the maximum supported array length will be<br>returned as length in ret1. In all other cases, the length value in ret1 will reflect the number of bytes<br>successfully consumed from the input CCB array.</p>
<pre><code>  Implementation note
  Virtual machines should never reject submissions based on the alignment of address if the
  entire array is contained within a single memory page of the smallest page size supported by the
  virtual machine.
</code></pre>
<p>A guest may choose to submit addresses used in this API function, including the CCB array address,<br>as either a real or virtual addresses, with the type of each address indicated in flags. Virtual addresses<br>must be present in either the TLB or an active TSB to be processed. The translation context for virtual<br>addresses is determined by a combination of CCB contents and the flags argument.</p>
<p>The flags argument is divided into multiple fields defined as follows:</p>
<p>Bits            Field Description<br>[63:16]         Reserved<br>[15]            Disable ADI for VA reads (in API 2.0)<br>                Reserved (in API 1.0)<br>[14]            Virtual addresses within CCBs are translated in privileged context<br>[13:12]         Alternate translation context for virtual addresses within CCBs:<br>                 0b’00        CCBs requesting alternate context are rejected<br>                 0b’01        Reserved<br>                 0b’10        CCBs requesting alternate context use secondary context<br>                 0b’11        CCBs requesting alternate context use nucleus context<br>[11:9]          Reserved<br>[8]             Queue info flag<br>[7]             All-or-nothing flag<br>[6]             If address is a virtual address, treat its translation context as privileged<br>[5:4]           Address type of address:<br>                 0b’00        Real address<br>                 0b’01        Virtual address in primary context<br>                 0b’10        Virtual address in secondary context<br>                 0b’11        Virtual address in nucleus context<br>[3:2]           Reserved<br>[1:0]           CCB command type:<br>                 0b’00        Reserved<br>                 0b’01        Reserved<br>                 0b’10        Query command<br>                 0b’11        Reserved</p>
<pre><code>                                          529
</code></pre>
<p>                                             Coprocessor services</p>
<pre><code>     The CCB submission type and address type for the CCB array must be provided in the flags argument.
     All other fields are optional values which change the default behavior of the CCB processing.

     When set to one, the &quot;Disable ADI for VA reads&quot; bit will turn off ADI checking when using a virtual
     address to load data. ADI checking will still be done when loading real-addressed memory. This bit is only
     available when using major version 2 of the coprocessor API group; at major version 1 it is reserved. For
     more information about using ADI and DAX, see Section 36.2.1.1.7, âApplication Data Integrity (ADI)â.

     By default, all virtual addresses are treated as user addresses. If the virtual address translations are
     privileged, they must be marked as such in the appropriate flags field. The virtual addresses used within
     the submitted CCBs must all be translated with the same privilege level.

     By default, all virtual addresses used within the submitted CCBs are translated using the primary context
     active at the time of the submission. The address type field within a CCB allows each address to request
     translation in an alternate address context. The address context used when the alternate address context is
     requested is selected in the flags argument.

     The all-or-nothing flag specifies whether the virtual machine should allow partial submissions of the
     input CCB array. When using CCBs with serial-conditional flags, it is strongly recommended to use
     the all-or-nothing flag to avoid broken conditional chains. Using long CCB chains on a machine under
     high coprocessor load may make this impractical, however, and require submitting without the flag.
     When submitting serial-conditional CCBs without the all-or-nothing flag, guest software must manually
     implement the serial-conditional behavior at any point where the chain was not submitted in a single API
     call, and resubmission of the remaining CCBs should clear any conditional flag that might be set in the
     first remaining CCB. Failure to do so will produce indeterminate CCB execution status and ordering.

     When the all-or-nothing flag is not specified, callers should check the value of length in ret1 to determine
     how many CCBs from the array were successfully submitted. Any remaining CCBs can be resubmitted
     without modifications.

     The value of length in ret1 is also valid when the API call returns an error, and callers should always
     check its value to determine which CCBs in the array were already processed. This will additionally
     identify which CCB encountered the processing error, and was not submitted successfully.

     If the queue info flag is used during submission, and at least one CCB was successfully submitted, the
     length value in ret1 will be a multi-field value defined as follows:
      Bits          Field Description
      [63:48]       DAX unit instance identifier
      [47:32]       DAX queue instance identifier
      [31:16]       Reserved
      [15:0]        Number of CCB bytes successfully submitted

     The value of status data depends on the status value. See error status code descriptions for details.
     The value is undefined for status values that do not specifically list a value for the status data.

     The API has a reserved input and output register which will be used in subsequent minor versions of this
     API function. Guest software implementations should treat that register as voltile across the function call
     in order to maintain forward compatibility.
</code></pre>
<p>36.3.1.1. Errors<br>          EOK                       One or more CCBs have been accepted and enqueued in the virtual machine<br>                                    and no errors were been encountered during submission. Some submitted<br>                                    CCBs may not have been enqueued due to internal virtual machine limitations,<br>                                    and may be resubmitted without changes.</p>
<pre><code>                                                   530
</code></pre>
<p>                        Coprocessor services</p>
<p>EWOULDBLOCK    An internal resource conflict within the virtual machine has prevented it from<br>               being able to complete the CCB submissions sufficiently quickly, requiring<br>               it to abandon processing before it was complete. Some CCBs may have been<br>               successfully enqueued prior to the block, and all remaining CCBs may be<br>               resubmitted without changes.<br>EBADALIGN      CCB array is not on a 64-byte boundary, or the array length is not a multiple<br>               of 64 bytes.<br>ENORADDR       A real address used either for the CCB array, or within one of the submitted<br>               CCBs, is not valid for the guest. Some CCBs may have been enqueued prior<br>               to the error being detected.<br>ENOMAP         A virtual address used either for the CCB array, or within one of the submitted<br>               CCBs, could not be translated by the virtual machine using either the TLB<br>               or TSB contents. The submission may be retried after adding the required<br>               mapping, or by converting the virtual address into a real address. Due to the<br>               shared nature of address translation resources, there is no theoretical limit on<br>               the number of times the translation may fail, and it is recommended all guests<br>               implement some real address based backup. The virtual address which failed<br>               translation is returned as status data in ret2. Some CCBs may have been<br>               enqueued prior to the error being detected.<br>EINVAL         The virtual machine detected an invalid CCB during submission, or invalid<br>               input arguments, such as bad flag values. Note that not all invalid CCB values<br>               will be detected during submission, and some may be reported as errors in the<br>               completion area instead. Some CCBs may have been enqueued prior to the<br>               error being detected. This error may be returned if the CCB version is invalid.<br>ETOOMANY       The request was submitted with the all-or-nothing flag set, and the array size is<br>               greater than the virtual machine can support in a single request. The maximum<br>               supported size for the current virtual machine can be queried by submitting a<br>               request with a zero length array, as described above.<br>ENOACCESS      The guest does not have permission to submit CCBs, or an address used in a<br>               CCBs lacks sufficient permissions to perform the required operation (no write<br>               permission on the destination buffer address, for example). A virtual address<br>               which fails permission checking is returned as status data in ret2. Some<br>               CCBs may have been enqueued prior to the error being detected.<br>EUNAVAILABLE   The requested CCB operation could not be performed at this time. The<br>               restricted operation availability may apply only to the first unsuccessfully<br>               submitted CCB, or may apply to a larger scope. The status should not be<br>               interpreted as permanent, and the guest should attempt to submit CCBs in<br>               the future which had previously been unable to be performed. The status<br>               data provides additional information about scope of the retricted availability<br>               as follows:<br>               Value       Description<br>               0           Processing for the exact CCB instance submitted was unavailable,<br>                           and it is recommended the guest emulate the operation. The<br>                           guest should continue to submit all other CCBs, and assume no<br>                           restrictions beyond this exact CCB instance.<br>               1           Processing is unavailable for all CCBs using the requested opcode,<br>                           and it is recommended the guest emulate the operation. The<br>                           guest should continue to submit all other CCBs that use different<br>                           opcodes, but can expect continued rejections of CCBs using the<br>                           same opcode in the near future.</p>
<pre><code>                             531
</code></pre>
<p>                                              Coprocessor services</p>
<pre><code>                                  Value     Description
                                  2         Processing is unavailable for all CCBs using the requested CCB
                                            version, and it is recommended the guest emulate the operation.
                                            The guest should continue to submit all other CCBs that use
                                            different CCB versions, but can expect continued rejections of
                                            CCBs using the same CCB version in the near future.
                                  3         Processing is unavailable for all CCBs on the submitting vcpu,
                                            and it is recommended the guest emulate the operation or resubmit
                                            the CCB on a different vcpu. The guest should continue to submit
                                            CCBs on all other vcpus but can expect continued rejections of all
                                            CCBs on this vcpu in the near future.
                                  4         Processing is unavailable for all CCBs, and it is recommended
                                            the guest emulate the operation. The guest should expect all CCB
                                            submissions to be similarly rejected in the near future.
</code></pre>
<p>36.3.2. ccb_info</p>
<pre><code>    trap#               FAST_TRAP
    function#           CCB_INFO
    arg0                address
    ret0                status
    ret1                CCB state
    ret2                position
    ret3                dax
    ret4                queue

   Requests status information on a previously submitted CCB. The previously submitted CCB is identified
   by the 64-byte aligned real address of the CCBs completion area.

   A CCB can be in one of 4 states:


    State                     Value       Description
    COMPLETED                 0           The CCB has been fetched and executed, and is no longer active in
                                          the virtual machine.
    ENQUEUED                  1           The requested CCB is current in a queue awaiting execution.
    INPROGRESS                2           The CCB has been fetched and is currently being executed. It may still
                                          be possible to stop the execution using the ccb_kill hypercall.
    NOTFOUND                  3           The CCB could not be located in the virtual machine, and does not
                                          appear to have been executed. This may occur if the CCB was lost
                                          due to a hardware error, or the CCB may not have been successfully
                                          submitted to the virtual machine in the first place.

           Implementation note
           Some platforms may not be able to report CCBs that are currently being processed, and therefore
           guest software should invoke the ccb_kill hypercall prior to assuming the request CCB will never
           be executed because it was in the NOTFOUND state.


                                                   532
</code></pre>
<p>                                             Coprocessor services</p>
<pre><code>     The position return value is only valid when the state is ENQUEUED. The value returned is the number
     of other CCBs ahead of the requested CCB, to provide a relative estimate of when the CCB may execute.

     The dax return value is only valid when the state is ENQUEUED. The value returned is the DAX unit
     instance indentifier for the DAX unit processing the queue where the requested CCB is located. The value
     matches the value that would have been, or was, returned by ccb_submit using the queue info flag.

     The queue return value is only valid when the state is ENQUEUED. The value returned is the DAX
     queue instance indentifier for the DAX unit processing the queue where the requested CCB is located. The
     value matches the value that would have been, or was, returned by ccb_submit using the queue info flag.
</code></pre>
<p>36.3.2.1. Errors</p>
<pre><code>      EOK                       The request was proccessed and the CCB state is valid.
      EBADALIGN                 address is not on a 64-byte aligned.
      ENORADDR                  The real address provided for address is not valid.
      EINVAL                    The CCB completion area contents are not valid.
      EWOULDBLOCK               Internal resource contraints prevented the CCB state from being queried at this
                                time. The guest should retry the request.
      ENOACCESS                 The guest does not have permission to access the coprocessor virtual device
                                functionality.
</code></pre>
<p>36.3.3. ccb_kill</p>
<pre><code>      trap#           FAST_TRAP
      function#       CCB_KILL
      arg0            address
      ret0            status
      ret1            result

     Request to stop execution of a previously submitted CCB. The previously submitted CCB is identified by
     the 64-byte aligned real address of the CCBs completion area.

     The kill attempt can produce one of several values in the result return value, reflecting the CCB state
     and actions taken by the Hypervisor:

      Result                Value       Description
      COMPLETED             0           The CCB has been fetched and executed, and is no longer active in
                                        the virtual machine. It could not be killed and no action was taken.
      DEQUEUED              1           The requested CCB was still enqueued when the kill request was
                                        submitted, and has been removed from the queue. Since the CCB
                                        never began execution, no memory modifications were produced by
                                        it, and the completion area will never be updated. The same CCB may
                                        be submitted again, if desired, with no modifications required.
      KILLED                2           The CCB had been fetched and was being executed when the kill
                                        request was submitted. The CCB execution was stopped, and the CCB
                                        is no longer active in the virtual machine. The CCB completion area
                                        will reflect the killed status, with the subsequent implications that
                                        partial results may have been produced. Partial results may include full


                                                  533
</code></pre>
<p>                                              Coprocessor services</p>
<pre><code>      Result                 Value       Description
                                         command execution if the command was stopped just prior to writing
                                         to the completion area.
      NOTFOUND               3           The CCB could not be located in the virtual machine, and does not
                                         appear to have been executed. This may occur if the CCB was lost
                                         due to a hardware error, or the CCB may not have been successfully
                                         submitted to the virtual machine in the first place. CCBs in the state
                                         are guaranteed to never execute in the future unless resubmitted.
</code></pre>
<p>36.3.3.1. Interactions with Pipelined CCBs</p>
<pre><code>     If the pipeline target CCB is killed but the pipeline source CCB was skipped, the completion area of the
     target CCB may contain status (4,0) &quot;Command was skipped&quot; instead of (3,7) &quot;Command was killed&quot;.

     If the pipeline source CCB is killed, the pipeline target CCB&#39;s completion status may read (1,0) &quot;Success&quot;.
     This does not mean the target CCB was processed; since the source CCB was killed, there was no
     meaningful output on which the target CCB could operate.
</code></pre>
<p>36.3.3.2. Errors</p>
<pre><code>      EOK                        The request was proccessed and the result is valid.
      EBADALIGN                  address is not on a 64-byte aligned.
      ENORADDR                   The real address provided for address is not valid.
      EINVAL                     The CCB completion area contents are not valid.
      EWOULDBLOCK                Internal resource contraints prevented the CCB from being killed at this time.
                                 The guest should retry the request.
      ENOACCESS                  The guest does not have permission to access the coprocessor virtual device
                                 functionality.
</code></pre>
<p>36.3.4. dax_info<br>          trap#            FAST_TRAP<br>          function#        DAX_INFO<br>          ret0             status<br>          ret1             Number of enabled DAX units<br>          ret2             Number of disabled DAX units</p>
<pre><code>     Returns the number of DAX units that are enabled for the calling guest to submit CCBs. The number of
     DAX units that are disabled for the calling guest are also returned. A disabled DAX unit would have been
     available for CCB submission to the calling guest had it not been offlined.
</code></pre>
<p>36.3.4.1. Errors</p>
<pre><code>      EOK                        The request was proccessed and the number of enabled/disabled DAX units
                                 are valid.




                                                   534
</code></pre>
<p></p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_dax-hv-api/" title="Kernel-4.18.0-80.el8_dax-hv-api" target="_blank" rel="external">http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_dax-hv-api/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/02/19/Kernel-4.18.0-80.el8_digicolor/" title="Kernel-4.18.0-80.el8_digicolor"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/02/19/Kernel-4.18.0-80.el8_proc/" title="Kernel-4.18.0-80.el8_proc"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>