<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-4.18.0-80.el8_runtime_p | oosTech.com</title>
  <meta name="description" content="Runtime Power Management Framework for I&#x2F;O Devices (C) 2009-2011 Rafael J. Wysocki &amp;#114;&amp;#x6a;&amp;#x77;&amp;#64;&amp;#x73;&amp;#x69;&amp;#115;&amp;#x6b;&amp;#x2e;&amp;#112;&amp;#x6c;, Novell Inc.(C) 2010 Alan Stern &amp;#115;&amp;#116;&amp;#101;&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-4.18.0-80.el8_runtime_p">
<meta property="og:url" content="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_runtime_pm/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="Runtime Power Management Framework for I&#x2F;O Devices (C) 2009-2011 Rafael J. Wysocki &amp;#114;&amp;#x6a;&amp;#x77;&amp;#64;&amp;#x73;&amp;#x69;&amp;#115;&amp;#x6b;&amp;#x2e;&amp;#112;&amp;#x6c;, Novell Inc.(C) 2010 Alan Stern &amp;#115;&amp;#116;&amp;#101;&amp;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-18T16:00:00.000Z">
<meta property="article:modified_time" content="2021-02-18T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_runtime_pm/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-4.18.0-80.el8_runtime_pm" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-4.18.0-80.el8_runtime_p
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/02/19/Kernel-4.18.0-80.el8_runtime_pm/" class="article-date">
	 published: <time datetime="2021-02-18T16:00:00.000Z" itemprop="datePublished">2021-02-19</time>
	</a>
</span>

        
	<a href="/2021/02/19/Kernel-4.18.0-80.el8_runtime_pm/" class="article-date">
	   updated: <time datetime="2021-02-18T16:00:00.000Z" itemprop="dateUpdated">2021-02-19</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/02/19/Kernel-4.18.0-80.el8_runtime_pm/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>Runtime Power Management Framework for I/O Devices</p>
<p>(C) 2009-2011 Rafael J. Wysocki <a href="mailto:&#114;&#x6a;&#x77;&#64;&#x73;&#x69;&#115;&#x6b;&#x2e;&#112;&#x6c;">&#114;&#x6a;&#x77;&#64;&#x73;&#x69;&#115;&#x6b;&#x2e;&#112;&#x6c;</a>, Novell Inc.<br>(C) 2010 Alan Stern <a href="mailto:&#115;&#116;&#101;&#x72;&#110;&#64;&#114;&#x6f;&#x77;&#108;&#x61;&#110;&#x64;&#x2e;&#104;&#97;&#x72;&#118;&#97;&#x72;&#x64;&#x2e;&#x65;&#x64;&#x75;">&#115;&#116;&#101;&#x72;&#110;&#64;&#114;&#x6f;&#x77;&#108;&#x61;&#110;&#x64;&#x2e;&#104;&#97;&#x72;&#118;&#97;&#x72;&#x64;&#x2e;&#x65;&#x64;&#x75;</a><br>(C) 2014 Intel Corp., Rafael J. Wysocki <a href="mailto:&#114;&#x61;&#x66;&#x61;&#101;&#108;&#46;&#x6a;&#46;&#x77;&#x79;&#x73;&#111;&#99;&#x6b;&#x69;&#64;&#x69;&#110;&#116;&#101;&#x6c;&#46;&#99;&#111;&#x6d;">&#114;&#x61;&#x66;&#x61;&#101;&#108;&#46;&#x6a;&#46;&#x77;&#x79;&#x73;&#111;&#99;&#x6b;&#x69;&#64;&#x69;&#110;&#116;&#101;&#x6c;&#46;&#99;&#111;&#x6d;</a></p>
<ol>
<li>Introduction</li>
</ol>
<p>Support for runtime power management (runtime PM) of I/O devices is provided<br>at the power management core (PM core) level by means of:</p>
<ul>
<li><p>The power management workqueue pm_wq in which bus types and device drivers can<br>put their PM-related work items.  It is strongly recommended that pm_wq be<br>used for queuing all work items related to runtime PM, because this allows<br>them to be synchronized with system-wide power transitions (suspend to RAM,<br>hibernation and resume from system sleep states).  pm_wq is declared in<br>include/linux/pm_runtime.h and defined in kernel/power/main.c.</p>
</li>
<li><p>A number of runtime PM fields in the ‘power’ member of ‘struct device’ (which<br>is of the type ‘struct dev_pm_info’, defined in include/linux/pm.h) that can<br>be used for synchronizing runtime PM operations with one another.</p>
</li>
<li><p>Three device runtime PM callbacks in ‘struct dev_pm_ops’ (defined in<br>include/linux/pm.h).</p>
</li>
<li><p>A set of helper functions defined in drivers/base/power/runtime.c that can be<br>used for carrying out runtime PM operations in such a way that the<br>synchronization between them is taken care of by the PM core.  Bus types and<br>device drivers are encouraged to use these functions.</p>
</li>
</ul>
<p>The runtime PM callbacks present in ‘struct dev_pm_ops’, the device runtime PM<br>fields of ‘struct dev_pm_info’ and the core helper functions provided for<br>runtime PM are described below.</p>
<ol start="2">
<li>Device Runtime PM Callbacks</li>
</ol>
<p>There are three device runtime PM callbacks defined in ‘struct dev_pm_ops’:</p>
<p>struct dev_pm_ops {<br>    …<br>    int (*runtime_suspend)(struct device *dev);<br>    int (*runtime_resume)(struct device *dev);<br>    int (*runtime_idle)(struct device *dev);<br>    …<br>};</p>
<p>The -&gt;runtime_suspend(), -&gt;runtime_resume() and -&gt;runtime_idle() callbacks<br>are executed by the PM core for the device’s subsystem that may be either of<br>the following:</p>
<ol>
<li><p>PM domain of the device, if the device’s PM domain object, dev-&gt;pm_domain,<br>is present.</p>
</li>
<li><p>Device type of the device, if both dev-&gt;type and dev-&gt;type-&gt;pm are present.</p>
</li>
<li><p>Device class of the device, if both dev-&gt;class and dev-&gt;class-&gt;pm are<br>present.</p>
</li>
<li><p>Bus type of the device, if both dev-&gt;bus and dev-&gt;bus-&gt;pm are present.</p>
</li>
</ol>
<p>If the subsystem chosen by applying the above rules doesn’t provide the relevant<br>callback, the PM core will invoke the corresponding driver callback stored in<br>dev-&gt;driver-&gt;pm directly (if present).</p>
<p>The PM core always checks which callback to use in the order given above, so the<br>priority order of callbacks from high to low is: PM domain, device type, class<br>and bus type.  Moreover, the high-priority one will always take precedence over<br>a low-priority one.  The PM domain, bus type, device type and class callbacks<br>are referred to as subsystem-level callbacks in what follows.</p>
<p>By default, the callbacks are always invoked in process context with interrupts<br>enabled.  However, the pm_runtime_irq_safe() helper function can be used to tell<br>the PM core that it is safe to run the -&gt;runtime_suspend(), -&gt;runtime_resume()<br>and -&gt;runtime_idle() callbacks for the given device in atomic context with<br>interrupts disabled.  This implies that the callback routines in question must<br>not block or sleep, but it also means that the synchronous helper functions<br>listed at the end of Section 4 may be used for that device within an interrupt<br>handler or generally in an atomic context.</p>
<p>The subsystem-level suspend callback, if present, is <em>entirely</em> <em>responsible</em><br>for handling the suspend of the device as appropriate, which may, but need not<br>include executing the device driver’s own -&gt;runtime_suspend() callback (from the<br>PM core’s point of view it is not necessary to implement a -&gt;runtime_suspend()<br>callback in a device driver as long as the subsystem-level suspend callback<br>knows what to do to handle the device).</p>
<ul>
<li><p>Once the subsystem-level suspend callback (or the driver suspend callback,<br>if invoked directly) has completed successfully for the given device, the PM<br>core regards the device as suspended, which need not mean that it has been<br>put into a low power state.  It is supposed to mean, however, that the<br>device will not process data and will not communicate with the CPU(s) and<br>RAM until the appropriate resume callback is executed for it.  The runtime<br>PM status of a device after successful execution of the suspend callback is<br>‘suspended’.</p>
</li>
<li><p>If the suspend callback returns -EBUSY or -EAGAIN, the device’s runtime PM<br>status remains ‘active’, which means that the device <em>must</em> be fully<br>operational afterwards.</p>
</li>
<li><p>If the suspend callback returns an error code different from -EBUSY and<br>-EAGAIN, the PM core regards this as a fatal error and will refuse to run<br>the helper functions described in Section 4 for the device until its status<br>is directly set to  either ‘active’, or ‘suspended’ (the PM core provides<br>special helper functions for this purpose).</p>
</li>
</ul>
<p>In particular, if the driver requires remote wakeup capability (i.e. hardware<br>mechanism allowing the device to request a change of its power state, such as<br>PCI PME) for proper functioning and device_can_wakeup() returns ‘false’ for the<br>device, then -&gt;runtime_suspend() should return -EBUSY.  On the other hand, if<br>device_can_wakeup() returns ‘true’ for the device and the device is put into a<br>low-power state during the execution of the suspend callback, it is expected<br>that remote wakeup will be enabled for the device.  Generally, remote wakeup<br>should be enabled for all input devices put into low-power states at run time.</p>
<p>The subsystem-level resume callback, if present, is <em>entirely</em> <em>responsible</em> for<br>handling the resume of the device as appropriate, which may, but need not<br>include executing the device driver’s own -&gt;runtime_resume() callback (from the<br>PM core’s point of view it is not necessary to implement a -&gt;runtime_resume()<br>callback in a device driver as long as the subsystem-level resume callback knows<br>what to do to handle the device).</p>
<ul>
<li><p>Once the subsystem-level resume callback (or the driver resume callback, if<br>invoked directly) has completed successfully, the PM core regards the device<br>as fully operational, which means that the device <em>must</em> be able to complete<br>I/O operations as needed.  The runtime PM status of the device is then<br>‘active’.</p>
</li>
<li><p>If the resume callback returns an error code, the PM core regards this as a<br>fatal error and will refuse to run the helper functions described in Section<br>4 for the device, until its status is directly set to either ‘active’, or<br>‘suspended’ (by means of special helper functions provided by the PM core<br>for this purpose).</p>
</li>
</ul>
<p>The idle callback (a subsystem-level one, if present, or the driver one) is<br>executed by the PM core whenever the device appears to be idle, which is<br>indicated to the PM core by two counters, the device’s usage counter and the<br>counter of ‘active’ children of the device.</p>
<ul>
<li>If any of these counters is decreased using a helper function provided by<br>the PM core and it turns out to be equal to zero, the other counter is<br>checked.  If that counter also is equal to zero, the PM core executes the<br>idle callback with the device as its argument.</li>
</ul>
<p>The action performed by the idle callback is totally dependent on the subsystem<br>(or driver) in question, but the expected and recommended action is to check<br>if the device can be suspended (i.e. if all of the conditions necessary for<br>suspending the device are satisfied) and to queue up a suspend request for the<br>device in that case.  If there is no idle callback, or if the callback returns<br>0, then the PM core will attempt to carry out a runtime suspend of the device,<br>also respecting devices configured for autosuspend.  In essence this means a<br>call to pm_runtime_autosuspend() (do note that drivers needs to update the<br>device last busy mark, pm_runtime_mark_last_busy(), to control the delay under<br>this circumstance).  To prevent this (for example, if the callback routine has<br>started a delayed suspend), the routine must return a non-zero value.  Negative<br>error return codes are ignored by the PM core.</p>
<p>The helper functions provided by the PM core, described in Section 4, guarantee<br>that the following constraints are met with respect to runtime PM callbacks for<br>one device:</p>
<p>(1) The callbacks are mutually exclusive (e.g. it is forbidden to execute<br>    -&gt;runtime_suspend() in parallel with -&gt;runtime_resume() or with another<br>    instance of -&gt;runtime_suspend() for the same device) with the exception that<br>    -&gt;runtime_suspend() or -&gt;runtime_resume() can be executed in parallel with<br>    -&gt;runtime_idle() (although -&gt;runtime_idle() will not be started while any<br>    of the other callbacks is being executed for the same device).</p>
<p>(2) -&gt;runtime_idle() and -&gt;runtime_suspend() can only be executed for ‘active’<br>    devices (i.e. the PM core will only execute -&gt;runtime_idle() or<br>    -&gt;runtime_suspend() for the devices the runtime PM status of which is<br>    ‘active’).</p>
<p>(3) -&gt;runtime_idle() and -&gt;runtime_suspend() can only be executed for a device<br>    the usage counter of which is equal to zero <em>and</em> either the counter of<br>    ‘active’ children of which is equal to zero, or the ‘power.ignore_children’<br>    flag of which is set.</p>
<p>(4) -&gt;runtime_resume() can only be executed for ‘suspended’ devices  (i.e. the<br>    PM core will only execute -&gt;runtime_resume() for the devices the runtime<br>    PM status of which is ‘suspended’).</p>
<p>Additionally, the helper functions provided by the PM core obey the following<br>rules:</p>
<ul>
<li><p>If -&gt;runtime_suspend() is about to be executed or there’s a pending request<br>to execute it, -&gt;runtime_idle() will not be executed for the same device.</p>
</li>
<li><p>A request to execute or to schedule the execution of -&gt;runtime_suspend()<br>will cancel any pending requests to execute -&gt;runtime_idle() for the same<br>device.</p>
</li>
<li><p>If -&gt;runtime_resume() is about to be executed or there’s a pending request<br>to execute it, the other callbacks will not be executed for the same device.</p>
</li>
<li><p>A request to execute -&gt;runtime_resume() will cancel any pending or<br>scheduled requests to execute the other callbacks for the same device,<br>except for scheduled autosuspends.</p>
</li>
</ul>
<ol start="3">
<li>Runtime PM Device Fields</li>
</ol>
<p>The following device runtime PM fields are present in ‘struct dev_pm_info’, as<br>defined in include/linux/pm.h:</p>
<p>  struct timer_list suspend_timer;<br>    - timer used for scheduling (delayed) suspend and autosuspend requests</p>
<p>  unsigned long timer_expires;<br>    - timer expiration time, in jiffies (if this is different from zero, the<br>      timer is running and will expire at that time, otherwise the timer is not<br>      running)</p>
<p>  struct work_struct work;<br>    - work structure used for queuing up requests (i.e. work items in pm_wq)</p>
<p>  wait_queue_head_t wait_queue;<br>    - wait queue used if any of the helper functions needs to wait for another<br>      one to complete</p>
<p>  spinlock_t lock;<br>    - lock used for synchronization</p>
<p>  atomic_t usage_count;<br>    - the usage counter of the device</p>
<p>  atomic_t child_count;<br>    - the count of ‘active’ children of the device</p>
<p>  unsigned int ignore_children;<br>    - if set, the value of child_count is ignored (but still updated)</p>
<p>  unsigned int disable_depth;<br>    - used for disabling the helper functions (they work normally if this is<br>      equal to zero); the initial value of it is 1 (i.e. runtime PM is<br>      initially disabled for all devices)</p>
<p>  int runtime_error;<br>    - if set, there was a fatal error (one of the callbacks returned error code<br>      as described in Section 2), so the helper functions will not work until<br>      this flag is cleared; this is the error code returned by the failing<br>      callback</p>
<p>  unsigned int idle_notification;<br>    - if set, -&gt;runtime_idle() is being executed</p>
<p>  unsigned int request_pending;<br>    - if set, there’s a pending request (i.e. a work item queued up into pm_wq)</p>
<p>  enum rpm_request request;<br>    - type of request that’s pending (valid if request_pending is set)</p>
<p>  unsigned int deferred_resume;<br>    - set if -&gt;runtime_resume() is about to be run while -&gt;runtime_suspend() is<br>      being executed for that device and it is not practical to wait for the<br>      suspend to complete; means “start a resume as soon as you’ve suspended”</p>
<p>  enum rpm_status runtime_status;<br>    - the runtime PM status of the device; this field’s initial value is<br>      RPM_SUSPENDED, which means that each device is initially regarded by the<br>      PM core as ‘suspended’, regardless of its real hardware status</p>
<p>  unsigned int runtime_auto;<br>    - if set, indicates that the user space has allowed the device driver to<br>      power manage the device at run time via the /sys/devices/…/power/control<br>      interface; it may only be modified with the help of the pm_runtime_allow()<br>      and pm_runtime_forbid() helper functions</p>
<p>  unsigned int no_callbacks;<br>    - indicates that the device does not use the runtime PM callbacks (see<br>      Section 8); it may be modified only by the pm_runtime_no_callbacks()<br>      helper function</p>
<p>  unsigned int irq_safe;<br>    - indicates that the -&gt;runtime_suspend() and -&gt;runtime_resume() callbacks<br>      will be invoked with the spinlock held and interrupts disabled</p>
<p>  unsigned int use_autosuspend;<br>    - indicates that the device’s driver supports delayed autosuspend (see<br>      Section 9); it may be modified only by the<br>      pm_runtime{_dont}_use_autosuspend() helper functions</p>
<p>  unsigned int timer_autosuspends;<br>    - indicates that the PM core should attempt to carry out an autosuspend<br>      when the timer expires rather than a normal suspend</p>
<p>  int autosuspend_delay;<br>    - the delay time (in milliseconds) to be used for autosuspend</p>
<p>  unsigned long last_busy;<br>    - the time (in jiffies) when the pm_runtime_mark_last_busy() helper<br>      function was last called for this device; used in calculating inactivity<br>      periods for autosuspend</p>
<p>All of the above fields are members of the ‘power’ member of ‘struct device’.</p>
<ol start="4">
<li>Runtime PM Device Helper Functions</li>
</ol>
<p>The following runtime PM helper functions are defined in<br>drivers/base/power/runtime.c and include/linux/pm_runtime.h:</p>
<p>  void pm_runtime_init(struct device *dev);<br>    - initialize the device runtime PM fields in ‘struct dev_pm_info’</p>
<p>  void pm_runtime_remove(struct device *dev);<br>    - make sure that the runtime PM of the device will be disabled after<br>      removing the device from device hierarchy</p>
<p>  int pm_runtime_idle(struct device *dev);<br>    - execute the subsystem-level idle callback for the device; returns an<br>      error code on failure, where -EINPROGRESS means that -&gt;runtime_idle() is<br>      already being executed; if there is no callback or the callback returns 0<br>      then run pm_runtime_autosuspend(dev) and return its result</p>
<p>  int pm_runtime_suspend(struct device *dev);<br>    - execute the subsystem-level suspend callback for the device; returns 0 on<br>      success, 1 if the device’s runtime PM status was already ‘suspended’, or<br>      error code on failure, where -EAGAIN or -EBUSY means it is safe to attempt<br>      to suspend the device again in future and -EACCES means that<br>      ‘power.disable_depth’ is different from 0</p>
<p>  int pm_runtime_autosuspend(struct device *dev);<br>    - same as pm_runtime_suspend() except that the autosuspend delay is taken<br>      into account; if pm_runtime_autosuspend_expiration() says the delay has<br>      not yet expired then an autosuspend is scheduled for the appropriate time<br>      and 0 is returned</p>
<p>  int pm_runtime_resume(struct device *dev);<br>    - execute the subsystem-level resume callback for the device; returns 0 on<br>      success, 1 if the device’s runtime PM status was already ‘active’ or<br>      error code on failure, where -EAGAIN means it may be safe to attempt to<br>      resume the device again in future, but ‘power.runtime_error’ should be<br>      checked additionally, and -EACCES means that ‘power.disable_depth’ is<br>      different from 0</p>
<p>  int pm_request_idle(struct device *dev);<br>    - submit a request to execute the subsystem-level idle callback for the<br>      device (the request is represented by a work item in pm_wq); returns 0 on<br>      success or error code if the request has not been queued up</p>
<p>  int pm_request_autosuspend(struct device *dev);<br>    - schedule the execution of the subsystem-level suspend callback for the<br>      device when the autosuspend delay has expired; if the delay has already<br>      expired then the work item is queued up immediately</p>
<p>  int pm_schedule_suspend(struct device *dev, unsigned int delay);<br>    - schedule the execution of the subsystem-level suspend callback for the<br>      device in future, where ‘delay’ is the time to wait before queuing up a<br>      suspend work item in pm_wq, in milliseconds (if ‘delay’ is zero, the work<br>      item is queued up immediately); returns 0 on success, 1 if the device’s PM<br>      runtime status was already ‘suspended’, or error code if the request<br>      hasn’t been scheduled (or queued up if ‘delay’ is 0); if the execution of<br>      -&gt;runtime_suspend() is already scheduled and not yet expired, the new<br>      value of ‘delay’ will be used as the time to wait</p>
<p>  int pm_request_resume(struct device *dev);<br>    - submit a request to execute the subsystem-level resume callback for the<br>      device (the request is represented by a work item in pm_wq); returns 0 on<br>      success, 1 if the device’s runtime PM status was already ‘active’, or<br>      error code if the request hasn’t been queued up</p>
<p>  void pm_runtime_get_noresume(struct device *dev);<br>    - increment the device’s usage counter</p>
<p>  int pm_runtime_get(struct device *dev);<br>    - increment the device’s usage counter, run pm_request_resume(dev) and<br>      return its result</p>
<p>  int pm_runtime_get_sync(struct device *dev);<br>    - increment the device’s usage counter, run pm_runtime_resume(dev) and<br>      return its result</p>
<p>  int pm_runtime_get_if_in_use(struct device *dev);<br>    - return -EINVAL if ‘power.disable_depth’ is nonzero; otherwise, if the<br>      runtime PM status is RPM_ACTIVE and the runtime PM usage counter is<br>      nonzero, increment the counter and return 1; otherwise return 0 without<br>      changing the counter</p>
<p>  void pm_runtime_put_noidle(struct device *dev);<br>    - decrement the device’s usage counter</p>
<p>  int pm_runtime_put(struct device *dev);<br>    - decrement the device’s usage counter; if the result is 0 then run<br>      pm_request_idle(dev) and return its result</p>
<p>  int pm_runtime_put_autosuspend(struct device *dev);<br>    - decrement the device’s usage counter; if the result is 0 then run<br>      pm_request_autosuspend(dev) and return its result</p>
<p>  int pm_runtime_put_sync(struct device *dev);<br>    - decrement the device’s usage counter; if the result is 0 then run<br>      pm_runtime_idle(dev) and return its result</p>
<p>  int pm_runtime_put_sync_suspend(struct device *dev);<br>    - decrement the device’s usage counter; if the result is 0 then run<br>      pm_runtime_suspend(dev) and return its result</p>
<p>  int pm_runtime_put_sync_autosuspend(struct device *dev);<br>    - decrement the device’s usage counter; if the result is 0 then run<br>      pm_runtime_autosuspend(dev) and return its result</p>
<p>  void pm_runtime_enable(struct device *dev);<br>    - decrement the device’s ‘power.disable_depth’ field; if that field is equal<br>      to zero, the runtime PM helper functions can execute subsystem-level<br>      callbacks described in Section 2 for the device</p>
<p>  int pm_runtime_disable(struct device *dev);<br>    - increment the device’s ‘power.disable_depth’ field (if the value of that<br>      field was previously zero, this prevents subsystem-level runtime PM<br>      callbacks from being run for the device), make sure that all of the<br>      pending runtime PM operations on the device are either completed or<br>      canceled; returns 1 if there was a resume request pending and it was<br>      necessary to execute the subsystem-level resume callback for the device<br>      to satisfy that request, otherwise 0 is returned</p>
<p>  int pm_runtime_barrier(struct device *dev);<br>    - check if there’s a resume request pending for the device and resume it<br>      (synchronously) in that case, cancel any other pending runtime PM requests<br>      regarding it and wait for all runtime PM operations on it in progress to<br>      complete; returns 1 if there was a resume request pending and it was<br>      necessary to execute the subsystem-level resume callback for the device to<br>      satisfy that request, otherwise 0 is returned</p>
<p>  void pm_suspend_ignore_children(struct device *dev, bool enable);<br>    - set/unset the power.ignore_children flag of the device</p>
<p>  int pm_runtime_set_active(struct device *dev);<br>    - clear the device’s ‘power.runtime_error’ flag, set the device’s runtime<br>      PM status to ‘active’ and update its parent’s counter of ‘active’<br>      children as appropriate (it is only valid to use this function if<br>      ‘power.runtime_error’ is set or ‘power.disable_depth’ is greater than<br>      zero); it will fail and return error code if the device has a parent<br>      which is not active and the ‘power.ignore_children’ flag of which is unset</p>
<p>  void pm_runtime_set_suspended(struct device *dev);<br>    - clear the device’s ‘power.runtime_error’ flag, set the device’s runtime<br>      PM status to ‘suspended’ and update its parent’s counter of ‘active’<br>      children as appropriate (it is only valid to use this function if<br>      ‘power.runtime_error’ is set or ‘power.disable_depth’ is greater than<br>      zero)</p>
<p>  bool pm_runtime_active(struct device *dev);<br>    - return true if the device’s runtime PM status is ‘active’ or its<br>      ‘power.disable_depth’ field is not equal to zero, or false otherwise</p>
<p>  bool pm_runtime_suspended(struct device *dev);<br>    - return true if the device’s runtime PM status is ‘suspended’ and its<br>      ‘power.disable_depth’ field is equal to zero, or false otherwise</p>
<p>  bool pm_runtime_status_suspended(struct device *dev);<br>    - return true if the device’s runtime PM status is ‘suspended’</p>
<p>  void pm_runtime_allow(struct device *dev);<br>    - set the power.runtime_auto flag for the device and decrease its usage<br>      counter (used by the /sys/devices/…/power/control interface to<br>      effectively allow the device to be power managed at run time)</p>
<p>  void pm_runtime_forbid(struct device *dev);<br>    - unset the power.runtime_auto flag for the device and increase its usage<br>      counter (used by the /sys/devices/…/power/control interface to<br>      effectively prevent the device from being power managed at run time)</p>
<p>  void pm_runtime_no_callbacks(struct device *dev);<br>    - set the power.no_callbacks flag for the device and remove the runtime<br>      PM attributes from /sys/devices/…/power (or prevent them from being<br>      added when the device is registered)</p>
<p>  void pm_runtime_irq_safe(struct device *dev);<br>    - set the power.irq_safe flag for the device, causing the runtime-PM<br>      callbacks to be invoked with interrupts off</p>
<p>  bool pm_runtime_is_irq_safe(struct device *dev);<br>    - return true if power.irq_safe flag was set for the device, causing<br>      the runtime-PM callbacks to be invoked with interrupts off</p>
<p>  void pm_runtime_mark_last_busy(struct device *dev);<br>    - set the power.last_busy field to the current time</p>
<p>  void pm_runtime_use_autosuspend(struct device *dev);<br>    - set the power.use_autosuspend flag, enabling autosuspend delays; call<br>      pm_runtime_get_sync if the flag was previously cleared and<br>      power.autosuspend_delay is negative</p>
<p>  void pm_runtime_dont_use_autosuspend(struct device *dev);<br>    - clear the power.use_autosuspend flag, disabling autosuspend delays;<br>      decrement the device’s usage counter if the flag was previously set and<br>      power.autosuspend_delay is negative; call pm_runtime_idle</p>
<p>  void pm_runtime_set_autosuspend_delay(struct device *dev, int delay);<br>    - set the power.autosuspend_delay value to ‘delay’ (expressed in<br>      milliseconds); if ‘delay’ is negative then runtime suspends are<br>      prevented; if power.use_autosuspend is set, pm_runtime_get_sync may be<br>      called or the device’s usage counter may be decremented and<br>      pm_runtime_idle called depending on if power.autosuspend_delay is<br>      changed to or from a negative value; if power.use_autosuspend is clear,<br>      pm_runtime_idle is called</p>
<p>  unsigned long pm_runtime_autosuspend_expiration(struct device *dev);<br>    - calculate the time when the current autosuspend delay period will expire,<br>      based on power.last_busy and power.autosuspend_delay; if the delay time<br>      is 1000 ms or larger then the expiration time is rounded up to the<br>      nearest second; returns 0 if the delay period has already expired or<br>      power.use_autosuspend isn’t set, otherwise returns the expiration time<br>      in jiffies</p>
<p>It is safe to execute the following helper functions from interrupt context:</p>
<p>pm_request_idle()<br>pm_request_autosuspend()<br>pm_schedule_suspend()<br>pm_request_resume()<br>pm_runtime_get_noresume()<br>pm_runtime_get()<br>pm_runtime_put_noidle()<br>pm_runtime_put()<br>pm_runtime_put_autosuspend()<br>pm_runtime_enable()<br>pm_suspend_ignore_children()<br>pm_runtime_set_active()<br>pm_runtime_set_suspended()<br>pm_runtime_suspended()<br>pm_runtime_mark_last_busy()<br>pm_runtime_autosuspend_expiration()</p>
<p>If pm_runtime_irq_safe() has been called for a device then the following helper<br>functions may also be used in interrupt context:</p>
<p>pm_runtime_idle()<br>pm_runtime_suspend()<br>pm_runtime_autosuspend()<br>pm_runtime_resume()<br>pm_runtime_get_sync()<br>pm_runtime_put_sync()<br>pm_runtime_put_sync_suspend()<br>pm_runtime_put_sync_autosuspend()</p>
<ol start="5">
<li>Runtime PM Initialization, Device Probing and Removal</li>
</ol>
<p>Initially, the runtime PM is disabled for all devices, which means that the<br>majority of the runtime PM helper functions described in Section 4 will return<br>-EAGAIN until pm_runtime_enable() is called for the device.</p>
<p>In addition to that, the initial runtime PM status of all devices is<br>‘suspended’, but it need not reflect the actual physical state of the device.<br>Thus, if the device is initially active (i.e. it is able to process I/O), its<br>runtime PM status must be changed to ‘active’, with the help of<br>pm_runtime_set_active(), before pm_runtime_enable() is called for the device.</p>
<p>However, if the device has a parent and the parent’s runtime PM is enabled,<br>calling pm_runtime_set_active() for the device will affect the parent, unless<br>the parent’s ‘power.ignore_children’ flag is set.  Namely, in that case the<br>parent won’t be able to suspend at run time, using the PM core’s helper<br>functions, as long as the child’s status is ‘active’, even if the child’s<br>runtime PM is still disabled (i.e. pm_runtime_enable() hasn’t been called for<br>the child yet or pm_runtime_disable() has been called for it).  For this reason,<br>once pm_runtime_set_active() has been called for the device, pm_runtime_enable()<br>should be called for it too as soon as reasonably possible or its runtime PM<br>status should be changed back to ‘suspended’ with the help of<br>pm_runtime_set_suspended().</p>
<p>If the default initial runtime PM status of the device (i.e. ‘suspended’)<br>reflects the actual state of the device, its bus type’s or its driver’s<br>-&gt;probe() callback will likely need to wake it up using one of the PM core’s<br>helper functions described in Section 4.  In that case, pm_runtime_resume()<br>should be used.  Of course, for this purpose the device’s runtime PM has to be<br>enabled earlier by calling pm_runtime_enable().</p>
<p>Note, if the device may execute pm_runtime calls during the probe (such as<br>if it is registers with a subsystem that may call back in) then the<br>pm_runtime_get_sync() call paired with a pm_runtime_put() call will be<br>appropriate to ensure that the device is not put back to sleep during the<br>probe. This can happen with systems such as the network device layer.</p>
<p>It may be desirable to suspend the device once -&gt;probe() has finished.<br>Therefore the driver core uses the asynchronous pm_request_idle() to submit a<br>request to execute the subsystem-level idle callback for the device at that<br>time.  A driver that makes use of the runtime autosuspend feature, may want to<br>update the last busy mark before returning from -&gt;probe().</p>
<p>Moreover, the driver core prevents runtime PM callbacks from racing with the bus<br>notifier callback in __device_release_driver(), which is necessary, because the<br>notifier is used by some subsystems to carry out operations affecting the<br>runtime PM functionality.  It does so by calling pm_runtime_get_sync() before<br>driver_sysfs_remove() and the BUS_NOTIFY_UNBIND_DRIVER notifications.  This<br>resumes the device if it’s in the suspended state and prevents it from<br>being suspended again while those routines are being executed.</p>
<p>To allow bus types and drivers to put devices into the suspended state by<br>calling pm_runtime_suspend() from their -&gt;remove() routines, the driver core<br>executes pm_runtime_put_sync() after running the BUS_NOTIFY_UNBIND_DRIVER<br>notifications in __device_release_driver().  This requires bus types and<br>drivers to make their -&gt;remove() callbacks avoid races with runtime PM directly,<br>but also it allows of more flexibility in the handling of devices during the<br>removal of their drivers.</p>
<p>Drivers in -&gt;remove() callback should undo the runtime PM changes done<br>in -&gt;probe(). Usually this means calling pm_runtime_disable(),<br>pm_runtime_dont_use_autosuspend() etc.</p>
<p>The user space can effectively disallow the driver of the device to power manage<br>it at run time by changing the value of its /sys/devices/…/power/control<br>attribute to “on”, which causes pm_runtime_forbid() to be called.  In principle,<br>this mechanism may also be used by the driver to effectively turn off the<br>runtime power management of the device until the user space turns it on.<br>Namely, during the initialization the driver can make sure that the runtime PM<br>status of the device is ‘active’ and call pm_runtime_forbid().  It should be<br>noted, however, that if the user space has already intentionally changed the<br>value of /sys/devices/…/power/control to “auto” to allow the driver to power<br>manage the device at run time, the driver may confuse it by using<br>pm_runtime_forbid() this way.</p>
<ol start="6">
<li>Runtime PM and System Sleep</li>
</ol>
<p>Runtime PM and system sleep (i.e., system suspend and hibernation, also known<br>as suspend-to-RAM and suspend-to-disk) interact with each other in a couple of<br>ways.  If a device is active when a system sleep starts, everything is<br>straightforward.  But what should happen if the device is already suspended?</p>
<p>The device may have different wake-up settings for runtime PM and system sleep.<br>For example, remote wake-up may be enabled for runtime suspend but disallowed<br>for system sleep (device_may_wakeup(dev) returns ‘false’).  When this happens,<br>the subsystem-level system suspend callback is responsible for changing the<br>device’s wake-up setting (it may leave that to the device driver’s system<br>suspend routine).  It may be necessary to resume the device and suspend it again<br>in order to do so.  The same is true if the driver uses different power levels<br>or other settings for runtime suspend and system sleep.</p>
<p>During system resume, the simplest approach is to bring all devices back to full<br>power, even if they had been suspended before the system suspend began.  There<br>are several reasons for this, including:</p>
<ul>
<li><p>The device might need to switch power levels, wake-up settings, etc.</p>
</li>
<li><p>Remote wake-up events might have been lost by the firmware.</p>
</li>
<li><p>The device’s children may need the device to be at full power in order<br>to resume themselves.</p>
</li>
<li><p>The driver’s idea of the device state may not agree with the device’s<br>physical state.  This can happen during resume from hibernation.</p>
</li>
<li><p>The device might need to be reset.</p>
</li>
<li><p>Even though the device was suspended, if its usage counter was &gt; 0 then most<br>likely it would need a runtime resume in the near future anyway.</p>
</li>
</ul>
<p>If the device had been suspended before the system suspend began and it’s<br>brought back to full power during resume, then its runtime PM status will have<br>to be updated to reflect the actual post-system sleep status.  The way to do<br>this is:</p>
<pre><code>pm_runtime_disable(dev);
pm_runtime_set_active(dev);
pm_runtime_enable(dev);
</code></pre>
<p>The PM core always increments the runtime usage counter before calling the<br>-&gt;suspend() callback and decrements it after calling the -&gt;resume() callback.<br>Hence disabling runtime PM temporarily like this will not cause any runtime<br>suspend attempts to be permanently lost.  If the usage count goes to zero<br>following the return of the -&gt;resume() callback, the -&gt;runtime_idle() callback<br>will be invoked as usual.</p>
<p>On some systems, however, system sleep is not entered through a global firmware<br>or hardware operation.  Instead, all hardware components are put into low-power<br>states directly by the kernel in a coordinated way.  Then, the system sleep<br>state effectively follows from the states the hardware components end up in<br>and the system is woken up from that state by a hardware interrupt or a similar<br>mechanism entirely under the kernel’s control.  As a result, the kernel never<br>gives control away and the states of all devices during resume are precisely<br>known to it.  If that is the case and none of the situations listed above takes<br>place (in particular, if the system is not waking up from hibernation), it may<br>be more efficient to leave the devices that had been suspended before the system<br>suspend began in the suspended state.</p>
<p>To this end, the PM core provides a mechanism allowing some coordination between<br>different levels of device hierarchy.  Namely, if a system suspend .prepare()<br>callback returns a positive number for a device, that indicates to the PM core<br>that the device appears to be runtime-suspended and its state is fine, so it<br>may be left in runtime suspend provided that all of its descendants are also<br>left in runtime suspend.  If that happens, the PM core will not execute any<br>system suspend and resume callbacks for all of those devices, except for the<br>complete callback, which is then entirely responsible for handling the device<br>as appropriate.  This only applies to system suspend transitions that are not<br>related to hibernation (see Documentation/driver-api/pm/devices.rst for more<br>information).</p>
<p>The PM core does its best to reduce the probability of race conditions between<br>the runtime PM and system suspend/resume (and hibernation) callbacks by carrying<br>out the following operations:</p>
<ul>
<li><p>During system suspend pm_runtime_get_noresume() is called for every device<br>right before executing the subsystem-level .prepare() callback for it and<br>pm_runtime_barrier() is called for every device right before executing the<br>subsystem-level .suspend() callback for it.  In addition to that the PM core<br>calls  __pm_runtime_disable() with ‘false’ as the second argument for every<br>device right before executing the subsystem-level .suspend_late() callback<br>for it.</p>
</li>
<li><p>During system resume pm_runtime_enable() and pm_runtime_put() are called for<br>every device right after executing the subsystem-level .resume_early()<br>callback and right after executing the subsystem-level .complete() callback<br>for it, respectively.</p>
</li>
</ul>
<ol start="7">
<li>Generic subsystem callbacks</li>
</ol>
<p>Subsystems may wish to conserve code space by using the set of generic power<br>management callbacks provided by the PM core, defined in<br>driver/base/power/generic_ops.c:</p>
<p>  int pm_generic_runtime_suspend(struct device *dev);<br>    - invoke the -&gt;runtime_suspend() callback provided by the driver of this<br>      device and return its result, or return 0 if not defined</p>
<p>  int pm_generic_runtime_resume(struct device *dev);<br>    - invoke the -&gt;runtime_resume() callback provided by the driver of this<br>      device and return its result, or return 0 if not defined</p>
<p>  int pm_generic_suspend(struct device *dev);<br>    - if the device has not been suspended at run time, invoke the -&gt;suspend()<br>      callback provided by its driver and return its result, or return 0 if not<br>      defined</p>
<p>  int pm_generic_suspend_noirq(struct device *dev);<br>    - if pm_runtime_suspended(dev) returns “false”, invoke the -&gt;suspend_noirq()<br>      callback provided by the device’s driver and return its result, or return<br>      0 if not defined</p>
<p>  int pm_generic_resume(struct device *dev);<br>    - invoke the -&gt;resume() callback provided by the driver of this device and,<br>      if successful, change the device’s runtime PM status to ‘active’</p>
<p>  int pm_generic_resume_noirq(struct device *dev);<br>    - invoke the -&gt;resume_noirq() callback provided by the driver of this device</p>
<p>  int pm_generic_freeze(struct device *dev);<br>    - if the device has not been suspended at run time, invoke the -&gt;freeze()<br>      callback provided by its driver and return its result, or return 0 if not<br>      defined</p>
<p>  int pm_generic_freeze_noirq(struct device *dev);<br>    - if pm_runtime_suspended(dev) returns “false”, invoke the -&gt;freeze_noirq()<br>      callback provided by the device’s driver and return its result, or return<br>      0 if not defined</p>
<p>  int pm_generic_thaw(struct device *dev);<br>    - if the device has not been suspended at run time, invoke the -&gt;thaw()<br>      callback provided by its driver and return its result, or return 0 if not<br>      defined</p>
<p>  int pm_generic_thaw_noirq(struct device *dev);<br>    - if pm_runtime_suspended(dev) returns “false”, invoke the -&gt;thaw_noirq()<br>      callback provided by the device’s driver and return its result, or return<br>      0 if not defined</p>
<p>  int pm_generic_poweroff(struct device *dev);<br>    - if the device has not been suspended at run time, invoke the -&gt;poweroff()<br>      callback provided by its driver and return its result, or return 0 if not<br>      defined</p>
<p>  int pm_generic_poweroff_noirq(struct device *dev);<br>    - if pm_runtime_suspended(dev) returns “false”, run the -&gt;poweroff_noirq()<br>      callback provided by the device’s driver and return its result, or return<br>      0 if not defined</p>
<p>  int pm_generic_restore(struct device *dev);<br>    - invoke the -&gt;restore() callback provided by the driver of this device and,<br>      if successful, change the device’s runtime PM status to ‘active’</p>
<p>  int pm_generic_restore_noirq(struct device *dev);<br>    - invoke the -&gt;restore_noirq() callback provided by the device’s driver</p>
<p>These functions are the defaults used by the PM core, if a subsystem doesn’t<br>provide its own callbacks for -&gt;runtime_idle(), -&gt;runtime_suspend(),<br>-&gt;runtime_resume(), -&gt;suspend(), -&gt;suspend_noirq(), -&gt;resume(),<br>-&gt;resume_noirq(), -&gt;freeze(), -&gt;freeze_noirq(), -&gt;thaw(), -&gt;thaw_noirq(),<br>-&gt;poweroff(), -&gt;poweroff_noirq(), -&gt;restore(), -&gt;restore_noirq() in the<br>subsystem-level dev_pm_ops structure.</p>
<p>Device drivers that wish to use the same function as a system suspend, freeze,<br>poweroff and runtime suspend callback, and similarly for system resume, thaw,<br>restore, and runtime resume, can achieve this with the help of the<br>UNIVERSAL_DEV_PM_OPS macro defined in include/linux/pm.h (possibly setting its<br>last argument to NULL).</p>
<ol start="8">
<li>“No-Callback” Devices</li>
</ol>
<p>Some “devices” are only logical sub-devices of their parent and cannot be<br>power-managed on their own.  (The prototype example is a USB interface.  Entire<br>USB devices can go into low-power mode or send wake-up requests, but neither is<br>possible for individual interfaces.)  The drivers for these devices have no<br>need of runtime PM callbacks; if the callbacks did exist, -&gt;runtime_suspend()<br>and -&gt;runtime_resume() would always return 0 without doing anything else and<br>-&gt;runtime_idle() would always call pm_runtime_suspend().</p>
<p>Subsystems can tell the PM core about these devices by calling<br>pm_runtime_no_callbacks().  This should be done after the device structure is<br>initialized and before it is registered (although after device registration is<br>also okay).  The routine will set the device’s power.no_callbacks flag and<br>prevent the non-debugging runtime PM sysfs attributes from being created.</p>
<p>When power.no_callbacks is set, the PM core will not invoke the<br>-&gt;runtime_idle(), -&gt;runtime_suspend(), or -&gt;runtime_resume() callbacks.<br>Instead it will assume that suspends and resumes always succeed and that idle<br>devices should be suspended.</p>
<p>As a consequence, the PM core will never directly inform the device’s subsystem<br>or driver about runtime power changes.  Instead, the driver for the device’s<br>parent must take responsibility for telling the device’s driver when the<br>parent’s power state changes.</p>
<ol start="9">
<li>Autosuspend, or automatically-delayed suspends</li>
</ol>
<p>Changing a device’s power state isn’t free; it requires both time and energy.<br>A device should be put in a low-power state only when there’s some reason to<br>think it will remain in that state for a substantial time.  A common heuristic<br>says that a device which hasn’t been used for a while is liable to remain<br>unused; following this advice, drivers should not allow devices to be suspended<br>at runtime until they have been inactive for some minimum period.  Even when<br>the heuristic ends up being non-optimal, it will still prevent devices from<br>“bouncing” too rapidly between low-power and full-power states.</p>
<p>The term “autosuspend” is an historical remnant.  It doesn’t mean that the<br>device is automatically suspended (the subsystem or driver still has to call<br>the appropriate PM routines); rather it means that runtime suspends will<br>automatically be delayed until the desired period of inactivity has elapsed.</p>
<p>Inactivity is determined based on the power.last_busy field.  Drivers should<br>call pm_runtime_mark_last_busy() to update this field after carrying out I/O,<br>typically just before calling pm_runtime_put_autosuspend().  The desired length<br>of the inactivity period is a matter of policy.  Subsystems can set this length<br>initially by calling pm_runtime_set_autosuspend_delay(), but after device<br>registration the length should be controlled by user space, using the<br>/sys/devices/…/power/autosuspend_delay_ms attribute.</p>
<p>In order to use autosuspend, subsystems or drivers must call<br>pm_runtime_use_autosuspend() (preferably before registering the device), and<br>thereafter they should use the various *_autosuspend() helper functions instead<br>of the non-autosuspend counterparts:</p>
<pre><code>Instead of: pm_runtime_suspend    use: pm_runtime_autosuspend;
Instead of: pm_schedule_suspend   use: pm_request_autosuspend;
Instead of: pm_runtime_put        use: pm_runtime_put_autosuspend;
Instead of: pm_runtime_put_sync   use: pm_runtime_put_sync_autosuspend.
</code></pre>
<p>Drivers may also continue to use the non-autosuspend helper functions; they<br>will behave normally, which means sometimes taking the autosuspend delay into<br>account (see pm_runtime_idle).</p>
<p>Under some circumstances a driver or subsystem may want to prevent a device<br>from autosuspending immediately, even though the usage counter is zero and the<br>autosuspend delay time has expired.  If the -&gt;runtime_suspend() callback<br>returns -EAGAIN or -EBUSY, and if the next autosuspend delay expiration time is<br>in the future (as it normally would be if the callback invoked<br>pm_runtime_mark_last_busy()), the PM core will automatically reschedule the<br>autosuspend.  The -&gt;runtime_suspend() callback can’t do this rescheduling<br>itself because no suspend requests of any kind are accepted while the device is<br>suspending (i.e., while the callback is running).</p>
<p>The implementation is well suited for asynchronous use in interrupt contexts.<br>However such use inevitably involves races, because the PM core can’t<br>synchronize -&gt;runtime_suspend() callbacks with the arrival of I/O requests.<br>This synchronization must be handled by the driver, using its private lock.<br>Here is a schematic pseudo-code example:</p>
<pre><code>foo_read_or_write(struct foo_priv *foo, void *data)
&#123;
    lock(&amp;foo-&gt;private_lock);
    add_request_to_io_queue(foo, data);
    if (foo-&gt;num_pending_requests++ == 0)
        pm_runtime_get(&amp;foo-&gt;dev);
    if (!foo-&gt;is_suspended)
        foo_process_next_request(foo);
    unlock(&amp;foo-&gt;private_lock);
&#125;

foo_io_completion(struct foo_priv *foo, void *req)
&#123;
    lock(&amp;foo-&gt;private_lock);
    if (--foo-&gt;num_pending_requests == 0) &#123;
        pm_runtime_mark_last_busy(&amp;foo-&gt;dev);
        pm_runtime_put_autosuspend(&amp;foo-&gt;dev);
    &#125; else &#123;
        foo_process_next_request(foo);
    &#125;
    unlock(&amp;foo-&gt;private_lock);
    /* Send req result back to the user ... */
&#125;

int foo_runtime_suspend(struct device *dev)
&#123;
    struct foo_priv foo = container_of(dev, ...);
    int ret = 0;

    lock(&amp;foo-&gt;private_lock);
    if (foo-&gt;num_pending_requests &gt; 0) &#123;
        ret = -EBUSY;
    &#125; else &#123;
        /* ... suspend the device ... */
        foo-&gt;is_suspended = 1;
    &#125;
    unlock(&amp;foo-&gt;private_lock);
    return ret;
&#125;

int foo_runtime_resume(struct device *dev)
&#123;
    struct foo_priv foo = container_of(dev, ...);

    lock(&amp;foo-&gt;private_lock);
    /* ... resume the device ... */
    foo-&gt;is_suspended = 0;
    pm_runtime_mark_last_busy(&amp;foo-&gt;dev);
    if (foo-&gt;num_pending_requests &gt; 0)
        foo_process_next_request(foo);
    unlock(&amp;foo-&gt;private_lock);
    return 0;
&#125;
</code></pre>
<p>The important point is that after foo_io_completion() asks for an autosuspend,<br>the foo_runtime_suspend() callback may race with foo_read_or_write().<br>Therefore foo_runtime_suspend() has to check whether there are any pending I/O<br>requests (while holding the private lock) before allowing the suspend to<br>proceed.</p>
<p>In addition, the power.autosuspend_delay field can be changed by user space at<br>any time.  If a driver cares about this, it can call<br>pm_runtime_autosuspend_expiration() from within the -&gt;runtime_suspend()<br>callback while holding its private lock.  If the function returns a nonzero<br>value then the delay has not yet expired and the callback should return<br>-EAGAIN.</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_runtime_pm/" title="Kernel-4.18.0-80.el8_runtime_p" target="_blank" rel="external">http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_runtime_pm/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/02/19/Kernel-4.18.0-80.el8_parport-lowlevel/" title="Kernel-4.18.0-80.el8_parport-lowlevel"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/02/19/Kernel-4.18.0-80.el8_rxrpc/" title="Kernel-4.18.0-80.el8_rxrpc"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>