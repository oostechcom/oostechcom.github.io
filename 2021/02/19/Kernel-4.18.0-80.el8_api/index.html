<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-4.18.0-80.el8_api | oosTech.com</title>
  <meta name="description" content="The Definitive KVM (Kernel-based Virtual Machine) API Documentation General description   The kvm API is a set of ioctls that are issued to control various aspectsof a virtual machine.  The ioctls bel">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-4.18.0-80.el8_api">
<meta property="og:url" content="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_api/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="The Definitive KVM (Kernel-based Virtual Machine) API Documentation General description   The kvm API is a set of ioctls that are issued to control various aspectsof a virtual machine.  The ioctls bel">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-18T16:00:00.000Z">
<meta property="article:modified_time" content="2021-02-18T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_api/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#The-Definitive-KVM-Kernel-based-Virtual-Machine-API-Documentation"><span class="toc-number">1.</span> <span class="toc-text">The Definitive KVM (Kernel-based Virtual Machine) API Documentation</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-4.18.0-80.el8_api" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-4.18.0-80.el8_api
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/02/19/Kernel-4.18.0-80.el8_api/" class="article-date">
	 published: <time datetime="2021-02-18T16:00:00.000Z" itemprop="datePublished">2021-02-19</time>
	</a>
</span>

        
	<a href="/2021/02/19/Kernel-4.18.0-80.el8_api/" class="article-date">
	   updated: <time datetime="2021-02-18T16:00:00.000Z" itemprop="dateUpdated">2021-02-19</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/02/19/Kernel-4.18.0-80.el8_api/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="The-Definitive-KVM-Kernel-based-Virtual-Machine-API-Documentation"><a href="#The-Definitive-KVM-Kernel-based-Virtual-Machine-API-Documentation" class="headerlink" title="The Definitive KVM (Kernel-based Virtual Machine) API Documentation"></a>The Definitive KVM (Kernel-based Virtual Machine) API Documentation</h1><ol>
<li>General description</li>
</ol>
<hr>
<p>The kvm API is a set of ioctls that are issued to control various aspects<br>of a virtual machine.  The ioctls belong to three classes</p>
<ul>
<li><p>System ioctls: These query and set global attributes which affect the<br>whole kvm subsystem.  In addition a system ioctl is used to create<br>virtual machines</p>
</li>
<li><p>VM ioctls: These query and set attributes that affect an entire virtual<br>machine, for example memory layout.  In addition a VM ioctl is used to<br>create virtual cpus (vcpus).</p>
<p>Only run VM ioctls from the same process (address space) that was used<br>to create the VM.</p>
</li>
<li><p>vcpu ioctls: These query and set attributes that control the operation<br>of a single virtual cpu.</p>
<p>Only run vcpu ioctls from the same thread that was used to create the<br>vcpu.</p>
</li>
</ul>
<ol start="2">
<li>File descriptors</li>
</ol>
<hr>
<p>The kvm API is centered around file descriptors.  An initial<br>open(“/dev/kvm”) obtains a handle to the kvm subsystem; this handle<br>can be used to issue system ioctls.  A KVM_CREATE_VM ioctl on this<br>handle will create a VM file descriptor which can be used to issue VM<br>ioctls.  A KVM_CREATE_VCPU ioctl on a VM fd will create a virtual cpu<br>and return a file descriptor pointing to it.  Finally, ioctls on a vcpu<br>fd can be used to control the vcpu, including the important task of<br>actually running guest code.</p>
<p>In general file descriptors can be migrated among processes by means<br>of fork() and the SCM_RIGHTS facility of unix domain socket.  These<br>kinds of tricks are explicitly not supported by kvm.  While they will<br>not cause harm to the host, their actual behavior is not guaranteed by<br>the API.  The only supported use is one virtual machine per process,<br>and one vcpu per thread.</p>
<ol start="3">
<li>Extensions</li>
</ol>
<hr>
<p>As of Linux 2.6.22, the KVM ABI has been stabilized: no backward<br>incompatible change are allowed.  However, there is an extension<br>facility that allows backward-compatible extensions to the API to be<br>queried and used.</p>
<p>The extension mechanism is not based on the Linux version number.<br>Instead, kvm defines extension identifiers and a facility to query<br>whether a particular extension identifier is available.  If it is, a<br>set of ioctls is available for application use.</p>
<ol start="4">
<li>API description</li>
</ol>
<hr>
<p>This section describes ioctls that can be used to control kvm guests.<br>For each ioctl, the following information is provided along with a<br>description:</p>
<p>  Capability: which KVM extension provides this ioctl.  Can be ‘basic’,<br>      which means that is will be provided by any kernel that supports<br>      API version 12 (see section 4.1), a KVM_CAP_xyz constant, which<br>      means availability needs to be checked with KVM_CHECK_EXTENSION<br>      (see section 4.4), or ‘none’ which means that while not all kernels<br>      support this ioctl, there’s no capability bit to check its<br>      availability: for kernels that don’t support the ioctl,<br>      the ioctl returns -ENOTTY.</p>
<p>  Architectures: which instruction set architectures provide this ioctl.<br>      x86 includes both i386 and x86_64.</p>
<p>  Type: system, vm, or vcpu.</p>
<p>  Parameters: what parameters are accepted by the ioctl.</p>
<p>  Returns: the return value.  General error numbers (EBADF, ENOMEM, EINVAL)<br>      are not detailed, but errors with specific meanings are.</p>
<p>4.1 KVM_GET_API_VERSION</p>
<p>Capability: basic<br>Architectures: all<br>Type: system ioctl<br>Parameters: none<br>Returns: the constant KVM_API_VERSION (=12)</p>
<p>This identifies the API version as the stable kvm API. It is not<br>expected that this number will change.  However, Linux 2.6.20 and<br>2.6.21 report earlier versions; these are not documented and not<br>supported.  Applications should refuse to run if KVM_GET_API_VERSION<br>returns a value other than 12.  If this check passes, all ioctls<br>described as ‘basic’ will be available.</p>
<p>4.2 KVM_CREATE_VM</p>
<p>Capability: basic<br>Architectures: all<br>Type: system ioctl<br>Parameters: machine type identifier (KVM_VM_*)<br>Returns: a VM fd that can be used to control the new virtual machine.</p>
<p>The new VM has no virtual cpus and no memory.<br>You probably want to use 0 as machine type.</p>
<p>In order to create user controlled virtual machines on S390, check<br>KVM_CAP_S390_UCONTROL and use the flag KVM_VM_S390_UCONTROL as<br>privileged user (CAP_SYS_ADMIN).</p>
<p>To use hardware assisted virtualization on MIPS (VZ ASE) rather than<br>the default trap &amp; emulate implementation (which changes the virtual<br>memory layout to fit in user mode), check KVM_CAP_MIPS_VZ and use the<br>flag KVM_VM_MIPS_VZ.</p>
<p>On arm64, the physical address size for a VM (IPA Size limit) is limited<br>to 40bits by default. The limit can be configured if the host supports the<br>extension KVM_CAP_ARM_VM_IPA_SIZE. When supported, use<br>KVM_VM_TYPE_ARM_IPA_SIZE(IPA_Bits) to set the size in the machine type<br>identifier, where IPA_Bits is the maximum width of any physical<br>address used by the VM. The IPA_Bits is encoded in bits[7-0] of the<br>machine type identifier.</p>
<p>e.g, to configure a guest to use 48bit physical address size :</p>
<pre><code>vm_fd = ioctl(dev_fd, KVM_CREATE_VM, KVM_VM_TYPE_ARM_IPA_SIZE(48));
</code></pre>
<p>The requested size (IPA_Bits) must be :<br>  0 - Implies default size, 40bits (for backward compatibility)</p>
<p>  or</p>
<p>  N - Implies N bits, where N is a positive integer such that,<br>      32 &lt;= N &lt;= Host_IPA_Limit</p>
<p>Host_IPA_Limit is the maximum possible value for IPA_Bits on the host and<br>is dependent on the CPU capability and the kernel configuration. The limit can<br>be retrieved using KVM_CAP_ARM_VM_IPA_SIZE of the KVM_CHECK_EXTENSION<br>ioctl() at run-time.</p>
<p>Please note that configuring the IPA size does not affect the capability<br>exposed by the guest CPUs in ID_AA64MMFR0_EL1[PARange]. It only affects<br>size of the address translated by the stage2 level (guest physical to<br>host physical address translations).</p>
<p>4.3 KVM_GET_MSR_INDEX_LIST, KVM_GET_MSR_FEATURE_INDEX_LIST</p>
<p>Capability: basic, KVM_CAP_GET_MSR_FEATURES for KVM_GET_MSR_FEATURE_INDEX_LIST<br>Architectures: x86<br>Type: system ioctl<br>Parameters: struct kvm_msr_list (in/out)<br>Returns: 0 on success; -1 on error<br>Errors:<br>  EFAULT:    the msr index list cannot be read from or written to<br>  E2BIG:     the msr index list is to be to fit in the array specified by<br>             the user.</p>
<p>struct kvm_msr_list {<br>    __u32 nmsrs; /* number of msrs in entries */<br>    __u32 indices[0];<br>};</p>
<p>The user fills in the size of the indices array in nmsrs, and in return<br>kvm adjusts nmsrs to reflect the actual number of msrs and fills in the<br>indices array with their numbers.</p>
<p>KVM_GET_MSR_INDEX_LIST returns the guest msrs that are supported.  The list<br>varies by kvm version and host processor, but does not change otherwise.</p>
<p>Note: if kvm indicates supports MCE (KVM_CAP_MCE), then the MCE bank MSRs are<br>not returned in the MSR list, as different vcpus can have a different number<br>of banks, as set via the KVM_X86_SETUP_MCE ioctl.</p>
<p>KVM_GET_MSR_FEATURE_INDEX_LIST returns the list of MSRs that can be passed<br>to the KVM_GET_MSRS system ioctl.  This lets userspace probe host capabilities<br>and processor features that are exposed via MSRs (e.g., VMX capabilities).<br>This list also varies by kvm version and host processor, but does not change<br>otherwise.</p>
<p>4.4 KVM_CHECK_EXTENSION</p>
<p>Capability: basic, KVM_CAP_CHECK_EXTENSION_VM for vm ioctl<br>Architectures: all<br>Type: system ioctl, vm ioctl<br>Parameters: extension identifier (KVM_CAP_*)<br>Returns: 0 if unsupported; 1 (or some other positive integer) if supported</p>
<p>The API allows the application to query about extensions to the core<br>kvm API.  Userspace passes an extension identifier (an integer) and<br>receives an integer that describes the extension availability.<br>Generally 0 means no and 1 means yes, but some extensions may report<br>additional information in the integer return value.</p>
<p>Based on their initialization different VMs may have different capabilities.<br>It is thus encouraged to use the vm ioctl to query for capabilities (available<br>with KVM_CAP_CHECK_EXTENSION_VM on the vm fd)</p>
<p>4.5 KVM_GET_VCPU_MMAP_SIZE</p>
<p>Capability: basic<br>Architectures: all<br>Type: system ioctl<br>Parameters: none<br>Returns: size of vcpu mmap area, in bytes</p>
<p>The KVM_RUN ioctl (cf.) communicates with userspace via a shared<br>memory region.  This ioctl returns the size of that region.  See the<br>KVM_RUN documentation for details.</p>
<p>4.6 KVM_SET_MEMORY_REGION</p>
<p>Capability: basic<br>Architectures: all<br>Type: vm ioctl<br>Parameters: struct kvm_memory_region (in)<br>Returns: 0 on success, -1 on error</p>
<p>This ioctl is obsolete and has been removed.</p>
<p>4.7 KVM_CREATE_VCPU</p>
<p>Capability: basic<br>Architectures: all<br>Type: vm ioctl<br>Parameters: vcpu id (apic id on x86)<br>Returns: vcpu fd on success, -1 on error</p>
<p>This API adds a vcpu to a virtual machine. No more than max_vcpus may be added.<br>The vcpu id is an integer in the range [0, max_vcpu_id).</p>
<p>The recommended max_vcpus value can be retrieved using the KVM_CAP_NR_VCPUS of<br>the KVM_CHECK_EXTENSION ioctl() at run-time.<br>The maximum possible value for max_vcpus can be retrieved using the<br>KVM_CAP_MAX_VCPUS of the KVM_CHECK_EXTENSION ioctl() at run-time.</p>
<p>If the KVM_CAP_NR_VCPUS does not exist, you should assume that max_vcpus is 4<br>cpus max.<br>If the KVM_CAP_MAX_VCPUS does not exist, you should assume that max_vcpus is<br>same as the value returned from KVM_CAP_NR_VCPUS.</p>
<p>The maximum possible value for max_vcpu_id can be retrieved using the<br>KVM_CAP_MAX_VCPU_ID of the KVM_CHECK_EXTENSION ioctl() at run-time.</p>
<p>If the KVM_CAP_MAX_VCPU_ID does not exist, you should assume that max_vcpu_id<br>is the same as the value returned from KVM_CAP_MAX_VCPUS.</p>
<p>On powerpc using book3s_hv mode, the vcpus are mapped onto virtual<br>threads in one or more virtual CPU cores.  (This is because the<br>hardware requires all the hardware threads in a CPU core to be in the<br>same partition.)  The KVM_CAP_PPC_SMT capability indicates the number<br>of vcpus per virtual core (vcore).  The vcore id is obtained by<br>dividing the vcpu id by the number of vcpus per vcore.  The vcpus in a<br>given vcore will always be in the same physical core as each other<br>(though that might be a different physical core from time to time).<br>Userspace can control the threading (SMT) mode of the guest by its<br>allocation of vcpu ids.  For example, if userspace wants<br>single-threaded guest vcpus, it should make all vcpu ids be a multiple<br>of the number of vcpus per vcore.</p>
<p>For virtual cpus that have been created with S390 user controlled virtual<br>machines, the resulting vcpu fd can be memory mapped at page offset<br>KVM_S390_SIE_PAGE_OFFSET in order to obtain a memory map of the virtual<br>cpu’s hardware control block.</p>
<p>4.8 KVM_GET_DIRTY_LOG (vm ioctl)</p>
<p>Capability: basic<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_dirty_log (in/out)<br>Returns: 0 on success, -1 on error</p>
<p>/* for KVM_GET_DIRTY_LOG */<br>struct kvm_dirty_log {<br>    __u32 slot;<br>    __u32 padding;<br>    union {<br>        void __user <em>dirty_bitmap; /</em> one bit per page */<br>        __u64 padding;<br>    };<br>};</p>
<p>Given a memory slot, return a bitmap containing any pages dirtied<br>since the last call to this ioctl.  Bit 0 is the first page in the<br>memory slot.  Ensure the entire structure is cleared to avoid padding<br>issues.</p>
<p>If KVM_CAP_MULTI_ADDRESS_SPACE is available, bits 16-31 specifies<br>the address space for which you want to return the dirty bitmap.<br>They must be less than the value that KVM_CHECK_EXTENSION returns for<br>the KVM_CAP_MULTI_ADDRESS_SPACE capability.</p>
<p>4.9 KVM_SET_MEMORY_ALIAS</p>
<p>Capability: basic<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_memory_alias (in)<br>Returns: 0 (success), -1 (error)</p>
<p>This ioctl is obsolete and has been removed.</p>
<p>4.10 KVM_RUN</p>
<p>Capability: basic<br>Architectures: all<br>Type: vcpu ioctl<br>Parameters: none<br>Returns: 0 on success, -1 on error<br>Errors:<br>  EINTR:     an unmasked signal is pending</p>
<p>This ioctl is used to run a guest virtual cpu.  While there are no<br>explicit parameters, there is an implicit parameter block that can be<br>obtained by mmap()ing the vcpu fd at offset 0, with the size given by<br>KVM_GET_VCPU_MMAP_SIZE.  The parameter block is formatted as a ‘struct<br>kvm_run’ (see below).</p>
<p>4.11 KVM_GET_REGS</p>
<p>Capability: basic<br>Architectures: all except ARM, arm64<br>Type: vcpu ioctl<br>Parameters: struct kvm_regs (out)<br>Returns: 0 on success, -1 on error</p>
<p>Reads the general purpose registers from the vcpu.</p>
<p>/* x86 <em>/<br>struct kvm_regs {<br>    /</em> out (KVM_GET_REGS) / in (KVM_SET_REGS) */<br>    __u64 rax, rbx, rcx, rdx;<br>    __u64 rsi, rdi, rsp, rbp;<br>    __u64 r8,  r9,  r10, r11;<br>    __u64 r12, r13, r14, r15;<br>    __u64 rip, rflags;<br>};</p>
<p>/* mips <em>/<br>struct kvm_regs {<br>    /</em> out (KVM_GET_REGS) / in (KVM_SET_REGS) */<br>    __u64 gpr[32];<br>    __u64 hi;<br>    __u64 lo;<br>    __u64 pc;<br>};</p>
<p>4.12 KVM_SET_REGS</p>
<p>Capability: basic<br>Architectures: all except ARM, arm64<br>Type: vcpu ioctl<br>Parameters: struct kvm_regs (in)<br>Returns: 0 on success, -1 on error</p>
<p>Writes the general purpose registers into the vcpu.</p>
<p>See KVM_GET_REGS for the data structure.</p>
<p>4.13 KVM_GET_SREGS</p>
<p>Capability: basic<br>Architectures: x86, ppc<br>Type: vcpu ioctl<br>Parameters: struct kvm_sregs (out)<br>Returns: 0 on success, -1 on error</p>
<p>Reads special registers from the vcpu.</p>
<p>/* x86 */<br>struct kvm_sregs {<br>    struct kvm_segment cs, ds, es, fs, gs, ss;<br>    struct kvm_segment tr, ldt;<br>    struct kvm_dtable gdt, idt;<br>    __u64 cr0, cr2, cr3, cr4, cr8;<br>    __u64 efer;<br>    __u64 apic_base;<br>    __u64 interrupt_bitmap[(KVM_NR_INTERRUPTS + 63) / 64];<br>};</p>
<p>/* ppc – see arch/powerpc/include/uapi/asm/kvm.h */</p>
<p>interrupt_bitmap is a bitmap of pending external interrupts.  At most<br>one bit may be set.  This interrupt has been acknowledged by the APIC<br>but not yet injected into the cpu core.</p>
<p>4.14 KVM_SET_SREGS</p>
<p>Capability: basic<br>Architectures: x86, ppc<br>Type: vcpu ioctl<br>Parameters: struct kvm_sregs (in)<br>Returns: 0 on success, -1 on error</p>
<p>Writes special registers into the vcpu.  See KVM_GET_SREGS for the<br>data structures.</p>
<p>4.15 KVM_TRANSLATE</p>
<p>Capability: basic<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_translation (in/out)<br>Returns: 0 on success, -1 on error</p>
<p>Translates a virtual address according to the vcpu’s current address<br>translation mode.</p>
<p>struct kvm_translation {<br>    /* in */<br>    __u64 linear_address;</p>
<pre><code>/* out */
__u64 physical_address;
__u8  valid;
__u8  writeable;
__u8  usermode;
__u8  pad[5];
</code></pre>
<p>};</p>
<p>4.16 KVM_INTERRUPT</p>
<p>Capability: basic<br>Architectures: x86, ppc, mips<br>Type: vcpu ioctl<br>Parameters: struct kvm_interrupt (in)<br>Returns: 0 on success, negative on failure.</p>
<p>Queues a hardware interrupt vector to be injected.</p>
<p>/* for KVM_INTERRUPT <em>/<br>struct kvm_interrupt {<br>    /</em> in */<br>    __u32 irq;<br>};</p>
<p>X86:</p>
<p>Returns: 0 on success,<br>     -EEXIST if an interrupt is already enqueued<br>     -EINVAL the the irq number is invalid<br>     -ENXIO if the PIC is in the kernel<br>     -EFAULT if the pointer is invalid</p>
<p>Note ‘irq’ is an interrupt vector, not an interrupt pin or line. This<br>ioctl is useful if the in-kernel PIC is not used.</p>
<p>PPC:</p>
<p>Queues an external interrupt to be injected. This ioctl is overleaded<br>with 3 different irq values:</p>
<p>a) KVM_INTERRUPT_SET</p>
<p>  This injects an edge type external interrupt into the guest once it’s ready<br>  to receive interrupts. When injected, the interrupt is done.</p>
<p>b) KVM_INTERRUPT_UNSET</p>
<p>  This unsets any pending interrupt.</p>
<p>  Only available with KVM_CAP_PPC_UNSET_IRQ.</p>
<p>c) KVM_INTERRUPT_SET_LEVEL</p>
<p>  This injects a level type external interrupt into the guest context. The<br>  interrupt stays pending until a specific ioctl with KVM_INTERRUPT_UNSET<br>  is triggered.</p>
<p>  Only available with KVM_CAP_PPC_IRQ_LEVEL.</p>
<p>Note that any value for ‘irq’ other than the ones stated above is invalid<br>and incurs unexpected behavior.</p>
<p>MIPS:</p>
<p>Queues an external interrupt to be injected into the virtual CPU. A negative<br>interrupt number dequeues the interrupt.</p>
<p>4.17 KVM_DEBUG_GUEST</p>
<p>Capability: basic<br>Architectures: none<br>Type: vcpu ioctl<br>Parameters: none)<br>Returns: -1 on error</p>
<p>Support for this has been removed.  Use KVM_SET_GUEST_DEBUG instead.</p>
<p>4.18 KVM_GET_MSRS</p>
<p>Capability: basic (vcpu), KVM_CAP_GET_MSR_FEATURES (system)<br>Architectures: x86<br>Type: system ioctl, vcpu ioctl<br>Parameters: struct kvm_msrs (in/out)<br>Returns: number of msrs successfully returned;<br>        -1 on error</p>
<p>When used as a system ioctl:<br>Reads the values of MSR-based features that are available for the VM.  This<br>is similar to KVM_GET_SUPPORTED_CPUID, but it returns MSR indices and values.<br>The list of msr-based features can be obtained using KVM_GET_MSR_FEATURE_INDEX_LIST<br>in a system ioctl.</p>
<p>When used as a vcpu ioctl:<br>Reads model-specific registers from the vcpu.  Supported msr indices can<br>be obtained using KVM_GET_MSR_INDEX_LIST in a system ioctl.</p>
<p>struct kvm_msrs {<br>    __u32 nmsrs; /* number of msrs in entries */<br>    __u32 pad;</p>
<pre><code>struct kvm_msr_entry entries[0];
</code></pre>
<p>};</p>
<p>struct kvm_msr_entry {<br>    __u32 index;<br>    __u32 reserved;<br>    __u64 data;<br>};</p>
<p>Application code should set the ‘nmsrs’ member (which indicates the<br>size of the entries array) and the ‘index’ member of each array entry.<br>kvm will fill in the ‘data’ member.</p>
<p>4.19 KVM_SET_MSRS</p>
<p>Capability: basic<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_msrs (in)<br>Returns: 0 on success, -1 on error</p>
<p>Writes model-specific registers to the vcpu.  See KVM_GET_MSRS for the<br>data structures.</p>
<p>Application code should set the ‘nmsrs’ member (which indicates the<br>size of the entries array), and the ‘index’ and ‘data’ members of each<br>array entry.</p>
<p>4.20 KVM_SET_CPUID</p>
<p>Capability: basic<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_cpuid (in)<br>Returns: 0 on success, -1 on error</p>
<p>Defines the vcpu responses to the cpuid instruction.  Applications<br>should use the KVM_SET_CPUID2 ioctl if available.</p>
<p>struct kvm_cpuid_entry {<br>    __u32 function;<br>    __u32 eax;<br>    __u32 ebx;<br>    __u32 ecx;<br>    __u32 edx;<br>    __u32 padding;<br>};</p>
<p>/* for KVM_SET_CPUID */<br>struct kvm_cpuid {<br>    __u32 nent;<br>    __u32 padding;<br>    struct kvm_cpuid_entry entries[0];<br>};</p>
<p>4.21 KVM_SET_SIGNAL_MASK</p>
<p>Capability: basic<br>Architectures: all<br>Type: vcpu ioctl<br>Parameters: struct kvm_signal_mask (in)<br>Returns: 0 on success, -1 on error</p>
<p>Defines which signals are blocked during execution of KVM_RUN.  This<br>signal mask temporarily overrides the threads signal mask.  Any<br>unblocked signal received (except SIGKILL and SIGSTOP, which retain<br>their traditional behaviour) will cause KVM_RUN to return with -EINTR.</p>
<p>Note the signal will only be delivered if not blocked by the original<br>signal mask.</p>
<p>/* for KVM_SET_SIGNAL_MASK */<br>struct kvm_signal_mask {<br>    __u32 len;<br>    __u8  sigset[0];<br>};</p>
<p>4.22 KVM_GET_FPU</p>
<p>Capability: basic<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_fpu (out)<br>Returns: 0 on success, -1 on error</p>
<p>Reads the floating point state from the vcpu.</p>
<p>/* for KVM_GET_FPU and KVM_SET_FPU <em>/<br>struct kvm_fpu {<br>    __u8  fpr[8][16];<br>    __u16 fcw;<br>    __u16 fsw;<br>    __u8  ftwx;  /</em> in fxsave format */<br>    __u8  pad1;<br>    __u16 last_opcode;<br>    __u64 last_ip;<br>    __u64 last_dp;<br>    __u8  xmm[16][16];<br>    __u32 mxcsr;<br>    __u32 pad2;<br>};</p>
<p>4.23 KVM_SET_FPU</p>
<p>Capability: basic<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_fpu (in)<br>Returns: 0 on success, -1 on error</p>
<p>Writes the floating point state to the vcpu.</p>
<p>/* for KVM_GET_FPU and KVM_SET_FPU <em>/<br>struct kvm_fpu {<br>    __u8  fpr[8][16];<br>    __u16 fcw;<br>    __u16 fsw;<br>    __u8  ftwx;  /</em> in fxsave format */<br>    __u8  pad1;<br>    __u16 last_opcode;<br>    __u64 last_ip;<br>    __u64 last_dp;<br>    __u8  xmm[16][16];<br>    __u32 mxcsr;<br>    __u32 pad2;<br>};</p>
<p>4.24 KVM_CREATE_IRQCHIP</p>
<p>Capability: KVM_CAP_IRQCHIP, KVM_CAP_S390_IRQCHIP (s390)<br>Architectures: x86, ARM, arm64, s390<br>Type: vm ioctl<br>Parameters: none<br>Returns: 0 on success, -1 on error</p>
<p>Creates an interrupt controller model in the kernel.<br>On x86, creates a virtual ioapic, a virtual PIC (two PICs, nested), and sets up<br>future vcpus to have a local APIC.  IRQ routing for GSIs 0-15 is set to both<br>PIC and IOAPIC; GSI 16-23 only go to the IOAPIC.<br>On ARM/arm64, a GICv2 is created. Any other GIC versions require the usage of<br>KVM_CREATE_DEVICE, which also supports creating a GICv2.  Using<br>KVM_CREATE_DEVICE is preferred over KVM_CREATE_IRQCHIP for GICv2.<br>On s390, a dummy irq routing table is created.</p>
<p>Note that on s390 the KVM_CAP_S390_IRQCHIP vm capability needs to be enabled<br>before KVM_CREATE_IRQCHIP can be used.</p>
<p>4.25 KVM_IRQ_LINE</p>
<p>Capability: KVM_CAP_IRQCHIP<br>Architectures: x86, arm, arm64<br>Type: vm ioctl<br>Parameters: struct kvm_irq_level<br>Returns: 0 on success, -1 on error</p>
<p>Sets the level of a GSI input to the interrupt controller model in the kernel.<br>On some architectures it is required that an interrupt controller model has<br>been previously created with KVM_CREATE_IRQCHIP.  Note that edge-triggered<br>interrupts require the level to be set to 1 and then back to 0.</p>
<p>On real hardware, interrupt pins can be active-low or active-high.  This<br>does not matter for the level field of struct kvm_irq_level: 1 always<br>means active (asserted), 0 means inactive (deasserted).</p>
<p>x86 allows the operating system to program the interrupt polarity<br>(active-low/active-high) for level-triggered interrupts, and KVM used<br>to consider the polarity.  However, due to bitrot in the handling of<br>active-low interrupts, the above convention is now valid on x86 too.<br>This is signaled by KVM_CAP_X86_IOAPIC_POLARITY_IGNORED.  Userspace<br>should not present interrupts to the guest as active-low unless this<br>capability is present (or unless it is not using the in-kernel irqchip,<br>of course).</p>
<p>ARM/arm64 can signal an interrupt either at the CPU level, or at the<br>in-kernel irqchip (GIC), and for in-kernel irqchip can tell the GIC to<br>use PPIs designated for specific cpus.  The irq field is interpreted<br>like this:</p>
<p> Â bits:  | 31 … 24 | 23  … 16 | 15    …    0 |<br>  field: | irq_type  | vcpu_index |     irq_id     |</p>
<p>The irq_type field has the following values:</p>
<ul>
<li>irq_type[0]: out-of-kernel GIC: irq_id 0 is IRQ, irq_id 1 is FIQ</li>
<li>irq_type[1]: in-kernel GIC: SPI, irq_id between 32 and 1019 (incl.)<pre><code>         (the vcpu_index field is ignored)
</code></pre>
</li>
<li>irq_type[2]: in-kernel GIC: PPI, irq_id between 16 and 31 (incl.)</li>
</ul>
<p>(The irq_id field thus corresponds nicely to the IRQ ID in the ARM GIC specs)</p>
<p>In both cases, level is used to assert/deassert the line.</p>
<p>struct kvm_irq_level {<br>    union {<br>        __u32 irq;     /* GSI <em>/<br>        __s32 status;  /</em> not used for KVM_IRQ_LEVEL <em>/<br>    };<br>    __u32 level;           /</em> 0 or 1 */<br>};</p>
<p>4.26 KVM_GET_IRQCHIP</p>
<p>Capability: KVM_CAP_IRQCHIP<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_irqchip (in/out)<br>Returns: 0 on success, -1 on error</p>
<p>Reads the state of a kernel interrupt controller created with<br>KVM_CREATE_IRQCHIP into a buffer provided by the caller.</p>
<p>struct kvm_irqchip {<br>    __u32 chip_id;  /* 0 = PIC1, 1 = PIC2, 2 = IOAPIC <em>/<br>    __u32 pad;<br>        union {<br>        char dummy[512];  /</em> reserving space */<br>        struct kvm_pic_state pic;<br>        struct kvm_ioapic_state ioapic;<br>    } chip;<br>};</p>
<p>4.27 KVM_SET_IRQCHIP</p>
<p>Capability: KVM_CAP_IRQCHIP<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_irqchip (in)<br>Returns: 0 on success, -1 on error</p>
<p>Sets the state of a kernel interrupt controller created with<br>KVM_CREATE_IRQCHIP from a buffer provided by the caller.</p>
<p>struct kvm_irqchip {<br>    __u32 chip_id;  /* 0 = PIC1, 1 = PIC2, 2 = IOAPIC <em>/<br>    __u32 pad;<br>        union {<br>        char dummy[512];  /</em> reserving space */<br>        struct kvm_pic_state pic;<br>        struct kvm_ioapic_state ioapic;<br>    } chip;<br>};</p>
<p>4.28 KVM_XEN_HVM_CONFIG</p>
<p>Capability: KVM_CAP_XEN_HVM<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_xen_hvm_config (in)<br>Returns: 0 on success, -1 on error</p>
<p>Sets the MSR that the Xen HVM guest uses to initialize its hypercall<br>page, and provides the starting address and size of the hypercall<br>blobs in userspace.  When the guest writes the MSR, kvm copies one<br>page of a blob (32- or 64-bit, depending on the vcpu mode) to guest<br>memory.</p>
<p>struct kvm_xen_hvm_config {<br>    __u32 flags;<br>    __u32 msr;<br>    __u64 blob_addr_32;<br>    __u64 blob_addr_64;<br>    __u8 blob_size_32;<br>    __u8 blob_size_64;<br>    __u8 pad2[30];<br>};</p>
<p>4.29 KVM_GET_CLOCK</p>
<p>Capability: KVM_CAP_ADJUST_CLOCK<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_clock_data (out)<br>Returns: 0 on success, -1 on error</p>
<p>Gets the current timestamp of kvmclock as seen by the current guest. In<br>conjunction with KVM_SET_CLOCK, it is used to ensure monotonicity on scenarios<br>such as migration.</p>
<p>When KVM_CAP_ADJUST_CLOCK is passed to KVM_CHECK_EXTENSION, it returns the<br>set of bits that KVM can return in struct kvm_clock_data’s flag member.</p>
<p>The only flag defined now is KVM_CLOCK_TSC_STABLE.  If set, the returned<br>value is the exact kvmclock value seen by all VCPUs at the instant<br>when KVM_GET_CLOCK was called.  If clear, the returned value is simply<br>CLOCK_MONOTONIC plus a constant offset; the offset can be modified<br>with KVM_SET_CLOCK.  KVM will try to make all VCPUs follow this clock,<br>but the exact value read by each VCPU could differ, because the host<br>TSC is not stable.</p>
<p>struct kvm_clock_data {<br>    __u64 clock;  /* kvmclock current value */<br>    __u32 flags;<br>    __u32 pad[9];<br>};</p>
<p>4.30 KVM_SET_CLOCK</p>
<p>Capability: KVM_CAP_ADJUST_CLOCK<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_clock_data (in)<br>Returns: 0 on success, -1 on error</p>
<p>Sets the current timestamp of kvmclock to the value specified in its parameter.<br>In conjunction with KVM_GET_CLOCK, it is used to ensure monotonicity on scenarios<br>such as migration.</p>
<p>struct kvm_clock_data {<br>    __u64 clock;  /* kvmclock current value */<br>    __u32 flags;<br>    __u32 pad[9];<br>};</p>
<p>4.31 KVM_GET_VCPU_EVENTS</p>
<p>Capability: KVM_CAP_VCPU_EVENTS<br>Extended by: KVM_CAP_INTR_SHADOW<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_vcpu_event (out)<br>Returns: 0 on success, -1 on error</p>
<p>Gets currently pending exceptions, interrupts, and NMIs as well as related<br>states of the vcpu.</p>
<p>struct kvm_vcpu_events {<br>    struct {<br>        __u8 injected;<br>        __u8 nr;<br>        __u8 has_error_code;<br>        __u8 pad;<br>        __u32 error_code;<br>    } exception;<br>    struct {<br>        __u8 injected;<br>        __u8 nr;<br>        __u8 soft;<br>        __u8 shadow;<br>    } interrupt;<br>    struct {<br>        __u8 injected;<br>        __u8 pending;<br>        __u8 masked;<br>        __u8 pad;<br>    } nmi;<br>    __u32 sipi_vector;<br>    __u32 flags;<br>    struct {<br>        __u8 smm;<br>        __u8 pending;<br>        __u8 smm_inside_nmi;<br>        __u8 latched_init;<br>    } smi;<br>};</p>
<p>Only two fields are defined in the flags field:</p>
<ul>
<li><p>KVM_VCPUEVENT_VALID_SHADOW may be set in the flags field to signal that<br>interrupt.shadow contains a valid state.</p>
</li>
<li><p>KVM_VCPUEVENT_VALID_SMM may be set in the flags field to signal that<br>smi contains a valid state.</p>
</li>
</ul>
<p>4.32 KVM_SET_VCPU_EVENTS</p>
<p>Capability: KVM_CAP_VCPU_EVENTS<br>Extended by: KVM_CAP_INTR_SHADOW<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_vcpu_event (in)<br>Returns: 0 on success, -1 on error</p>
<p>Set pending exceptions, interrupts, and NMIs as well as related states of the<br>vcpu.</p>
<p>See KVM_GET_VCPU_EVENTS for the data structure.</p>
<p>Fields that may be modified asynchronously by running VCPUs can be excluded<br>from the update. These fields are nmi.pending, sipi_vector, smi.smm,<br>smi.pending. Keep the corresponding bits in the flags field cleared to<br>suppress overwriting the current in-kernel state. The bits are:</p>
<p>KVM_VCPUEVENT_VALID_NMI_PENDING - transfer nmi.pending to the kernel<br>KVM_VCPUEVENT_VALID_SIPI_VECTOR - transfer sipi_vector<br>KVM_VCPUEVENT_VALID_SMM         - transfer the smi sub-struct.</p>
<p>If KVM_CAP_INTR_SHADOW is available, KVM_VCPUEVENT_VALID_SHADOW can be set in<br>the flags field to signal that interrupt.shadow contains a valid state and<br>shall be written into the VCPU.</p>
<p>KVM_VCPUEVENT_VALID_SMM can only be set if KVM_CAP_X86_SMM is available.</p>
<p>4.33 KVM_GET_DEBUGREGS</p>
<p>Capability: KVM_CAP_DEBUGREGS<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_debugregs (out)<br>Returns: 0 on success, -1 on error</p>
<p>Reads debug registers from the vcpu.</p>
<p>struct kvm_debugregs {<br>    __u64 db[4];<br>    __u64 dr6;<br>    __u64 dr7;<br>    __u64 flags;<br>    __u64 reserved[9];<br>};</p>
<p>4.34 KVM_SET_DEBUGREGS</p>
<p>Capability: KVM_CAP_DEBUGREGS<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_debugregs (in)<br>Returns: 0 on success, -1 on error</p>
<p>Writes debug registers into the vcpu.</p>
<p>See KVM_GET_DEBUGREGS for the data structure. The flags field is unused<br>yet and must be cleared on entry.</p>
<p>4.35 KVM_SET_USER_MEMORY_REGION</p>
<p>Capability: KVM_CAP_USER_MEM<br>Architectures: all<br>Type: vm ioctl<br>Parameters: struct kvm_userspace_memory_region (in)<br>Returns: 0 on success, -1 on error</p>
<p>struct kvm_userspace_memory_region {<br>    __u32 slot;<br>    __u32 flags;<br>    __u64 guest_phys_addr;<br>    __u64 memory_size; /* bytes <em>/<br>    __u64 userspace_addr; /</em> start of the userspace allocated memory */<br>};</p>
<p>/* for kvm_memory_region::flags */<br>#define KVM_MEM_LOG_DIRTY_PAGES    (1UL &lt;&lt; 0)<br>#define KVM_MEM_READONLY    (1UL &lt;&lt; 1)</p>
<p>This ioctl allows the user to create or modify a guest physical memory<br>slot.  When changing an existing slot, it may be moved in the guest<br>physical memory space, or its flags may be modified.  It may not be<br>resized.  Slots may not overlap in guest physical address space.<br>Bits 0-15 of “slot” specifies the slot id and this value should be<br>less than the maximum number of user memory slots supported per VM.<br>The maximum allowed slots can be queried using KVM_CAP_NR_MEMSLOTS,<br>if this capability is supported by the architecture.</p>
<p>If KVM_CAP_MULTI_ADDRESS_SPACE is available, bits 16-31 of “slot”<br>specifies the address space which is being modified.  They must be<br>less than the value that KVM_CHECK_EXTENSION returns for the<br>KVM_CAP_MULTI_ADDRESS_SPACE capability.  Slots in separate address spaces<br>are unrelated; the restriction on overlapping slots only applies within<br>each address space.</p>
<p>Memory for the region is taken starting at the address denoted by the<br>field userspace_addr, which must point at user addressable memory for<br>the entire memory slot size.  Any object may back this memory, including<br>anonymous memory, ordinary files, and hugetlbfs.</p>
<p>It is recommended that the lower 21 bits of guest_phys_addr and userspace_addr<br>be identical.  This allows large pages in the guest to be backed by large<br>pages in the host.</p>
<p>The flags field supports two flags: KVM_MEM_LOG_DIRTY_PAGES and<br>KVM_MEM_READONLY.  The former can be set to instruct KVM to keep track of<br>writes to memory within the slot.  See KVM_GET_DIRTY_LOG ioctl to know how to<br>use it.  The latter can be set, if KVM_CAP_READONLY_MEM capability allows it,<br>to make a new slot read-only.  In this case, writes to this memory will be<br>posted to userspace as KVM_EXIT_MMIO exits.</p>
<p>When the KVM_CAP_SYNC_MMU capability is available, changes in the backing of<br>the memory region are automatically reflected into the guest.  For example, an<br>mmap() that affects the region will be made visible immediately.  Another<br>example is madvise(MADV_DROP).</p>
<p>It is recommended to use this API instead of the KVM_SET_MEMORY_REGION ioctl.<br>The KVM_SET_MEMORY_REGION does not allow fine grained control over memory<br>allocation and is deprecated.</p>
<p>4.36 KVM_SET_TSS_ADDR</p>
<p>Capability: KVM_CAP_SET_TSS_ADDR<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: unsigned long tss_address (in)<br>Returns: 0 on success, -1 on error</p>
<p>This ioctl defines the physical address of a three-page region in the guest<br>physical address space.  The region must be within the first 4GB of the<br>guest physical address space and must not conflict with any memory slot<br>or any mmio address.  The guest may malfunction if it accesses this memory<br>region.</p>
<p>This ioctl is required on Intel-based hosts.  This is needed on Intel hardware<br>because of a quirk in the virtualization implementation (see the internals<br>documentation when it pops into existence).</p>
<p>4.37 KVM_ENABLE_CAP</p>
<p>Capability: KVM_CAP_ENABLE_CAP, KVM_CAP_ENABLE_CAP_VM<br>Architectures: x86 (only KVM_CAP_ENABLE_CAP_VM),<br>           mips (only KVM_CAP_ENABLE_CAP), ppc, s390<br>Type: vcpu ioctl, vm ioctl (with KVM_CAP_ENABLE_CAP_VM)<br>Parameters: struct kvm_enable_cap (in)<br>Returns: 0 on success; -1 on error</p>
<p>+Not all extensions are enabled by default. Using this ioctl the application<br>can enable an extension, making it available to the guest.</p>
<p>On systems that do not support this ioctl, it always fails. On systems that<br>do support it, it only works for extensions that are supported for enablement.</p>
<p>To check if a capability can be enabled, the KVM_CHECK_EXTENSION ioctl should<br>be used.</p>
<p>struct kvm_enable_cap {<br>       /* in */<br>       __u32 cap;</p>
<p>The capability that is supposed to get enabled.</p>
<pre><code>   __u32 flags;
</code></pre>
<p>A bitfield indicating future enhancements. Has to be 0 for now.</p>
<pre><code>   __u64 args[4];
</code></pre>
<p>Arguments for enabling a feature. If a feature needs initial values to<br>function properly, this is the place to put them.</p>
<pre><code>   __u8  pad[64];
</code></pre>
<p>};</p>
<p>The vcpu ioctl should be used for vcpu-specific capabilities, the vm ioctl<br>for vm-wide capabilities.</p>
<p>4.38 KVM_GET_MP_STATE</p>
<p>Capability: KVM_CAP_MP_STATE<br>Architectures: x86, s390, arm, arm64<br>Type: vcpu ioctl<br>Parameters: struct kvm_mp_state (out)<br>Returns: 0 on success; -1 on error</p>
<p>struct kvm_mp_state {<br>    __u32 mp_state;<br>};</p>
<p>Returns the vcpu’s current “multiprocessing state” (though also valid on<br>uniprocessor guests).</p>
<p>Possible values are:</p>
<ul>
<li>KVM_MP_STATE_RUNNABLE:        the vcpu is currently running [x86,arm/arm64]</li>
<li>KVM_MP_STATE_UNINITIALIZED:   the vcpu is an application processor (AP)<pre><code>                          which has not yet received an INIT signal [x86]
</code></pre>
</li>
<li>KVM_MP_STATE_INIT_RECEIVED:   the vcpu has received an INIT signal, and is<pre><code>                          now ready for a SIPI [x86]
</code></pre>
</li>
<li>KVM_MP_STATE_HALTED:          the vcpu has executed a HLT instruction and<pre><code>                          is waiting for an interrupt [x86]
</code></pre>
</li>
<li>KVM_MP_STATE_SIPI_RECEIVED:   the vcpu has just received a SIPI (vector<pre><code>                          accessible via KVM_GET_VCPU_EVENTS) [x86]
</code></pre>
</li>
<li>KVM_MP_STATE_STOPPED:         the vcpu is stopped [s390,arm/arm64]</li>
<li>KVM_MP_STATE_CHECK_STOP:      the vcpu is in a special error state [s390]</li>
<li>KVM_MP_STATE_OPERATING:       the vcpu is operating (running or halted)<pre><code>                          [s390]
</code></pre>
</li>
<li>KVM_MP_STATE_LOAD:            the vcpu is in a special load/startup state<pre><code>                          [s390]
</code></pre>
</li>
</ul>
<p>On x86, this ioctl is only useful after KVM_CREATE_IRQCHIP. Without an<br>in-kernel irqchip, the multiprocessing state must be maintained by userspace on<br>these architectures.</p>
<p>For arm/arm64:</p>
<p>The only states that are valid are KVM_MP_STATE_STOPPED and<br>KVM_MP_STATE_RUNNABLE which reflect if the vcpu is paused or not.</p>
<p>4.39 KVM_SET_MP_STATE</p>
<p>Capability: KVM_CAP_MP_STATE<br>Architectures: x86, s390, arm, arm64<br>Type: vcpu ioctl<br>Parameters: struct kvm_mp_state (in)<br>Returns: 0 on success; -1 on error</p>
<p>Sets the vcpu’s current “multiprocessing state”; see KVM_GET_MP_STATE for<br>arguments.</p>
<p>On x86, this ioctl is only useful after KVM_CREATE_IRQCHIP. Without an<br>in-kernel irqchip, the multiprocessing state must be maintained by userspace on<br>these architectures.</p>
<p>For arm/arm64:</p>
<p>The only states that are valid are KVM_MP_STATE_STOPPED and<br>KVM_MP_STATE_RUNNABLE which reflect if the vcpu should be paused or not.</p>
<p>4.40 KVM_SET_IDENTITY_MAP_ADDR</p>
<p>Capability: KVM_CAP_SET_IDENTITY_MAP_ADDR<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: unsigned long identity (in)<br>Returns: 0 on success, -1 on error</p>
<p>This ioctl defines the physical address of a one-page region in the guest<br>physical address space.  The region must be within the first 4GB of the<br>guest physical address space and must not conflict with any memory slot<br>or any mmio address.  The guest may malfunction if it accesses this memory<br>region.</p>
<p>Setting the address to 0 will result in resetting the address to its default<br>(0xfffbc000).</p>
<p>This ioctl is required on Intel-based hosts.  This is needed on Intel hardware<br>because of a quirk in the virtualization implementation (see the internals<br>documentation when it pops into existence).</p>
<p>Fails if any VCPU has already been created.</p>
<p>4.41 KVM_SET_BOOT_CPU_ID</p>
<p>Capability: KVM_CAP_SET_BOOT_CPU_ID<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: unsigned long vcpu_id<br>Returns: 0 on success, -1 on error</p>
<p>Define which vcpu is the Bootstrap Processor (BSP).  Values are the same<br>as the vcpu id in KVM_CREATE_VCPU.  If this ioctl is not called, the default<br>is vcpu 0.</p>
<p>4.42 KVM_GET_XSAVE</p>
<p>Capability: KVM_CAP_XSAVE<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_xsave (out)<br>Returns: 0 on success, -1 on error</p>
<p>struct kvm_xsave {<br>    __u32 region[1024];<br>};</p>
<p>This ioctl would copy current vcpu’s xsave struct to the userspace.</p>
<p>4.43 KVM_SET_XSAVE</p>
<p>Capability: KVM_CAP_XSAVE<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_xsave (in)<br>Returns: 0 on success, -1 on error</p>
<p>struct kvm_xsave {<br>    __u32 region[1024];<br>};</p>
<p>This ioctl would copy userspace’s xsave struct to the kernel.</p>
<p>4.44 KVM_GET_XCRS</p>
<p>Capability: KVM_CAP_XCRS<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_xcrs (out)<br>Returns: 0 on success, -1 on error</p>
<p>struct kvm_xcr {<br>    __u32 xcr;<br>    __u32 reserved;<br>    __u64 value;<br>};</p>
<p>struct kvm_xcrs {<br>    __u32 nr_xcrs;<br>    __u32 flags;<br>    struct kvm_xcr xcrs[KVM_MAX_XCRS];<br>    __u64 padding[16];<br>};</p>
<p>This ioctl would copy current vcpu’s xcrs to the userspace.</p>
<p>4.45 KVM_SET_XCRS</p>
<p>Capability: KVM_CAP_XCRS<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_xcrs (in)<br>Returns: 0 on success, -1 on error</p>
<p>struct kvm_xcr {<br>    __u32 xcr;<br>    __u32 reserved;<br>    __u64 value;<br>};</p>
<p>struct kvm_xcrs {<br>    __u32 nr_xcrs;<br>    __u32 flags;<br>    struct kvm_xcr xcrs[KVM_MAX_XCRS];<br>    __u64 padding[16];<br>};</p>
<p>This ioctl would set vcpu’s xcr to the value userspace specified.</p>
<p>4.46 KVM_GET_SUPPORTED_CPUID</p>
<p>Capability: KVM_CAP_EXT_CPUID<br>Architectures: x86<br>Type: system ioctl<br>Parameters: struct kvm_cpuid2 (in/out)<br>Returns: 0 on success, -1 on error</p>
<p>struct kvm_cpuid2 {<br>    __u32 nent;<br>    __u32 padding;<br>    struct kvm_cpuid_entry2 entries[0];<br>};</p>
<p>#define KVM_CPUID_FLAG_SIGNIFCANT_INDEX        BIT(0)<br>#define KVM_CPUID_FLAG_STATEFUL_FUNC        BIT(1)<br>#define KVM_CPUID_FLAG_STATE_READ_NEXT        BIT(2)</p>
<p>struct kvm_cpuid_entry2 {<br>    __u32 function;<br>    __u32 index;<br>    __u32 flags;<br>    __u32 eax;<br>    __u32 ebx;<br>    __u32 ecx;<br>    __u32 edx;<br>    __u32 padding[3];<br>};</p>
<p>This ioctl returns x86 cpuid features which are supported by both the<br>hardware and kvm in its default configuration.  Userspace can use the<br>information returned by this ioctl to construct cpuid information (for<br>KVM_SET_CPUID2) that is consistent with hardware, kernel, and<br>userspace capabilities, and with user requirements (for example, the<br>user may wish to constrain cpuid to emulate older hardware, or for<br>feature consistency across a cluster).</p>
<p>Note that certain capabilities, such as KVM_CAP_X86_DISABLE_EXITS, may<br>expose cpuid features (e.g. MONITOR) which are not supported by kvm in<br>its default configuration. If userspace enables such capabilities, it<br>is responsible for modifying the results of this ioctl appropriately.</p>
<p>Userspace invokes KVM_GET_SUPPORTED_CPUID by passing a kvm_cpuid2 structure<br>with the ‘nent’ field indicating the number of entries in the variable-size<br>array ‘entries’.  If the number of entries is too low to describe the cpu<br>capabilities, an error (E2BIG) is returned.  If the number is too high,<br>the ‘nent’ field is adjusted and an error (ENOMEM) is returned.  If the<br>number is just right, the ‘nent’ field is adjusted to the number of valid<br>entries in the ‘entries’ array, which is then filled.</p>
<p>The entries returned are the host cpuid as returned by the cpuid instruction,<br>with unknown or unsupported features masked out.  Some features (for example,<br>x2apic), may not be present in the host cpu, but are exposed by kvm if it can<br>emulate them efficiently. The fields in each entry are defined as follows:</p>
<p>  function: the eax value used to obtain the entry<br>  index: the ecx value used to obtain the entry (for entries that are<br>         affected by ecx)<br>  flags: an OR of zero or more of the following:<br>        KVM_CPUID_FLAG_SIGNIFCANT_INDEX:<br>           if the index field is valid<br>        KVM_CPUID_FLAG_STATEFUL_FUNC:<br>           if cpuid for this function returns different values for successive<br>           invocations; there will be several entries with the same function,<br>           all with this flag set<br>        KVM_CPUID_FLAG_STATE_READ_NEXT:<br>           for KVM_CPUID_FLAG_STATEFUL_FUNC entries, set if this entry is<br>           the first entry to be read by a cpu<br>   eax, ebx, ecx, edx: the values returned by the cpuid instruction for<br>         this function/index combination</p>
<p>The TSC deadline timer feature (CPUID leaf 1, ecx[24]) is always returned<br>as false, since the feature depends on KVM_CREATE_IRQCHIP for local APIC<br>support.  Instead it is reported via</p>
<p>  ioctl(KVM_CHECK_EXTENSION, KVM_CAP_TSC_DEADLINE_TIMER)</p>
<p>if that returns true and you use KVM_CREATE_IRQCHIP, or if you emulate the<br>feature in userspace, then you can enable the feature for KVM_SET_CPUID2.</p>
<p>4.47 KVM_PPC_GET_PVINFO</p>
<p>Capability: KVM_CAP_PPC_GET_PVINFO<br>Architectures: ppc<br>Type: vm ioctl<br>Parameters: struct kvm_ppc_pvinfo (out)<br>Returns: 0 on success, !0 on error</p>
<p>struct kvm_ppc_pvinfo {<br>    __u32 flags;<br>    __u32 hcall[4];<br>    __u8  pad[108];<br>};</p>
<p>This ioctl fetches PV specific information that need to be passed to the guest<br>using the device tree or other means from vm context.</p>
<p>The hcall array defines 4 instructions that make up a hypercall.</p>
<p>If any additional field gets added to this structure later on, a bit for that<br>additional piece of information will be set in the flags bitmap.</p>
<p>The flags bitmap is defined as:</p>
<p>   /* the host supports the ePAPR idle hcall<br>   #define KVM_PPC_PVINFO_FLAGS_EV_IDLE   (1&lt;&lt;0)</p>
<p>4.52 KVM_SET_GSI_ROUTING</p>
<p>Capability: KVM_CAP_IRQ_ROUTING<br>Architectures: x86 s390 arm arm64<br>Type: vm ioctl<br>Parameters: struct kvm_irq_routing (in)<br>Returns: 0 on success, -1 on error</p>
<p>Sets the GSI routing table entries, overwriting any previously set entries.</p>
<p>On arm/arm64, GSI routing has the following limitation:</p>
<ul>
<li>GSI routing does not apply to KVM_IRQ_LINE but only to KVM_IRQFD.</li>
</ul>
<p>struct kvm_irq_routing {<br>    __u32 nr;<br>    __u32 flags;<br>    struct kvm_irq_routing_entry entries[0];<br>};</p>
<p>No flags are specified so far, the corresponding field must be set to zero.</p>
<p>struct kvm_irq_routing_entry {<br>    __u32 gsi;<br>    __u32 type;<br>    __u32 flags;<br>    __u32 pad;<br>    union {<br>        struct kvm_irq_routing_irqchip irqchip;<br>        struct kvm_irq_routing_msi msi;<br>        struct kvm_irq_routing_s390_adapter adapter;<br>        struct kvm_irq_routing_hv_sint hv_sint;<br>        __u32 pad[8];<br>    } u;<br>};</p>
<p>/* gsi routing entry types */<br>#define KVM_IRQ_ROUTING_IRQCHIP 1<br>#define KVM_IRQ_ROUTING_MSI 2<br>#define KVM_IRQ_ROUTING_S390_ADAPTER 3<br>#define KVM_IRQ_ROUTING_HV_SINT 4</p>
<p>flags:</p>
<ul>
<li>KVM_MSI_VALID_DEVID: used along with KVM_IRQ_ROUTING_MSI routing entry<br>type, specifies that the devid field contains a valid value.  The per-VM<br>KVM_CAP_MSI_DEVID capability advertises the requirement to provide<br>the device ID.  If this capability is not available, userspace should<br>never set the KVM_MSI_VALID_DEVID flag as the ioctl might fail.</li>
<li>zero otherwise</li>
</ul>
<p>struct kvm_irq_routing_irqchip {<br>    __u32 irqchip;<br>    __u32 pin;<br>};</p>
<p>struct kvm_irq_routing_msi {<br>    __u32 address_lo;<br>    __u32 address_hi;<br>    __u32 data;<br>    union {<br>        __u32 pad;<br>        __u32 devid;<br>    };<br>};</p>
<p>If KVM_MSI_VALID_DEVID is set, devid contains a unique device identifier<br>for the device that wrote the MSI message.  For PCI, this is usually a<br>BFD identifier in the lower 16 bits.</p>
<p>On x86, address_hi is ignored unless the KVM_X2APIC_API_USE_32BIT_IDS<br>feature of KVM_CAP_X2APIC_API capability is enabled.  If it is enabled,<br>address_hi bits 31-8 provide bits 31-8 of the destination id.  Bits 7-0 of<br>address_hi must be zero.</p>
<p>struct kvm_irq_routing_s390_adapter {<br>    __u64 ind_addr;<br>    __u64 summary_addr;<br>    __u64 ind_offset;<br>    __u32 summary_offset;<br>    __u32 adapter_id;<br>};</p>
<p>struct kvm_irq_routing_hv_sint {<br>    __u32 vcpu;<br>    __u32 sint;<br>};</p>
<p>4.55 KVM_SET_TSC_KHZ</p>
<p>Capability: KVM_CAP_TSC_CONTROL<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: virtual tsc_khz<br>Returns: 0 on success, -1 on error</p>
<p>Specifies the tsc frequency for the virtual machine. The unit of the<br>frequency is KHz.</p>
<p>4.56 KVM_GET_TSC_KHZ</p>
<p>Capability: KVM_CAP_GET_TSC_KHZ<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: none<br>Returns: virtual tsc-khz on success, negative value on error</p>
<p>Returns the tsc frequency of the guest. The unit of the return value is<br>KHz. If the host has unstable tsc this ioctl returns -EIO instead as an<br>error.</p>
<p>4.57 KVM_GET_LAPIC</p>
<p>Capability: KVM_CAP_IRQCHIP<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_lapic_state (out)<br>Returns: 0 on success, -1 on error</p>
<p>#define KVM_APIC_REG_SIZE 0x400<br>struct kvm_lapic_state {<br>    char regs[KVM_APIC_REG_SIZE];<br>};</p>
<p>Reads the Local APIC registers and copies them into the input argument.  The<br>data format and layout are the same as documented in the architecture manual.</p>
<p>If KVM_X2APIC_API_USE_32BIT_IDS feature of KVM_CAP_X2APIC_API is<br>enabled, then the format of APIC_ID register depends on the APIC mode<br>(reported by MSR_IA32_APICBASE) of its VCPU.  x2APIC stores APIC ID in<br>the APIC_ID register (bytes 32-35).  xAPIC only allows an 8-bit APIC ID<br>which is stored in bits 31-24 of the APIC register, or equivalently in<br>byte 35 of struct kvm_lapic_state’s regs field.  KVM_GET_LAPIC must then<br>be called after MSR_IA32_APICBASE has been set with KVM_SET_MSR.</p>
<p>If KVM_X2APIC_API_USE_32BIT_IDS feature is disabled, struct kvm_lapic_state<br>always uses xAPIC format.</p>
<p>4.58 KVM_SET_LAPIC</p>
<p>Capability: KVM_CAP_IRQCHIP<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_lapic_state (in)<br>Returns: 0 on success, -1 on error</p>
<p>#define KVM_APIC_REG_SIZE 0x400<br>struct kvm_lapic_state {<br>    char regs[KVM_APIC_REG_SIZE];<br>};</p>
<p>Copies the input argument into the Local APIC registers.  The data format<br>and layout are the same as documented in the architecture manual.</p>
<p>The format of the APIC ID register (bytes 32-35 of struct kvm_lapic_state’s<br>regs field) depends on the state of the KVM_CAP_X2APIC_API capability.<br>See the note in KVM_GET_LAPIC.</p>
<p>4.59 KVM_IOEVENTFD</p>
<p>Capability: KVM_CAP_IOEVENTFD<br>Architectures: all<br>Type: vm ioctl<br>Parameters: struct kvm_ioeventfd (in)<br>Returns: 0 on success, !0 on error</p>
<p>This ioctl attaches or detaches an ioeventfd to a legal pio/mmio address<br>within the guest.  A guest write in the registered address will signal the<br>provided event instead of triggering an exit.</p>
<p>struct kvm_ioeventfd {<br>    __u64 datamatch;<br>    __u64 addr;        /* legal pio/mmio address <em>/<br>    __u32 len;         /</em> 0, 1, 2, 4, or 8 bytes    */<br>    __s32 fd;<br>    __u32 flags;<br>    __u8  pad[36];<br>};</p>
<p>For the special case of virtio-ccw devices on s390, the ioevent is matched<br>to a subchannel/virtqueue tuple instead.</p>
<p>The following flags are defined:</p>
<p>#define KVM_IOEVENTFD_FLAG_DATAMATCH (1 &lt;&lt; kvm_ioeventfd_flag_nr_datamatch)<br>#define KVM_IOEVENTFD_FLAG_PIO       (1 &lt;&lt; kvm_ioeventfd_flag_nr_pio)<br>#define KVM_IOEVENTFD_FLAG_DEASSIGN  (1 &lt;&lt; kvm_ioeventfd_flag_nr_deassign)<br>#define KVM_IOEVENTFD_FLAG_VIRTIO_CCW_NOTIFY <br>    (1 &lt;&lt; kvm_ioeventfd_flag_nr_virtio_ccw_notify)</p>
<p>If datamatch flag is set, the event will be signaled only if the written value<br>to the registered address is equal to datamatch in struct kvm_ioeventfd.</p>
<p>For virtio-ccw devices, addr contains the subchannel id and datamatch the<br>virtqueue index.</p>
<p>With KVM_CAP_IOEVENTFD_ANY_LENGTH, a zero length ioeventfd is allowed, and<br>the kernel will ignore the length of guest write and may get a faster vmexit.<br>The speedup may only apply to specific architectures, but the ioeventfd will<br>work anyway.</p>
<p>4.60 KVM_DIRTY_TLB</p>
<p>Capability: KVM_CAP_SW_TLB<br>Architectures: ppc<br>Type: vcpu ioctl<br>Parameters: struct kvm_dirty_tlb (in)<br>Returns: 0 on success, -1 on error</p>
<p>struct kvm_dirty_tlb {<br>    __u64 bitmap;<br>    __u32 num_dirty;<br>};</p>
<p>This must be called whenever userspace has changed an entry in the shared<br>TLB, prior to calling KVM_RUN on the associated vcpu.</p>
<p>The “bitmap” field is the userspace address of an array.  This array<br>consists of a number of bits, equal to the total number of TLB entries as<br>determined by the last successful call to KVM_CONFIG_TLB, rounded up to the<br>nearest multiple of 64.</p>
<p>Each bit corresponds to one TLB entry, ordered the same as in the shared TLB<br>array.</p>
<p>The array is little-endian: the bit 0 is the least significant bit of the<br>first byte, bit 8 is the least significant bit of the second byte, etc.<br>This avoids any complications with differing word sizes.</p>
<p>The “num_dirty” field is a performance hint for KVM to determine whether it<br>should skip processing the bitmap and just invalidate everything.  It must<br>be set to the number of set bits in the bitmap.</p>
<p>4.62 KVM_CREATE_SPAPR_TCE</p>
<p>Capability: KVM_CAP_SPAPR_TCE<br>Architectures: powerpc<br>Type: vm ioctl<br>Parameters: struct kvm_create_spapr_tce (in)<br>Returns: file descriptor for manipulating the created TCE table</p>
<p>This creates a virtual TCE (translation control entry) table, which<br>is an IOMMU for PAPR-style virtual I/O.  It is used to translate<br>logical addresses used in virtual I/O into guest physical addresses,<br>and provides a scatter/gather capability for PAPR virtual I/O.</p>
<p>/* for KVM_CAP_SPAPR_TCE */<br>struct kvm_create_spapr_tce {<br>    __u64 liobn;<br>    __u32 window_size;<br>};</p>
<p>The liobn field gives the logical IO bus number for which to create a<br>TCE table.  The window_size field specifies the size of the DMA window<br>which this TCE table will translate - the table will contain one 64<br>bit TCE entry for every 4kiB of the DMA window.</p>
<p>When the guest issues an H_PUT_TCE hcall on a liobn for which a TCE<br>table has been created using this ioctl(), the kernel will handle it<br>in real mode, updating the TCE table.  H_PUT_TCE calls for other<br>liobns will cause a vm exit and must be handled by userspace.</p>
<p>The return value is a file descriptor which can be passed to mmap(2)<br>to map the created TCE table into userspace.  This lets userspace read<br>the entries written by kernel-handled H_PUT_TCE calls, and also lets<br>userspace update the TCE table directly which is useful in some<br>circumstances.</p>
<p>4.63 KVM_ALLOCATE_RMA</p>
<p>Capability: KVM_CAP_PPC_RMA<br>Architectures: powerpc<br>Type: vm ioctl<br>Parameters: struct kvm_allocate_rma (out)<br>Returns: file descriptor for mapping the allocated RMA</p>
<p>This allocates a Real Mode Area (RMA) from the pool allocated at boot<br>time by the kernel.  An RMA is a physically-contiguous, aligned region<br>of memory used on older POWER processors to provide the memory which<br>will be accessed by real-mode (MMU off) accesses in a KVM guest.<br>POWER processors support a set of sizes for the RMA that usually<br>includes 64MB, 128MB, 256MB and some larger powers of two.</p>
<p>/* for KVM_ALLOCATE_RMA */<br>struct kvm_allocate_rma {<br>    __u64 rma_size;<br>};</p>
<p>The return value is a file descriptor which can be passed to mmap(2)<br>to map the allocated RMA into userspace.  The mapped area can then be<br>passed to the KVM_SET_USER_MEMORY_REGION ioctl to establish it as the<br>RMA for a virtual machine.  The size of the RMA in bytes (which is<br>fixed at host kernel boot time) is returned in the rma_size field of<br>the argument structure.</p>
<p>The KVM_CAP_PPC_RMA capability is 1 or 2 if the KVM_ALLOCATE_RMA ioctl<br>is supported; 2 if the processor requires all virtual machines to have<br>an RMA, or 1 if the processor can use an RMA but doesn’t require it,<br>because it supports the Virtual RMA (VRMA) facility.</p>
<p>4.64 KVM_NMI</p>
<p>Capability: KVM_CAP_USER_NMI<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: none<br>Returns: 0 on success, -1 on error</p>
<p>Queues an NMI on the thread’s vcpu.  Note this is well defined only<br>when KVM_CREATE_IRQCHIP has not been called, since this is an interface<br>between the virtual cpu core and virtual local APIC.  After KVM_CREATE_IRQCHIP<br>has been called, this interface is completely emulated within the kernel.</p>
<p>To use this to emulate the LINT1 input with KVM_CREATE_IRQCHIP, use the<br>following algorithm:</p>
<ul>
<li>pause the vcpu</li>
<li>read the local APIC’s state (KVM_GET_LAPIC)</li>
<li>check whether changing LINT1 will queue an NMI (see the LVT entry for LINT1)</li>
<li>if so, issue KVM_NMI</li>
<li>resume the vcpu</li>
</ul>
<p>Some guests configure the LINT1 NMI input to cause a panic, aiding in<br>debugging.</p>
<p>4.65 KVM_S390_UCAS_MAP</p>
<p>Capability: KVM_CAP_S390_UCONTROL<br>Architectures: s390<br>Type: vcpu ioctl<br>Parameters: struct kvm_s390_ucas_mapping (in)<br>Returns: 0 in case of success</p>
<p>The parameter is defined like this:<br>    struct kvm_s390_ucas_mapping {<br>        __u64 user_addr;<br>        __u64 vcpu_addr;<br>        __u64 length;<br>    };</p>
<p>This ioctl maps the memory at “user_addr” with the length “length” to<br>the vcpu’s address space starting at “vcpu_addr”. All parameters need to<br>be aligned by 1 megabyte.</p>
<p>4.66 KVM_S390_UCAS_UNMAP</p>
<p>Capability: KVM_CAP_S390_UCONTROL<br>Architectures: s390<br>Type: vcpu ioctl<br>Parameters: struct kvm_s390_ucas_mapping (in)<br>Returns: 0 in case of success</p>
<p>The parameter is defined like this:<br>    struct kvm_s390_ucas_mapping {<br>        __u64 user_addr;<br>        __u64 vcpu_addr;<br>        __u64 length;<br>    };</p>
<p>This ioctl unmaps the memory in the vcpu’s address space starting at<br>“vcpu_addr” with the length “length”. The field “user_addr” is ignored.<br>All parameters need to be aligned by 1 megabyte.</p>
<p>4.67 KVM_S390_VCPU_FAULT</p>
<p>Capability: KVM_CAP_S390_UCONTROL<br>Architectures: s390<br>Type: vcpu ioctl<br>Parameters: vcpu absolute address (in)<br>Returns: 0 in case of success</p>
<p>This call creates a page table entry on the virtual cpu’s address space<br>(for user controlled virtual machines) or the virtual machine’s address<br>space (for regular virtual machines). This only works for minor faults,<br>thus it’s recommended to access subject memory page via the user page<br>table upfront. This is useful to handle validity intercepts for user<br>controlled virtual machines to fault in the virtual cpu’s lowcore pages<br>prior to calling the KVM_RUN ioctl.</p>
<p>4.68 KVM_SET_ONE_REG</p>
<p>Capability: KVM_CAP_ONE_REG<br>Architectures: all<br>Type: vcpu ioctl<br>Parameters: struct kvm_one_reg (in)<br>Returns: 0 on success, negative value on failure</p>
<p>struct kvm_one_reg {<br>       __u64 id;<br>       __u64 addr;<br>};</p>
<p>Using this ioctl, a single vcpu register can be set to a specific value<br>defined by user space with the passed in struct kvm_one_reg, where id<br>refers to the register identifier as described below and addr is a pointer<br>to a variable with the respective size. There can be architecture agnostic<br>and architecture specific registers. Each have their own range of operation<br>and their own constants and width. To keep track of the implemented<br>registers, find a list below:</p>
<p>  Arch  |           Register            | Width (bits)<br>        |                               |<br>  PPC   | KVM_REG_PPC_HIOR              | 64<br>  PPC   | KVM_REG_PPC_IAC1              | 64<br>  PPC   | KVM_REG_PPC_IAC2              | 64<br>  PPC   | KVM_REG_PPC_IAC3              | 64<br>  PPC   | KVM_REG_PPC_IAC4              | 64<br>  PPC   | KVM_REG_PPC_DAC1              | 64<br>  PPC   | KVM_REG_PPC_DAC2              | 64<br>  PPC   | KVM_REG_PPC_DABR              | 64<br>  PPC   | KVM_REG_PPC_DSCR              | 64<br>  PPC   | KVM_REG_PPC_PURR              | 64<br>  PPC   | KVM_REG_PPC_SPURR             | 64<br>  PPC   | KVM_REG_PPC_DAR               | 64<br>  PPC   | KVM_REG_PPC_DSISR             | 32<br>  PPC   | KVM_REG_PPC_AMR               | 64<br>  PPC   | KVM_REG_PPC_UAMOR             | 64<br>  PPC   | KVM_REG_PPC_MMCR0             | 64<br>  PPC   | KVM_REG_PPC_MMCR1             | 64<br>  PPC   | KVM_REG_PPC_MMCRA             | 64<br>  PPC   | KVM_REG_PPC_MMCR2             | 64<br>  PPC   | KVM_REG_PPC_MMCRS             | 64<br>  PPC   | KVM_REG_PPC_SIAR              | 64<br>  PPC   | KVM_REG_PPC_SDAR              | 64<br>  PPC   | KVM_REG_PPC_SIER              | 64<br>  PPC   | KVM_REG_PPC_PMC1              | 32<br>  PPC   | KVM_REG_PPC_PMC2              | 32<br>  PPC   | KVM_REG_PPC_PMC3              | 32<br>  PPC   | KVM_REG_PPC_PMC4              | 32<br>  PPC   | KVM_REG_PPC_PMC5              | 32<br>  PPC   | KVM_REG_PPC_PMC6              | 32<br>  PPC   | KVM_REG_PPC_PMC7              | 32<br>  PPC   | KVM_REG_PPC_PMC8              | 32<br>  PPC   | KVM_REG_PPC_FPR0              | 64<br>          …<br>  PPC   | KVM_REG_PPC_FPR31             | 64<br>  PPC   | KVM_REG_PPC_VR0               | 128<br>          …<br>  PPC   | KVM_REG_PPC_VR31              | 128<br>  PPC   | KVM_REG_PPC_VSR0              | 128<br>          …<br>  PPC   | KVM_REG_PPC_VSR31             | 128<br>  PPC   | KVM_REG_PPC_FPSCR             | 64<br>  PPC   | KVM_REG_PPC_VSCR              | 32<br>  PPC   | KVM_REG_PPC_VPA_ADDR          | 64<br>  PPC   | KVM_REG_PPC_VPA_SLB           | 128<br>  PPC   | KVM_REG_PPC_VPA_DTL           | 128<br>  PPC   | KVM_REG_PPC_EPCR              | 32<br>  PPC   | KVM_REG_PPC_EPR               | 32<br>  PPC   | KVM_REG_PPC_TCR               | 32<br>  PPC   | KVM_REG_PPC_TSR               | 32<br>  PPC   | KVM_REG_PPC_OR_TSR            | 32<br>  PPC   | KVM_REG_PPC_CLEAR_TSR         | 32<br>  PPC   | KVM_REG_PPC_MAS0              | 32<br>  PPC   | KVM_REG_PPC_MAS1              | 32<br>  PPC   | KVM_REG_PPC_MAS2              | 64<br>  PPC   | KVM_REG_PPC_MAS7_3            | 64<br>  PPC   | KVM_REG_PPC_MAS4              | 32<br>  PPC   | KVM_REG_PPC_MAS6              | 32<br>  PPC   | KVM_REG_PPC_MMUCFG            | 32<br>  PPC   | KVM_REG_PPC_TLB0CFG           | 32<br>  PPC   | KVM_REG_PPC_TLB1CFG           | 32<br>  PPC   | KVM_REG_PPC_TLB2CFG           | 32<br>  PPC   | KVM_REG_PPC_TLB3CFG           | 32<br>  PPC   | KVM_REG_PPC_TLB0PS            | 32<br>  PPC   | KVM_REG_PPC_TLB1PS            | 32<br>  PPC   | KVM_REG_PPC_TLB2PS            | 32<br>  PPC   | KVM_REG_PPC_TLB3PS            | 32<br>  PPC   | KVM_REG_PPC_EPTCFG            | 32<br>  PPC   | KVM_REG_PPC_ICP_STATE         | 64<br>  PPC   | KVM_REG_PPC_TB_OFFSET         | 64<br>  PPC   | KVM_REG_PPC_SPMC1             | 32<br>  PPC   | KVM_REG_PPC_SPMC2             | 32<br>  PPC   | KVM_REG_PPC_IAMR              | 64<br>  PPC   | KVM_REG_PPC_TFHAR             | 64<br>  PPC   | KVM_REG_PPC_TFIAR             | 64<br>  PPC   | KVM_REG_PPC_TEXASR            | 64<br>  PPC   | KVM_REG_PPC_FSCR              | 64<br>  PPC   | KVM_REG_PPC_PSPB              | 32<br>  PPC   | KVM_REG_PPC_EBBHR             | 64<br>  PPC   | KVM_REG_PPC_EBBRR             | 64<br>  PPC   | KVM_REG_PPC_BESCR             | 64<br>  PPC   | KVM_REG_PPC_TAR               | 64<br>  PPC   | KVM_REG_PPC_DPDES             | 64<br>  PPC   | KVM_REG_PPC_DAWR              | 64<br>  PPC   | KVM_REG_PPC_DAWRX             | 64<br>  PPC   | KVM_REG_PPC_CIABR             | 64<br>  PPC   | KVM_REG_PPC_IC                | 64<br>  PPC   | KVM_REG_PPC_VTB               | 64<br>  PPC   | KVM_REG_PPC_CSIGR             | 64<br>  PPC   | KVM_REG_PPC_TACR              | 64<br>  PPC   | KVM_REG_PPC_TCSCR             | 64<br>  PPC   | KVM_REG_PPC_PID               | 64<br>  PPC   | KVM_REG_PPC_ACOP              | 64<br>  PPC   | KVM_REG_PPC_VRSAVE            | 32<br>  PPC   | KVM_REG_PPC_LPCR              | 32<br>  PPC   | KVM_REG_PPC_LPCR_64           | 64<br>  PPC   | KVM_REG_PPC_PPR               | 64<br>  PPC   | KVM_REG_PPC_ARCH_COMPAT       | 32<br>  PPC   | KVM_REG_PPC_DABRX             | 32<br>  PPC   | KVM_REG_PPC_WORT              | 64<br>  PPC    | KVM_REG_PPC_SPRG9             | 64<br>  PPC    | KVM_REG_PPC_DBSR              | 32<br>  PPC   | KVM_REG_PPC_TIDR              | 64<br>  PPC   | KVM_REG_PPC_PSSCR             | 64<br>  PPC   | KVM_REG_PPC_DEC_EXPIRY        | 64<br>  PPC   | KVM_REG_PPC_PTCR              | 64<br>  PPC   | KVM_REG_PPC_TM_GPR0           | 64<br>          …<br>  PPC   | KVM_REG_PPC_TM_GPR31          | 64<br>  PPC   | KVM_REG_PPC_TM_VSR0           | 128<br>          …<br>  PPC   | KVM_REG_PPC_TM_VSR63          | 128<br>  PPC   | KVM_REG_PPC_TM_CR             | 64<br>  PPC   | KVM_REG_PPC_TM_LR             | 64<br>  PPC   | KVM_REG_PPC_TM_CTR            | 64<br>  PPC   | KVM_REG_PPC_TM_FPSCR          | 64<br>  PPC   | KVM_REG_PPC_TM_AMR            | 64<br>  PPC   | KVM_REG_PPC_TM_PPR            | 64<br>  PPC   | KVM_REG_PPC_TM_VRSAVE         | 64<br>  PPC   | KVM_REG_PPC_TM_VSCR           | 32<br>  PPC   | KVM_REG_PPC_TM_DSCR           | 64<br>  PPC   | KVM_REG_PPC_TM_TAR            | 64<br>  PPC   | KVM_REG_PPC_TM_XER            | 64<br>        |                               |<br>  MIPS  | KVM_REG_MIPS_R0               | 64<br>          …<br>  MIPS  | KVM_REG_MIPS_R31              | 64<br>  MIPS  | KVM_REG_MIPS_HI               | 64<br>  MIPS  | KVM_REG_MIPS_LO               | 64<br>  MIPS  | KVM_REG_MIPS_PC               | 64<br>  MIPS  | KVM_REG_MIPS_CP0_INDEX        | 32<br>  MIPS  | KVM_REG_MIPS_CP0_ENTRYLO0     | 64<br>  MIPS  | KVM_REG_MIPS_CP0_ENTRYLO1     | 64<br>  MIPS  | KVM_REG_MIPS_CP0_CONTEXT      | 64<br>  MIPS  | KVM_REG_MIPS_CP0_CONTEXTCONFIG| 32<br>  MIPS  | KVM_REG_MIPS_CP0_USERLOCAL    | 64<br>  MIPS  | KVM_REG_MIPS_CP0_XCONTEXTCONFIG| 64<br>  MIPS  | KVM_REG_MIPS_CP0_PAGEMASK     | 32<br>  MIPS  | KVM_REG_MIPS_CP0_PAGEGRAIN    | 32<br>  MIPS  | KVM_REG_MIPS_CP0_SEGCTL0      | 64<br>  MIPS  | KVM_REG_MIPS_CP0_SEGCTL1      | 64<br>  MIPS  | KVM_REG_MIPS_CP0_SEGCTL2      | 64<br>  MIPS  | KVM_REG_MIPS_CP0_PWBASE       | 64<br>  MIPS  | KVM_REG_MIPS_CP0_PWFIELD      | 64<br>  MIPS  | KVM_REG_MIPS_CP0_PWSIZE       | 64<br>  MIPS  | KVM_REG_MIPS_CP0_WIRED        | 32<br>  MIPS  | KVM_REG_MIPS_CP0_PWCTL        | 32<br>  MIPS  | KVM_REG_MIPS_CP0_HWRENA       | 32<br>  MIPS  | KVM_REG_MIPS_CP0_BADVADDR     | 64<br>  MIPS  | KVM_REG_MIPS_CP0_BADINSTR     | 32<br>  MIPS  | KVM_REG_MIPS_CP0_BADINSTRP    | 32<br>  MIPS  | KVM_REG_MIPS_CP0_COUNT        | 32<br>  MIPS  | KVM_REG_MIPS_CP0_ENTRYHI      | 64<br>  MIPS  | KVM_REG_MIPS_CP0_COMPARE      | 32<br>  MIPS  | KVM_REG_MIPS_CP0_STATUS       | 32<br>  MIPS  | KVM_REG_MIPS_CP0_INTCTL       | 32<br>  MIPS  | KVM_REG_MIPS_CP0_CAUSE        | 32<br>  MIPS  | KVM_REG_MIPS_CP0_EPC          | 64<br>  MIPS  | KVM_REG_MIPS_CP0_PRID         | 32<br>  MIPS  | KVM_REG_MIPS_CP0_EBASE        | 64<br>  MIPS  | KVM_REG_MIPS_CP0_CONFIG       | 32<br>  MIPS  | KVM_REG_MIPS_CP0_CONFIG1      | 32<br>  MIPS  | KVM_REG_MIPS_CP0_CONFIG2      | 32<br>  MIPS  | KVM_REG_MIPS_CP0_CONFIG3      | 32<br>  MIPS  | KVM_REG_MIPS_CP0_CONFIG4      | 32<br>  MIPS  | KVM_REG_MIPS_CP0_CONFIG5      | 32<br>  MIPS  | KVM_REG_MIPS_CP0_CONFIG7      | 32<br>  MIPS  | KVM_REG_MIPS_CP0_XCONTEXT     | 64<br>  MIPS  | KVM_REG_MIPS_CP0_ERROREPC     | 64<br>  MIPS  | KVM_REG_MIPS_CP0_KSCRATCH1    | 64<br>  MIPS  | KVM_REG_MIPS_CP0_KSCRATCH2    | 64<br>  MIPS  | KVM_REG_MIPS_CP0_KSCRATCH3    | 64<br>  MIPS  | KVM_REG_MIPS_CP0_KSCRATCH4    | 64<br>  MIPS  | KVM_REG_MIPS_CP0_KSCRATCH5    | 64<br>  MIPS  | KVM_REG_MIPS_CP0_KSCRATCH6    | 64<br>  MIPS  | KVM_REG_MIPS_CP0_MAAR(0..63)  | 64<br>  MIPS  | KVM_REG_MIPS_COUNT_CTL        | 64<br>  MIPS  | KVM_REG_MIPS_COUNT_RESUME     | 64<br>  MIPS  | KVM_REG_MIPS_COUNT_HZ         | 64<br>  MIPS  | KVM_REG_MIPS_FPR_32(0..31)    | 32<br>  MIPS  | KVM_REG_MIPS_FPR_64(0..31)    | 64<br>  MIPS  | KVM_REG_MIPS_VEC_128(0..31)   | 128<br>  MIPS  | KVM_REG_MIPS_FCR_IR           | 32<br>  MIPS  | KVM_REG_MIPS_FCR_CSR          | 32<br>  MIPS  | KVM_REG_MIPS_MSA_IR           | 32<br>  MIPS  | KVM_REG_MIPS_MSA_CSR          | 32</p>
<p>ARM registers are mapped using the lower 32 bits.  The upper 16 of that<br>is the register group type, or coprocessor number:</p>
<p>ARM core registers have the following id bit patterns:<br>  0x4020 0000 0010 <index into the kvm_regs struct:16></p>
<p>ARM 32-bit CP15 registers have the following id bit patterns:<br>  0x4020 0000 000F <a href="zero:1">zero:1</a> <a href="crn:4">crn:4</a> <a href="crm:4">crm:4</a> <a href="opc1:4">opc1:4</a> <a href="opc2:3">opc2:3</a></p>
<p>ARM 64-bit CP15 registers have the following id bit patterns:<br>  0x4030 0000 000F <a href="zero:1">zero:1</a> <a href="zero:4">zero:4</a> <a href="crm:4">crm:4</a> <a href="opc1:4">opc1:4</a> <a href="zero:3">zero:3</a></p>
<p>ARM CCSIDR registers are demultiplexed by CSSELR value:<br>  0x4020 0000 0011 00 <a href="csselr:8">csselr:8</a></p>
<p>ARM 32-bit VFP control registers have the following id bit patterns:<br>  0x4020 0000 0012 1 <a href="regno:12">regno:12</a></p>
<p>ARM 64-bit FP registers have the following id bit patterns:<br>  0x4030 0000 0012 0 <a href="regno:12">regno:12</a></p>
<p>ARM firmware pseudo-registers have the following bit pattern:<br>  0x4030 0000 0014 <a href="regno:16">regno:16</a></p>
<p>arm64 registers are mapped using the lower 32 bits. The upper 16 of<br>that is the register group type, or coprocessor number:</p>
<p>arm64 core/FP-SIMD registers have the following id bit patterns. Note<br>that the size of the access is variable, as the kvm_regs structure<br>contains elements ranging from 32 to 128 bits. The index is a 32bit<br>value in the kvm_regs structure seen as a 32bit array.<br>  0x60x0 0000 0010 <index into the kvm_regs struct:16></p>
<p>arm64 CCSIDR registers are demultiplexed by CSSELR value:<br>  0x6020 0000 0011 00 <a href="csselr:8">csselr:8</a></p>
<p>arm64 system registers have the following id bit patterns:<br>  0x6030 0000 0013 <a href="op0:2">op0:2</a> <a href="op1:3">op1:3</a> <a href="crn:4">crn:4</a> <a href="crm:4">crm:4</a> <a href="op2:3">op2:3</a></p>
<p>arm64 firmware pseudo-registers have the following bit pattern:<br>  0x6030 0000 0014 <a href="regno:16">regno:16</a></p>
<p>MIPS registers are mapped using the lower 32 bits.  The upper 16 of that is<br>the register group type:</p>
<p>MIPS core registers (see above) have the following id bit patterns:<br>  0x7030 0000 0000 <a href="reg:16">reg:16</a></p>
<p>MIPS CP0 registers (see KVM_REG_MIPS_CP0_* above) have the following id bit<br>patterns depending on whether they’re 32-bit or 64-bit registers:<br>  0x7020 0000 0001 00 <a href="reg:5">reg:5</a> <a href="sel:3">sel:3</a>   (32-bit)<br>  0x7030 0000 0001 00 <a href="reg:5">reg:5</a> <a href="sel:3">sel:3</a>   (64-bit)</p>
<p>Note: KVM_REG_MIPS_CP0_ENTRYLO0 and KVM_REG_MIPS_CP0_ENTRYLO1 are the MIPS64<br>versions of the EntryLo registers regardless of the word size of the host<br>hardware, host kernel, guest, and whether XPA is present in the guest, i.e.<br>with the RI and XI bits (if they exist) in bits 63 and 62 respectively, and<br>the PFNX field starting at bit 30.</p>
<p>MIPS MAARs (see KVM_REG_MIPS_CP0_MAAR(*) above) have the following id bit<br>patterns:<br>  0x7030 0000 0001 01 <a href="reg:8">reg:8</a></p>
<p>MIPS KVM control registers (see above) have the following id bit patterns:<br>  0x7030 0000 0002 <a href="reg:16">reg:16</a></p>
<p>MIPS FPU registers (see KVM_REG_MIPS_FPR_{32,64}() above) have the following<br>id bit patterns depending on the size of the register being accessed. They are<br>always accessed according to the current guest FPU mode (Status.FR and<br>Config5.FRE), i.e. as the guest would see them, and they become unpredictable<br>if the guest FPU mode is changed. MIPS SIMD Architecture (MSA) vector<br>registers (see KVM_REG_MIPS_VEC_128() above) have similar patterns as they<br>overlap the FPU registers:<br>  0x7020 0000 0003 00 &lt;0:3&gt; <a href="reg:5">reg:5</a> (32-bit FPU registers)<br>  0x7030 0000 0003 00 &lt;0:3&gt; <a href="reg:5">reg:5</a> (64-bit FPU registers)<br>  0x7040 0000 0003 00 &lt;0:3&gt; <a href="reg:5">reg:5</a> (128-bit MSA vector registers)</p>
<p>MIPS FPU control registers (see KVM_REG_MIPS_FCR_{IR,CSR} above) have the<br>following id bit patterns:<br>  0x7020 0000 0003 01 &lt;0:3&gt; <a href="reg:5">reg:5</a></p>
<p>MIPS MSA control registers (see KVM_REG_MIPS_MSA_{IR,CSR} above) have the<br>following id bit patterns:<br>  0x7020 0000 0003 02 &lt;0:3&gt; <a href="reg:5">reg:5</a></p>
<p>4.69 KVM_GET_ONE_REG</p>
<p>Capability: KVM_CAP_ONE_REG<br>Architectures: all<br>Type: vcpu ioctl<br>Parameters: struct kvm_one_reg (in and out)<br>Returns: 0 on success, negative value on failure</p>
<p>This ioctl allows to receive the value of a single register implemented<br>in a vcpu. The register to read is indicated by the “id” field of the<br>kvm_one_reg struct passed in. On success, the register value can be found<br>at the memory location pointed to by “addr”.</p>
<p>The list of registers accessible using this interface is identical to the<br>list in 4.68.</p>
<p>4.70 KVM_KVMCLOCK_CTRL</p>
<p>Capability: KVM_CAP_KVMCLOCK_CTRL<br>Architectures: Any that implement pvclocks (currently x86 only)<br>Type: vcpu ioctl<br>Parameters: None<br>Returns: 0 on success, -1 on error</p>
<p>This signals to the host kernel that the specified guest is being paused by<br>userspace.  The host will set a flag in the pvclock structure that is checked<br>from the soft lockup watchdog.  The flag is part of the pvclock structure that<br>is shared between guest and host, specifically the second bit of the flags<br>field of the pvclock_vcpu_time_info structure.  It will be set exclusively by<br>the host and read/cleared exclusively by the guest.  The guest operation of<br>checking and clearing the flag must an atomic operation so<br>load-link/store-conditional, or equivalent must be used.  There are two cases<br>where the guest will clear the flag: when the soft lockup watchdog timer resets<br>itself or when a soft lockup is detected.  This ioctl can be called any time<br>after pausing the vcpu, but before it is resumed.</p>
<p>4.71 KVM_SIGNAL_MSI</p>
<p>Capability: KVM_CAP_SIGNAL_MSI<br>Architectures: x86 arm arm64<br>Type: vm ioctl<br>Parameters: struct kvm_msi (in)<br>Returns: &gt;0 on delivery, 0 if guest blocked the MSI, and -1 on error</p>
<p>Directly inject a MSI message. Only valid with in-kernel irqchip that handles<br>MSI messages.</p>
<p>struct kvm_msi {<br>    __u32 address_lo;<br>    __u32 address_hi;<br>    __u32 data;<br>    __u32 flags;<br>    __u32 devid;<br>    __u8  pad[12];<br>};</p>
<p>flags: KVM_MSI_VALID_DEVID: devid contains a valid value.  The per-VM<br>  KVM_CAP_MSI_DEVID capability advertises the requirement to provide<br>  the device ID.  If this capability is not available, userspace<br>  should never set the KVM_MSI_VALID_DEVID flag as the ioctl might fail.</p>
<p>If KVM_MSI_VALID_DEVID is set, devid contains a unique device identifier<br>for the device that wrote the MSI message.  For PCI, this is usually a<br>BFD identifier in the lower 16 bits.</p>
<p>On x86, address_hi is ignored unless the KVM_X2APIC_API_USE_32BIT_IDS<br>feature of KVM_CAP_X2APIC_API capability is enabled.  If it is enabled,<br>address_hi bits 31-8 provide bits 31-8 of the destination id.  Bits 7-0 of<br>address_hi must be zero.</p>
<p>4.71 KVM_CREATE_PIT2</p>
<p>Capability: KVM_CAP_PIT2<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_pit_config (in)<br>Returns: 0 on success, -1 on error</p>
<p>Creates an in-kernel device model for the i8254 PIT. This call is only valid<br>after enabling in-kernel irqchip support via KVM_CREATE_IRQCHIP. The following<br>parameters have to be passed:</p>
<p>struct kvm_pit_config {<br>    __u32 flags;<br>    __u32 pad[15];<br>};</p>
<p>Valid flags are:</p>
<p>#define KVM_PIT_SPEAKER_DUMMY     1 /* emulate speaker port stub */</p>
<p>PIT timer interrupts may use a per-VM kernel thread for injection. If it<br>exists, this thread will have a name of the following pattern:</p>
<p>kvm-pit/<owner-process-pid></p>
<p>When running a guest with elevated priorities, the scheduling parameters of<br>this thread may have to be adjusted accordingly.</p>
<p>This IOCTL replaces the obsolete KVM_CREATE_PIT.</p>
<p>4.72 KVM_GET_PIT2</p>
<p>Capability: KVM_CAP_PIT_STATE2<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_pit_state2 (out)<br>Returns: 0 on success, -1 on error</p>
<p>Retrieves the state of the in-kernel PIT model. Only valid after<br>KVM_CREATE_PIT2. The state is returned in the following structure:</p>
<p>struct kvm_pit_state2 {<br>    struct kvm_pit_channel_state channels[3];<br>    __u32 flags;<br>    __u32 reserved[9];<br>};</p>
<p>Valid flags are:</p>
<p>/* disable PIT in HPET legacy mode */<br>#define KVM_PIT_FLAGS_HPET_LEGACY  0x00000001</p>
<p>This IOCTL replaces the obsolete KVM_GET_PIT.</p>
<p>4.73 KVM_SET_PIT2</p>
<p>Capability: KVM_CAP_PIT_STATE2<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_pit_state2 (in)<br>Returns: 0 on success, -1 on error</p>
<p>Sets the state of the in-kernel PIT model. Only valid after KVM_CREATE_PIT2.<br>See KVM_GET_PIT2 for details on struct kvm_pit_state2.</p>
<p>This IOCTL replaces the obsolete KVM_SET_PIT.</p>
<p>4.74 KVM_PPC_GET_SMMU_INFO</p>
<p>Capability: KVM_CAP_PPC_GET_SMMU_INFO<br>Architectures: powerpc<br>Type: vm ioctl<br>Parameters: None<br>Returns: 0 on success, -1 on error</p>
<p>This populates and returns a structure describing the features of<br>the “Server” class MMU emulation supported by KVM.<br>This can in turn be used by userspace to generate the appropriate<br>device-tree properties for the guest operating system.</p>
<p>The structure contains some global information, followed by an<br>array of supported segment page sizes:</p>
<pre><code>  struct kvm_ppc_smmu_info &#123;
     __u64 flags;
     __u32 slb_size;
     __u32 pad;
     struct kvm_ppc_one_seg_page_size sps[KVM_PPC_PAGE_SIZES_MAX_SZ];
  &#125;;
</code></pre>
<p>The supported flags are:</p>
<pre><code>- KVM_PPC_PAGE_SIZES_REAL:
    When that flag is set, guest page sizes must &quot;fit&quot; the backing
    store page sizes. When not set, any page size in the list can
    be used regardless of how they are backed by userspace.

- KVM_PPC_1T_SEGMENTS
    The emulated MMU supports 1T segments in addition to the
    standard 256M ones.

- KVM_PPC_NO_HASH
This flag indicates that HPT guests are not supported by KVM,
thus all guests must use radix MMU mode.
</code></pre>
<p>The “slb_size” field indicates how many SLB entries are supported</p>
<p>The “sps” array contains 8 entries indicating the supported base<br>page sizes for a segment in increasing order. Each entry is defined<br>as follow:</p>
<p>   struct kvm_ppc_one_seg_page_size {<br>    __u32 page_shift;    /* Base page shift of segment (or 0) <em>/<br>    __u32 slb_enc;        /</em> SLB encoding for BookS */<br>    struct kvm_ppc_one_page_size enc[KVM_PPC_PAGE_SIZES_MAX_SZ];<br>   };</p>
<p>An entry with a “page_shift” of 0 is unused. Because the array is<br>organized in increasing order, a lookup can stop when encoutering<br>such an entry.</p>
<p>The “slb_enc” field provides the encoding to use in the SLB for the<br>page size. The bits are in positions such as the value can directly<br>be OR’ed into the “vsid” argument of the slbmte instruction.</p>
<p>The “enc” array is a list which for each of those segment base page<br>size provides the list of supported actual page sizes (which can be<br>only larger or equal to the base page size), along with the<br>corresponding encoding in the hash PTE. Similarly, the array is<br>8 entries sorted by increasing sizes and an entry with a “0” shift<br>is an empty entry and a terminator:</p>
<p>   struct kvm_ppc_one_page_size {<br>    __u32 page_shift;    /* Page shift (or 0) <em>/<br>    __u32 pte_enc;        /</em> Encoding in the HPTE (&gt;&gt;12) */<br>   };</p>
<p>The “pte_enc” field provides a value that can OR’ed into the hash<br>PTE’s RPN field (ie, it needs to be shifted left by 12 to OR it<br>into the hash PTE second double word).</p>
<p>4.75 KVM_IRQFD</p>
<p>Capability: KVM_CAP_IRQFD<br>Architectures: x86 s390 arm arm64<br>Type: vm ioctl<br>Parameters: struct kvm_irqfd (in)<br>Returns: 0 on success, -1 on error</p>
<p>Allows setting an eventfd to directly trigger a guest interrupt.<br>kvm_irqfd.fd specifies the file descriptor to use as the eventfd and<br>kvm_irqfd.gsi specifies the irqchip pin toggled by this event.  When<br>an event is triggered on the eventfd, an interrupt is injected into<br>the guest using the specified gsi pin.  The irqfd is removed using<br>the KVM_IRQFD_FLAG_DEASSIGN flag, specifying both kvm_irqfd.fd<br>and kvm_irqfd.gsi.</p>
<p>With KVM_CAP_IRQFD_RESAMPLE, KVM_IRQFD supports a de-assert and notify<br>mechanism allowing emulation of level-triggered, irqfd-based<br>interrupts.  When KVM_IRQFD_FLAG_RESAMPLE is set the user must pass an<br>additional eventfd in the kvm_irqfd.resamplefd field.  When operating<br>in resample mode, posting of an interrupt through kvm_irq.fd asserts<br>the specified gsi in the irqchip.  When the irqchip is resampled, such<br>as from an EOI, the gsi is de-asserted and the user is notified via<br>kvm_irqfd.resamplefd.  It is the user’s responsibility to re-queue<br>the interrupt if the device making use of it still requires service.<br>Note that closing the resamplefd is not sufficient to disable the<br>irqfd.  The KVM_IRQFD_FLAG_RESAMPLE is only necessary on assignment<br>and need not be specified with KVM_IRQFD_FLAG_DEASSIGN.</p>
<p>On arm/arm64, gsi routing being supported, the following can happen:</p>
<ul>
<li>in case no routing entry is associated to this gsi, injection fails</li>
<li>in case the gsi is associated to an irqchip routing entry,<br>irqchip.pin + 32 corresponds to the injected SPI ID.</li>
<li>in case the gsi is associated to an MSI routing entry, the MSI<br>message and device ID are translated into an LPI (support restricted<br>to GICv3 ITS in-kernel emulation).</li>
</ul>
<p>4.76 KVM_PPC_ALLOCATE_HTAB</p>
<p>Capability: KVM_CAP_PPC_ALLOC_HTAB<br>Architectures: powerpc<br>Type: vm ioctl<br>Parameters: Pointer to u32 containing hash table order (in/out)<br>Returns: 0 on success, -1 on error</p>
<p>This requests the host kernel to allocate an MMU hash table for a<br>guest using the PAPR paravirtualization interface.  This only does<br>anything if the kernel is configured to use the Book 3S HV style of<br>virtualization.  Otherwise the capability doesn’t exist and the ioctl<br>returns an ENOTTY error.  The rest of this description assumes Book 3S<br>HV.</p>
<p>There must be no vcpus running when this ioctl is called; if there<br>are, it will do nothing and return an EBUSY error.</p>
<p>The parameter is a pointer to a 32-bit unsigned integer variable<br>containing the order (log base 2) of the desired size of the hash<br>table, which must be between 18 and 46.  On successful return from the<br>ioctl, the value will not be changed by the kernel.</p>
<p>If no hash table has been allocated when any vcpu is asked to run<br>(with the KVM_RUN ioctl), the host kernel will allocate a<br>default-sized hash table (16 MB).</p>
<p>If this ioctl is called when a hash table has already been allocated,<br>with a different order from the existing hash table, the existing hash<br>table will be freed and a new one allocated.  If this is ioctl is<br>called when a hash table has already been allocated of the same order<br>as specified, the kernel will clear out the existing hash table (zero<br>all HPTEs).  In either case, if the guest is using the virtualized<br>real-mode area (VRMA) facility, the kernel will re-create the VMRA<br>HPTEs on the next KVM_RUN of any vcpu.</p>
<p>4.77 KVM_S390_INTERRUPT</p>
<p>Capability: basic<br>Architectures: s390<br>Type: vm ioctl, vcpu ioctl<br>Parameters: struct kvm_s390_interrupt (in)<br>Returns: 0 on success, -1 on error</p>
<p>Allows to inject an interrupt to the guest. Interrupts can be floating<br>(vm ioctl) or per cpu (vcpu ioctl), depending on the interrupt type.</p>
<p>Interrupt parameters are passed via kvm_s390_interrupt:</p>
<p>struct kvm_s390_interrupt {<br>    __u32 type;<br>    __u32 parm;<br>    __u64 parm64;<br>};</p>
<p>type can be one of the following:</p>
<p>KVM_S390_SIGP_STOP (vcpu) - sigp stop; optional flags in parm<br>KVM_S390_PROGRAM_INT (vcpu) - program check; code in parm<br>KVM_S390_SIGP_SET_PREFIX (vcpu) - sigp set prefix; prefix address in parm<br>KVM_S390_RESTART (vcpu) - restart<br>KVM_S390_INT_CLOCK_COMP (vcpu) - clock comparator interrupt<br>KVM_S390_INT_CPU_TIMER (vcpu) - CPU timer interrupt<br>KVM_S390_INT_VIRTIO (vm) - virtio external interrupt; external interrupt<br>               parameters in parm and parm64<br>KVM_S390_INT_SERVICE (vm) - sclp external interrupt; sclp parameter in parm<br>KVM_S390_INT_EMERGENCY (vcpu) - sigp emergency; source cpu in parm<br>KVM_S390_INT_EXTERNAL_CALL (vcpu) - sigp external call; source cpu in parm<br>KVM_S390_INT_IO(ai,cssid,ssid,schid) (vm) - compound value to indicate an<br>    I/O interrupt (ai - adapter interrupt; cssid,ssid,schid - subchannel);<br>    I/O interruption parameters in parm (subchannel) and parm64 (intparm,<br>    interruption subclass)<br>KVM_S390_MCHK (vm, vcpu) - machine check interrupt; cr 14 bits in parm,<br>                           machine check interrupt code in parm64 (note that<br>                           machine checks needing further payload are not<br>                           supported by this ioctl)</p>
<p>Note that the vcpu ioctl is asynchronous to vcpu execution.</p>
<p>4.78 KVM_PPC_GET_HTAB_FD</p>
<p>Capability: KVM_CAP_PPC_HTAB_FD<br>Architectures: powerpc<br>Type: vm ioctl<br>Parameters: Pointer to struct kvm_get_htab_fd (in)<br>Returns: file descriptor number (&gt;= 0) on success, -1 on error</p>
<p>This returns a file descriptor that can be used either to read out the<br>entries in the guest’s hashed page table (HPT), or to write entries to<br>initialize the HPT.  The returned fd can only be written to if the<br>KVM_GET_HTAB_WRITE bit is set in the flags field of the argument, and<br>can only be read if that bit is clear.  The argument struct looks like<br>this:</p>
<p>/* For KVM_PPC_GET_HTAB_FD */<br>struct kvm_get_htab_fd {<br>    __u64    flags;<br>    __u64    start_index;<br>    __u64    reserved[2];<br>};</p>
<p>/* Values for kvm_get_htab_fd.flags */<br>#define KVM_GET_HTAB_BOLTED_ONLY    ((__u64)0x1)<br>#define KVM_GET_HTAB_WRITE        ((__u64)0x2)</p>
<p>The `start_index’ field gives the index in the HPT of the entry at<br>which to start reading.  It is ignored when writing.</p>
<p>Reads on the fd will initially supply information about all<br>“interesting” HPT entries.  Interesting entries are those with the<br>bolted bit set, if the KVM_GET_HTAB_BOLTED_ONLY bit is set, otherwise<br>all entries.  When the end of the HPT is reached, the read() will<br>return.  If read() is called again on the fd, it will start again from<br>the beginning of the HPT, but will only return HPT entries that have<br>changed since they were last read.</p>
<p>Data read or written is structured as a header (8 bytes) followed by a<br>series of valid HPT entries (16 bytes) each.  The header indicates how<br>many valid HPT entries there are and how many invalid entries follow<br>the valid entries.  The invalid entries are not represented explicitly<br>in the stream.  The header format is:</p>
<p>struct kvm_get_htab_header {<br>    __u32    index;<br>    __u16    n_valid;<br>    __u16    n_invalid;<br>};</p>
<p>Writes to the fd create HPT entries starting at the index given in the<br>header; first <code>n_valid&#39; valid entries with contents from the data written, then </code>n_invalid’ invalid entries, invalidating any previously<br>valid entries found.</p>
<p>4.79 KVM_CREATE_DEVICE</p>
<p>Capability: KVM_CAP_DEVICE_CTRL<br>Type: vm ioctl<br>Parameters: struct kvm_create_device (in/out)<br>Returns: 0 on success, -1 on error<br>Errors:<br>  ENODEV: The device type is unknown or unsupported<br>  EEXIST: Device already created, and this type of device may not<br>          be instantiated multiple times</p>
<p>  Other error conditions may be defined by individual device types or<br>  have their standard meanings.</p>
<p>Creates an emulated device in the kernel.  The file descriptor returned<br>in fd can be used with KVM_SET/GET/HAS_DEVICE_ATTR.</p>
<p>If the KVM_CREATE_DEVICE_TEST flag is set, only test whether the<br>device type is supported (not necessarily whether it can be created<br>in the current vm).</p>
<p>Individual devices should not define flags.  Attributes should be used<br>for specifying any behavior that is not implied by the device type<br>number.</p>
<p>struct kvm_create_device {<br>    __u32    type;    /* in: KVM_DEV_TYPE_xxx <em>/<br>    __u32    fd;    /</em> out: device handle <em>/<br>    __u32    flags;    /</em> in: KVM_CREATE_DEVICE_xxx */<br>};</p>
<p>4.80 KVM_SET_DEVICE_ATTR/KVM_GET_DEVICE_ATTR</p>
<p>Capability: KVM_CAP_DEVICE_CTRL, KVM_CAP_VM_ATTRIBUTES for vm device,<br>  KVM_CAP_VCPU_ATTRIBUTES for vcpu device<br>Type: device ioctl, vm ioctl, vcpu ioctl<br>Parameters: struct kvm_device_attr<br>Returns: 0 on success, -1 on error<br>Errors:<br>  ENXIO:  The group or attribute is unknown/unsupported for this device<br>          or hardware support is missing.<br>  EPERM:  The attribute cannot (currently) be accessed this way<br>          (e.g. read-only attribute, or attribute that only makes<br>          sense when the device is in a different state)</p>
<p>  Other error conditions may be defined by individual device types.</p>
<p>Gets/sets a specified piece of device configuration and/or state.  The<br>semantics are device-specific.  See individual device documentation in<br>the “devices” directory.  As with ONE_REG, the size of the data<br>transferred is defined by the particular attribute.</p>
<p>struct kvm_device_attr {<br>    __u32    flags;        /* no flags currently defined <em>/<br>    __u32    group;        /</em> device-defined <em>/<br>    __u64    attr;        /</em> group-defined <em>/<br>    __u64    addr;        /</em> userspace address of attr data */<br>};</p>
<p>4.81 KVM_HAS_DEVICE_ATTR</p>
<p>Capability: KVM_CAP_DEVICE_CTRL, KVM_CAP_VM_ATTRIBUTES for vm device,<br>  KVM_CAP_VCPU_ATTRIBUTES for vcpu device<br>Type: device ioctl, vm ioctl, vcpu ioctl<br>Parameters: struct kvm_device_attr<br>Returns: 0 on success, -1 on error<br>Errors:<br>  ENXIO:  The group or attribute is unknown/unsupported for this device<br>          or hardware support is missing.</p>
<p>Tests whether a device supports a particular attribute.  A successful<br>return indicates the attribute is implemented.  It does not necessarily<br>indicate that the attribute can be read or written in the device’s<br>current state.  “addr” is ignored.</p>
<p>4.82 KVM_ARM_VCPU_INIT</p>
<p>Capability: basic<br>Architectures: arm, arm64<br>Type: vcpu ioctl<br>Parameters: struct kvm_vcpu_init (in)<br>Returns: 0 on success; -1 on error<br>Errors:<br> Â EINVAL: Â Â Â the target is unknown, or the combination of features is invalid.<br> Â ENOENT: Â Â Â a features bit specified is unknown.</p>
<p>This tells KVM what type of CPU to present to the guest, and what<br>optional features it should have. Â This will cause a reset of the cpu<br>registers to their initial values. Â If this is not called, KVM_RUN will<br>return ENOEXEC for that vcpu.</p>
<p>Note that because some registers reflect machine topology, all vcpus<br>should be created before this ioctl is invoked.</p>
<p>Userspace can call this function multiple times for a given vcpu, including<br>after the vcpu has been run. This will reset the vcpu to its initial<br>state. All calls to this function after the initial call must use the same<br>target and same set of feature flags, otherwise EINVAL will be returned.</p>
<p>Possible features:<br>    - KVM_ARM_VCPU_POWER_OFF: Starts the CPU in a power-off state.<br>      Depends on KVM_CAP_ARM_PSCI.  If not set, the CPU will be powered on<br>      and execute guest code when KVM_RUN is called.<br>    - KVM_ARM_VCPU_EL1_32BIT: Starts the CPU in a 32bit mode.<br>      Depends on KVM_CAP_ARM_EL1_32BIT (arm64 only).<br>    - KVM_ARM_VCPU_PSCI_0_2: Emulate PSCI v0.2 (or a future revision<br>          backward compatible with v0.2) for the CPU.<br>      Depends on KVM_CAP_ARM_PSCI_0_2.<br>    - KVM_ARM_VCPU_PMU_V3: Emulate PMUv3 for the CPU.<br>      Depends on KVM_CAP_ARM_PMU_V3.</p>
<p>4.83 KVM_ARM_PREFERRED_TARGET</p>
<p>Capability: basic<br>Architectures: arm, arm64<br>Type: vm ioctl<br>Parameters: struct struct kvm_vcpu_init (out)<br>Returns: 0 on success; -1 on error<br>Errors:<br>  ENODEV:    no preferred target available for the host</p>
<p>This queries KVM for preferred CPU target type which can be emulated<br>by KVM on underlying host.</p>
<p>The ioctl returns struct kvm_vcpu_init instance containing information<br>about preferred CPU target type and recommended features for it.  The<br>kvm_vcpu_init-&gt;features bitmap returned will have feature bits set if<br>the preferred target recommends setting these features, but this is<br>not mandatory.</p>
<p>The information returned by this ioctl can be used to prepare an instance<br>of struct kvm_vcpu_init for KVM_ARM_VCPU_INIT ioctl which will result in<br>in VCPU matching underlying host.</p>
<p>4.84 KVM_GET_REG_LIST</p>
<p>Capability: basic<br>Architectures: arm, arm64, mips<br>Type: vcpu ioctl<br>Parameters: struct kvm_reg_list (in/out)<br>Returns: 0 on success; -1 on error<br>Errors:<br> Â E2BIG: Â Â Â Â the reg index list is too big to fit in the array specified by<br> Â Â Â Â Â Â Â Â Â Â Â Â the user (the number required will be written into n).</p>
<p>struct kvm_reg_list {<br>    __u64 n; /* number of registers in reg[] */<br>    __u64 reg[0];<br>};</p>
<p>This ioctl returns the guest registers that are supported for the<br>KVM_GET_ONE_REG/KVM_SET_ONE_REG calls.</p>
<p>4.85 KVM_ARM_SET_DEVICE_ADDR (deprecated)</p>
<p>Capability: KVM_CAP_ARM_SET_DEVICE_ADDR<br>Architectures: arm, arm64<br>Type: vm ioctl<br>Parameters: struct kvm_arm_device_address (in)<br>Returns: 0 on success, -1 on error<br>Errors:<br>  ENODEV: The device id is unknown<br>  ENXIO:  Device not supported on current system<br>  EEXIST: Address already set<br>  E2BIG:  Address outside guest physical address space<br>  EBUSY:  Address overlaps with other device range</p>
<p>struct kvm_arm_device_addr {<br>    __u64 id;<br>    __u64 addr;<br>};</p>
<p>Specify a device address in the guest’s physical address space where guests<br>can access emulated or directly exposed devices, which the host kernel needs<br>to know about. The id field is an architecture specific identifier for a<br>specific device.</p>
<p>ARM/arm64 divides the id field into two parts, a device id and an<br>address type id specific to the individual device.</p>
<p> Â bits:  | 63        …       32 | 31    …    16 | 15    …    0 |<br>  field: |        0x00000000      |     device id   |  addr type id  |</p>
<p>ARM/arm64 currently only require this when using the in-kernel GIC<br>support for the hardware VGIC features, using KVM_ARM_DEVICE_VGIC_V2<br>as the device id.  When setting the base address for the guest’s<br>mapping of the VGIC virtual CPU and distributor interface, the ioctl<br>must be called after calling KVM_CREATE_IRQCHIP, but before calling<br>KVM_RUN on any of the VCPUs.  Calling this ioctl twice for any of the<br>base addresses will return -EEXIST.</p>
<p>Note, this IOCTL is deprecated and the more flexible SET/GET_DEVICE_ATTR API<br>should be used instead.</p>
<p>4.86 KVM_PPC_RTAS_DEFINE_TOKEN</p>
<p>Capability: KVM_CAP_PPC_RTAS<br>Architectures: ppc<br>Type: vm ioctl<br>Parameters: struct kvm_rtas_token_args<br>Returns: 0 on success, -1 on error</p>
<p>Defines a token value for a RTAS (Run Time Abstraction Services)<br>service in order to allow it to be handled in the kernel.  The<br>argument struct gives the name of the service, which must be the name<br>of a service that has a kernel-side implementation.  If the token<br>value is non-zero, it will be associated with that service, and<br>subsequent RTAS calls by the guest specifying that token will be<br>handled by the kernel.  If the token value is 0, then any token<br>associated with the service will be forgotten, and subsequent RTAS<br>calls by the guest for that service will be passed to userspace to be<br>handled.</p>
<p>4.87 KVM_SET_GUEST_DEBUG</p>
<p>Capability: KVM_CAP_SET_GUEST_DEBUG<br>Architectures: x86, s390, ppc, arm64<br>Type: vcpu ioctl<br>Parameters: struct kvm_guest_debug (in)<br>Returns: 0 on success; -1 on error</p>
<p>struct kvm_guest_debug {<br>       __u32 control;<br>       __u32 pad;<br>       struct kvm_guest_debug_arch arch;<br>};</p>
<p>Set up the processor specific debug registers and configure vcpu for<br>handling guest debug events. There are two parts to the structure, the<br>first a control bitfield indicates the type of debug events to handle<br>when running. Common control bits are:</p>
<ul>
<li>KVM_GUESTDBG_ENABLE:        guest debugging is enabled</li>
<li>KVM_GUESTDBG_SINGLESTEP:    the next run should single-step</li>
</ul>
<p>The top 16 bits of the control field are architecture specific control<br>flags which can include the following:</p>
<ul>
<li>KVM_GUESTDBG_USE_SW_BP:     using software breakpoints [x86, arm64]</li>
<li>KVM_GUESTDBG_USE_HW_BP:     using hardware breakpoints [x86, s390, arm64]</li>
<li>KVM_GUESTDBG_INJECT_DB:     inject DB type exception [x86]</li>
<li>KVM_GUESTDBG_INJECT_BP:     inject BP type exception [x86]</li>
<li>KVM_GUESTDBG_EXIT_PENDING:  trigger an immediate guest exit [s390]</li>
</ul>
<p>For example KVM_GUESTDBG_USE_SW_BP indicates that software breakpoints<br>are enabled in memory so we need to ensure breakpoint exceptions are<br>correctly trapped and the KVM run loop exits at the breakpoint and not<br>running off into the normal guest vector. For KVM_GUESTDBG_USE_HW_BP<br>we need to ensure the guest vCPUs architecture specific registers are<br>updated to the correct (supplied) values.</p>
<p>The second part of the structure is architecture specific and<br>typically contains a set of debug registers.</p>
<p>For arm64 the number of debug registers is implementation defined and<br>can be determined by querying the KVM_CAP_GUEST_DEBUG_HW_BPS and<br>KVM_CAP_GUEST_DEBUG_HW_WPS capabilities which return a positive number<br>indicating the number of supported registers.</p>
<p>When debug events exit the main run loop with the reason<br>KVM_EXIT_DEBUG with the kvm_debug_exit_arch part of the kvm_run<br>structure containing architecture specific debug information.</p>
<p>4.88 KVM_GET_EMULATED_CPUID</p>
<p>Capability: KVM_CAP_EXT_EMUL_CPUID<br>Architectures: x86<br>Type: system ioctl<br>Parameters: struct kvm_cpuid2 (in/out)<br>Returns: 0 on success, -1 on error</p>
<p>struct kvm_cpuid2 {<br>    __u32 nent;<br>    __u32 flags;<br>    struct kvm_cpuid_entry2 entries[0];<br>};</p>
<p>The member ‘flags’ is used for passing flags from userspace.</p>
<p>#define KVM_CPUID_FLAG_SIGNIFCANT_INDEX        BIT(0)<br>#define KVM_CPUID_FLAG_STATEFUL_FUNC        BIT(1)<br>#define KVM_CPUID_FLAG_STATE_READ_NEXT        BIT(2)</p>
<p>struct kvm_cpuid_entry2 {<br>    __u32 function;<br>    __u32 index;<br>    __u32 flags;<br>    __u32 eax;<br>    __u32 ebx;<br>    __u32 ecx;<br>    __u32 edx;<br>    __u32 padding[3];<br>};</p>
<p>This ioctl returns x86 cpuid features which are emulated by<br>kvm.Userspace can use the information returned by this ioctl to query<br>which features are emulated by kvm instead of being present natively.</p>
<p>Userspace invokes KVM_GET_EMULATED_CPUID by passing a kvm_cpuid2<br>structure with the ‘nent’ field indicating the number of entries in<br>the variable-size array ‘entries’. If the number of entries is too low<br>to describe the cpu capabilities, an error (E2BIG) is returned. If the<br>number is too high, the ‘nent’ field is adjusted and an error (ENOMEM)<br>is returned. If the number is just right, the ‘nent’ field is adjusted<br>to the number of valid entries in the ‘entries’ array, which is then<br>filled.</p>
<p>The entries returned are the set CPUID bits of the respective features<br>which kvm emulates, as returned by the CPUID instruction, with unknown<br>or unsupported feature bits cleared.</p>
<p>Features like x2apic, for example, may not be present in the host cpu<br>but are exposed by kvm in KVM_GET_SUPPORTED_CPUID because they can be<br>emulated efficiently and thus not included here.</p>
<p>The fields in each entry are defined as follows:</p>
<p>  function: the eax value used to obtain the entry<br>  index: the ecx value used to obtain the entry (for entries that are<br>         affected by ecx)<br>  flags: an OR of zero or more of the following:<br>        KVM_CPUID_FLAG_SIGNIFCANT_INDEX:<br>           if the index field is valid<br>        KVM_CPUID_FLAG_STATEFUL_FUNC:<br>           if cpuid for this function returns different values for successive<br>           invocations; there will be several entries with the same function,<br>           all with this flag set<br>        KVM_CPUID_FLAG_STATE_READ_NEXT:<br>           for KVM_CPUID_FLAG_STATEFUL_FUNC entries, set if this entry is<br>           the first entry to be read by a cpu<br>   eax, ebx, ecx, edx: the values returned by the cpuid instruction for<br>         this function/index combination</p>
<p>4.89 KVM_S390_MEM_OP</p>
<p>Capability: KVM_CAP_S390_MEM_OP<br>Architectures: s390<br>Type: vcpu ioctl<br>Parameters: struct kvm_s390_mem_op (in)<br>Returns: = 0 on success,<br>         &lt; 0 on generic error (e.g. -EFAULT or -ENOMEM),<br>         &gt; 0 if an exception occurred while walking the page tables</p>
<p>Read or write data from/to the logical (virtual) memory of a VCPU.</p>
<p>Parameters are specified via the following structure:</p>
<p>struct kvm_s390_mem_op {<br>    __u64 gaddr;        /* the guest address <em>/<br>    __u64 flags;        /</em> flags <em>/<br>    __u32 size;        /</em> amount of bytes <em>/<br>    __u32 op;        /</em> type of operation <em>/<br>    __u64 buf;        /</em> buffer in userspace <em>/<br>    __u8 ar;        /</em> the access register number <em>/<br>    __u8 reserved[31];    /</em> should be set to 0 */<br>};</p>
<p>The type of operation is specified in the “op” field. It is either<br>KVM_S390_MEMOP_LOGICAL_READ for reading from logical memory space or<br>KVM_S390_MEMOP_LOGICAL_WRITE for writing to logical memory space. The<br>KVM_S390_MEMOP_F_CHECK_ONLY flag can be set in the “flags” field to check<br>whether the corresponding memory access would create an access exception<br>(without touching the data in the memory at the destination). In case an<br>access exception occurred while walking the MMU tables of the guest, the<br>ioctl returns a positive error number to indicate the type of exception.<br>This exception is also raised directly at the corresponding VCPU if the<br>flag KVM_S390_MEMOP_F_INJECT_EXCEPTION is set in the “flags” field.</p>
<p>The start address of the memory region has to be specified in the “gaddr”<br>field, and the length of the region in the “size” field. “buf” is the buffer<br>supplied by the userspace application where the read data should be written<br>to for KVM_S390_MEMOP_LOGICAL_READ, or where the data that should be written<br>is stored for a KVM_S390_MEMOP_LOGICAL_WRITE. “buf” is unused and can be NULL<br>when KVM_S390_MEMOP_F_CHECK_ONLY is specified. “ar” designates the access<br>register number to be used.</p>
<p>The “reserved” field is meant for future extensions. It is not used by<br>KVM with the currently defined set of flags.</p>
<p>4.90 KVM_S390_GET_SKEYS</p>
<p>Capability: KVM_CAP_S390_SKEYS<br>Architectures: s390<br>Type: vm ioctl<br>Parameters: struct kvm_s390_skeys<br>Returns: 0 on success, KVM_S390_GET_KEYS_NONE if guest is not using storage<br>         keys, negative value on error</p>
<p>This ioctl is used to get guest storage key values on the s390<br>architecture. The ioctl takes parameters via the kvm_s390_skeys struct.</p>
<p>struct kvm_s390_skeys {<br>    __u64 start_gfn;<br>    __u64 count;<br>    __u64 skeydata_addr;<br>    __u32 flags;<br>    __u32 reserved[9];<br>};</p>
<p>The start_gfn field is the number of the first guest frame whose storage keys<br>you want to get.</p>
<p>The count field is the number of consecutive frames (starting from start_gfn)<br>whose storage keys to get. The count field must be at least 1 and the maximum<br>allowed value is defined as KVM_S390_SKEYS_ALLOC_MAX. Values outside this range<br>will cause the ioctl to return -EINVAL.</p>
<p>The skeydata_addr field is the address to a buffer large enough to hold count<br>bytes. This buffer will be filled with storage key data by the ioctl.</p>
<p>4.91 KVM_S390_SET_SKEYS</p>
<p>Capability: KVM_CAP_S390_SKEYS<br>Architectures: s390<br>Type: vm ioctl<br>Parameters: struct kvm_s390_skeys<br>Returns: 0 on success, negative value on error</p>
<p>This ioctl is used to set guest storage key values on the s390<br>architecture. The ioctl takes parameters via the kvm_s390_skeys struct.<br>See section on KVM_S390_GET_SKEYS for struct definition.</p>
<p>The start_gfn field is the number of the first guest frame whose storage keys<br>you want to set.</p>
<p>The count field is the number of consecutive frames (starting from start_gfn)<br>whose storage keys to get. The count field must be at least 1 and the maximum<br>allowed value is defined as KVM_S390_SKEYS_ALLOC_MAX. Values outside this range<br>will cause the ioctl to return -EINVAL.</p>
<p>The skeydata_addr field is the address to a buffer containing count bytes of<br>storage keys. Each byte in the buffer will be set as the storage key for a<br>single frame starting at start_gfn for count frames.</p>
<p>Note: If any architecturally invalid key value is found in the given data then<br>the ioctl will return -EINVAL.</p>
<p>4.92 KVM_S390_IRQ</p>
<p>Capability: KVM_CAP_S390_INJECT_IRQ<br>Architectures: s390<br>Type: vcpu ioctl<br>Parameters: struct kvm_s390_irq (in)<br>Returns: 0 on success, -1 on error<br>Errors:<br>  EINVAL: interrupt type is invalid<br>          type is KVM_S390_SIGP_STOP and flag parameter is invalid value<br>          type is KVM_S390_INT_EXTERNAL_CALL and code is bigger<br>            than the maximum of VCPUs<br>  EBUSY:  type is KVM_S390_SIGP_SET_PREFIX and vcpu is not stopped<br>          type is KVM_S390_SIGP_STOP and a stop irq is already pending<br>          type is KVM_S390_INT_EXTERNAL_CALL and an external call interrupt<br>            is already pending</p>
<p>Allows to inject an interrupt to the guest.</p>
<p>Using struct kvm_s390_irq as a parameter allows<br>to inject additional payload which is not<br>possible via KVM_S390_INTERRUPT.</p>
<p>Interrupt parameters are passed via kvm_s390_irq:</p>
<p>struct kvm_s390_irq {<br>    __u64 type;<br>    union {<br>        struct kvm_s390_io_info io;<br>        struct kvm_s390_ext_info ext;<br>        struct kvm_s390_pgm_info pgm;<br>        struct kvm_s390_emerg_info emerg;<br>        struct kvm_s390_extcall_info extcall;<br>        struct kvm_s390_prefix_info prefix;<br>        struct kvm_s390_stop_info stop;<br>        struct kvm_s390_mchk_info mchk;<br>        char reserved[64];<br>    } u;<br>};</p>
<p>type can be one of the following:</p>
<p>KVM_S390_SIGP_STOP - sigp stop; parameter in .stop<br>KVM_S390_PROGRAM_INT - program check; parameters in .pgm<br>KVM_S390_SIGP_SET_PREFIX - sigp set prefix; parameters in .prefix<br>KVM_S390_RESTART - restart; no parameters<br>KVM_S390_INT_CLOCK_COMP - clock comparator interrupt; no parameters<br>KVM_S390_INT_CPU_TIMER - CPU timer interrupt; no parameters<br>KVM_S390_INT_EMERGENCY - sigp emergency; parameters in .emerg<br>KVM_S390_INT_EXTERNAL_CALL - sigp external call; parameters in .extcall<br>KVM_S390_MCHK - machine check interrupt; parameters in .mchk</p>
<p>Note that the vcpu ioctl is asynchronous to vcpu execution.</p>
<p>4.94 KVM_S390_GET_IRQ_STATE</p>
<p>Capability: KVM_CAP_S390_IRQ_STATE<br>Architectures: s390<br>Type: vcpu ioctl<br>Parameters: struct kvm_s390_irq_state (out)<br>Returns: &gt;= number of bytes copied into buffer,<br>         -EINVAL if buffer size is 0,<br>         -ENOBUFS if buffer size is too small to fit all pending interrupts,<br>         -EFAULT if the buffer address was invalid</p>
<p>This ioctl allows userspace to retrieve the complete state of all currently<br>pending interrupts in a single buffer. Use cases include migration<br>and introspection. The parameter structure contains the address of a<br>userspace buffer and its length:</p>
<p>struct kvm_s390_irq_state {<br>    __u64 buf;<br>    __u32 flags;        /* will stay unused for compatibility reasons <em>/<br>    __u32 len;<br>    __u32 reserved[4];  /</em> will stay unused for compatibility reasons */<br>};</p>
<p>Userspace passes in the above struct and for each pending interrupt a<br>struct kvm_s390_irq is copied to the provided buffer.</p>
<p>The structure contains a flags and a reserved field for future extensions. As<br>the kernel never checked for flags == 0 and QEMU never pre-zeroed flags and<br>reserved, these fields can not be used in the future without breaking<br>compatibility.</p>
<p>If -ENOBUFS is returned the buffer provided was too small and userspace<br>may retry with a bigger buffer.</p>
<p>4.95 KVM_S390_SET_IRQ_STATE</p>
<p>Capability: KVM_CAP_S390_IRQ_STATE<br>Architectures: s390<br>Type: vcpu ioctl<br>Parameters: struct kvm_s390_irq_state (in)<br>Returns: 0 on success,<br>         -EFAULT if the buffer address was invalid,<br>         -EINVAL for an invalid buffer length (see below),<br>         -EBUSY if there were already interrupts pending,<br>         errors occurring when actually injecting the<br>          interrupt. See KVM_S390_IRQ.</p>
<p>This ioctl allows userspace to set the complete state of all cpu-local<br>interrupts currently pending for the vcpu. It is intended for restoring<br>interrupt state after a migration. The input parameter is a userspace buffer<br>containing a struct kvm_s390_irq_state:</p>
<p>struct kvm_s390_irq_state {<br>    __u64 buf;<br>    __u32 flags;        /* will stay unused for compatibility reasons <em>/<br>    __u32 len;<br>    __u32 reserved[4];  /</em> will stay unused for compatibility reasons */<br>};</p>
<p>The restrictions for flags and reserved apply as well.<br>(see KVM_S390_GET_IRQ_STATE)</p>
<p>The userspace memory referenced by buf contains a struct kvm_s390_irq<br>for each interrupt to be injected into the guest.<br>If one of the interrupts could not be injected for some reason the<br>ioctl aborts.</p>
<p>len must be a multiple of sizeof(struct kvm_s390_irq). It must be &gt; 0<br>and it must not exceed (max_vcpus + 32) * sizeof(struct kvm_s390_irq),<br>which is the maximum number of possibly pending cpu-local interrupts.</p>
<p>4.96 KVM_SMI</p>
<p>Capability: KVM_CAP_X86_SMM<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: none<br>Returns: 0 on success, -1 on error</p>
<p>Queues an SMI on the thread’s vcpu.</p>
<p>4.97 KVM_CAP_PPC_MULTITCE</p>
<p>Capability: KVM_CAP_PPC_MULTITCE<br>Architectures: ppc<br>Type: vm</p>
<p>This capability means the kernel is capable of handling hypercalls<br>H_PUT_TCE_INDIRECT and H_STUFF_TCE without passing those into the user<br>space. This significantly accelerates DMA operations for PPC KVM guests.<br>User space should expect that its handlers for these hypercalls<br>are not going to be called if user space previously registered LIOBN<br>in KVM (via KVM_CREATE_SPAPR_TCE or similar calls).</p>
<p>In order to enable H_PUT_TCE_INDIRECT and H_STUFF_TCE use in the guest,<br>user space might have to advertise it for the guest. For example,<br>IBM pSeries (sPAPR) guest starts using them if “hcall-multi-tce” is<br>present in the “ibm,hypertas-functions” device-tree property.</p>
<p>The hypercalls mentioned above may or may not be processed successfully<br>in the kernel based fast path. If they can not be handled by the kernel,<br>they will get passed on to user space. So user space still has to have<br>an implementation for these despite the in kernel acceleration.</p>
<p>This capability is always enabled.</p>
<p>4.98 KVM_CREATE_SPAPR_TCE_64</p>
<p>Capability: KVM_CAP_SPAPR_TCE_64<br>Architectures: powerpc<br>Type: vm ioctl<br>Parameters: struct kvm_create_spapr_tce_64 (in)<br>Returns: file descriptor for manipulating the created TCE table</p>
<p>This is an extension for KVM_CAP_SPAPR_TCE which only supports 32bit<br>windows, described in 4.62 KVM_CREATE_SPAPR_TCE</p>
<p>This capability uses extended struct in ioctl interface:</p>
<p>/* for KVM_CAP_SPAPR_TCE_64 <em>/<br>struct kvm_create_spapr_tce_64 {<br>    __u64 liobn;<br>    __u32 page_shift;<br>    __u32 flags;<br>    __u64 offset;    /</em> in pages <em>/<br>    __u64 size;     /</em> in pages */<br>};</p>
<p>The aim of extension is to support an additional bigger DMA window with<br>a variable page size.<br>KVM_CREATE_SPAPR_TCE_64 receives a 64bit window size, an IOMMU page shift and<br>a bus offset of the corresponding DMA window, @size and @offset are numbers<br>of IOMMU pages.</p>
<p>@flags are not used at the moment.</p>
<p>The rest of functionality is identical to KVM_CREATE_SPAPR_TCE.</p>
<p>4.99 KVM_REINJECT_CONTROL</p>
<p>Capability: KVM_CAP_REINJECT_CONTROL<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_reinject_control (in)<br>Returns: 0 on success,<br>         -EFAULT if struct kvm_reinject_control cannot be read,<br>         -ENXIO if KVM_CREATE_PIT or KVM_CREATE_PIT2 didn’t succeed earlier.</p>
<p>i8254 (PIT) has two modes, reinject and !reinject.  The default is reinject,<br>where KVM queues elapsed i8254 ticks and monitors completion of interrupt from<br>vector(s) that i8254 injects.  Reinject mode dequeues a tick and injects its<br>interrupt whenever there isn’t a pending interrupt from i8254.<br>!reinject mode injects an interrupt as soon as a tick arrives.</p>
<p>struct kvm_reinject_control {<br>    __u8 pit_reinject;<br>    __u8 reserved[31];<br>};</p>
<p>pit_reinject = 0 (!reinject mode) is recommended, unless running an old<br>operating system that uses the PIT for timing (e.g. Linux 2.4.x).</p>
<p>4.100 KVM_PPC_CONFIGURE_V3_MMU</p>
<p>Capability: KVM_CAP_PPC_RADIX_MMU or KVM_CAP_PPC_HASH_MMU_V3<br>Architectures: ppc<br>Type: vm ioctl<br>Parameters: struct kvm_ppc_mmuv3_cfg (in)<br>Returns: 0 on success,<br>         -EFAULT if struct kvm_ppc_mmuv3_cfg cannot be read,<br>         -EINVAL if the configuration is invalid</p>
<p>This ioctl controls whether the guest will use radix or HPT (hashed<br>page table) translation, and sets the pointer to the process table for<br>the guest.</p>
<p>struct kvm_ppc_mmuv3_cfg {<br>    __u64    flags;<br>    __u64    process_table;<br>};</p>
<p>There are two bits that can be set in flags; KVM_PPC_MMUV3_RADIX and<br>KVM_PPC_MMUV3_GTSE.  KVM_PPC_MMUV3_RADIX, if set, configures the guest<br>to use radix tree translation, and if clear, to use HPT translation.<br>KVM_PPC_MMUV3_GTSE, if set and if KVM permits it, configures the guest<br>to be able to use the global TLB and SLB invalidation instructions;<br>if clear, the guest may not use these instructions.</p>
<p>The process_table field specifies the address and size of the guest<br>process table, which is in the guest’s space.  This field is formatted<br>as the second doubleword of the partition table entry, as defined in<br>the Power ISA V3.00, Book III section 5.7.6.1.</p>
<p>4.101 KVM_PPC_GET_RMMU_INFO</p>
<p>Capability: KVM_CAP_PPC_RADIX_MMU<br>Architectures: ppc<br>Type: vm ioctl<br>Parameters: struct kvm_ppc_rmmu_info (out)<br>Returns: 0 on success,<br>     -EFAULT if struct kvm_ppc_rmmu_info cannot be written,<br>     -EINVAL if no useful information can be returned</p>
<p>This ioctl returns a structure containing two things: (a) a list<br>containing supported radix tree geometries, and (b) a list that maps<br>page sizes to put in the “AP” (actual page size) field for the tlbie<br>(TLB invalidate entry) instruction.</p>
<p>struct kvm_ppc_rmmu_info {<br>    struct kvm_ppc_radix_geom {<br>        __u8    page_shift;<br>        __u8    level_bits[4];<br>        __u8    pad[3];<br>    }    geometries[8];<br>    __u32    ap_encodings[8];<br>};</p>
<p>The geometries[] field gives up to 8 supported geometries for the<br>radix page table, in terms of the log base 2 of the smallest page<br>size, and the number of bits indexed at each level of the tree, from<br>the PTE level up to the PGD level in that order.  Any unused entries<br>will have 0 in the page_shift field.</p>
<p>The ap_encodings gives the supported page sizes and their AP field<br>encodings, encoded with the AP value in the top 3 bits and the log<br>base 2 of the page size in the bottom 6 bits.</p>
<p>4.102 KVM_PPC_RESIZE_HPT_PREPARE</p>
<p>Capability: KVM_CAP_SPAPR_RESIZE_HPT<br>Architectures: powerpc<br>Type: vm ioctl<br>Parameters: struct kvm_ppc_resize_hpt (in)<br>Returns: 0 on successful completion,<br>     &gt;0 if a new HPT is being prepared, the value is an estimated<br>             number of milliseconds until preparation is complete<br>         -EFAULT if struct kvm_reinject_control cannot be read,<br>     -EINVAL if the supplied shift or flags are invalid<br>     -ENOMEM if unable to allocate the new HPT<br>     -ENOSPC if there was a hash collision when moving existing<br>                  HPT entries to the new HPT<br>     -EIO on other error conditions</p>
<p>Used to implement the PAPR extension for runtime resizing of a guest’s<br>Hashed Page Table (HPT).  Specifically this starts, stops or monitors<br>the preparation of a new potential HPT for the guest, essentially<br>implementing the H_RESIZE_HPT_PREPARE hypercall.</p>
<p>If called with shift &gt; 0 when there is no pending HPT for the guest,<br>this begins preparation of a new pending HPT of size 2^(shift) bytes.<br>It then returns a positive integer with the estimated number of<br>milliseconds until preparation is complete.</p>
<p>If called when there is a pending HPT whose size does not match that<br>requested in the parameters, discards the existing pending HPT and<br>creates a new one as above.</p>
<p>If called when there is a pending HPT of the size requested, will:</p>
<ul>
<li>If preparation of the pending HPT is already complete, return 0</li>
<li>If preparation of the pending HPT has failed, return an error<br>code, then discard the pending HPT.</li>
<li>If preparation of the pending HPT is still in progress, return an<br>estimated number of milliseconds until preparation is complete.</li>
</ul>
<p>If called with shift == 0, discards any currently pending HPT and<br>returns 0 (i.e. cancels any in-progress preparation).</p>
<p>flags is reserved for future expansion, currently setting any bits in<br>flags will result in an -EINVAL.</p>
<p>Normally this will be called repeatedly with the same parameters until<br>it returns &lt;= 0.  The first call will initiate preparation, subsequent<br>ones will monitor preparation until it completes or fails.</p>
<p>struct kvm_ppc_resize_hpt {<br>    __u64 flags;<br>    __u32 shift;<br>    __u32 pad;<br>};</p>
<p>4.103 KVM_PPC_RESIZE_HPT_COMMIT</p>
<p>Capability: KVM_CAP_SPAPR_RESIZE_HPT<br>Architectures: powerpc<br>Type: vm ioctl<br>Parameters: struct kvm_ppc_resize_hpt (in)<br>Returns: 0 on successful completion,<br>         -EFAULT if struct kvm_reinject_control cannot be read,<br>     -EINVAL if the supplied shift or flags are invalid<br>     -ENXIO is there is no pending HPT, or the pending HPT doesn’t<br>                 have the requested size<br>     -EBUSY if the pending HPT is not fully prepared<br>     -ENOSPC if there was a hash collision when moving existing<br>                  HPT entries to the new HPT<br>     -EIO on other error conditions</p>
<p>Used to implement the PAPR extension for runtime resizing of a guest’s<br>Hashed Page Table (HPT).  Specifically this requests that the guest be<br>transferred to working with the new HPT, essentially implementing the<br>H_RESIZE_HPT_COMMIT hypercall.</p>
<p>This should only be called after KVM_PPC_RESIZE_HPT_PREPARE has<br>returned 0 with the same parameters.  In other cases<br>KVM_PPC_RESIZE_HPT_COMMIT will return an error (usually -ENXIO or<br>-EBUSY, though others may be possible if the preparation was started,<br>but failed).</p>
<p>This will have undefined effects on the guest if it has not already<br>placed itself in a quiescent state where no vcpu will make MMU enabled<br>memory accesses.</p>
<p>On succsful completion, the pending HPT will become the guest’s active<br>HPT and the previous HPT will be discarded.</p>
<p>On failure, the guest will still be operating on its previous HPT.</p>
<p>struct kvm_ppc_resize_hpt {<br>    __u64 flags;<br>    __u32 shift;<br>    __u32 pad;<br>};</p>
<p>4.104 KVM_X86_GET_MCE_CAP_SUPPORTED</p>
<p>Capability: KVM_CAP_MCE<br>Architectures: x86<br>Type: system ioctl<br>Parameters: u64 mce_cap (out)<br>Returns: 0 on success, -1 on error</p>
<p>Returns supported MCE capabilities. The u64 mce_cap parameter<br>has the same format as the MSR_IA32_MCG_CAP register. Supported<br>capabilities will have the corresponding bits set.</p>
<p>4.105 KVM_X86_SETUP_MCE</p>
<p>Capability: KVM_CAP_MCE<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: u64 mcg_cap (in)<br>Returns: 0 on success,<br>         -EFAULT if u64 mcg_cap cannot be read,<br>         -EINVAL if the requested number of banks is invalid,<br>         -EINVAL if requested MCE capability is not supported.</p>
<p>Initializes MCE support for use. The u64 mcg_cap parameter<br>has the same format as the MSR_IA32_MCG_CAP register and<br>specifies which capabilities should be enabled. The maximum<br>supported number of error-reporting banks can be retrieved when<br>checking for KVM_CAP_MCE. The supported capabilities can be<br>retrieved with KVM_X86_GET_MCE_CAP_SUPPORTED.</p>
<p>4.106 KVM_X86_SET_MCE</p>
<p>Capability: KVM_CAP_MCE<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_x86_mce (in)<br>Returns: 0 on success,<br>         -EFAULT if struct kvm_x86_mce cannot be read,<br>         -EINVAL if the bank number is invalid,<br>         -EINVAL if VAL bit is not set in status field.</p>
<p>Inject a machine check error (MCE) into the guest. The input<br>parameter is:</p>
<p>struct kvm_x86_mce {<br>    __u64 status;<br>    __u64 addr;<br>    __u64 misc;<br>    __u64 mcg_status;<br>    __u8 bank;<br>    __u8 pad1[7];<br>    __u64 pad2[3];<br>};</p>
<p>If the MCE being reported is an uncorrected error, KVM will<br>inject it as an MCE exception into the guest. If the guest<br>MCG_STATUS register reports that an MCE is in progress, KVM<br>causes an KVM_EXIT_SHUTDOWN vmexit.</p>
<p>Otherwise, if the MCE is a corrected error, KVM will just<br>store it in the corresponding bank (provided this bank is<br>not holding a previously reported uncorrected error).</p>
<p>4.107 KVM_S390_GET_CMMA_BITS</p>
<p>Capability: KVM_CAP_S390_CMMA_MIGRATION<br>Architectures: s390<br>Type: vm ioctl<br>Parameters: struct kvm_s390_cmma_log (in, out)<br>Returns: 0 on success, a negative value on error</p>
<p>This ioctl is used to get the values of the CMMA bits on the s390<br>architecture. It is meant to be used in two scenarios:</p>
<ul>
<li>During live migration to save the CMMA values. Live migration needs<br>to be enabled via the KVM_REQ_START_MIGRATION VM property.</li>
<li>To non-destructively peek at the CMMA values, with the flag<br>KVM_S390_CMMA_PEEK set.</li>
</ul>
<p>The ioctl takes parameters via the kvm_s390_cmma_log struct. The desired<br>values are written to a buffer whose location is indicated via the “values”<br>member in the kvm_s390_cmma_log struct.  The values in the input struct are<br>also updated as needed.<br>Each CMMA value takes up one byte.</p>
<p>struct kvm_s390_cmma_log {<br>    __u64 start_gfn;<br>    __u32 count;<br>    __u32 flags;<br>    union {<br>        __u64 remaining;<br>        __u64 mask;<br>    };<br>    __u64 values;<br>};</p>
<p>start_gfn is the number of the first guest frame whose CMMA values are<br>to be retrieved,</p>
<p>count is the length of the buffer in bytes,</p>
<p>values points to the buffer where the result will be written to.</p>
<p>If count is greater than KVM_S390_SKEYS_MAX, then it is considered to be<br>KVM_S390_SKEYS_MAX. KVM_S390_SKEYS_MAX is re-used for consistency with<br>other ioctls.</p>
<p>The result is written in the buffer pointed to by the field values, and<br>the values of the input parameter are updated as follows.</p>
<p>Depending on the flags, different actions are performed. The only<br>supported flag so far is KVM_S390_CMMA_PEEK.</p>
<p>The default behaviour if KVM_S390_CMMA_PEEK is not set is:<br>start_gfn will indicate the first page frame whose CMMA bits were dirty.<br>It is not necessarily the same as the one passed as input, as clean pages<br>are skipped.</p>
<p>count will indicate the number of bytes actually written in the buffer.<br>It can (and very often will) be smaller than the input value, since the<br>buffer is only filled until 16 bytes of clean values are found (which<br>are then not copied in the buffer). Since a CMMA migration block needs<br>the base address and the length, for a total of 16 bytes, we will send<br>back some clean data if there is some dirty data afterwards, as long as<br>the size of the clean data does not exceed the size of the header. This<br>allows to minimize the amount of data to be saved or transferred over<br>the network at the expense of more roundtrips to userspace. The next<br>invocation of the ioctl will skip over all the clean values, saving<br>potentially more than just the 16 bytes we found.</p>
<p>If KVM_S390_CMMA_PEEK is set:<br>the existing storage attributes are read even when not in migration<br>mode, and no other action is performed;</p>
<p>the output start_gfn will be equal to the input start_gfn,</p>
<p>the output count will be equal to the input count, except if the end of<br>memory has been reached.</p>
<p>In both cases:<br>the field “remaining” will indicate the total number of dirty CMMA values<br>still remaining, or 0 if KVM_S390_CMMA_PEEK is set and migration mode is<br>not enabled.</p>
<p>mask is unused.</p>
<p>values points to the userspace buffer where the result will be stored.</p>
<p>This ioctl can fail with -ENOMEM if not enough memory can be allocated to<br>complete the task, with -ENXIO if CMMA is not enabled, with -EINVAL if<br>KVM_S390_CMMA_PEEK is not set but migration mode was not enabled, with<br>-EFAULT if the userspace address is invalid or if no page table is<br>present for the addresses (e.g. when using hugepages).</p>
<p>4.108 KVM_S390_SET_CMMA_BITS</p>
<p>Capability: KVM_CAP_S390_CMMA_MIGRATION<br>Architectures: s390<br>Type: vm ioctl<br>Parameters: struct kvm_s390_cmma_log (in)<br>Returns: 0 on success, a negative value on error</p>
<p>This ioctl is used to set the values of the CMMA bits on the s390<br>architecture. It is meant to be used during live migration to restore<br>the CMMA values, but there are no restrictions on its use.<br>The ioctl takes parameters via the kvm_s390_cmma_values struct.<br>Each CMMA value takes up one byte.</p>
<p>struct kvm_s390_cmma_log {<br>    __u64 start_gfn;<br>    __u32 count;<br>    __u32 flags;<br>    union {<br>        __u64 remaining;<br>        __u64 mask;<br>    };<br>    __u64 values;<br>};</p>
<p>start_gfn indicates the starting guest frame number,</p>
<p>count indicates how many values are to be considered in the buffer,</p>
<p>flags is not used and must be 0.</p>
<p>mask indicates which PGSTE bits are to be considered.</p>
<p>remaining is not used.</p>
<p>values points to the buffer in userspace where to store the values.</p>
<p>This ioctl can fail with -ENOMEM if not enough memory can be allocated to<br>complete the task, with -ENXIO if CMMA is not enabled, with -EINVAL if<br>the count field is too large (e.g. more than KVM_S390_CMMA_SIZE_MAX) or<br>if the flags field was not 0, with -EFAULT if the userspace address is<br>invalid, if invalid pages are written to (e.g. after the end of memory)<br>or if no page table is present for the addresses (e.g. when using<br>hugepages).</p>
<p>4.109 KVM_PPC_GET_CPU_CHAR</p>
<p>Capability: KVM_CAP_PPC_GET_CPU_CHAR<br>Architectures: powerpc<br>Type: vm ioctl<br>Parameters: struct kvm_ppc_cpu_char (out)<br>Returns: 0 on successful completion<br>     -EFAULT if struct kvm_ppc_cpu_char cannot be written</p>
<p>This ioctl gives userspace information about certain characteristics<br>of the CPU relating to speculative execution of instructions and<br>possible information leakage resulting from speculative execution (see<br>CVE-2017-5715, CVE-2017-5753 and CVE-2017-5754).  The information is<br>returned in struct kvm_ppc_cpu_char, which looks like this:</p>
<p>struct kvm_ppc_cpu_char {<br>    __u64    character;        /* characteristics of the CPU <em>/<br>    __u64    behaviour;        /</em> recommended software behaviour <em>/<br>    __u64    character_mask;        /</em> valid bits in character <em>/<br>    __u64    behaviour_mask;        /</em> valid bits in behaviour */<br>};</p>
<p>For extensibility, the character_mask and behaviour_mask fields<br>indicate which bits of character and behaviour have been filled in by<br>the kernel.  If the set of defined bits is extended in future then<br>userspace will be able to tell whether it is running on a kernel that<br>knows about the new bits.</p>
<p>The character field describes attributes of the CPU which can help<br>with preventing inadvertent information disclosure - specifically,<br>whether there is an instruction to flash-invalidate the L1 data cache<br>(ori 30,30,0 or mtspr SPRN_TRIG2,rN), whether the L1 data cache is set<br>to a mode where entries can only be used by the thread that created<br>them, whether the bcctr[l] instruction prevents speculation, and<br>whether a speculation barrier instruction (ori 31,31,0) is provided.</p>
<p>The behaviour field describes actions that software should take to<br>prevent inadvertent information disclosure, and thus describes which<br>vulnerabilities the hardware is subject to; specifically whether the<br>L1 data cache should be flushed when returning to user mode from the<br>kernel, and whether a speculation barrier should be placed between an<br>array bounds check and the array access.</p>
<p>These fields use the same bit definitions as the new<br>H_GET_CPU_CHARACTERISTICS hypercall.</p>
<p>4.110 KVM_MEMORY_ENCRYPT_OP</p>
<p>Capability: basic<br>Architectures: x86<br>Type: system<br>Parameters: an opaque platform specific structure (in/out)<br>Returns: 0 on success; -1 on error</p>
<p>If the platform supports creating encrypted VMs then this ioctl can be used<br>for issuing platform-specific memory encryption commands to manage those<br>encrypted VMs.</p>
<p>Currently, this ioctl is used for issuing Secure Encrypted Virtualization<br>(SEV) commands on AMD Processors. The SEV commands are defined in<br>Documentation/virtual/kvm/amd-memory-encryption.rst.</p>
<p>4.111 KVM_MEMORY_ENCRYPT_REG_REGION</p>
<p>Capability: basic<br>Architectures: x86<br>Type: system<br>Parameters: struct kvm_enc_region (in)<br>Returns: 0 on success; -1 on error</p>
<p>This ioctl can be used to register a guest memory region which may<br>contain encrypted data (e.g. guest RAM, SMRAM etc).</p>
<p>It is used in the SEV-enabled guest. When encryption is enabled, a guest<br>memory region may contain encrypted data. The SEV memory encryption<br>engine uses a tweak such that two identical plaintext pages, each at<br>different locations will have differing ciphertexts. So swapping or<br>moving ciphertext of those pages will not result in plaintext being<br>swapped. So relocating (or migrating) physical backing pages for the SEV<br>guest will require some additional steps.</p>
<p>Note: The current SEV key management spec does not provide commands to<br>swap or migrate (move) ciphertext pages. Hence, for now we pin the guest<br>memory region registered with the ioctl.</p>
<p>4.112 KVM_MEMORY_ENCRYPT_UNREG_REGION</p>
<p>Capability: basic<br>Architectures: x86<br>Type: system<br>Parameters: struct kvm_enc_region (in)<br>Returns: 0 on success; -1 on error</p>
<p>This ioctl can be used to unregister the guest memory region registered<br>with KVM_MEMORY_ENCRYPT_REG_REGION ioctl above.</p>
<p>4.113 KVM_HYPERV_EVENTFD</p>
<p>Capability: KVM_CAP_HYPERV_EVENTFD<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_hyperv_eventfd (in)</p>
<p>This ioctl (un)registers an eventfd to receive notifications from the guest on<br>the specified Hyper-V connection id through the SIGNAL_EVENT hypercall, without<br>causing a user exit.  SIGNAL_EVENT hypercall with non-zero event flag number<br>(bits 24-31) still triggers a KVM_EXIT_HYPERV_HCALL user exit.</p>
<p>struct kvm_hyperv_eventfd {<br>    __u32 conn_id;<br>    __s32 fd;<br>    __u32 flags;<br>    __u32 padding[3];<br>};</p>
<p>The conn_id field should fit within 24 bits:</p>
<p>#define KVM_HYPERV_CONN_ID_MASK        0x00ffffff</p>
<p>The acceptable values for the flags field are:</p>
<p>#define KVM_HYPERV_EVENTFD_DEASSIGN    (1 &lt;&lt; 0)</p>
<p>Returns: 0 on success,<br>    -EINVAL if conn_id or flags is outside the allowed range<br>    -ENOENT on deassign if the conn_id isn’t registered<br>    -EEXIST on assign if the conn_id is already registered</p>
<p>4.114 KVM_GET_NESTED_STATE</p>
<p>Capability: KVM_CAP_NESTED_STATE<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_nested_state (in/out)<br>Returns: 0 on success, -1 on error<br>Errors:<br>  E2BIG:     the total state size (including the fixed-size part of struct<br>             kvm_nested_state) exceeds the value of ‘size’ specified by<br>             the user; the size required will be written into size.</p>
<p>struct kvm_nested_state {<br>    __u16 flags;<br>    __u16 format;<br>    __u32 size;<br>    union {<br>        struct kvm_vmx_nested_state vmx;<br>        struct kvm_svm_nested_state svm;<br>        __u8 pad[120];<br>    };<br>    __u8 data[0];<br>};</p>
<p>#define KVM_STATE_NESTED_GUEST_MODE    0x00000001<br>#define KVM_STATE_NESTED_RUN_PENDING    0x00000002</p>
<p>#define KVM_STATE_NESTED_SMM_GUEST_MODE    0x00000001<br>#define KVM_STATE_NESTED_SMM_VMXON    0x00000002</p>
<p>struct kvm_vmx_nested_state {<br>    __u64 vmxon_pa;<br>    __u64 vmcs_pa;</p>
<pre><code>struct &#123;
    __u16 flags;
&#125; smm;
</code></pre>
<p>};</p>
<p>This ioctl copies the vcpu’s nested virtualization state from the kernel to<br>userspace.</p>
<p>The maximum size of the state, including the fixed-size part of struct<br>kvm_nested_state, can be retrieved by passing KVM_CAP_NESTED_STATE to<br>the KVM_CHECK_EXTENSION ioctl().</p>
<p>4.115 KVM_SET_NESTED_STATE</p>
<p>Capability: KVM_CAP_NESTED_STATE<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_nested_state (in)<br>Returns: 0 on success, -1 on error</p>
<p>This copies the vcpu’s kvm_nested_state struct from userspace to the kernel.  For<br>the definition of struct kvm_nested_state, see KVM_GET_NESTED_STATE.</p>
<ol start="5">
<li>The kvm_run structure</li>
</ol>
<hr>
<p>Application code obtains a pointer to the kvm_run structure by<br>mmap()ing a vcpu fd.  From that point, application code can control<br>execution by changing fields in kvm_run prior to calling the KVM_RUN<br>ioctl, and obtain information about the reason KVM_RUN returned by<br>looking up structure members.</p>
<p>struct kvm_run {<br>    /* in */<br>    __u8 request_interrupt_window;</p>
<p>Request that KVM_RUN return when it becomes possible to inject external<br>interrupts into the guest.  Useful in conjunction with KVM_INTERRUPT.</p>
<pre><code>__u8 immediate_exit;
</code></pre>
<p>This field is polled once when KVM_RUN starts; if non-zero, KVM_RUN<br>exits immediately, returning -EINTR.  In the common scenario where a<br>signal is used to “kick” a VCPU out of KVM_RUN, this field can be used<br>to avoid usage of KVM_SET_SIGNAL_MASK, which has worse scalability.<br>Rather than blocking the signal outside KVM_RUN, userspace can set up<br>a signal handler that sets run-&gt;immediate_exit to a non-zero value.</p>
<p>This field is ignored if KVM_CAP_IMMEDIATE_EXIT is not available.</p>
<pre><code>__u8 padding1[6];

/* out */
__u32 exit_reason;
</code></pre>
<p>When KVM_RUN has returned successfully (return value 0), this informs<br>application code why KVM_RUN has returned.  Allowable values for this<br>field are detailed below.</p>
<pre><code>__u8 ready_for_interrupt_injection;
</code></pre>
<p>If request_interrupt_window has been specified, this field indicates<br>an interrupt can be injected now with KVM_INTERRUPT.</p>
<pre><code>__u8 if_flag;
</code></pre>
<p>The value of the current interrupt flag.  Only valid if in-kernel<br>local APIC is not used.</p>
<pre><code>__u16 flags;
</code></pre>
<p>More architecture-specific flags detailing state of the VCPU that may<br>affect the device’s behavior.  The only currently defined flag is<br>KVM_RUN_X86_SMM, which is valid on x86 machines and is set if the<br>VCPU is in system management mode.</p>
<pre><code>/* in (pre_kvm_run), out (post_kvm_run) */
__u64 cr8;
</code></pre>
<p>The value of the cr8 register.  Only valid if in-kernel local APIC is<br>not used.  Both input and output.</p>
<pre><code>__u64 apic_base;
</code></pre>
<p>The value of the APIC BASE msr.  Only valid if in-kernel local<br>APIC is not used.  Both input and output.</p>
<pre><code>union &#123;
    /* KVM_EXIT_UNKNOWN */
    struct &#123;
        __u64 hardware_exit_reason;
    &#125; hw;
</code></pre>
<p>If exit_reason is KVM_EXIT_UNKNOWN, the vcpu has exited due to unknown<br>reasons.  Further architecture-specific information is available in<br>hardware_exit_reason.</p>
<pre><code>    /* KVM_EXIT_FAIL_ENTRY */
    struct &#123;
        __u64 hardware_entry_failure_reason;
    &#125; fail_entry;
</code></pre>
<p>If exit_reason is KVM_EXIT_FAIL_ENTRY, the vcpu could not be run due<br>to unknown reasons.  Further architecture-specific information is<br>available in hardware_entry_failure_reason.</p>
<pre><code>    /* KVM_EXIT_EXCEPTION */
    struct &#123;
        __u32 exception;
        __u32 error_code;
    &#125; ex;
</code></pre>
<p>Unused.</p>
<pre><code>    /* KVM_EXIT_IO */
    struct &#123;
</code></pre>
<p>#define KVM_EXIT_IO_IN  0<br>#define KVM_EXIT_IO_OUT 1<br>            __u8 direction;<br>            __u8 size; /* bytes <em>/<br>            __u16 port;<br>            __u32 count;<br>            __u64 data_offset; /</em> relative to kvm_run start */<br>        } io;</p>
<p>If exit_reason is KVM_EXIT_IO, then the vcpu has<br>executed a port I/O instruction which could not be satisfied by kvm.<br>data_offset describes where the data is located (KVM_EXIT_IO_OUT) or<br>where kvm expects application code to place the data for the next<br>KVM_RUN invocation (KVM_EXIT_IO_IN).  Data format is a packed array.</p>
<pre><code>    /* KVM_EXIT_DEBUG */
    struct &#123;
        struct kvm_debug_exit_arch arch;
    &#125; debug;
</code></pre>
<p>If the exit_reason is KVM_EXIT_DEBUG, then a vcpu is processing a debug event<br>for which architecture specific information is returned.</p>
<pre><code>    /* KVM_EXIT_MMIO */
    struct &#123;
        __u64 phys_addr;
        __u8  data[8];
        __u32 len;
        __u8  is_write;
    &#125; mmio;
</code></pre>
<p>If exit_reason is KVM_EXIT_MMIO, then the vcpu has<br>executed a memory-mapped I/O instruction which could not be satisfied<br>by kvm.  The ‘data’ member contains the written data if ‘is_write’ is<br>true, and should be filled by application code otherwise.</p>
<p>The ‘data’ member contains, in its first ‘len’ bytes, the value as it would<br>appear if the VCPU performed a load or store of the appropriate width directly<br>to the byte array.</p>
<p>NOTE: For KVM_EXIT_IO, KVM_EXIT_MMIO, KVM_EXIT_OSI, KVM_EXIT_PAPR and<br>      KVM_EXIT_EPR the corresponding<br>operations are complete (and guest state is consistent) only after userspace<br>has re-entered the kernel with KVM_RUN.  The kernel side will first finish<br>incomplete operations and then check for pending signals.  Userspace<br>can re-enter the guest with an unmasked signal pending to complete<br>pending operations.</p>
<pre><code>    /* KVM_EXIT_HYPERCALL */
    struct &#123;
        __u64 nr;
        __u64 args[6];
        __u64 ret;
        __u32 longmode;
        __u32 pad;
    &#125; hypercall;
</code></pre>
<p>Unused.  This was once used for ‘hypercall to userspace’.  To implement<br>such functionality, use KVM_EXIT_IO (x86) or KVM_EXIT_MMIO (all except s390).<br>Note KVM_EXIT_IO is significantly faster than KVM_EXIT_MMIO.</p>
<pre><code>    /* KVM_EXIT_TPR_ACCESS */
    struct &#123;
        __u64 rip;
        __u32 is_write;
        __u32 pad;
    &#125; tpr_access;
</code></pre>
<p>To be documented (KVM_TPR_ACCESS_REPORTING).</p>
<pre><code>    /* KVM_EXIT_S390_SIEIC */
    struct &#123;
        __u8 icptcode;
        __u64 mask; /* psw upper half */
        __u64 addr; /* psw lower half */
        __u16 ipa;
        __u32 ipb;
    &#125; s390_sieic;
</code></pre>
<p>s390 specific.</p>
<pre><code>    /* KVM_EXIT_S390_RESET */
</code></pre>
<p>#define KVM_S390_RESET_POR       1<br>#define KVM_S390_RESET_CLEAR     2<br>#define KVM_S390_RESET_SUBSYSTEM 4<br>#define KVM_S390_RESET_CPU_INIT  8<br>#define KVM_S390_RESET_IPL       16<br>        __u64 s390_reset_flags;</p>
<p>s390 specific.</p>
<pre><code>    /* KVM_EXIT_S390_UCONTROL */
    struct &#123;
        __u64 trans_exc_code;
        __u32 pgm_code;
    &#125; s390_ucontrol;
</code></pre>
<p>s390 specific. A page fault has occurred for a user controlled virtual<br>machine (KVM_VM_S390_UNCONTROL) on it’s host page table that cannot be<br>resolved by the kernel.<br>The program code and the translation exception code that were placed<br>in the cpu’s lowcore are presented here as defined by the z Architecture<br>Principles of Operation Book in the Chapter for Dynamic Address Translation<br>(DAT)</p>
<pre><code>    /* KVM_EXIT_DCR */
    struct &#123;
        __u32 dcrn;
        __u32 data;
        __u8  is_write;
    &#125; dcr;
</code></pre>
<p>Deprecated - was used for 440 KVM.</p>
<pre><code>    /* KVM_EXIT_OSI */
    struct &#123;
        __u64 gprs[32];
    &#125; osi;
</code></pre>
<p>MOL uses a special hypercall interface it calls ‘OSI’. To enable it, we catch<br>hypercalls and exit with this exit struct that contains all the guest gprs.</p>
<p>If exit_reason is KVM_EXIT_OSI, then the vcpu has triggered such a hypercall.<br>Userspace can now handle the hypercall and when it’s done modify the gprs as<br>necessary. Upon guest entry all guest GPRs will then be replaced by the values<br>in this struct.</p>
<pre><code>    /* KVM_EXIT_PAPR_HCALL */
    struct &#123;
        __u64 nr;
        __u64 ret;
        __u64 args[9];
    &#125; papr_hcall;
</code></pre>
<p>This is used on 64-bit PowerPC when emulating a pSeries partition,<br>e.g. with the ‘pseries’ machine type in qemu.  It occurs when the<br>guest does a hypercall using the ‘sc 1’ instruction.  The ‘nr’ field<br>contains the hypercall number (from the guest R3), and ‘args’ contains<br>the arguments (from the guest R4 - R12).  Userspace should put the<br>return code in ‘ret’ and any extra returned values in args[].<br>The possible hypercalls are defined in the Power Architecture Platform<br>Requirements (PAPR) document available from <a target="_blank" rel="noopener" href="http://www.power.org/">www.power.org</a> (free<br>developer registration required to access it).</p>
<pre><code>    /* KVM_EXIT_S390_TSCH */
    struct &#123;
        __u16 subchannel_id;
        __u16 subchannel_nr;
        __u32 io_int_parm;
        __u32 io_int_word;
        __u32 ipb;
        __u8 dequeued;
    &#125; s390_tsch;
</code></pre>
<p>s390 specific. This exit occurs when KVM_CAP_S390_CSS_SUPPORT has been enabled<br>and TEST SUBCHANNEL was intercepted. If dequeued is set, a pending I/O<br>interrupt for the target subchannel has been dequeued and subchannel_id,<br>subchannel_nr, io_int_parm and io_int_word contain the parameters for that<br>interrupt. ipb is needed for instruction parameter decoding.</p>
<pre><code>    /* KVM_EXIT_EPR */
    struct &#123;
        __u32 epr;
    &#125; epr;
</code></pre>
<p>On FSL BookE PowerPC chips, the interrupt controller has a fast patch<br>interrupt acknowledge path to the core. When the core successfully<br>delivers an interrupt, it automatically populates the EPR register with<br>the interrupt vector number and acknowledges the interrupt inside<br>the interrupt controller.</p>
<p>In case the interrupt controller lives in user space, we need to do<br>the interrupt acknowledge cycle through it to fetch the next to be<br>delivered interrupt vector using this exit.</p>
<p>It gets triggered whenever both KVM_CAP_PPC_EPR are enabled and an<br>external interrupt has just been delivered into the guest. User space<br>should put the acknowledged interrupt vector into the ‘epr’ field.</p>
<pre><code>    /* KVM_EXIT_SYSTEM_EVENT */
    struct &#123;
</code></pre>
<p>#define KVM_SYSTEM_EVENT_SHUTDOWN       1<br>#define KVM_SYSTEM_EVENT_RESET          2<br>#define KVM_SYSTEM_EVENT_CRASH          3<br>            __u32 type;<br>            __u64 flags;<br>        } system_event;</p>
<p>If exit_reason is KVM_EXIT_SYSTEM_EVENT then the vcpu has triggered<br>a system-level event using some architecture specific mechanism (hypercall<br>or some special instruction). In case of ARM/ARM64, this is triggered using<br>HVC instruction based PSCI call from the vcpu. The ‘type’ field describes<br>the system-level event type. The ‘flags’ field describes architecture<br>specific flags for the system-level event.</p>
<p>Valid values for ‘type’ are:<br>  KVM_SYSTEM_EVENT_SHUTDOWN – the guest has requested a shutdown of the<br>   VM. Userspace is not obliged to honour this, and if it does honour<br>   this does not need to destroy the VM synchronously (ie it may call<br>   KVM_RUN again before shutdown finally occurs).<br>  KVM_SYSTEM_EVENT_RESET – the guest has requested a reset of the VM.<br>   As with SHUTDOWN, userspace can choose to ignore the request, or<br>   to schedule the reset to occur in the future and may call KVM_RUN again.<br>  KVM_SYSTEM_EVENT_CRASH – the guest crash occurred and the guest<br>   has requested a crash condition maintenance. Userspace can choose<br>   to ignore the request, or to gather VM memory core dump and/or<br>   reset/shutdown of the VM.</p>
<pre><code>    /* KVM_EXIT_IOAPIC_EOI */
    struct &#123;
        __u8 vector;
    &#125; eoi;
</code></pre>
<p>Indicates that the VCPU’s in-kernel local APIC received an EOI for a<br>level-triggered IOAPIC interrupt.  This exit only triggers when the<br>IOAPIC is implemented in userspace (i.e. KVM_CAP_SPLIT_IRQCHIP is enabled);<br>the userspace IOAPIC should process the EOI and retrigger the interrupt if<br>it is still asserted.  Vector is the LAPIC interrupt vector for which the<br>EOI was received.</p>
<pre><code>    struct kvm_hyperv_exit &#123;
</code></pre>
<p>#define KVM_EXIT_HYPERV_SYNIC          1<br>#define KVM_EXIT_HYPERV_HCALL          2<br>            __u32 type;<br>            union {<br>                struct {<br>                    __u32 msr;<br>                    __u64 control;<br>                    __u64 evt_page;<br>                    __u64 msg_page;<br>                } synic;<br>                struct {<br>                    __u64 input;<br>                    __u64 result;<br>                    __u64 params[2];<br>                } hcall;<br>            } u;<br>        };<br>        /* KVM_EXIT_HYPERV */<br>                struct kvm_hyperv_exit hyperv;<br>Indicates that the VCPU exits into userspace to process some tasks<br>related to Hyper-V emulation.<br>Valid values for ‘type’ are:<br>    KVM_EXIT_HYPERV_SYNIC – synchronously notify user-space about<br>Hyper-V SynIC state change. Notification is used to remap SynIC<br>event/message pages and to enable/disable SynIC messages/events processing<br>in userspace.</p>
<pre><code>    /* Fix the size of the union. */
    char padding[256];
&#125;;

/*
 * shared registers between kvm and userspace.
 * kvm_valid_regs specifies the register classes set by the host
 * kvm_dirty_regs specified the register classes dirtied by userspace
 * struct kvm_sync_regs is architecture specific, as well as the
 * bits for kvm_valid_regs and kvm_dirty_regs
 */
__u64 kvm_valid_regs;
__u64 kvm_dirty_regs;
union &#123;
    struct kvm_sync_regs regs;
    char padding[SYNC_REGS_SIZE_BYTES];
&#125; s;
</code></pre>
<p>If KVM_CAP_SYNC_REGS is defined, these fields allow userspace to access<br>certain guest registers without having to call SET/GET_*REGS. Thus we can<br>avoid some system call overhead if userspace has to handle the exit.<br>Userspace can query the validity of the structure by checking<br>kvm_valid_regs for specific bits. These bits are architecture specific<br>and usually define the validity of a groups of registers. (e.g. one bit<br> for general purpose registers)</p>
<p>Please note that the kernel is allowed to use the kvm_run structure as the<br>primary storage for certain register types. Therefore, the kernel may use the<br>values in kvm_run even if the corresponding bit in kvm_dirty_regs is not set.</p>
<p>};</p>
<ol start="6">
<li>Capabilities that can be enabled on vCPUs</li>
</ol>
<hr>
<p>There are certain capabilities that change the behavior of the virtual CPU or<br>the virtual machine when enabled. To enable them, please see section 4.37.<br>Below you can find a list of capabilities and what their effect on the vCPU or<br>the virtual machine is when enabling them.</p>
<p>The following information is provided along with the description:</p>
<p>  Architectures: which instruction set architectures provide this ioctl.<br>      x86 includes both i386 and x86_64.</p>
<p>  Target: whether this is a per-vcpu or per-vm capability.</p>
<p>  Parameters: what parameters are accepted by the capability.</p>
<p>  Returns: the return value.  General error numbers (EBADF, ENOMEM, EINVAL)<br>      are not detailed, but errors with specific meanings are.</p>
<p>6.1 KVM_CAP_PPC_OSI</p>
<p>Architectures: ppc<br>Target: vcpu<br>Parameters: none<br>Returns: 0 on success; -1 on error</p>
<p>This capability enables interception of OSI hypercalls that otherwise would<br>be treated as normal system calls to be injected into the guest. OSI hypercalls<br>were invented by Mac-on-Linux to have a standardized communication mechanism<br>between the guest and the host.</p>
<p>When this capability is enabled, KVM_EXIT_OSI can occur.</p>
<p>6.2 KVM_CAP_PPC_PAPR</p>
<p>Architectures: ppc<br>Target: vcpu<br>Parameters: none<br>Returns: 0 on success; -1 on error</p>
<p>This capability enables interception of PAPR hypercalls. PAPR hypercalls are<br>done using the hypercall instruction “sc 1”.</p>
<p>It also sets the guest privilege level to “supervisor” mode. Usually the guest<br>runs in “hypervisor” privilege mode with a few missing features.</p>
<p>In addition to the above, it changes the semantics of SDR1. In this mode, the<br>HTAB address part of SDR1 contains an HVA instead of a GPA, as PAPR keeps the<br>HTAB invisible to the guest.</p>
<p>When this capability is enabled, KVM_EXIT_PAPR_HCALL can occur.</p>
<p>6.3 KVM_CAP_SW_TLB</p>
<p>Architectures: ppc<br>Target: vcpu<br>Parameters: args[0] is the address of a struct kvm_config_tlb<br>Returns: 0 on success; -1 on error</p>
<p>struct kvm_config_tlb {<br>    __u64 params;<br>    __u64 array;<br>    __u32 mmu_type;<br>    __u32 array_len;<br>};</p>
<p>Configures the virtual CPU’s TLB array, establishing a shared memory area<br>between userspace and KVM.  The “params” and “array” fields are userspace<br>addresses of mmu-type-specific data structures.  The “array_len” field is an<br>safety mechanism, and should be set to the size in bytes of the memory that<br>userspace has reserved for the array.  It must be at least the size dictated<br>by “mmu_type” and “params”.</p>
<p>While KVM_RUN is active, the shared region is under control of KVM.  Its<br>contents are undefined, and any modification by userspace results in<br>boundedly undefined behavior.</p>
<p>On return from KVM_RUN, the shared region will reflect the current state of<br>the guest’s TLB.  If userspace makes any changes, it must call KVM_DIRTY_TLB<br>to tell KVM which entries have been changed, prior to calling KVM_RUN again<br>on this vcpu.</p>
<p>For mmu types KVM_MMU_FSL_BOOKE_NOHV and KVM_MMU_FSL_BOOKE_HV:</p>
<ul>
<li>The “params” field is of type “struct kvm_book3e_206_tlb_params”.</li>
<li>The “array” field points to an array of type “struct<br>kvm_book3e_206_tlb_entry”.</li>
<li>The array consists of all entries in the first TLB, followed by all<br>entries in the second TLB.</li>
<li>Within a TLB, entries are ordered first by increasing set number.  Within a<br>set, entries are ordered by way (increasing ESEL).</li>
<li>The hash for determining set number in TLB0 is: (MAS2 &gt;&gt; 12) &amp; (num_sets - 1)<br>where “num_sets” is the tlb_sizes[] value divided by the tlb_ways[] value.</li>
<li>The tsize field of mas1 shall be set to 4K on TLB0, even though the<br>hardware ignores this value for TLB0.</li>
</ul>
<p>6.4 KVM_CAP_S390_CSS_SUPPORT</p>
<p>Architectures: s390<br>Target: vcpu<br>Parameters: none<br>Returns: 0 on success; -1 on error</p>
<p>This capability enables support for handling of channel I/O instructions.</p>
<p>TEST PENDING INTERRUPTION and the interrupt portion of TEST SUBCHANNEL are<br>handled in-kernel, while the other I/O instructions are passed to userspace.</p>
<p>When this capability is enabled, KVM_EXIT_S390_TSCH will occur on TEST<br>SUBCHANNEL intercepts.</p>
<p>Note that even though this capability is enabled per-vcpu, the complete<br>virtual machine is affected.</p>
<p>6.5 KVM_CAP_PPC_EPR</p>
<p>Architectures: ppc<br>Target: vcpu<br>Parameters: args[0] defines whether the proxy facility is active<br>Returns: 0 on success; -1 on error</p>
<p>This capability enables or disables the delivery of interrupts through the<br>external proxy facility.</p>
<p>When enabled (args[0] != 0), every time the guest gets an external interrupt<br>delivered, it automatically exits into user space with a KVM_EXIT_EPR exit<br>to receive the topmost interrupt vector.</p>
<p>When disabled (args[0] == 0), behavior is as if this facility is unsupported.</p>
<p>When this capability is enabled, KVM_EXIT_EPR can occur.</p>
<p>6.6 KVM_CAP_IRQ_MPIC</p>
<p>Architectures: ppc<br>Parameters: args[0] is the MPIC device fd<br>            args[1] is the MPIC CPU number for this vcpu</p>
<p>This capability connects the vcpu to an in-kernel MPIC device.</p>
<p>6.7 KVM_CAP_IRQ_XICS</p>
<p>Architectures: ppc<br>Target: vcpu<br>Parameters: args[0] is the XICS device fd<br>            args[1] is the XICS CPU number (server ID) for this vcpu</p>
<p>This capability connects the vcpu to an in-kernel XICS device.</p>
<p>6.8 KVM_CAP_S390_IRQCHIP</p>
<p>Architectures: s390<br>Target: vm<br>Parameters: none</p>
<p>This capability enables the in-kernel irqchip for s390. Please refer to<br>“4.24 KVM_CREATE_IRQCHIP” for details.</p>
<p>6.9 KVM_CAP_MIPS_FPU</p>
<p>Architectures: mips<br>Target: vcpu<br>Parameters: args[0] is reserved for future use (should be 0).</p>
<p>This capability allows the use of the host Floating Point Unit by the guest. It<br>allows the Config1.FP bit to be set to enable the FPU in the guest. Once this is<br>done the KVM_REG_MIPS_FPR_* and KVM_REG_MIPS_FCR_* registers can be accessed<br>(depending on the current guest FPU register mode), and the Status.FR,<br>Config5.FRE bits are accessible via the KVM API and also from the guest,<br>depending on them being supported by the FPU.</p>
<p>6.10 KVM_CAP_MIPS_MSA</p>
<p>Architectures: mips<br>Target: vcpu<br>Parameters: args[0] is reserved for future use (should be 0).</p>
<p>This capability allows the use of the MIPS SIMD Architecture (MSA) by the guest.<br>It allows the Config3.MSAP bit to be set to enable the use of MSA by the guest.<br>Once this is done the KVM_REG_MIPS_VEC_* and KVM_REG_MIPS_MSA_* registers can be<br>accessed, and the Config5.MSAEn bit is accessible via the KVM API and also from<br>the guest.</p>
<p>6.74 KVM_CAP_SYNC_REGS<br>Architectures: s390, x86<br>Target: s390: always enabled, x86: vcpu<br>Parameters: none<br>Returns: x86: KVM_CHECK_EXTENSION returns a bit-array indicating which register<br>sets are supported (bitfields defined in arch/x86/include/uapi/asm/kvm.h).</p>
<p>As described above in the kvm_sync_regs struct info in section 5 (kvm_run):<br>KVM_CAP_SYNC_REGS “allow[s] userspace to access certain guest registers<br>without having to call SET/GET_*REGS”. This reduces overhead by eliminating<br>repeated ioctl calls for setting and/or getting register values. This is<br>particularly important when userspace is making synchronous guest state<br>modifications, e.g. when emulating and/or intercepting instructions in<br>userspace.</p>
<p>For s390 specifics, please refer to the source code.</p>
<p>For x86:</p>
<ul>
<li>the register sets to be copied out to kvm_run are selectable<br>by userspace (rather that all sets being copied out for every exit).</li>
<li>vcpu_events are available in addition to regs and sregs.</li>
</ul>
<p>For x86, the ‘kvm_valid_regs’ field of struct kvm_run is overloaded to<br>function as an input bit-array field set by userspace to indicate the<br>specific register sets to be copied out on the next exit.</p>
<p>To indicate when userspace has modified values that should be copied into<br>the vCPU, the all architecture bitarray field, ‘kvm_dirty_regs’ must be set.<br>This is done using the same bitflags as for the ‘kvm_valid_regs’ field.<br>If the dirty bit is not set, then the register set values will not be copied<br>into the vCPU even if they’ve been modified.</p>
<p>Unused bitfields in the bitarrays must be set to zero.</p>
<p>struct kvm_sync_regs {<br>        struct kvm_regs regs;<br>        struct kvm_sregs sregs;<br>        struct kvm_vcpu_events events;<br>};</p>
<ol start="7">
<li>Capabilities that can be enabled on VMs</li>
</ol>
<hr>
<p>There are certain capabilities that change the behavior of the virtual<br>machine when enabled. To enable them, please see section 4.37. Below<br>you can find a list of capabilities and what their effect on the VM<br>is when enabling them.</p>
<p>The following information is provided along with the description:</p>
<p>  Architectures: which instruction set architectures provide this ioctl.<br>      x86 includes both i386 and x86_64.</p>
<p>  Parameters: what parameters are accepted by the capability.</p>
<p>  Returns: the return value.  General error numbers (EBADF, ENOMEM, EINVAL)<br>      are not detailed, but errors with specific meanings are.</p>
<p>7.1 KVM_CAP_PPC_ENABLE_HCALL</p>
<p>Architectures: ppc<br>Parameters: args[0] is the sPAPR hcall number<br>        args[1] is 0 to disable, 1 to enable in-kernel handling</p>
<p>This capability controls whether individual sPAPR hypercalls (hcalls)<br>get handled by the kernel or not.  Enabling or disabling in-kernel<br>handling of an hcall is effective across the VM.  On creation, an<br>initial set of hcalls are enabled for in-kernel handling, which<br>consists of those hcalls for which in-kernel handlers were implemented<br>before this capability was implemented.  If disabled, the kernel will<br>not to attempt to handle the hcall, but will always exit to userspace<br>to handle it.  Note that it may not make sense to enable some and<br>disable others of a group of related hcalls, but KVM does not prevent<br>userspace from doing that.</p>
<p>If the hcall number specified is not one that has an in-kernel<br>implementation, the KVM_ENABLE_CAP ioctl will fail with an EINVAL<br>error.</p>
<p>7.2 KVM_CAP_S390_USER_SIGP</p>
<p>Architectures: s390<br>Parameters: none</p>
<p>This capability controls which SIGP orders will be handled completely in user<br>space. With this capability enabled, all fast orders will be handled completely<br>in the kernel:</p>
<ul>
<li>SENSE</li>
<li>SENSE RUNNING</li>
<li>EXTERNAL CALL</li>
<li>EMERGENCY SIGNAL</li>
<li>CONDITIONAL EMERGENCY SIGNAL</li>
</ul>
<p>All other orders will be handled completely in user space.</p>
<p>Only privileged operation exceptions will be checked for in the kernel (or even<br>in the hardware prior to interception). If this capability is not enabled, the<br>old way of handling SIGP orders is used (partially in kernel and user space).</p>
<p>7.3 KVM_CAP_S390_VECTOR_REGISTERS</p>
<p>Architectures: s390<br>Parameters: none<br>Returns: 0 on success, negative value on error</p>
<p>Allows use of the vector registers introduced with z13 processor, and<br>provides for the synchronization between host and user space.  Will<br>return -EINVAL if the machine does not support vectors.</p>
<p>7.4 KVM_CAP_S390_USER_STSI</p>
<p>Architectures: s390<br>Parameters: none</p>
<p>This capability allows post-handlers for the STSI instruction. After<br>initial handling in the kernel, KVM exits to user space with<br>KVM_EXIT_S390_STSI to allow user space to insert further data.</p>
<p>Before exiting to userspace, kvm handlers should fill in s390_stsi field of<br>vcpu-&gt;run:<br>struct {<br>    __u64 addr;<br>    __u8 ar;<br>    __u8 reserved;<br>    __u8 fc;<br>    __u8 sel1;<br>    __u16 sel2;<br>} s390_stsi;</p>
<p>@addr - guest address of STSI SYSIB<br>@fc   - function code<br>@sel1 - selector 1<br>@sel2 - selector 2<br>@ar   - access register number</p>
<p>KVM handlers should exit to userspace with rc = -EREMOTE.</p>
<p>7.5 KVM_CAP_SPLIT_IRQCHIP</p>
<p>Architectures: x86<br>Parameters: args[0] - number of routes reserved for userspace IOAPICs<br>Returns: 0 on success, -1 on error</p>
<p>Create a local apic for each processor in the kernel. This can be used<br>instead of KVM_CREATE_IRQCHIP if the userspace VMM wishes to emulate the<br>IOAPIC and PIC (and also the PIT, even though this has to be enabled<br>separately).</p>
<p>This capability also enables in kernel routing of interrupt requests;<br>when KVM_CAP_SPLIT_IRQCHIP only routes of KVM_IRQ_ROUTING_MSI type are<br>used in the IRQ routing table.  The first args[0] MSI routes are reserved<br>for the IOAPIC pins.  Whenever the LAPIC receives an EOI for these routes,<br>a KVM_EXIT_IOAPIC_EOI vmexit will be reported to userspace.</p>
<p>Fails if VCPU has already been created, or if the irqchip is already in the<br>kernel (i.e. KVM_CREATE_IRQCHIP has already been called).</p>
<p>7.6 KVM_CAP_S390_RI</p>
<p>Architectures: s390<br>Parameters: none</p>
<p>Allows use of runtime-instrumentation introduced with zEC12 processor.<br>Will return -EINVAL if the machine does not support runtime-instrumentation.<br>Will return -EBUSY if a VCPU has already been created.</p>
<p>7.7 KVM_CAP_X2APIC_API</p>
<p>Architectures: x86<br>Parameters: args[0] - features that should be enabled<br>Returns: 0 on success, -EINVAL when args[0] contains invalid features</p>
<p>Valid feature flags in args[0] are</p>
<p>#define KVM_X2APIC_API_USE_32BIT_IDS            (1ULL &lt;&lt; 0)<br>#define KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK  (1ULL &lt;&lt; 1)</p>
<p>Enabling KVM_X2APIC_API_USE_32BIT_IDS changes the behavior of<br>KVM_SET_GSI_ROUTING, KVM_SIGNAL_MSI, KVM_SET_LAPIC, and KVM_GET_LAPIC,<br>allowing the use of 32-bit APIC IDs.  See KVM_CAP_X2APIC_API in their<br>respective sections.</p>
<p>KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK must be enabled for x2APIC to work<br>in logical mode or with more than 255 VCPUs.  Otherwise, KVM treats 0xff<br>as a broadcast even in x2APIC mode in order to support physical x2APIC<br>without interrupt remapping.  This is undesirable in logical mode,<br>where 0xff represents CPUs 0-7 in cluster 0.</p>
<p>7.8 KVM_CAP_S390_USER_INSTR0</p>
<p>Architectures: s390<br>Parameters: none</p>
<p>With this capability enabled, all illegal instructions 0x0000 (2 bytes) will<br>be intercepted and forwarded to user space. User space can use this<br>mechanism e.g. to realize 2-byte software breakpoints. The kernel will<br>not inject an operating exception for these instructions, user space has<br>to take care of that.</p>
<p>This capability can be enabled dynamically even if VCPUs were already<br>created and are running.</p>
<p>7.9 KVM_CAP_S390_GS</p>
<p>Architectures: s390<br>Parameters: none<br>Returns: 0 on success; -EINVAL if the machine does not support<br>     guarded storage; -EBUSY if a VCPU has already been created.</p>
<p>Allows use of guarded storage for the KVM guest.</p>
<p>7.10 KVM_CAP_S390_AIS</p>
<p>Architectures: s390<br>Parameters: none</p>
<p>Allow use of adapter-interruption suppression.<br>Returns: 0 on success; -EBUSY if a VCPU has already been created.</p>
<p>7.11 KVM_CAP_PPC_SMT</p>
<p>Architectures: ppc<br>Parameters: vsmt_mode, flags</p>
<p>Enabling this capability on a VM provides userspace with a way to set<br>the desired virtual SMT mode (i.e. the number of virtual CPUs per<br>virtual core).  The virtual SMT mode, vsmt_mode, must be a power of 2<br>between 1 and 8.  On POWER8, vsmt_mode must also be no greater than<br>the number of threads per subcore for the host.  Currently flags must<br>be 0.  A successful call to enable this capability will result in<br>vsmt_mode being returned when the KVM_CAP_PPC_SMT capability is<br>subsequently queried for the VM.  This capability is only supported by<br>HV KVM, and can only be set before any VCPUs have been created.<br>The KVM_CAP_PPC_SMT_POSSIBLE capability indicates which virtual SMT<br>modes are available.</p>
<p>7.12 KVM_CAP_PPC_FWNMI</p>
<p>Architectures: ppc<br>Parameters: none</p>
<p>With this capability a machine check exception in the guest address<br>space will cause KVM to exit the guest with NMI exit reason. This<br>enables QEMU to build error log and branch to guest kernel registered<br>machine check handling routine. Without this capability KVM will<br>branch to guests’ 0x200 interrupt vector.</p>
<p>7.13 KVM_CAP_X86_DISABLE_EXITS</p>
<p>Architectures: x86<br>Parameters: args[0] defines which exits are disabled<br>Returns: 0 on success, -EINVAL when args[0] contains invalid exits</p>
<p>Valid bits in args[0] are</p>
<p>#define KVM_X86_DISABLE_EXITS_MWAIT            (1 &lt;&lt; 0)<br>#define KVM_X86_DISABLE_EXITS_HLT              (1 &lt;&lt; 1)</p>
<p>Enabling this capability on a VM provides userspace with a way to no<br>longer intercept some instructions for improved latency in some<br>workloads, and is suggested when vCPUs are associated to dedicated<br>physical CPUs.  More bits can be added in the future; userspace can<br>just pass the KVM_CHECK_EXTENSION result to KVM_ENABLE_CAP to disable<br>all such vmexits.</p>
<p>Do not enable KVM_FEATURE_PV_UNHALT if you disable HLT exits.</p>
<p>7.14 KVM_CAP_S390_HPAGE_1M</p>
<p>Architectures: s390<br>Parameters: none<br>Returns: 0 on success, -EINVAL if hpage module parameter was not set<br>     or cmma is enabled, or the VM has the KVM_VM_S390_UCONTROL<br>     flag set</p>
<p>With this capability the KVM support for memory backing with 1m pages<br>through hugetlbfs can be enabled for a VM. After the capability is<br>enabled, cmma can’t be enabled anymore and pfmfi and the storage key<br>interpretation are disabled. If cmma has already been enabled or the<br>hpage module parameter is not set to 1, -EINVAL is returned.</p>
<p>While it is generally possible to create a huge page backed VM without<br>this capability, the VM will not be able to run.</p>
<p>7.14 KVM_CAP_MSR_PLATFORM_INFO</p>
<p>Architectures: x86<br>Parameters: args[0] whether feature should be enabled or not</p>
<p>With this capability, a guest may read the MSR_PLATFORM_INFO MSR. Otherwise,<br>a #GP would be raised when the guest tries to access. Currently, this<br>capability does not enable write permissions of this MSR for the guest.</p>
<p>7.16 KVM_CAP_PPC_NESTED_HV</p>
<p>Architectures: ppc<br>Parameters: none<br>Returns: 0 on success, -EINVAL when the implementation doesn’t support<br>     nested-HV virtualization.</p>
<p>HV-KVM on POWER9 and later systems allows for “nested-HV”<br>virtualization, which provides a way for a guest VM to run guests that<br>can run using the CPU’s supervisor mode (privileged non-hypervisor<br>state).  Enabling this capability on a VM depends on the CPU having<br>the necessary functionality and on the facility being enabled with a<br>kvm-hv module parameter.</p>
<ol start="8">
<li>Other capabilities.</li>
</ol>
<hr>
<p>This section lists capabilities that give information about other<br>features of the KVM implementation.</p>
<p>8.1 KVM_CAP_PPC_HWRNG</p>
<p>Architectures: ppc</p>
<p>This capability, if KVM_CHECK_EXTENSION indicates that it is<br>available, means that that the kernel has an implementation of the<br>H_RANDOM hypercall backed by a hardware random-number generator.<br>If present, the kernel H_RANDOM handler can be enabled for guest use<br>with the KVM_CAP_PPC_ENABLE_HCALL capability.</p>
<p>8.2 KVM_CAP_HYPERV_SYNIC</p>
<p>Architectures: x86<br>This capability, if KVM_CHECK_EXTENSION indicates that it is<br>available, means that that the kernel has an implementation of the<br>Hyper-V Synthetic interrupt controller(SynIC). Hyper-V SynIC is<br>used to support Windows Hyper-V based guest paravirt drivers(VMBus).</p>
<p>In order to use SynIC, it has to be activated by setting this<br>capability via KVM_ENABLE_CAP ioctl on the vcpu fd. Note that this<br>will disable the use of APIC hardware virtualization even if supported<br>by the CPU, as it’s incompatible with SynIC auto-EOI behavior.</p>
<p>8.3 KVM_CAP_PPC_RADIX_MMU</p>
<p>Architectures: ppc</p>
<p>This capability, if KVM_CHECK_EXTENSION indicates that it is<br>available, means that that the kernel can support guests using the<br>radix MMU defined in Power ISA V3.00 (as implemented in the POWER9<br>processor).</p>
<p>8.4 KVM_CAP_PPC_HASH_MMU_V3</p>
<p>Architectures: ppc</p>
<p>This capability, if KVM_CHECK_EXTENSION indicates that it is<br>available, means that that the kernel can support guests using the<br>hashed page table MMU defined in Power ISA V3.00 (as implemented in<br>the POWER9 processor), including in-memory segment tables.</p>
<p>8.5 KVM_CAP_MIPS_VZ</p>
<p>Architectures: mips</p>
<p>This capability, if KVM_CHECK_EXTENSION on the main kvm handle indicates that<br>it is available, means that full hardware assisted virtualization capabilities<br>of the hardware are available for use through KVM. An appropriate<br>KVM_VM_MIPS_* type must be passed to KVM_CREATE_VM to create a VM which<br>utilises it.</p>
<p>If KVM_CHECK_EXTENSION on a kvm VM handle indicates that this capability is<br>available, it means that the VM is using full hardware assisted virtualization<br>capabilities of the hardware. This is useful to check after creating a VM with<br>KVM_VM_MIPS_DEFAULT.</p>
<p>The value returned by KVM_CHECK_EXTENSION should be compared against known<br>values (see below). All other values are reserved. This is to allow for the<br>possibility of other hardware assisted virtualization implementations which<br>may be incompatible with the MIPS VZ ASE.</p>
<p> 0: The trap &amp; emulate implementation is in use to run guest code in user<br>    mode. Guest virtual memory segments are rearranged to fit the guest in the<br>    user mode address space.</p>
<p> 1: The MIPS VZ ASE is in use, providing full hardware assisted<br>    virtualization, including standard guest virtual memory segments.</p>
<p>8.6 KVM_CAP_MIPS_TE</p>
<p>Architectures: mips</p>
<p>This capability, if KVM_CHECK_EXTENSION on the main kvm handle indicates that<br>it is available, means that the trap &amp; emulate implementation is available to<br>run guest code in user mode, even if KVM_CAP_MIPS_VZ indicates that hardware<br>assisted virtualisation is also available. KVM_VM_MIPS_TE (0) must be passed<br>to KVM_CREATE_VM to create a VM which utilises it.</p>
<p>If KVM_CHECK_EXTENSION on a kvm VM handle indicates that this capability is<br>available, it means that the VM is using trap &amp; emulate.</p>
<p>8.7 KVM_CAP_MIPS_64BIT</p>
<p>Architectures: mips</p>
<p>This capability indicates the supported architecture type of the guest, i.e. the<br>supported register and address width.</p>
<p>The values returned when this capability is checked by KVM_CHECK_EXTENSION on a<br>kvm VM handle correspond roughly to the CP0_Config.AT register field, and should<br>be checked specifically against known values (see below). All other values are<br>reserved.</p>
<p> 0: MIPS32 or microMIPS32.<br>    Both registers and addresses are 32-bits wide.<br>    It will only be possible to run 32-bit guest code.</p>
<p> 1: MIPS64 or microMIPS64 with access only to 32-bit compatibility segments.<br>    Registers are 64-bits wide, but addresses are 32-bits wide.<br>    64-bit guest code may run but cannot access MIPS64 memory segments.<br>    It will also be possible to run 32-bit guest code.</p>
<p> 2: MIPS64 or microMIPS64 with access to all address segments.<br>    Both registers and addresses are 64-bits wide.<br>    It will be possible to run 64-bit or 32-bit guest code.</p>
<p>8.9 KVM_CAP_ARM_USER_IRQ</p>
<p>Architectures: arm, arm64<br>This capability, if KVM_CHECK_EXTENSION indicates that it is available, means<br>that if userspace creates a VM without an in-kernel interrupt controller, it<br>will be notified of changes to the output level of in-kernel emulated devices,<br>which can generate virtual interrupts, presented to the VM.<br>For such VMs, on every return to userspace, the kernel<br>updates the vcpu’s run-&gt;s.regs.device_irq_level field to represent the actual<br>output level of the device.</p>
<p>Whenever kvm detects a change in the device output level, kvm guarantees at<br>least one return to userspace before running the VM.  This exit could either<br>be a KVM_EXIT_INTR or any other exit event, like KVM_EXIT_MMIO. This way,<br>userspace can always sample the device output level and re-compute the state of<br>the userspace interrupt controller.  Userspace should always check the state<br>of run-&gt;s.regs.device_irq_level on every kvm exit.<br>The value in run-&gt;s.regs.device_irq_level can represent both level and edge<br>triggered interrupt signals, depending on the device.  Edge triggered interrupt<br>signals will exit to userspace with the bit in run-&gt;s.regs.device_irq_level<br>set exactly once per edge signal.</p>
<p>The field run-&gt;s.regs.device_irq_level is available independent of<br>run-&gt;kvm_valid_regs or run-&gt;kvm_dirty_regs bits.</p>
<p>If KVM_CAP_ARM_USER_IRQ is supported, the KVM_CHECK_EXTENSION ioctl returns a<br>number larger than 0 indicating the version of this capability is implemented<br>and thereby which bits in in run-&gt;s.regs.device_irq_level can signal values.</p>
<p>Currently the following bits are defined for the device_irq_level bitmap:</p>
<p>  KVM_CAP_ARM_USER_IRQ &gt;= 1:</p>
<pre><code>KVM_ARM_DEV_EL1_VTIMER -  EL1 virtual timer
KVM_ARM_DEV_EL1_PTIMER -  EL1 physical timer
KVM_ARM_DEV_PMU        -  ARM PMU overflow interrupt signal
</code></pre>
<p>Future versions of kvm may implement additional events. These will get<br>indicated by returning a higher number from KVM_CHECK_EXTENSION and will be<br>listed above.</p>
<p>8.10 KVM_CAP_PPC_SMT_POSSIBLE</p>
<p>Architectures: ppc</p>
<p>Querying this capability returns a bitmap indicating the possible<br>virtual SMT modes that can be set using KVM_CAP_PPC_SMT.  If bit N<br>(counting from the right) is set, then a virtual SMT mode of 2^N is<br>available.</p>
<p>8.11 KVM_CAP_HYPERV_SYNIC2</p>
<p>Architectures: x86</p>
<p>This capability enables a newer version of Hyper-V Synthetic interrupt<br>controller (SynIC).  The only difference with KVM_CAP_HYPERV_SYNIC is that KVM<br>doesn’t clear SynIC message and event flags pages when they are enabled by<br>writing to the respective MSRs.</p>
<p>8.12 KVM_CAP_HYPERV_VP_INDEX</p>
<p>Architectures: x86</p>
<p>This capability indicates that userspace can load HV_X64_MSR_VP_INDEX msr.  Its<br>value is used to denote the target vcpu for a SynIC interrupt.  For<br>compatibilty, KVM initializes this msr to KVM’s internal vcpu index.  When this<br>capability is absent, userspace can still query this msr’s value.</p>
<p>8.13 KVM_CAP_S390_AIS_MIGRATION</p>
<p>Architectures: s390<br>Parameters: none</p>
<p>This capability indicates if the flic device will be able to get/set the<br>AIS states for migration via the KVM_DEV_FLIC_AISM_ALL attribute and allows<br>to discover this without having to create a flic device.</p>
<p>8.14 KVM_CAP_S390_PSW</p>
<p>Architectures: s390</p>
<p>This capability indicates that the PSW is exposed via the kvm_run structure.</p>
<p>8.15 KVM_CAP_S390_GMAP</p>
<p>Architectures: s390</p>
<p>This capability indicates that the user space memory used as guest mapping can<br>be anywhere in the user memory address space, as long as the memory slots are<br>aligned and sized to a segment (1MB) boundary.</p>
<p>8.16 KVM_CAP_S390_COW</p>
<p>Architectures: s390</p>
<p>This capability indicates that the user space memory used as guest mapping can<br>use copy-on-write semantics as well as dirty pages tracking via read-only page<br>tables.</p>
<p>8.17 KVM_CAP_S390_BPB</p>
<p>Architectures: s390</p>
<p>This capability indicates that kvm will implement the interfaces to handle<br>reset, migration and nested KVM for branch prediction blocking. The stfle<br>facility 82 should not be provided to the guest without this capability.</p>
<p>8.18 KVM_CAP_HYPERV_TLBFLUSH</p>
<p>Architectures: x86</p>
<p>This capability indicates that KVM supports paravirtualized Hyper-V TLB Flush<br>hypercalls:<br>HvFlushVirtualAddressSpace, HvFlushVirtualAddressSpaceEx,<br>HvFlushVirtualAddressList, HvFlushVirtualAddressListEx.</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_api/" title="Kernel-4.18.0-80.el8_api" target="_blank" rel="external">http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_api/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/02/19/Kernel-4.18.0-80.el8_histogram/" title="Kernel-4.18.0-80.el8_histogra"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/02/19/Kernel-4.18.0-80.el8_kernel-parameters/" title="Kernel-4.18.0-80.el8_kernel-parameters"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>