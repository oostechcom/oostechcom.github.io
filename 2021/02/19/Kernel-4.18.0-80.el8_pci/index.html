<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-4.18.0-80.el8_pci | oosTech.com</title>
  <meta name="description" content="PCI Power Management Copyright (c) 2010 Rafael J. Wysocki &amp;#x72;&amp;#x6a;&amp;#119;&amp;#64;&amp;#x73;&amp;#x69;&amp;#115;&amp;#107;&amp;#46;&amp;#x70;&amp;#x6c;, Novell Inc. An overview of concepts and the Linux kernel’s interfaces relate">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-4.18.0-80.el8_pci">
<meta property="og:url" content="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_pci/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="PCI Power Management Copyright (c) 2010 Rafael J. Wysocki &amp;#x72;&amp;#x6a;&amp;#119;&amp;#64;&amp;#x73;&amp;#x69;&amp;#115;&amp;#107;&amp;#46;&amp;#x70;&amp;#x6c;, Novell Inc. An overview of concepts and the Linux kernel’s interfaces relate">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-18T16:00:00.000Z">
<meta property="article:modified_time" content="2021-02-18T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_pci/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_mpc5200/" class="title">Kernel-3.10.0-957.el7_mpc5200</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_6pack/" class="title">Kernel-3.10.0-957.el7_6pack</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Hardware-and-Platform-Support-for-PCI-Power-Management"><span class="toc-number">1.</span> <span class="toc-text">Hardware and Platform Support for PCI Power Management</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Native-and-Platform-Based-Power-Management"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. Native and Platform-Based Power Management</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Native-PCI-Power-Management"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. Native PCI Power Management</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-ACPI-Device-Power-Management"><span class="toc-number">1.3.</span> <span class="toc-text">1.3. ACPI Device Power Management</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Wakeup-Signaling"><span class="toc-number">1.4.</span> <span class="toc-text">1.4. Wakeup Signaling</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PCI-Subsystem-and-Device-Power-Management"><span class="toc-number">2.</span> <span class="toc-text">PCI Subsystem and Device Power Management</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Device-Power-Management-Callbacks"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. Device Power Management Callbacks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Device-Initialization"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. Device Initialization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Runtime-Device-Power-Management"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. Runtime Device Power Management</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-System-Wide-Power-Transitions"><span class="toc-number">2.4.</span> <span class="toc-text">2.4. System-Wide Power Transitions</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PCI-Device-Drivers-and-Power-Management"><span class="toc-number">3.</span> <span class="toc-text">PCI Device Drivers and Power Management</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Power-Management-Callbacks"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. Power Management Callbacks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Device-Runtime-Power-Management"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. Device Runtime Power Management</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Resources"><span class="toc-number">4.</span> <span class="toc-text">Resources</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-4.18.0-80.el8_pci" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-4.18.0-80.el8_pci
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/02/19/Kernel-4.18.0-80.el8_pci/" class="article-date">
	 published: <time datetime="2021-02-18T16:00:00.000Z" itemprop="datePublished">2021-02-19</time>
	</a>
</span>

        
	<a href="/2021/02/19/Kernel-4.18.0-80.el8_pci/" class="article-date">
	   updated: <time datetime="2021-02-18T16:00:00.000Z" itemprop="dateUpdated">2021-02-19</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/02/19/Kernel-4.18.0-80.el8_pci/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>PCI Power Management</p>
<p>Copyright (c) 2010 Rafael J. Wysocki <a href="mailto:&#x72;&#x6a;&#119;&#64;&#x73;&#x69;&#115;&#107;&#46;&#x70;&#x6c;">&#x72;&#x6a;&#119;&#64;&#x73;&#x69;&#115;&#107;&#46;&#x70;&#x6c;</a>, Novell Inc.</p>
<p>An overview of concepts and the Linux kernel’s interfaces related to PCI power<br>management.  Based on previous work by Patrick Mochel <a href="mailto:&#109;&#111;&#99;&#104;&#101;&#x6c;&#x40;&#116;&#x72;&#97;&#x6e;&#115;&#x6d;&#x65;&#x74;&#97;&#x2e;&#99;&#x6f;&#x6d;">&#109;&#111;&#99;&#104;&#101;&#x6c;&#x40;&#116;&#x72;&#97;&#x6e;&#115;&#x6d;&#x65;&#x74;&#97;&#x2e;&#99;&#x6f;&#x6d;</a><br>(and others).</p>
<p>This document only covers the aspects of power management specific to PCI<br>devices.  For general description of the kernel’s interfaces related to device<br>power management refer to Documentation/driver-api/pm/devices.rst and<br>Documentation/power/runtime_pm.txt.</p>
<hr>
<ol>
<li>Hardware and Platform Support for PCI Power Management</li>
<li>PCI Subsystem and Device Power Management</li>
<li>PCI Device Drivers and Power Management</li>
<li>Resources</li>
</ol>
<ol>
<li><h1 id="Hardware-and-Platform-Support-for-PCI-Power-Management"><a href="#Hardware-and-Platform-Support-for-PCI-Power-Management" class="headerlink" title="Hardware and Platform Support for PCI Power Management"></a>Hardware and Platform Support for PCI Power Management</h1></li>
</ol>
<h2 id="1-1-Native-and-Platform-Based-Power-Management"><a href="#1-1-Native-and-Platform-Based-Power-Management" class="headerlink" title="1.1. Native and Platform-Based Power Management"></a>1.1. Native and Platform-Based Power Management</h2><p>In general, power management is a feature allowing one to save energy by putting<br>devices into states in which they draw less power (low-power states) at the<br>price of reduced functionality or performance.</p>
<p>Usually, a device is put into a low-power state when it is underutilized or<br>completely inactive.  However, when it is necessary to use the device once<br>again, it has to be put back into the “fully functional” state (full-power<br>state).  This may happen when there are some data for the device to handle or<br>as a result of an external event requiring the device to be active, which may<br>be signaled by the device itself.</p>
<p>PCI devices may be put into low-power states in two ways, by using the device<br>capabilities introduced by the PCI Bus Power Management Interface Specification,<br>or with the help of platform firmware, such as an ACPI BIOS.  In the first<br>approach, that is referred to as the native PCI power management (native PCI PM)<br>in what follows, the device power state is changed as a result of writing a<br>specific value into one of its standard configuration registers.  The second<br>approach requires the platform firmware to provide special methods that may be<br>used by the kernel to change the device’s power state.</p>
<p>Devices supporting the native PCI PM usually can generate wakeup signals called<br>Power Management Events (PMEs) to let the kernel know about external events<br>requiring the device to be active.  After receiving a PME the kernel is supposed<br>to put the device that sent it into the full-power state.  However, the PCI Bus<br>Power Management Interface Specification doesn’t define any standard method of<br>delivering the PME from the device to the CPU and the operating system kernel.<br>It is assumed that the platform firmware will perform this task and therefore,<br>even though a PCI device is set up to generate PMEs, it also may be necessary to<br>prepare the platform firmware for notifying the CPU of the PMEs coming from the<br>device (e.g. by generating interrupts).</p>
<p>In turn, if the methods provided by the platform firmware are used for changing<br>the power state of a device, usually the platform also provides a method for<br>preparing the device to generate wakeup signals.  In that case, however, it<br>often also is necessary to prepare the device for generating PMEs using the<br>native PCI PM mechanism, because the method provided by the platform depends on<br>that.</p>
<p>Thus in many situations both the native and the platform-based power management<br>mechanisms have to be used simultaneously to obtain the desired result.</p>
<h2 id="1-2-Native-PCI-Power-Management"><a href="#1-2-Native-PCI-Power-Management" class="headerlink" title="1.2. Native PCI Power Management"></a>1.2. Native PCI Power Management</h2><p>The PCI Bus Power Management Interface Specification (PCI PM Spec) was<br>introduced between the PCI 2.1 and PCI 2.2 Specifications.  It defined a<br>standard interface for performing various operations related to power<br>management.</p>
<p>The implementation of the PCI PM Spec is optional for conventional PCI devices,<br>but it is mandatory for PCI Express devices.  If a device supports the PCI PM<br>Spec, it has an 8 byte power management capability field in its PCI<br>configuration space.  This field is used to describe and control the standard<br>features related to the native PCI power management.</p>
<p>The PCI PM Spec defines 4 operating states for devices (D0-D3) and for buses<br>(B0-B3).  The higher the number, the less power is drawn by the device or bus<br>in that state.  However, the higher the number, the longer the latency for<br>the device or bus to return to the full-power state (D0 or B0, respectively).</p>
<p>There are two variants of the D3 state defined by the specification.  The first<br>one is D3hot, referred to as the software accessible D3, because devices can be<br>programmed to go into it.  The second one, D3cold, is the state that PCI devices<br>are in when the supply voltage (Vcc) is removed from them.  It is not possible<br>to program a PCI device to go into D3cold, although there may be a programmable<br>interface for putting the bus the device is on into a state in which Vcc is<br>removed from all devices on the bus.</p>
<p>PCI bus power management, however, is not supported by the Linux kernel at the<br>time of this writing and therefore it is not covered by this document.</p>
<p>Note that every PCI device can be in the full-power state (D0) or in D3cold,<br>regardless of whether or not it implements the PCI PM Spec.  In addition to<br>that, if the PCI PM Spec is implemented by the device, it must support D3hot<br>as well as D0.  The support for the D1 and D2 power states is optional.</p>
<p>PCI devices supporting the PCI PM Spec can be programmed to go to any of the<br>supported low-power states (except for D3cold).  While in D1-D3hot the<br>standard configuration registers of the device must be accessible to software<br>(i.e. the device is required to respond to PCI configuration accesses), although<br>its I/O and memory spaces are then disabled.  This allows the device to be<br>programmatically put into D0.  Thus the kernel can switch the device back and<br>forth between D0 and the supported low-power states (except for D3cold) and the<br>possible power state transitions the device can undergo are the following:</p>
<p>+—————————-+<br>| Current State | New State  |<br>+—————————-+<br>| D0            | D1, D2, D3 |<br>+—————————-+<br>| D1            | D2, D3     |<br>+—————————-+<br>| D2            | D3         |<br>+—————————-+<br>| D1, D2, D3    | D0         |<br>+—————————-+</p>
<p>The transition from D3cold to D0 occurs when the supply voltage is provided to<br>the device (i.e. power is restored).  In that case the device returns to D0 with<br>a full power-on reset sequence and the power-on defaults are restored to the<br>device by hardware just as at initial power up.</p>
<p>PCI devices supporting the PCI PM Spec can be programmed to generate PMEs<br>while in a low-power state (D1-D3), but they are not required to be capable<br>of generating PMEs from all supported low-power states.  In particular, the<br>capability of generating PMEs from D3cold is optional and depends on the<br>presence of additional voltage (3.3Vaux) allowing the device to remain<br>sufficiently active to generate a wakeup signal.</p>
<h2 id="1-3-ACPI-Device-Power-Management"><a href="#1-3-ACPI-Device-Power-Management" class="headerlink" title="1.3. ACPI Device Power Management"></a>1.3. ACPI Device Power Management</h2><p>The platform firmware support for the power management of PCI devices is<br>system-specific.  However, if the system in question is compliant with the<br>Advanced Configuration and Power Interface (ACPI) Specification, like the<br>majority of x86-based systems, it is supposed to implement device power<br>management interfaces defined by the ACPI standard.</p>
<p>For this purpose the ACPI BIOS provides special functions called “control<br>methods” that may be executed by the kernel to perform specific tasks, such as<br>putting a device into a low-power state.  These control methods are encoded<br>using special byte-code language called the ACPI Machine Language (AML) and<br>stored in the machine’s BIOS.  The kernel loads them from the BIOS and executes<br>them as needed using an AML interpreter that translates the AML byte code into<br>computations and memory or I/O space accesses.  This way, in theory, a BIOS<br>writer can provide the kernel with a means to perform actions depending<br>on the system design in a system-specific fashion.</p>
<p>ACPI control methods may be divided into global control methods, that are not<br>associated with any particular devices, and device control methods, that have<br>to be defined separately for each device supposed to be handled with the help of<br>the platform.  This means, in particular, that ACPI device control methods can<br>only be used to handle devices that the BIOS writer knew about in advance.  The<br>ACPI methods used for device power management fall into that category.</p>
<p>The ACPI specification assumes that devices can be in one of four power states<br>labeled as D0, D1, D2, and D3 that roughly correspond to the native PCI PM<br>D0-D3 states (although the difference between D3hot and D3cold is not taken<br>into account by ACPI).  Moreover, for each power state of a device there is a<br>set of power resources that have to be enabled for the device to be put into<br>that state.  These power resources are controlled (i.e. enabled or disabled)<br>with the help of their own control methods, _ON and _OFF, that have to be<br>defined individually for each of them.</p>
<p>To put a device into the ACPI power state Dx (where x is a number between 0 and<br>3 inclusive) the kernel is supposed to (1) enable the power resources required<br>by the device in this state using their _ON control methods and (2) execute the<br>_PSx control method defined for the device.  In addition to that, if the device<br>is going to be put into a low-power state (D1-D3) and is supposed to generate<br>wakeup signals from that state, the _DSW (or _PSW, replaced with _DSW by ACPI<br>3.0) control method defined for it has to be executed before _PSx.  Power<br>resources that are not required by the device in the target power state and are<br>not required any more by any other device should be disabled (by executing their<br>_OFF control methods).  If the current power state of the device is D3, it can<br>only be put into D0 this way.</p>
<p>However, quite often the power states of devices are changed during a<br>system-wide transition into a sleep state or back into the working state.  ACPI<br>defines four system sleep states, S1, S2, S3, and S4, and denotes the system<br>working state as S0.  In general, the target system sleep (or working) state<br>determines the highest power (lowest number) state the device can be put<br>into and the kernel is supposed to obtain this information by executing the<br>device’s _SxD control method (where x is a number between 0 and 4 inclusive).<br>If the device is required to wake up the system from the target sleep state, the<br>lowest power (highest number) state it can be put into is also determined by the<br>target state of the system.  The kernel is then supposed to use the device’s<br>_SxW control method to obtain the number of that state.  It also is supposed to<br>use the device’s _PRW control method to learn which power resources need to be<br>enabled for the device to be able to generate wakeup signals.</p>
<h2 id="1-4-Wakeup-Signaling"><a href="#1-4-Wakeup-Signaling" class="headerlink" title="1.4. Wakeup Signaling"></a>1.4. Wakeup Signaling</h2><p>Wakeup signals generated by PCI devices, either as native PCI PMEs, or as<br>a result of the execution of the _DSW (or _PSW) ACPI control method before<br>putting the device into a low-power state, have to be caught and handled as<br>appropriate.  If they are sent while the system is in the working state<br>(ACPI S0), they should be translated into interrupts so that the kernel can<br>put the devices generating them into the full-power state and take care of the<br>events that triggered them.  In turn, if they are sent while the system is<br>sleeping, they should cause the system’s core logic to trigger wakeup.</p>
<p>On ACPI-based systems wakeup signals sent by conventional PCI devices are<br>converted into ACPI General-Purpose Events (GPEs) which are hardware signals<br>from the system core logic generated in response to various events that need to<br>be acted upon.  Every GPE is associated with one or more sources of potentially<br>interesting events.  In particular, a GPE may be associated with a PCI device<br>capable of signaling wakeup.  The information on the connections between GPEs<br>and event sources is recorded in the system’s ACPI BIOS from where it can be<br>read by the kernel.</p>
<p>If a PCI device known to the system’s ACPI BIOS signals wakeup, the GPE<br>associated with it (if there is one) is triggered.  The GPEs associated with PCI<br>bridges may also be triggered in response to a wakeup signal from one of the<br>devices below the bridge (this also is the case for root bridges) and, for<br>example, native PCI PMEs from devices unknown to the system’s ACPI BIOS may be<br>handled this way.</p>
<p>A GPE may be triggered when the system is sleeping (i.e. when it is in one of<br>the ACPI S1-S4 states), in which case system wakeup is started by its core logic<br>(the device that was the source of the signal causing the system wakeup to occur<br>may be identified later).  The GPEs used in such situations are referred to as<br>wakeup GPEs.</p>
<p>Usually, however, GPEs are also triggered when the system is in the working<br>state (ACPI S0) and in that case the system’s core logic generates a System<br>Control Interrupt (SCI) to notify the kernel of the event.  Then, the SCI<br>handler identifies the GPE that caused the interrupt to be generated which,<br>in turn, allows the kernel to identify the source of the event (that may be<br>a PCI device signaling wakeup).  The GPEs used for notifying the kernel of<br>events occurring while the system is in the working state are referred to as<br>runtime GPEs.</p>
<p>Unfortunately, there is no standard way of handling wakeup signals sent by<br>conventional PCI devices on systems that are not ACPI-based, but there is one<br>for PCI Express devices.  Namely, the PCI Express Base Specification introduced<br>a native mechanism for converting native PCI PMEs into interrupts generated by<br>root ports.  For conventional PCI devices native PMEs are out-of-band, so they<br>are routed separately and they need not pass through bridges (in principle they<br>may be routed directly to the system’s core logic), but for PCI Express devices<br>they are in-band messages that have to pass through the PCI Express hierarchy,<br>including the root port on the path from the device to the Root Complex.  Thus<br>it was possible to introduce a mechanism by which a root port generates an<br>interrupt whenever it receives a PME message from one of the devices below it.<br>The PCI Express Requester ID of the device that sent the PME message is then<br>recorded in one of the root port’s configuration registers from where it may be<br>read by the interrupt handler allowing the device to be identified.  [PME<br>messages sent by PCI Express endpoints integrated with the Root Complex don’t<br>pass through root ports, but instead they cause a Root Complex Event Collector<br>(if there is one) to generate interrupts.]</p>
<p>In principle the native PCI Express PME signaling may also be used on ACPI-based<br>systems along with the GPEs, but to use it the kernel has to ask the system’s<br>ACPI BIOS to release control of root port configuration registers.  The ACPI<br>BIOS, however, is not required to allow the kernel to control these registers<br>and if it doesn’t do that, the kernel must not modify their contents.  Of course<br>the native PCI Express PME signaling cannot be used by the kernel in that case.</p>
<ol start="2">
<li><h1 id="PCI-Subsystem-and-Device-Power-Management"><a href="#PCI-Subsystem-and-Device-Power-Management" class="headerlink" title="PCI Subsystem and Device Power Management"></a>PCI Subsystem and Device Power Management</h1></li>
</ol>
<h2 id="2-1-Device-Power-Management-Callbacks"><a href="#2-1-Device-Power-Management-Callbacks" class="headerlink" title="2.1. Device Power Management Callbacks"></a>2.1. Device Power Management Callbacks</h2><p>The PCI Subsystem participates in the power management of PCI devices in a<br>number of ways.  First of all, it provides an intermediate code layer between<br>the device power management core (PM core) and PCI device drivers.<br>Specifically, the pm field of the PCI subsystem’s struct bus_type object,<br>pci_bus_type, points to a struct dev_pm_ops object, pci_dev_pm_ops, containing<br>pointers to several device power management callbacks:</p>
<p>const struct dev_pm_ops pci_dev_pm_ops = {<br>    .prepare = pci_pm_prepare,<br>    .complete = pci_pm_complete,<br>    .suspend = pci_pm_suspend,<br>    .resume = pci_pm_resume,<br>    .freeze = pci_pm_freeze,<br>    .thaw = pci_pm_thaw,<br>    .poweroff = pci_pm_poweroff,<br>    .restore = pci_pm_restore,<br>    .suspend_noirq = pci_pm_suspend_noirq,<br>    .resume_noirq = pci_pm_resume_noirq,<br>    .freeze_noirq = pci_pm_freeze_noirq,<br>    .thaw_noirq = pci_pm_thaw_noirq,<br>    .poweroff_noirq = pci_pm_poweroff_noirq,<br>    .restore_noirq = pci_pm_restore_noirq,<br>    .runtime_suspend = pci_pm_runtime_suspend,<br>    .runtime_resume = pci_pm_runtime_resume,<br>    .runtime_idle = pci_pm_runtime_idle,<br>};</p>
<p>These callbacks are executed by the PM core in various situations related to<br>device power management and they, in turn, execute power management callbacks<br>provided by PCI device drivers.  They also perform power management operations<br>involving some standard configuration registers of PCI devices that device<br>drivers need not know or care about.</p>
<p>The structure representing a PCI device, struct pci_dev, contains several fields<br>that these callbacks operate on:</p>
<p>struct pci_dev {<br>    …<br>    pci_power_t     current_state;  /* Current operating state. <em>/<br>    int        pm_cap;        /</em> PM capability offset in the<br>                       configuration space <em>/<br>    unsigned int    pme_support:5;    /</em> Bitmask of states from which PME#<br>                       can be generated <em>/<br>    unsigned int    pme_interrupt:1;/</em> Is native PCIe PME signaling used? <em>/<br>    unsigned int    d1_support:1;    /</em> Low power state D1 is supported <em>/<br>    unsigned int    d2_support:1;    /</em> Low power state D2 is supported <em>/<br>    unsigned int    no_d1d2:1;    /</em> D1 and D2 are forbidden <em>/<br>    unsigned int    wakeup_prepared:1;  /</em> Device prepared for wake up <em>/<br>    unsigned int    d3_delay;    /</em> D3-&gt;D0 transition time in ms */<br>    …<br>};</p>
<p>They also indirectly use some fields of the struct device that is embedded in<br>struct pci_dev.</p>
<h2 id="2-2-Device-Initialization"><a href="#2-2-Device-Initialization" class="headerlink" title="2.2. Device Initialization"></a>2.2. Device Initialization</h2><p>The PCI subsystem’s first task related to device power management is to<br>prepare the device for power management and initialize the fields of struct<br>pci_dev used for this purpose.  This happens in two functions defined in<br>drivers/pci/pci.c, pci_pm_init() and platform_pci_wakeup_init().</p>
<p>The first of these functions checks if the device supports native PCI PM<br>and if that’s the case the offset of its power management capability structure<br>in the configuration space is stored in the pm_cap field of the device’s struct<br>pci_dev object.  Next, the function checks which PCI low-power states are<br>supported by the device and from which low-power states the device can generate<br>native PCI PMEs.  The power management fields of the device’s struct pci_dev and<br>the struct device embedded in it are updated accordingly and the generation of<br>PMEs by the device is disabled.</p>
<p>The second function checks if the device can be prepared to signal wakeup with<br>the help of the platform firmware, such as the ACPI BIOS.  If that is the case,<br>the function updates the wakeup fields in struct device embedded in the<br>device’s struct pci_dev and uses the firmware-provided method to prevent the<br>device from signaling wakeup.</p>
<p>At this point the device is ready for power management.  For driverless devices,<br>however, this functionality is limited to a few basic operations carried out<br>during system-wide transitions to a sleep state and back to the working state.</p>
<h2 id="2-3-Runtime-Device-Power-Management"><a href="#2-3-Runtime-Device-Power-Management" class="headerlink" title="2.3. Runtime Device Power Management"></a>2.3. Runtime Device Power Management</h2><p>The PCI subsystem plays a vital role in the runtime power management of PCI<br>devices.  For this purpose it uses the general runtime power management<br>(runtime PM) framework described in Documentation/power/runtime_pm.txt.<br>Namely, it provides subsystem-level callbacks:</p>
<pre><code>pci_pm_runtime_suspend()
pci_pm_runtime_resume()
pci_pm_runtime_idle()
</code></pre>
<p>that are executed by the core runtime PM routines.  It also implements the<br>entire mechanics necessary for handling runtime wakeup signals from PCI devices<br>in low-power states, which at the time of this writing works for both the native<br>PCI Express PME signaling and the ACPI GPE-based wakeup signaling described in<br>Section 1.</p>
<p>First, a PCI device is put into a low-power state, or suspended, with the help<br>of pm_schedule_suspend() or pm_runtime_suspend() which for PCI devices call<br>pci_pm_runtime_suspend() to do the actual job.  For this to work, the device’s<br>driver has to provide a pm-&gt;runtime_suspend() callback (see below), which is<br>run by pci_pm_runtime_suspend() as the first action.  If the driver’s callback<br>returns successfully, the device’s standard configuration registers are saved,<br>the device is prepared to generate wakeup signals and, finally, it is put into<br>the target low-power state.</p>
<p>The low-power state to put the device into is the lowest-power (highest number)<br>state from which it can signal wakeup.  The exact method of signaling wakeup is<br>system-dependent and is determined by the PCI subsystem on the basis of the<br>reported capabilities of the device and the platform firmware.  To prepare the<br>device for signaling wakeup and put it into the selected low-power state, the<br>PCI subsystem can use the platform firmware as well as the device’s native PCI<br>PM capabilities, if supported.</p>
<p>It is expected that the device driver’s pm-&gt;runtime_suspend() callback will<br>not attempt to prepare the device for signaling wakeup or to put it into a<br>low-power state.  The driver ought to leave these tasks to the PCI subsystem<br>that has all of the information necessary to perform them.</p>
<p>A suspended device is brought back into the “active” state, or resumed,<br>with the help of pm_request_resume() or pm_runtime_resume() which both call<br>pci_pm_runtime_resume() for PCI devices.  Again, this only works if the device’s<br>driver provides a pm-&gt;runtime_resume() callback (see below).  However, before<br>the driver’s callback is executed, pci_pm_runtime_resume() brings the device<br>back into the full-power state, prevents it from signaling wakeup while in that<br>state and restores its standard configuration registers.  Thus the driver’s<br>callback need not worry about the PCI-specific aspects of the device resume.</p>
<p>Note that generally pci_pm_runtime_resume() may be called in two different<br>situations.  First, it may be called at the request of the device’s driver, for<br>example if there are some data for it to process.  Second, it may be called<br>as a result of a wakeup signal from the device itself (this sometimes is<br>referred to as “remote wakeup”).  Of course, for this purpose the wakeup signal<br>is handled in one of the ways described in Section 1 and finally converted into<br>a notification for the PCI subsystem after the source device has been<br>identified.</p>
<p>The pci_pm_runtime_idle() function, called for PCI devices by pm_runtime_idle()<br>and pm_request_idle(), executes the device driver’s pm-&gt;runtime_idle()<br>callback, if defined, and if that callback doesn’t return error code (or is not<br>present at all), suspends the device with the help of pm_runtime_suspend().<br>Sometimes pci_pm_runtime_idle() is called automatically by the PM core (for<br>example, it is called right after the device has just been resumed), in which<br>cases it is expected to suspend the device if that makes sense.  Usually,<br>however, the PCI subsystem doesn’t really know if the device really can be<br>suspended, so it lets the device’s driver decide by running its<br>pm-&gt;runtime_idle() callback.</p>
<h2 id="2-4-System-Wide-Power-Transitions"><a href="#2-4-System-Wide-Power-Transitions" class="headerlink" title="2.4. System-Wide Power Transitions"></a>2.4. System-Wide Power Transitions</h2><p>There are a few different types of system-wide power transitions, described in<br>Documentation/driver-api/pm/devices.rst.  Each of them requires devices to be handled<br>in a specific way and the PM core executes subsystem-level power management<br>callbacks for this purpose.  They are executed in phases such that each phase<br>involves executing the same subsystem-level callback for every device belonging<br>to the given subsystem before the next phase begins.  These phases always run<br>after tasks have been frozen.</p>
<p>2.4.1. System Suspend</p>
<p>When the system is going into a sleep state in which the contents of memory will<br>be preserved, such as one of the ACPI sleep states S1-S3, the phases are:</p>
<pre><code>prepare, suspend, suspend_noirq.
</code></pre>
<p>The following PCI bus type’s callbacks, respectively, are used in these phases:</p>
<pre><code>pci_pm_prepare()
pci_pm_suspend()
pci_pm_suspend_noirq()
</code></pre>
<p>The pci_pm_prepare() routine first puts the device into the “fully functional”<br>state with the help of pm_runtime_resume().  Then, it executes the device<br>driver’s pm-&gt;prepare() callback if defined (i.e. if the driver’s struct<br>dev_pm_ops object is present and the prepare pointer in that object is valid).</p>
<p>The pci_pm_suspend() routine first checks if the device’s driver implements<br>legacy PCI suspend routines (see Section 3), in which case the driver’s legacy<br>suspend callback is executed, if present, and its result is returned.  Next, if<br>the device’s driver doesn’t provide a struct dev_pm_ops object (containing<br>pointers to the driver’s callbacks), pci_pm_default_suspend() is called, which<br>simply turns off the device’s bus master capability and runs<br>pcibios_disable_device() to disable it, unless the device is a bridge (PCI<br>bridges are ignored by this routine).  Next, the device driver’s pm-&gt;suspend()<br>callback is executed, if defined, and its result is returned if it fails.<br>Finally, pci_fixup_device() is called to apply hardware suspend quirks related<br>to the device if necessary.</p>
<p>Note that the suspend phase is carried out asynchronously for PCI devices, so<br>the pci_pm_suspend() callback may be executed in parallel for any pair of PCI<br>devices that don’t depend on each other in a known way (i.e. none of the paths<br>in the device tree from the root bridge to a leaf device contains both of them).</p>
<p>The pci_pm_suspend_noirq() routine is executed after suspend_device_irqs() has<br>been called, which means that the device driver’s interrupt handler won’t be<br>invoked while this routine is running.  It first checks if the device’s driver<br>implements legacy PCI suspends routines (Section 3), in which case the legacy<br>late suspend routine is called and its result is returned (the standard<br>configuration registers of the device are saved if the driver’s callback hasn’t<br>done that).  Second, if the device driver’s struct dev_pm_ops object is not<br>present, the device’s standard configuration registers are saved and the routine<br>returns success.  Otherwise the device driver’s pm-&gt;suspend_noirq() callback is<br>executed, if present, and its result is returned if it fails.  Next, if the<br>device’s standard configuration registers haven’t been saved yet (one of the<br>device driver’s callbacks executed before might do that), pci_pm_suspend_noirq()<br>saves them, prepares the device to signal wakeup (if necessary) and puts it into<br>a low-power state.</p>
<p>The low-power state to put the device into is the lowest-power (highest number)<br>state from which it can signal wakeup while the system is in the target sleep<br>state.  Just like in the runtime PM case described above, the mechanism of<br>signaling wakeup is system-dependent and determined by the PCI subsystem, which<br>is also responsible for preparing the device to signal wakeup from the system’s<br>target sleep state as appropriate.</p>
<p>PCI device drivers (that don’t implement legacy power management callbacks) are<br>generally not expected to prepare devices for signaling wakeup or to put them<br>into low-power states.  However, if one of the driver’s suspend callbacks<br>(pm-&gt;suspend() or pm-&gt;suspend_noirq()) saves the device’s standard configuration<br>registers, pci_pm_suspend_noirq() will assume that the device has been prepared<br>to signal wakeup and put into a low-power state by the driver (the driver is<br>then assumed to have used the helper functions provided by the PCI subsystem for<br>this purpose).  PCI device drivers are not encouraged to do that, but in some<br>rare cases doing that in the driver may be the optimum approach.</p>
<p>2.4.2. System Resume</p>
<p>When the system is undergoing a transition from a sleep state in which the<br>contents of memory have been preserved, such as one of the ACPI sleep states<br>S1-S3, into the working state (ACPI S0), the phases are:</p>
<pre><code>resume_noirq, resume, complete.
</code></pre>
<p>The following PCI bus type’s callbacks, respectively, are executed in these<br>phases:</p>
<pre><code>pci_pm_resume_noirq()
pci_pm_resume()
pci_pm_complete()
</code></pre>
<p>The pci_pm_resume_noirq() routine first puts the device into the full-power<br>state, restores its standard configuration registers and applies early resume<br>hardware quirks related to the device, if necessary.  This is done<br>unconditionally, regardless of whether or not the device’s driver implements<br>legacy PCI power management callbacks (this way all PCI devices are in the<br>full-power state and their standard configuration registers have been restored<br>when their interrupt handlers are invoked for the first time during resume,<br>which allows the kernel to avoid problems with the handling of shared interrupts<br>by drivers whose devices are still suspended).  If legacy PCI power management<br>callbacks (see Section 3) are implemented by the device’s driver, the legacy<br>early resume callback is executed and its result is returned.  Otherwise, the<br>device driver’s pm-&gt;resume_noirq() callback is executed, if defined, and its<br>result is returned.</p>
<p>The pci_pm_resume() routine first checks if the device’s standard configuration<br>registers have been restored and restores them if that’s not the case (this<br>only is necessary in the error path during a failing suspend).  Next, resume<br>hardware quirks related to the device are applied, if necessary, and if the<br>device’s driver implements legacy PCI power management callbacks (see<br>Section 3), the driver’s legacy resume callback is executed and its result is<br>returned.  Otherwise, the device’s wakeup signaling mechanisms are blocked and<br>its driver’s pm-&gt;resume() callback is executed, if defined (the callback’s<br>result is then returned).</p>
<p>The resume phase is carried out asynchronously for PCI devices, like the<br>suspend phase described above, which means that if two PCI devices don’t depend<br>on each other in a known way, the pci_pm_resume() routine may be executed for<br>the both of them in parallel.</p>
<p>The pci_pm_complete() routine only executes the device driver’s pm-&gt;complete()<br>callback, if defined.</p>
<p>2.4.3. System Hibernation</p>
<p>System hibernation is more complicated than system suspend, because it requires<br>a system image to be created and written into a persistent storage medium.  The<br>image is created atomically and all devices are quiesced, or frozen, before that<br>happens.</p>
<p>The freezing of devices is carried out after enough memory has been freed (at<br>the time of this writing the image creation requires at least 50% of system RAM<br>to be free) in the following three phases:</p>
<pre><code>prepare, freeze, freeze_noirq
</code></pre>
<p>that correspond to the PCI bus type’s callbacks:</p>
<pre><code>pci_pm_prepare()
pci_pm_freeze()
pci_pm_freeze_noirq()
</code></pre>
<p>This means that the prepare phase is exactly the same as for system suspend.<br>The other two phases, however, are different.</p>
<p>The pci_pm_freeze() routine is quite similar to pci_pm_suspend(), but it runs<br>the device driver’s pm-&gt;freeze() callback, if defined, instead of pm-&gt;suspend(),<br>and it doesn’t apply the suspend-related hardware quirks.  It is executed<br>asynchronously for different PCI devices that don’t depend on each other in a<br>known way.</p>
<p>The pci_pm_freeze_noirq() routine, in turn, is similar to<br>pci_pm_suspend_noirq(), but it calls the device driver’s pm-&gt;freeze_noirq()<br>routine instead of pm-&gt;suspend_noirq().  It also doesn’t attempt to prepare the<br>device for signaling wakeup and put it into a low-power state.  Still, it saves<br>the device’s standard configuration registers if they haven’t been saved by one<br>of the driver’s callbacks.</p>
<p>Once the image has been created, it has to be saved.  However, at this point all<br>devices are frozen and they cannot handle I/O, while their ability to handle<br>I/O is obviously necessary for the image saving.  Thus they have to be brought<br>back to the fully functional state and this is done in the following phases:</p>
<pre><code>thaw_noirq, thaw, complete
</code></pre>
<p>using the following PCI bus type’s callbacks:</p>
<pre><code>pci_pm_thaw_noirq()
pci_pm_thaw()
pci_pm_complete()
</code></pre>
<p>respectively.</p>
<p>The first of them, pci_pm_thaw_noirq(), is analogous to pci_pm_resume_noirq(),<br>but it doesn’t put the device into the full power state and doesn’t attempt to<br>restore its standard configuration registers.  It also executes the device<br>driver’s pm-&gt;thaw_noirq() callback, if defined, instead of pm-&gt;resume_noirq().</p>
<p>The pci_pm_thaw() routine is similar to pci_pm_resume(), but it runs the device<br>driver’s pm-&gt;thaw() callback instead of pm-&gt;resume().  It is executed<br>asynchronously for different PCI devices that don’t depend on each other in a<br>known way.</p>
<p>The complete phase it the same as for system resume.</p>
<p>After saving the image, devices need to be powered down before the system can<br>enter the target sleep state (ACPI S4 for ACPI-based systems).  This is done in<br>three phases:</p>
<pre><code>prepare, poweroff, poweroff_noirq
</code></pre>
<p>where the prepare phase is exactly the same as for system suspend.  The other<br>two phases are analogous to the suspend and suspend_noirq phases, respectively.<br>The PCI subsystem-level callbacks they correspond to</p>
<pre><code>pci_pm_poweroff()
pci_pm_poweroff_noirq()
</code></pre>
<p>work in analogy with pci_pm_suspend() and pci_pm_poweroff_noirq(), respectively,<br>although they don’t attempt to save the device’s standard configuration<br>registers.</p>
<p>2.4.4. System Restore</p>
<p>System restore requires a hibernation image to be loaded into memory and the<br>pre-hibernation memory contents to be restored before the pre-hibernation system<br>activity can be resumed.</p>
<p>As described in Documentation/driver-api/pm/devices.rst, the hibernation image is loaded<br>into memory by a fresh instance of the kernel, called the boot kernel, which in<br>turn is loaded and run by a boot loader in the usual way.  After the boot kernel<br>has loaded the image, it needs to replace its own code and data with the code<br>and data of the “hibernated” kernel stored within the image, called the image<br>kernel.  For this purpose all devices are frozen just like before creating<br>the image during hibernation, in the</p>
<pre><code>prepare, freeze, freeze_noirq
</code></pre>
<p>phases described above.  However, the devices affected by these phases are only<br>those having drivers in the boot kernel; other devices will still be in whatever<br>state the boot loader left them.</p>
<p>Should the restoration of the pre-hibernation memory contents fail, the boot<br>kernel would go through the “thawing” procedure described above, using the<br>thaw_noirq, thaw, and complete phases (that will only affect the devices having<br>drivers in the boot kernel), and then continue running normally.</p>
<p>If the pre-hibernation memory contents are restored successfully, which is the<br>usual situation, control is passed to the image kernel, which then becomes<br>responsible for bringing the system back to the working state.  To achieve this,<br>it must restore the devices’ pre-hibernation functionality, which is done much<br>like waking up from the memory sleep state, although it involves different<br>phases:</p>
<pre><code>restore_noirq, restore, complete
</code></pre>
<p>The first two of these are analogous to the resume_noirq and resume phases<br>described above, respectively, and correspond to the following PCI subsystem<br>callbacks:</p>
<pre><code>pci_pm_restore_noirq()
pci_pm_restore()
</code></pre>
<p>These callbacks work in analogy with pci_pm_resume_noirq() and pci_pm_resume(),<br>respectively, but they execute the device driver’s pm-&gt;restore_noirq() and<br>pm-&gt;restore() callbacks, if available.</p>
<p>The complete phase is carried out in exactly the same way as during system<br>resume.</p>
<ol start="3">
<li><h1 id="PCI-Device-Drivers-and-Power-Management"><a href="#PCI-Device-Drivers-and-Power-Management" class="headerlink" title="PCI Device Drivers and Power Management"></a>PCI Device Drivers and Power Management</h1></li>
</ol>
<h2 id="3-1-Power-Management-Callbacks"><a href="#3-1-Power-Management-Callbacks" class="headerlink" title="3.1. Power Management Callbacks"></a>3.1. Power Management Callbacks</h2><p>PCI device drivers participate in power management by providing callbacks to be<br>executed by the PCI subsystem’s power management routines described above and by<br>controlling the runtime power management of their devices.</p>
<p>At the time of this writing there are two ways to define power management<br>callbacks for a PCI device driver, the recommended one, based on using a<br>dev_pm_ops structure described in Documentation/driver-api/pm/devices.rst, and the<br>“legacy” one, in which the .suspend(), .suspend_late(), .resume_early(), and<br>.resume() callbacks from struct pci_driver are used.  The legacy approach,<br>however, doesn’t allow one to define runtime power management callbacks and is<br>not really suitable for any new drivers.  Therefore it is not covered by this<br>document (refer to the source code to learn more about it).</p>
<p>It is recommended that all PCI device drivers define a struct dev_pm_ops object<br>containing pointers to power management (PM) callbacks that will be executed by<br>the PCI subsystem’s PM routines in various circumstances.  A pointer to the<br>driver’s struct dev_pm_ops object has to be assigned to the driver.pm field in<br>its struct pci_driver object.  Once that has happened, the “legacy” PM callbacks<br>in struct pci_driver are ignored (even if they are not NULL).</p>
<p>The PM callbacks in struct dev_pm_ops are not mandatory and if they are not<br>defined (i.e. the respective fields of struct dev_pm_ops are unset) the PCI<br>subsystem will handle the device in a simplified default manner.  If they are<br>defined, though, they are expected to behave as described in the following<br>subsections.</p>
<p>3.1.1. prepare()</p>
<p>The prepare() callback is executed during system suspend, during hibernation<br>(when a hibernation image is about to be created), during power-off after<br>saving a hibernation image and during system restore, when a hibernation image<br>has just been loaded into memory.</p>
<p>This callback is only necessary if the driver’s device has children that in<br>general may be registered at any time.  In that case the role of the prepare()<br>callback is to prevent new children of the device from being registered until<br>one of the resume_noirq(), thaw_noirq(), or restore_noirq() callbacks is run.</p>
<p>In addition to that the prepare() callback may carry out some operations<br>preparing the device to be suspended, although it should not allocate memory<br>(if additional memory is required to suspend the device, it has to be<br>preallocated earlier, for example in a suspend/hibernate notifier as described<br>in Documentation/driver-api/pm/notifiers.rst).</p>
<p>3.1.2. suspend()</p>
<p>The suspend() callback is only executed during system suspend, after prepare()<br>callbacks have been executed for all devices in the system.</p>
<p>This callback is expected to quiesce the device and prepare it to be put into a<br>low-power state by the PCI subsystem.  It is not required (in fact it even is<br>not recommended) that a PCI driver’s suspend() callback save the standard<br>configuration registers of the device, prepare it for waking up the system, or<br>put it into a low-power state.  All of these operations can very well be taken<br>care of by the PCI subsystem, without the driver’s participation.</p>
<p>However, in some rare case it is convenient to carry out these operations in<br>a PCI driver.  Then, pci_save_state(), pci_prepare_to_sleep(), and<br>pci_set_power_state() should be used to save the device’s standard configuration<br>registers, to prepare it for system wakeup (if necessary), and to put it into a<br>low-power state, respectively.  Moreover, if the driver calls pci_save_state(),<br>the PCI subsystem will not execute either pci_prepare_to_sleep(), or<br>pci_set_power_state() for its device, so the driver is then responsible for<br>handling the device as appropriate.</p>
<p>While the suspend() callback is being executed, the driver’s interrupt handler<br>can be invoked to handle an interrupt from the device, so all suspend-related<br>operations relying on the driver’s ability to handle interrupts should be<br>carried out in this callback.</p>
<p>3.1.3. suspend_noirq()</p>
<p>The suspend_noirq() callback is only executed during system suspend, after<br>suspend() callbacks have been executed for all devices in the system and<br>after device interrupts have been disabled by the PM core.</p>
<p>The difference between suspend_noirq() and suspend() is that the driver’s<br>interrupt handler will not be invoked while suspend_noirq() is running.  Thus<br>suspend_noirq() can carry out operations that would cause race conditions to<br>arise if they were performed in suspend().</p>
<p>3.1.4. freeze()</p>
<p>The freeze() callback is hibernation-specific and is executed in two situations,<br>during hibernation, after prepare() callbacks have been executed for all devices<br>in preparation for the creation of a system image, and during restore,<br>after a system image has been loaded into memory from persistent storage and the<br>prepare() callbacks have been executed for all devices.</p>
<p>The role of this callback is analogous to the role of the suspend() callback<br>described above.  In fact, they only need to be different in the rare cases when<br>the driver takes the responsibility for putting the device into a low-power<br>state.</p>
<p>In that cases the freeze() callback should not prepare the device system wakeup<br>or put it into a low-power state.  Still, either it or freeze_noirq() should<br>save the device’s standard configuration registers using pci_save_state().</p>
<p>3.1.5. freeze_noirq()</p>
<p>The freeze_noirq() callback is hibernation-specific.  It is executed during<br>hibernation, after prepare() and freeze() callbacks have been executed for all<br>devices in preparation for the creation of a system image, and during restore,<br>after a system image has been loaded into memory and after prepare() and<br>freeze() callbacks have been executed for all devices.  It is always executed<br>after device interrupts have been disabled by the PM core.</p>
<p>The role of this callback is analogous to the role of the suspend_noirq()<br>callback described above and it very rarely is necessary to define<br>freeze_noirq().</p>
<p>The difference between freeze_noirq() and freeze() is analogous to the<br>difference between suspend_noirq() and suspend().</p>
<p>3.1.6. poweroff()</p>
<p>The poweroff() callback is hibernation-specific.  It is executed when the system<br>is about to be powered off after saving a hibernation image to a persistent<br>storage.  prepare() callbacks are executed for all devices before poweroff() is<br>called.</p>
<p>The role of this callback is analogous to the role of the suspend() and freeze()<br>callbacks described above, although it does not need to save the contents of<br>the device’s registers.  In particular, if the driver wants to put the device<br>into a low-power state itself instead of allowing the PCI subsystem to do that,<br>the poweroff() callback should use pci_prepare_to_sleep() and<br>pci_set_power_state() to prepare the device for system wakeup and to put it<br>into a low-power state, respectively, but it need not save the device’s standard<br>configuration registers.</p>
<p>3.1.7. poweroff_noirq()</p>
<p>The poweroff_noirq() callback is hibernation-specific.  It is executed after<br>poweroff() callbacks have been executed for all devices in the system.</p>
<p>The role of this callback is analogous to the role of the suspend_noirq() and<br>freeze_noirq() callbacks described above, but it does not need to save the<br>contents of the device’s registers.</p>
<p>The difference between poweroff_noirq() and poweroff() is analogous to the<br>difference between suspend_noirq() and suspend().</p>
<p>3.1.8. resume_noirq()</p>
<p>The resume_noirq() callback is only executed during system resume, after the<br>PM core has enabled the non-boot CPUs.  The driver’s interrupt handler will not<br>be invoked while resume_noirq() is running, so this callback can carry out<br>operations that might race with the interrupt handler.</p>
<p>Since the PCI subsystem unconditionally puts all devices into the full power<br>state in the resume_noirq phase of system resume and restores their standard<br>configuration registers, resume_noirq() is usually not necessary.  In general<br>it should only be used for performing operations that would lead to race<br>conditions if carried out by resume().</p>
<p>3.1.9. resume()</p>
<p>The resume() callback is only executed during system resume, after<br>resume_noirq() callbacks have been executed for all devices in the system and<br>device interrupts have been enabled by the PM core.</p>
<p>This callback is responsible for restoring the pre-suspend configuration of the<br>device and bringing it back to the fully functional state.  The device should be<br>able to process I/O in a usual way after resume() has returned.</p>
<p>3.1.10. thaw_noirq()</p>
<p>The thaw_noirq() callback is hibernation-specific.  It is executed after a<br>system image has been created and the non-boot CPUs have been enabled by the PM<br>core, in the thaw_noirq phase of hibernation.  It also may be executed if the<br>loading of a hibernation image fails during system restore (it is then executed<br>after enabling the non-boot CPUs).  The driver’s interrupt handler will not be<br>invoked while thaw_noirq() is running.</p>
<p>The role of this callback is analogous to the role of resume_noirq().  The<br>difference between these two callbacks is that thaw_noirq() is executed after<br>freeze() and freeze_noirq(), so in general it does not need to modify the<br>contents of the device’s registers.</p>
<p>3.1.11. thaw()</p>
<p>The thaw() callback is hibernation-specific.  It is executed after thaw_noirq()<br>callbacks have been executed for all devices in the system and after device<br>interrupts have been enabled by the PM core.</p>
<p>This callback is responsible for restoring the pre-freeze configuration of<br>the device, so that it will work in a usual way after thaw() has returned.</p>
<p>3.1.12. restore_noirq()</p>
<p>The restore_noirq() callback is hibernation-specific.  It is executed in the<br>restore_noirq phase of hibernation, when the boot kernel has passed control to<br>the image kernel and the non-boot CPUs have been enabled by the image kernel’s<br>PM core.</p>
<p>This callback is analogous to resume_noirq() with the exception that it cannot<br>make any assumption on the previous state of the device, even if the BIOS (or<br>generally the platform firmware) is known to preserve that state over a<br>suspend-resume cycle.</p>
<p>For the vast majority of PCI device drivers there is no difference between<br>resume_noirq() and restore_noirq().</p>
<p>3.1.13. restore()</p>
<p>The restore() callback is hibernation-specific.  It is executed after<br>restore_noirq() callbacks have been executed for all devices in the system and<br>after the PM core has enabled device drivers’ interrupt handlers to be invoked.</p>
<p>This callback is analogous to resume(), just like restore_noirq() is analogous<br>to resume_noirq().  Consequently, the difference between restore_noirq() and<br>restore() is analogous to the difference between resume_noirq() and resume().</p>
<p>For the vast majority of PCI device drivers there is no difference between<br>resume() and restore().</p>
<p>3.1.14. complete()</p>
<p>The complete() callback is executed in the following situations:</p>
<ul>
<li>during system resume, after resume() callbacks have been executed for all<br>devices,</li>
<li>during hibernation, before saving the system image, after thaw() callbacks<br>have been executed for all devices,</li>
<li>during system restore, when the system is going back to its pre-hibernation<br>state, after restore() callbacks have been executed for all devices.<br>It also may be executed if the loading of a hibernation image into memory fails<br>(in that case it is run after thaw() callbacks have been executed for all<br>devices that have drivers in the boot kernel).</li>
</ul>
<p>This callback is entirely optional, although it may be necessary if the<br>prepare() callback performs operations that need to be reversed.</p>
<p>3.1.15. runtime_suspend()</p>
<p>The runtime_suspend() callback is specific to device runtime power management<br>(runtime PM).  It is executed by the PM core’s runtime PM framework when the<br>device is about to be suspended (i.e. quiesced and put into a low-power state)<br>at run time.</p>
<p>This callback is responsible for freezing the device and preparing it to be<br>put into a low-power state, but it must allow the PCI subsystem to perform all<br>of the PCI-specific actions necessary for suspending the device.</p>
<p>3.1.16. runtime_resume()</p>
<p>The runtime_resume() callback is specific to device runtime PM.  It is executed<br>by the PM core’s runtime PM framework when the device is about to be resumed<br>(i.e. put into the full-power state and programmed to process I/O normally) at<br>run time.</p>
<p>This callback is responsible for restoring the normal functionality of the<br>device after it has been put into the full-power state by the PCI subsystem.<br>The device is expected to be able to process I/O in the usual way after<br>runtime_resume() has returned.</p>
<p>3.1.17. runtime_idle()</p>
<p>The runtime_idle() callback is specific to device runtime PM.  It is executed<br>by the PM core’s runtime PM framework whenever it may be desirable to suspend<br>the device according to the PM core’s information.  In particular, it is<br>automatically executed right after runtime_resume() has returned in case the<br>resume of the device has happened as a result of a spurious event.</p>
<p>This callback is optional, but if it is not implemented or if it returns 0, the<br>PCI subsystem will call pm_runtime_suspend() for the device, which in turn will<br>cause the driver’s runtime_suspend() callback to be executed.</p>
<p>3.1.18. Pointing Multiple Callback Pointers to One Routine</p>
<p>Although in principle each of the callbacks described in the previous<br>subsections can be defined as a separate function, it often is convenient to<br>point two or more members of struct dev_pm_ops to the same routine.  There are<br>a few convenience macros that can be used for this purpose.</p>
<p>The SIMPLE_DEV_PM_OPS macro declares a struct dev_pm_ops object with one<br>suspend routine pointed to by the .suspend(), .freeze(), and .poweroff()<br>members and one resume routine pointed to by the .resume(), .thaw(), and<br>.restore() members.  The other function pointers in this struct dev_pm_ops are<br>unset.</p>
<p>The UNIVERSAL_DEV_PM_OPS macro is similar to SIMPLE_DEV_PM_OPS, but it<br>additionally sets the .runtime_resume() pointer to the same value as<br>.resume() (and .thaw(), and .restore()) and the .runtime_suspend() pointer to<br>the same value as .suspend() (and .freeze() and .poweroff()).</p>
<p>The SET_SYSTEM_SLEEP_PM_OPS can be used inside of a declaration of struct<br>dev_pm_ops to indicate that one suspend routine is to be pointed to by the<br>.suspend(), .freeze(), and .poweroff() members and one resume routine is to<br>be pointed to by the .resume(), .thaw(), and .restore() members.</p>
<p>3.1.19. Driver Flags for Power Management</p>
<p>The PM core allows device drivers to set flags that influence the handling of<br>power management for the devices by the core itself and by middle layer code<br>including the PCI bus type.  The flags should be set once at the driver probe<br>time with the help of the dev_pm_set_driver_flags() function and they should not<br>be updated directly afterwards.</p>
<p>The DPM_FLAG_NEVER_SKIP flag prevents the PM core from using the direct-complete<br>mechanism allowing device suspend/resume callbacks to be skipped if the device<br>is in runtime suspend when the system suspend starts.  That also affects all of<br>the ancestors of the device, so this flag should only be used if absolutely<br>necessary.</p>
<p>The DPM_FLAG_SMART_PREPARE flag instructs the PCI bus type to only return a<br>positive value from pci_pm_prepare() if the -&gt;prepare callback provided by the<br>driver of the device returns a positive value.  That allows the driver to opt<br>out from using the direct-complete mechanism dynamically.</p>
<p>The DPM_FLAG_SMART_SUSPEND flag tells the PCI bus type that from the driver’s<br>perspective the device can be safely left in runtime suspend during system<br>suspend.  That causes pci_pm_suspend(), pci_pm_freeze() and pci_pm_poweroff()<br>to skip resuming the device from runtime suspend unless there are PCI-specific<br>reasons for doing that.  Also, it causes pci_pm_suspend_late/noirq(),<br>pci_pm_freeze_late/noirq() and pci_pm_poweroff_late/noirq() to return early<br>if the device remains in runtime suspend in the beginning of the “late” phase<br>of the system-wide transition under way.  Moreover, if the device is in<br>runtime suspend in pci_pm_resume_noirq() or pci_pm_restore_noirq(), its runtime<br>power management status will be changed to “active” (as it is going to be put<br>into D0 going forward), but if it is in runtime suspend in pci_pm_thaw_noirq(),<br>the function will set the power.direct_complete flag for it (to make the PM core<br>skip the subsequent “thaw” callbacks for it) and return.</p>
<p>Setting the DPM_FLAG_LEAVE_SUSPENDED flag means that the driver prefers the<br>device to be left in suspend after system-wide transitions to the working state.<br>This flag is checked by the PM core, but the PCI bus type informs the PM core<br>which devices may be left in suspend from its perspective (that happens during<br>the “noirq” phase of system-wide suspend and analogous transitions) and next it<br>uses the dev_pm_may_skip_resume() helper to decide whether or not to return from<br>pci_pm_resume_noirq() early, as the PM core will skip the remaining resume<br>callbacks for the device during the transition under way and will set its<br>runtime PM status to “suspended” if dev_pm_may_skip_resume() returns “true” for<br>it.</p>
<h2 id="3-2-Device-Runtime-Power-Management"><a href="#3-2-Device-Runtime-Power-Management" class="headerlink" title="3.2. Device Runtime Power Management"></a>3.2. Device Runtime Power Management</h2><p>In addition to providing device power management callbacks PCI device drivers<br>are responsible for controlling the runtime power management (runtime PM) of<br>their devices.</p>
<p>The PCI device runtime PM is optional, but it is recommended that PCI device<br>drivers implement it at least in the cases where there is a reliable way of<br>verifying that the device is not used (like when the network cable is detached<br>from an Ethernet adapter or there are no devices attached to a USB controller).</p>
<p>To support the PCI runtime PM the driver first needs to implement the<br>runtime_suspend() and runtime_resume() callbacks.  It also may need to implement<br>the runtime_idle() callback to prevent the device from being suspended again<br>every time right after the runtime_resume() callback has returned<br>(alternatively, the runtime_suspend() callback will have to check if the<br>device should really be suspended and return -EAGAIN if that is not the case).</p>
<p>The runtime PM of PCI devices is enabled by default by the PCI core.  PCI<br>device drivers do not need to enable it and should not attempt to do so.<br>However, it is blocked by pci_pm_init() that runs the pm_runtime_forbid()<br>helper function.  In addition to that, the runtime PM usage counter of<br>each PCI device is incremented by local_pci_probe() before executing the<br>probe callback provided by the device’s driver.</p>
<p>If a PCI driver implements the runtime PM callbacks and intends to use the<br>runtime PM framework provided by the PM core and the PCI subsystem, it needs<br>to decrement the device’s runtime PM usage counter in its probe callback<br>function.  If it doesn’t do that, the counter will always be different from<br>zero for the device and it will never be runtime-suspended.  The simplest<br>way to do that is by calling pm_runtime_put_noidle(), but if the driver<br>wants to schedule an autosuspend right away, for example, it may call<br>pm_runtime_put_autosuspend() instead for this purpose.  Generally, it<br>just needs to call a function that decrements the devices usage counter<br>from its probe routine to make runtime PM work for the device.</p>
<p>It is important to remember that the driver’s runtime_suspend() callback<br>may be executed right after the usage counter has been decremented, because<br>user space may already have caused the pm_runtime_allow() helper function<br>unblocking the runtime PM of the device to run via sysfs, so the driver must<br>be prepared to cope with that.</p>
<p>The driver itself should not call pm_runtime_allow(), though.  Instead, it<br>should let user space or some platform-specific code do that (user space can<br>do it via sysfs as stated above), but it must be prepared to handle the<br>runtime PM of the device correctly as soon as pm_runtime_allow() is called<br>(which may happen at any time, even before the driver is loaded).</p>
<p>When the driver’s remove callback runs, it has to balance the decrementation<br>of the device’s runtime PM usage counter at the probe time.  For this reason,<br>if it has decremented the counter in its probe callback, it must run<br>pm_runtime_get_noresume() in its remove callback.  [Since the core carries<br>out a runtime resume of the device and bumps up the device’s usage counter<br>before running the driver’s remove callback, the runtime PM of the device<br>is effectively disabled for the duration of the remove execution and all<br>runtime PM helper functions incrementing the device’s usage counter are<br>then effectively equivalent to pm_runtime_get_noresume().]</p>
<p>The runtime PM framework works by processing requests to suspend or resume<br>devices, or to check if they are idle (in which cases it is reasonable to<br>subsequently request that they be suspended).  These requests are represented<br>by work items put into the power management workqueue, pm_wq.  Although there<br>are a few situations in which power management requests are automatically<br>queued by the PM core (for example, after processing a request to resume a<br>device the PM core automatically queues a request to check if the device is<br>idle), device drivers are generally responsible for queuing power management<br>requests for their devices.  For this purpose they should use the runtime PM<br>helper functions provided by the PM core, discussed in<br>Documentation/power/runtime_pm.txt.</p>
<p>Devices can also be suspended and resumed synchronously, without placing a<br>request into pm_wq.  In the majority of cases this also is done by their<br>drivers that use helper functions provided by the PM core for this purpose.</p>
<p>For more information on the runtime PM of devices refer to<br>Documentation/power/runtime_pm.txt.</p>
<ol start="4">
<li><h1 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h1></li>
</ol>
<p>PCI Local Bus Specification, Rev. 3.0<br>PCI Bus Power Management Interface Specification, Rev. 1.2<br>Advanced Configuration and Power Interface (ACPI) Specification, Rev. 3.0b<br>PCI Express Base Specification, Rev. 2.0<br>Documentation/driver-api/pm/devices.rst<br>Documentation/power/runtime_pm.txt</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_pci/" title="Kernel-4.18.0-80.el8_pci" target="_blank" rel="external">http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_pci/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/02/19/Kernel-4.18.0-80.el8_gpio/" title="Kernel-4.18.0-80.el8_gpio"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/02/19/Kernel-4.18.0-80.el8_scsi_mid_low_api/" title="Kernel-4.18.0-80.el8_scsi_mid_low_api"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>