<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-4.18.0-80.el8_err_inject | oosTech.com</title>
  <meta name="description" content="IPF Machine Check (MC) error inject toolIPF Machine Check (MC) error inject tool is used to inject MCerrors from Linux. The tool is a test bed for IPF MC work flow includinghardware correctable error">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-4.18.0-80.el8_err_inject">
<meta property="og:url" content="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_err_inject/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="IPF Machine Check (MC) error inject toolIPF Machine Check (MC) error inject tool is used to inject MCerrors from Linux. The tool is a test bed for IPF MC work flow includinghardware correctable error">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-18T16:00:00.000Z">
<meta property="article:modified_time" content="2021-02-18T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_err_inject/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_mpc5200/" class="title">Kernel-3.10.0-957.el7_mpc5200</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_6pack/" class="title">Kernel-3.10.0-957.el7_6pack</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#IPF-Machine-Check-MC-error-inject-tool"><span class="toc-number">1.</span> <span class="toc-text">IPF Machine Check (MC) error inject tool</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cpu-logical-cpu-number-the-error-will-be-inject-in"><span class="toc-number">2.</span> <span class="toc-text">cpu: logical cpu number the error will be inject in.</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#loop-times-the-error-will-be-injected"><span class="toc-number">3.</span> <span class="toc-text">loop: times the error will be injected.</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#interval-In-second-every-so-often-one-error-is-injected"><span class="toc-number">4.</span> <span class="toc-text">interval: In second. every so often one error is injected.</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#err-type-info-err-struct-info-PAL-parameters"><span class="toc-number">5.</span> <span class="toc-text">err_type_info, err_struct_info: PAL parameters.</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text"></span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-4.18.0-80.el8_err_inject" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-4.18.0-80.el8_err_inject
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/02/19/Kernel-4.18.0-80.el8_err_inject/" class="article-date">
	 published: <time datetime="2021-02-18T16:00:00.000Z" itemprop="datePublished">2021-02-19</time>
	</a>
</span>

        
	<a href="/2021/02/19/Kernel-4.18.0-80.el8_err_inject/" class="article-date">
	   updated: <time datetime="2021-02-18T16:00:00.000Z" itemprop="dateUpdated">2021-02-19</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/02/19/Kernel-4.18.0-80.el8_err_inject/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="IPF-Machine-Check-MC-error-inject-tool"><a href="#IPF-Machine-Check-MC-error-inject-tool" class="headerlink" title="IPF Machine Check (MC) error inject tool"></a>IPF Machine Check (MC) error inject tool</h1><p>IPF Machine Check (MC) error inject tool is used to inject MC<br>errors from Linux. The tool is a test bed for IPF MC work flow including<br>hardware correctable error handling, OS recoverable error handling, MC<br>event logging, etc.</p>
<p>The tool includes two parts: a kernel driver and a user application<br>sample. The driver provides interface to PAL to inject error<br>and query error injection capabilities. The driver code is in<br>arch/ia64/kernel/err_inject.c. The application sample (shown below)<br>provides a combination of various errors and calls the driver’s interface<br>(sysfs interface) to inject errors or query error injection capabilities.</p>
<p>The tool can be used to test Intel IPF machine MC handling capabilities.<br>It’s especially useful for people who can not access hardware MC injection<br>tool to inject error. It’s also very useful to integrate with other<br>software test suits to do stressful testing on IPF.</p>
<p>Below is a sample application as part of the whole tool. The sample<br>can be used as a working test tool. Or it can be expanded to include<br>more features. It also can be a integrated into a library or other user<br>application to have more thorough test.</p>
<p>The sample application takes err.conf as error configuration input. GCC<br>compiles the code. After you install err_inject driver, you can run<br>this sample application to inject errors.</p>
<p>Errata: Itanium 2 Processors Specification Update lists some errata against<br>the pal_mc_error_inject PAL procedure. The following err.conf has been tested<br>on latest Montecito PAL.</p>
<p>err.conf:</p>
<p>#This is configuration file for err_inject_tool.<br>#The format of the each line is:<br>#cpu, loop, interval, err_type_info, err_struct_info, err_data_buffer<br>#where</p>
<h1 id="cpu-logical-cpu-number-the-error-will-be-inject-in"><a href="#cpu-logical-cpu-number-the-error-will-be-inject-in" class="headerlink" title="cpu: logical cpu number the error will be inject in."></a>cpu: logical cpu number the error will be inject in.</h1><h1 id="loop-times-the-error-will-be-injected"><a href="#loop-times-the-error-will-be-injected" class="headerlink" title="loop: times the error will be injected."></a>loop: times the error will be injected.</h1><h1 id="interval-In-second-every-so-often-one-error-is-injected"><a href="#interval-In-second-every-so-often-one-error-is-injected" class="headerlink" title="interval: In second. every so often one error is injected."></a>interval: In second. every so often one error is injected.</h1><h1 id="err-type-info-err-struct-info-PAL-parameters"><a href="#err-type-info-err-struct-info-PAL-parameters" class="headerlink" title="err_type_info, err_struct_info: PAL parameters."></a>err_type_info, err_struct_info: PAL parameters.</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>#Note: All values are hex w/o or w/ 0x prefix.</p>
<p>#On cpu2, inject only total 0x10 errors, interval 5 seconds<br>#corrected, data cache, hier-2, physical addr(assigned by tool code).<br>#working on Montecito latest PAL.<br>2, 10, 5, 4101, 95</p>
<p>#On cpu4, inject and consume total 0x10 errors, interval 5 seconds<br>#corrected, data cache, hier-2, physical addr(assigned by tool code).<br>#working on Montecito latest PAL.<br>4, 10, 5, 4109, 95</p>
<p>#On cpu15, inject and consume total 0x10 errors, interval 5 seconds<br>#recoverable, DTR0, hier-2.<br>#working on Montecito latest PAL.<br>0xf, 0x10, 5, 4249, 15</p>
<p>The sample application source code:</p>
<p>err_injection_tool.c:</p>
<p>/*</p>
<ul>
<li>This program is free software; you can redistribute it and/or modify</li>
<li>it under the terms of the GNU General Public License as published by</li>
<li>the Free Software Foundation; either version 2 of the License, or</li>
<li>(at your option) any later version.</li>
<li></li>
<li>This program is distributed in the hope that it will be useful, but</li>
<li>WITHOUT ANY WARRANTY; without even the implied warranty of</li>
<li>MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</li>
<li>NON INFRINGEMENT.  See the GNU General Public License for more</li>
<li>details.</li>
<li></li>
<li>You should have received a copy of the GNU General Public License</li>
<li>along with this program; if not, write to the Free Software</li>
<li>Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</li>
<li></li>
<li>Copyright (C) 2006 Intel Co</li>
<li>   Fenghua Yu <a href="mailto:&#x66;&#101;&#x6e;&#x67;&#104;&#117;&#x61;&#x2e;&#121;&#117;&#x40;&#x69;&#110;&#x74;&#101;&#108;&#x2e;&#99;&#111;&#x6d;">&#x66;&#101;&#x6e;&#x67;&#104;&#117;&#x61;&#x2e;&#121;&#117;&#x40;&#x69;&#110;&#x74;&#101;&#108;&#x2e;&#99;&#111;&#x6d;</a></li>
<li></li>
<li>/<br>#include &lt;sys/types.h&gt;<br>#include &lt;sys/stat.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;sched.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;stdarg.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;errno.h&gt;<br>#include &lt;time.h&gt;<br>#include &lt;sys/ipc.h&gt;<br>#include &lt;sys/sem.h&gt;<br>#include &lt;sys/wait.h&gt;<br>#include &lt;sys/mman.h&gt;<br>#include &lt;sys/shm.h&gt;</li>
</ul>
<p>#define MAX_FN_SIZE         256<br>#define MAX_BUF_SIZE         256<br>#define DATA_BUF_SIZE         256<br>#define NR_CPUS         512<br>#define MAX_TASK_NUM        2048<br>#define MIN_INTERVAL        5    // seconds<br>#define    ERR_DATA_BUFFER_SIZE     3    // Three 8-byte.<br>#define PARA_FIELD_NUM        5<br>#define MASK_SIZE        (NR_CPUS/64)<br>#define PATH_FORMAT “/sys/devices/system/cpu/cpu%d/err_inject/“</p>
<p>int sched_setaffinity(pid_t pid, unsigned int len, unsigned long *mask);</p>
<p>int verbose;<br>#define vbprintf if (verbose) printf</p>
<p>int log_info(int cpu, const char *fmt, …)<br>{<br>    FILE *log;<br>    char fn[MAX_FN_SIZE];<br>    char buf[MAX_BUF_SIZE];<br>    va_list args;</p>
<pre><code>sprintf(fn, &quot;%d.log&quot;, cpu);
log=fopen(fn, &quot;a+&quot;);
if (log==NULL) &#123;
    perror(&quot;Error open:&quot;);
    return -1;
&#125;

va_start(args, fmt);
vprintf(fmt, args);
memset(buf, 0, MAX_BUF_SIZE);
vsprintf(buf, fmt, args);
va_end(args);

fwrite(buf, sizeof(buf), 1, log);
fclose(log);

return 0;
</code></pre>
<p>}</p>
<p>typedef unsigned long u64;<br>typedef unsigned int  u32;</p>
<p>typedef union err_type_info_u {<br>    struct {<br>        u64    mode        : 3,    /* 0-2 <em>/<br>            err_inj        : 3,    /</em> 3-5 <em>/<br>            err_sev        : 2,    /</em> 6-7 <em>/<br>            err_struct    : 5,    /</em> 8-12 <em>/<br>            struct_hier    : 3,    /</em> 13-15 <em>/<br>            reserved    : 48;    /</em> 16-63 */<br>    } err_type_info_u;<br>    u64    err_type_info;<br>} err_type_info_t;</p>
<p>typedef union err_struct_info_u {<br>    struct {<br>        u64    siv        : 1,    /* 0     <em>/<br>            c_t        : 2,    /</em> 1-2     <em>/<br>            cl_p        : 3,    /</em> 3-5     <em>/<br>            cl_id        : 3,    /</em> 6-8     <em>/<br>            cl_dp        : 1,    /</em> 9     <em>/<br>            reserved1    : 22,    /</em> 10-31 <em>/<br>            tiv        : 1,    /</em> 32     <em>/<br>            trigger        : 4,    /</em> 33-36 <em>/<br>            trigger_pl     : 3,    /</em> 37-39 <em>/<br>            reserved2     : 24;    /</em> 40-63 <em>/<br>    } err_struct_info_cache;<br>    struct {<br>        u64    siv        : 1,    /</em> 0     <em>/<br>            tt        : 2,    /</em> 1-2     <em>/<br>            tc_tr        : 2,    /</em> 3-4     <em>/<br>            tr_slot        : 8,    /</em> 5-12     <em>/<br>            reserved1    : 19,    /</em> 13-31 <em>/<br>            tiv        : 1,    /</em> 32     <em>/<br>            trigger        : 4,    /</em> 33-36 <em>/<br>            trigger_pl     : 3,    /</em> 37-39 <em>/<br>            reserved2     : 24;    /</em> 40-63 <em>/<br>    } err_struct_info_tlb;<br>    struct {<br>        u64    siv        : 1,    /</em> 0     <em>/<br>            regfile_id    : 4,    /</em> 1-4     <em>/<br>            reg_num        : 7,    /</em> 5-11     <em>/<br>            reserved1    : 20,    /</em> 12-31 <em>/<br>            tiv        : 1,    /</em> 32     <em>/<br>            trigger        : 4,    /</em> 33-36 <em>/<br>            trigger_pl     : 3,    /</em> 37-39 <em>/<br>            reserved2     : 24;    /</em> 40-63 */<br>    } err_struct_info_register;<br>    struct {<br>        u64    reserved;<br>    } err_struct_info_bus_processor_interconnect;<br>    u64    err_struct_info;<br>} err_struct_info_t;</p>
<p>typedef union err_data_buffer_u {<br>    struct {<br>        u64    trigger_addr;        /* 0-63        <em>/<br>        u64    inj_addr;        /</em> 64-127     <em>/<br>        u64    way        : 5,    /</em> 128-132    <em>/<br>            index        : 20,    /</em> 133-152    <em>/<br>                    : 39;    /</em> 153-191    <em>/<br>    } err_data_buffer_cache;<br>    struct {<br>        u64    trigger_addr;        /</em> 0-63        <em>/<br>        u64    inj_addr;        /</em> 64-127     <em>/<br>        u64    way        : 5,    /</em> 128-132    <em>/<br>            index        : 20,    /</em> 133-152    <em>/<br>            reserved    : 39;    /</em> 153-191    <em>/<br>    } err_data_buffer_tlb;<br>    struct {<br>        u64    trigger_addr;        /</em> 0-63        <em>/<br>    } err_data_buffer_register;<br>    struct {<br>        u64    reserved;        /</em> 0-63        */<br>    } err_data_buffer_bus_processor_interconnect;<br>    u64 err_data_buffer[ERR_DATA_BUFFER_SIZE];<br>} err_data_buffer_t;</p>
<p>typedef union capabilities_u {<br>    struct {<br>        u64    i        : 1,<br>            d        : 1,<br>            rv        : 1,<br>            tag        : 1,<br>            data        : 1,<br>            mesi        : 1,<br>            dp        : 1,<br>            reserved1    : 3,<br>            pa        : 1,<br>            va        : 1,<br>            wi        : 1,<br>            reserved2    : 20,<br>            trigger        : 1,<br>            trigger_pl    : 1,<br>            reserved3    : 30;<br>    } capabilities_cache;<br>    struct {<br>        u64    d        : 1,<br>            i        : 1,<br>            rv        : 1,<br>            tc        : 1,<br>            tr        : 1,<br>            reserved1    : 27,<br>            trigger        : 1,<br>            trigger_pl    : 1,<br>            reserved2    : 30;<br>    } capabilities_tlb;<br>    struct {<br>        u64    gr_b0        : 1,<br>            gr_b1        : 1,<br>            fr        : 1,<br>            br        : 1,<br>            pr        : 1,<br>            ar        : 1,<br>            cr        : 1,<br>            rr        : 1,<br>            pkr        : 1,<br>            dbr        : 1,<br>            ibr        : 1,<br>            pmc        : 1,<br>            pmd        : 1,<br>            reserved1    : 3,<br>            regnum        : 1,<br>            reserved2    : 15,<br>            trigger        : 1,<br>            trigger_pl    : 1,<br>            reserved3    : 30;<br>    } capabilities_register;<br>    struct {<br>        u64    reserved;<br>    } capabilities_bus_processor_interconnect;<br>} capabilities_t;</p>
<p>typedef struct resources_s {<br>    u64    ibr0        : 1,<br>        ibr2        : 1,<br>        ibr4        : 1,<br>        ibr6        : 1,<br>        dbr0        : 1,<br>        dbr2        : 1,<br>        dbr4        : 1,<br>        dbr6        : 1,<br>        reserved    : 48;<br>} resources_t;</p>
<p>long get_page_size(void)<br>{<br>    long page_size=sysconf(_SC_PAGESIZE);<br>    return page_size;<br>}</p>
<p>#define PAGE_SIZE (get_page_size()==-1?0x4000:get_page_size())<br>#define SHM_SIZE (2<em>PAGE_SIZE</em>NR_CPUS)<br>#define SHM_VA 0x2000000100000000</p>
<p>int shmid;<br>void *shmaddr;</p>
<p>int create_shm(void)<br>{<br>    key_t key;<br>    char fn[MAX_FN_SIZE];</p>
<pre><code>/* cpu0 is always existing */
sprintf(fn, PATH_FORMAT, 0);
if ((key = ftok(fn, &#39;s&#39;)) == -1) &#123;
    perror(&quot;ftok&quot;);
    return -1;
&#125;

shmid = shmget(key, SHM_SIZE, 0644 | IPC_CREAT);
if (shmid == -1) &#123;
    if (errno==EEXIST) &#123;
        shmid = shmget(key, SHM_SIZE, 0);
        if (shmid == -1) &#123;
            perror(&quot;shmget&quot;);
            return -1;
        &#125;
    &#125;
    else &#123;
        perror(&quot;shmget&quot;);
        return -1;
    &#125;
&#125;
vbprintf(&quot;shmid=%d&quot;, shmid);

/* connect to the segment: */
shmaddr = shmat(shmid, (void *)SHM_VA, 0);
if (shmaddr == (void*)-1) &#123;
    perror(&quot;shmat&quot;);
    return -1;
&#125;

memset(shmaddr, 0, SHM_SIZE);
mlock(shmaddr, SHM_SIZE);

return 0;
</code></pre>
<p>}</p>
<p>int free_shm()<br>{<br>    munlock(shmaddr, SHM_SIZE);<br>        shmdt(shmaddr);<br>    semctl(shmid, 0, IPC_RMID);</p>
<pre><code>return 0;
</code></pre>
<p>}</p>
<p>#ifdef _SEM_SEMUN_UNDEFINED<br>union semun<br>{<br>    int val;<br>    struct semid_ds *buf;<br>    unsigned short int *array;<br>    struct seminfo *__buf;<br>};<br>#endif</p>
<p>u32 mode=1; /* 1: physical mode; 2: virtual mode. */<br>int one_lock=1;<br>key_t key[NR_CPUS];<br>int semid[NR_CPUS];</p>
<p>int create_sem(int cpu)<br>{<br>    union semun arg;<br>    char fn[MAX_FN_SIZE];<br>    int sid;</p>
<pre><code>sprintf(fn, PATH_FORMAT, cpu);
sprintf(fn, &quot;%s/%s&quot;, fn, &quot;err_type_info&quot;);
if ((key[cpu] = ftok(fn, &#39;e&#39;)) == -1) &#123;
    perror(&quot;ftok&quot;);
    return -1;
&#125;

if (semid[cpu]!=0)
    return 0;

/* clear old semaphore */
if ((sid = semget(key[cpu], 1, 0)) != -1)
    semctl(sid, 0, IPC_RMID);

/* get one semaphore */
if ((semid[cpu] = semget(key[cpu], 1, IPC_CREAT | IPC_EXCL)) == -1) &#123;
    perror(&quot;semget&quot;);
    printf(&quot;Please remove semaphore with key=0x%lx, then run the tool.\n&quot;,
        (u64)key[cpu]);
    return -1;
&#125;

vbprintf(&quot;semid[%d]=0x%lx, key[%d]=%lx\n&quot;,cpu,(u64)semid[cpu],cpu,
    (u64)key[cpu]);
/* initialize the semaphore to 1: */
arg.val = 1;
if (semctl(semid[cpu], 0, SETVAL, arg) == -1) &#123;
    perror(&quot;semctl&quot;);
    return -1;
&#125;

return 0;
</code></pre>
<p>}</p>
<p>static int lock(int cpu)<br>{<br>    struct sembuf lock;</p>
<pre><code>lock.sem_num = cpu;
lock.sem_op = 1;
semop(semid[cpu], &amp;lock, 1);

    return 0;
</code></pre>
<p>}</p>
<p>static int unlock(int cpu)<br>{<br>    struct sembuf unlock;</p>
<pre><code>unlock.sem_num = cpu;
unlock.sem_op = -1;
semop(semid[cpu], &amp;unlock, 1);

    return 0;
</code></pre>
<p>}</p>
<p>void free_sem(int cpu)<br>{<br>    semctl(semid[cpu], 0, IPC_RMID);<br>}</p>
<p>int wr_multi(char *fn, unsigned long *data, int size)<br>{<br>    int fd;<br>    char buf[MAX_BUF_SIZE];<br>    int ret;</p>
<pre><code>if (size==1)
    sprintf(buf, &quot;%lx&quot;, *data);
else if (size==3)
    sprintf(buf, &quot;%lx,%lx,%lx&quot;, data[0], data[1], data[2]);
else &#123;
    fprintf(stderr,&quot;write to file with wrong size!\n&quot;);
    return -1;
&#125;

fd=open(fn, O_RDWR);
if (!fd) &#123;
    perror(&quot;Error:&quot;);
    return -1;
&#125;
ret=write(fd, buf, sizeof(buf));
close(fd);
return ret;
</code></pre>
<p>}</p>
<p>int wr(char *fn, unsigned long data)<br>{<br>    return wr_multi(fn, &amp;data, 1);<br>}</p>
<p>int rd(char *fn, unsigned long *data)<br>{<br>    int fd;<br>    char buf[MAX_BUF_SIZE];</p>
<pre><code>fd=open(fn, O_RDONLY);
if (fd&lt;0) &#123;
    perror(&quot;Error:&quot;);
    return -1;
&#125;
read(fd, buf, MAX_BUF_SIZE);
*data=strtoul(buf, NULL, 16);
close(fd);
return 0;
</code></pre>
<p>}</p>
<p>int rd_status(char *path, int <em>status)<br>{<br>    char fn[MAX_FN_SIZE];<br>    sprintf(fn, “%s/status”, path);<br>    if (rd(fn, (u64</em>)status)&lt;0) {<br>        perror(“status reading error.\n”);<br>        return -1;<br>    }</p>
<pre><code>return 0;
</code></pre>
<p>}</p>
<p>int rd_capabilities(char *path, u64 *capabilities)<br>{<br>    char fn[MAX_FN_SIZE];<br>    sprintf(fn, “%s/capabilities”, path);<br>    if (rd(fn, capabilities)&lt;0) {<br>        perror(“capabilities reading error.\n”);<br>        return -1;<br>    }</p>
<pre><code>return 0;
</code></pre>
<p>}</p>
<p>int rd_all(char *path)<br>{<br>    unsigned long err_type_info, err_struct_info, err_data_buffer;<br>    int status;<br>    unsigned long capabilities, resources;<br>    char fn[MAX_FN_SIZE];</p>
<pre><code>sprintf(fn, &quot;%s/err_type_info&quot;, path);
if (rd(fn, &amp;err_type_info)&lt;0) &#123;
    perror(&quot;err_type_info reading error.\n&quot;);
    return -1;
&#125;
printf(&quot;err_type_info=%lx\n&quot;, err_type_info);

sprintf(fn, &quot;%s/err_struct_info&quot;, path);
if (rd(fn, &amp;err_struct_info)&lt;0) &#123;
    perror(&quot;err_struct_info reading error.\n&quot;);
    return -1;
&#125;
printf(&quot;err_struct_info=%lx\n&quot;, err_struct_info);

sprintf(fn, &quot;%s/err_data_buffer&quot;, path);
if (rd(fn, &amp;err_data_buffer)&lt;0) &#123;
    perror(&quot;err_data_buffer reading error.\n&quot;);
    return -1;
&#125;
printf(&quot;err_data_buffer=%lx\n&quot;, err_data_buffer);

sprintf(fn, &quot;%s/status&quot;, path);
if (rd(&quot;status&quot;, (u64*)&amp;status)&lt;0) &#123;
    perror(&quot;status reading error.\n&quot;);
    return -1;
&#125;
printf(&quot;status=%d\n&quot;, status);

sprintf(fn, &quot;%s/capabilities&quot;, path);
if (rd(fn,&amp;capabilities)&lt;0) &#123;
    perror(&quot;capabilities reading error.\n&quot;);
    return -1;
&#125;
printf(&quot;capabilities=%lx\n&quot;, capabilities);

sprintf(fn, &quot;%s/resources&quot;, path);
if (rd(fn, &amp;resources)&lt;0) &#123;
    perror(&quot;resources reading error.\n&quot;);
    return -1;
&#125;
printf(&quot;resources=%lx\n&quot;, resources);

return 0;
</code></pre>
<p>}</p>
<p>int query_capabilities(char *path, err_type_info_t err_type_info,<br>            u64 *capabilities)<br>{<br>    char fn[MAX_FN_SIZE];<br>    err_struct_info_t err_struct_info;<br>    err_data_buffer_t err_data_buffer;</p>
<pre><code>err_struct_info.err_struct_info=0;
memset(err_data_buffer.err_data_buffer, -1, ERR_DATA_BUFFER_SIZE*8);

sprintf(fn, &quot;%s/err_type_info&quot;, path);
wr(fn, err_type_info.err_type_info);
sprintf(fn, &quot;%s/err_struct_info&quot;, path);
wr(fn, 0x0);
sprintf(fn, &quot;%s/err_data_buffer&quot;, path);
wr_multi(fn, err_data_buffer.err_data_buffer, ERR_DATA_BUFFER_SIZE);

// Fire pal_mc_error_inject procedure.
sprintf(fn, &quot;%s/call_start&quot;, path);
wr(fn, mode);

if (rd_capabilities(path, capabilities)&lt;0)
    return -1;

return 0;
</code></pre>
<p>}</p>
<p>int query_all_capabilities()<br>{<br>    int status;<br>    err_type_info_t err_type_info;<br>    int err_sev, err_struct, struct_hier;<br>    int cap=0;<br>    u64 capabilities;<br>    char path[MAX_FN_SIZE];</p>
<pre><code>err_type_info.err_type_info=0;            // Initial
err_type_info.err_type_info_u.mode=0;        // Query mode;
err_type_info.err_type_info_u.err_inj=0;

printf(&quot;All capabilities implemented in pal_mc_error_inject:\n&quot;);
sprintf(path, PATH_FORMAT ,0);
for (err_sev=0;err_sev&lt;3;err_sev++)
    for (err_struct=0;err_struct&lt;5;err_struct++)
        for (struct_hier=0;struct_hier&lt;5;struct_hier++)
&#123;
    status=-1;
    capabilities=0;
    err_type_info.err_type_info_u.err_sev=err_sev;
    err_type_info.err_type_info_u.err_struct=err_struct;
    err_type_info.err_type_info_u.struct_hier=struct_hier;

    if (query_capabilities(path, err_type_info, &amp;capabilities)&lt;0)
        continue;

    if (rd_status(path, &amp;status)&lt;0)
        continue;

    if (status==0) &#123;
        cap=1;
        printf(&quot;For err_sev=%d, err_struct=%d, struct_hier=%d: &quot;,
            err_sev, err_struct, struct_hier);
        printf(&quot;capabilities 0x%lx\n&quot;, capabilities);
    &#125;
&#125;
if (!cap) &#123;
    printf(&quot;No capabilities supported.\n&quot;);
    return 0;
&#125;

return 0;
</code></pre>
<p>}</p>
<p>int err_inject(int cpu, char *path, err_type_info_t err_type_info,<br>        err_struct_info_t err_struct_info,<br>        err_data_buffer_t err_data_buffer)<br>{<br>    int status;<br>    char fn[MAX_FN_SIZE];</p>
<pre><code>log_info(cpu, &quot;err_type_info=%lx, err_struct_info=%lx, &quot;,
    err_type_info.err_type_info,
    err_struct_info.err_struct_info);
log_info(cpu,&quot;err_data_buffer=[%lx,%lx,%lx]\n&quot;,
    err_data_buffer.err_data_buffer[0],
    err_data_buffer.err_data_buffer[1],
    err_data_buffer.err_data_buffer[2]);
sprintf(fn, &quot;%s/err_type_info&quot;, path);
wr(fn, err_type_info.err_type_info);
sprintf(fn, &quot;%s/err_struct_info&quot;, path);
wr(fn, err_struct_info.err_struct_info);
sprintf(fn, &quot;%s/err_data_buffer&quot;, path);
wr_multi(fn, err_data_buffer.err_data_buffer, ERR_DATA_BUFFER_SIZE);

// Fire pal_mc_error_inject procedure.
sprintf(fn, &quot;%s/call_start&quot;, path);
wr(fn,mode);

if (rd_status(path, &amp;status)&lt;0) &#123;
    vbprintf(&quot;fail: read status\n&quot;);
    return -100;
&#125;

if (status!=0) &#123;
    log_info(cpu, &quot;fail: status=%d\n&quot;, status);
    return status;
&#125;

return status;
</code></pre>
<p>}</p>
<p>static int construct_data_buf(char *path, err_type_info_t err_type_info,<br>        err_struct_info_t err_struct_info,<br>        err_data_buffer_t *err_data_buffer,<br>        void *va1)<br>{<br>    char fn[MAX_FN_SIZE];<br>    u64 virt_addr=0, phys_addr=0;</p>
<pre><code>vbprintf(&quot;va1=%lx\n&quot;, (u64)va1);
memset(&amp;err_data_buffer-&gt;err_data_buffer_cache, 0, ERR_DATA_BUFFER_SIZE*8);

switch (err_type_info.err_type_info_u.err_struct) &#123;
    case 1: // Cache
        switch (err_struct_info.err_struct_info_cache.cl_id) &#123;
            case 1: //Virtual addr
                err_data_buffer-&gt;err_data_buffer_cache.inj_addr=(u64)va1;
                break;
            case 2: //Phys addr
                sprintf(fn, &quot;%s/virtual_to_phys&quot;, path);
                virt_addr=(u64)va1;
                if (wr(fn,virt_addr)&lt;0)
                    return -1;
                rd(fn, &amp;phys_addr);
                err_data_buffer-&gt;err_data_buffer_cache.inj_addr=phys_addr;
                break;
            default:
                printf(&quot;Not supported cl_id\n&quot;);
                break;
        &#125;
        break;
    case 2: //  TLB
        break;
    case 3: //  Register file
        break;
    case 4: //  Bus/system interconnect
    default:
        printf(&quot;Not supported err_struct\n&quot;);
        break;
&#125;

return 0;
</code></pre>
<p>}</p>
<p>typedef struct {<br>    u64 cpu;<br>    u64 loop;<br>    u64 interval;<br>    u64 err_type_info;<br>    u64 err_struct_info;<br>    u64 err_data_buffer[ERR_DATA_BUFFER_SIZE];<br>} parameters_t;</p>
<p>parameters_t line_para;<br>int para;</p>
<p>static int empty_data_buffer(u64 *err_data_buffer)<br>{<br>    int empty=1;<br>    int i;</p>
<pre><code>for (i=0;i&lt;ERR_DATA_BUFFER_SIZE; i++)
   if (err_data_buffer[i]!=-1)
    empty=0;

return empty;
</code></pre>
<p>}</p>
<p>int err_inj()<br>{<br>    err_type_info_t err_type_info;<br>    err_struct_info_t err_struct_info;<br>    err_data_buffer_t err_data_buffer;<br>    int count;<br>    FILE *fp;<br>    unsigned long cpu, loop, interval, err_type_info_conf, err_struct_info_conf;<br>    u64 err_data_buffer_conf[ERR_DATA_BUFFER_SIZE];<br>    int num;<br>    int i;<br>    char path[MAX_FN_SIZE];<br>    parameters_t parameters[MAX_TASK_NUM]={};<br>    pid_t child_pid[MAX_TASK_NUM];<br>    time_t current_time;<br>    int status;</p>
<pre><code>if (!para) &#123;
    fp=fopen(&quot;err.conf&quot;, &quot;r&quot;);
    if (fp==NULL) &#123;
    perror(&quot;Error open err.conf&quot;);
    return -1;
    &#125;

    num=0;
    while (!feof(fp)) &#123;
    char buf[256];
    memset(buf,0,256);
    fgets(buf, 256, fp);
    count=sscanf(buf, &quot;%lx, %lx, %lx, %lx, %lx, %lx, %lx, %lx\n&quot;,
            &amp;cpu, &amp;loop, &amp;interval,&amp;err_type_info_conf,
            &amp;err_struct_info_conf,
            &amp;err_data_buffer_conf[0],
            &amp;err_data_buffer_conf[1],
            &amp;err_data_buffer_conf[2]);
    if (count!=PARA_FIELD_NUM+3) &#123;
        err_data_buffer_conf[0]=-1;
        err_data_buffer_conf[1]=-1;
        err_data_buffer_conf[2]=-1;
        count=sscanf(buf, &quot;%lx, %lx, %lx, %lx, %lx\n&quot;,
            &amp;cpu, &amp;loop, &amp;interval,&amp;err_type_info_conf,
            &amp;err_struct_info_conf);
        if (count!=PARA_FIELD_NUM)
            continue;
    &#125;

    parameters[num].cpu=cpu;
    parameters[num].loop=loop;
    parameters[num].interval= interval&gt;MIN_INTERVAL
                  ?interval:MIN_INTERVAL;
    parameters[num].err_type_info=err_type_info_conf;
    parameters[num].err_struct_info=err_struct_info_conf;
    memcpy(parameters[num++].err_data_buffer,
        err_data_buffer_conf,ERR_DATA_BUFFER_SIZE*8) ;

    if (num&gt;=MAX_TASK_NUM)
        break;
    &#125;
&#125;
else &#123;
    parameters[0].cpu=line_para.cpu;
    parameters[0].loop=line_para.loop;
    parameters[0].interval= line_para.interval&gt;MIN_INTERVAL
                  ?line_para.interval:MIN_INTERVAL;
    parameters[0].err_type_info=line_para.err_type_info;
    parameters[0].err_struct_info=line_para.err_struct_info;
    memcpy(parameters[0].err_data_buffer,
        line_para.err_data_buffer,ERR_DATA_BUFFER_SIZE*8) ;

    num=1;
&#125;

/* Create semaphore: If one_lock, one semaphore for all processors.
   Otherwise, one semaphore for each processor. */
if (one_lock) &#123;
    if (create_sem(0)) &#123;
        printf(&quot;Can not create semaphore...exit\n&quot;);
        free_sem(0);
        return -1;
    &#125;
&#125;
else &#123;
    for (i=0;i&lt;num;i++) &#123;
       if (create_sem(parameters[i].cpu)) &#123;
        printf(&quot;Can not create semaphore for cpu%d...exit\n&quot;,i);
        free_sem(parameters[num].cpu);
        return -1;
       &#125;
    &#125;
&#125;

/* Create a shm segment which will be used to inject/consume errors on.*/
if (create_shm()==-1) &#123;
    printf(&quot;Error to create shm...exit\n&quot;);
    return -1;
&#125;

for (i=0;i&lt;num;i++) &#123;
    pid_t pid;

    current_time=time(NULL);
    log_info(parameters[i].cpu, &quot;\nBegine at %s&quot;, ctime(&amp;current_time));
    log_info(parameters[i].cpu, &quot;Configurations:\n&quot;);
    log_info(parameters[i].cpu,&quot;On cpu%ld: loop=%lx, interval=%lx(s)&quot;,
        parameters[i].cpu,
        parameters[i].loop,
        parameters[i].interval);
    log_info(parameters[i].cpu,&quot; err_type_info=%lx,err_struct_info=%lx\n&quot;,
        parameters[i].err_type_info,
        parameters[i].err_struct_info);

    sprintf(path, PATH_FORMAT, (int)parameters[i].cpu);
    err_type_info.err_type_info=parameters[i].err_type_info;
    err_struct_info.err_struct_info=parameters[i].err_struct_info;
    memcpy(err_data_buffer.err_data_buffer,
        parameters[i].err_data_buffer,
        ERR_DATA_BUFFER_SIZE*8);

    pid=fork();
    if (pid==0) &#123;
        unsigned long mask[MASK_SIZE];
        int j, k;

        void *va1, *va2;

        /* Allocate two memory areas va1 and va2 in shm */
        va1=shmaddr+parameters[i].cpu*PAGE_SIZE;
        va2=shmaddr+parameters[i].cpu*PAGE_SIZE+PAGE_SIZE;

        vbprintf(&quot;va1=%lx, va2=%lx\n&quot;, (u64)va1, (u64)va2);
        memset(va1, 0x1, PAGE_SIZE);
        memset(va2, 0x2, PAGE_SIZE);

        if (empty_data_buffer(err_data_buffer.err_data_buffer))
            /* If not specified yet, construct data buffer
             * with va1
             */
            construct_data_buf(path, err_type_info,
                err_struct_info, &amp;err_data_buffer,va1);

        for (j=0;j&lt;MASK_SIZE;j++)
            mask[j]=0;

        cpu=parameters[i].cpu;
        k = cpu%64;
        j = cpu/64;
        mask[j] = 1UL &lt;&lt; k;

        if (sched_setaffinity(0, MASK_SIZE*8, mask)==-1) &#123;
            perror(&quot;Error sched_setaffinity:&quot;);
            return -1;
        &#125;

        for (j=0; j&lt;parameters[i].loop; j++) &#123;
            log_info(parameters[i].cpu,&quot;Injection &quot;);
            log_info(parameters[i].cpu,&quot;on cpu%ld: #%d/%ld &quot;,

                parameters[i].cpu,j+1, parameters[i].loop);

            /* Hold the lock */
            if (one_lock)
                lock(0);
            else
            /* Hold lock on this cpu */
                lock(parameters[i].cpu);

            if ((status=err_inject(parameters[i].cpu,
                   path, err_type_info,
                   err_struct_info, err_data_buffer))
                   ==0) &#123;
                /* consume the error for &quot;inject only&quot;*/
                memcpy(va2, va1, PAGE_SIZE);
                memcpy(va1, va2, PAGE_SIZE);
                log_info(parameters[i].cpu,
                    &quot;successful\n&quot;);
            &#125;
            else &#123;
                log_info(parameters[i].cpu,&quot;fail:&quot;);
                log_info(parameters[i].cpu,
                    &quot;status=%d\n&quot;, status);
                unlock(parameters[i].cpu);
                break;
            &#125;
            if (one_lock)
            /* Release the lock */
                unlock(0);
            /* Release lock on this cpu */
            else
                unlock(parameters[i].cpu);

            if (j &lt; parameters[i].loop-1)
                sleep(parameters[i].interval);
        &#125;
        current_time=time(NULL);
        log_info(parameters[i].cpu, &quot;Done at %s&quot;, ctime(&amp;current_time));
        return 0;
    &#125;
    else if (pid&lt;0) &#123;
        perror(&quot;Error fork:&quot;);
        continue;
    &#125;
    child_pid[i]=pid;
&#125;
for (i=0;i&lt;num;i++)
    waitpid(child_pid[i], NULL, 0);

if (one_lock)
    free_sem(0);
else
    for (i=0;i&lt;num;i++)
        free_sem(parameters[i].cpu);

printf(&quot;All done.\n&quot;);

return 0;
</code></pre>
<p>}</p>
<p>void help()<br>{<br>    printf(“err_inject_tool:\n”);<br>    printf(“\t-q: query all capabilities. default: off\n”);<br>    printf(“\t-m: procedure mode. 1: physical 2: virtual. default: 1\n”);<br>    printf(“\t-i: inject errors. default: off\n”);<br>    printf(“\t-l: one lock per cpu. default: one lock for all\n”);<br>    printf(“\t-e: error parameters:\n”);<br>    printf(“\t\tcpu,loop,interval,err_type_info,err_struct_info[,err_data_buffer[0],err_data_buffer[1],err_data_buffer[2]]\n”);<br>    printf(“\t\t   cpu: logical cpu number the error will be inject in.\n”);<br>    printf(“\t\t   loop: times the error will be injected.\n”);<br>    printf(“\t\t   interval: In second. every so often one error is injected.\n”);<br>    printf(“\t\t   err_type_info, err_struct_info: PAL parameters.\n”);<br>    printf(“\t\t   err_data_buffer: PAL parameter. Optional. If not present,\n”);<br>    printf(“\t\t                    it’s constructed by tool automatically. Be\n”);<br>    printf(“\t\t                    careful to provide err_data_buffer and make\n”);<br>    printf(“\t\t                    sure it’s working with the environment.\n”);<br>    printf(“\t    Note:no space between error parameters.\n”);<br>    printf(“\t    default: Take error parameters from err.conf instead of command line.\n”);<br>    printf(“\t-v: verbose. default: off\n”);<br>    printf(“\t-h: help\n\n”);<br>    printf(“The tool will take err.conf file as “);<br>    printf(“input to inject single or multiple errors “);<br>    printf(“on one or multiple cpus in parallel.\n”);<br>}</p>
<p>int main(int argc, char **argv)<br>{<br>    char c;<br>    int do_err_inj=0;<br>    int do_query_all=0;<br>    int count;<br>    u32 m;</p>
<pre><code>/* Default one lock for all cpu&#39;s */
one_lock=1;
while ((c = getopt(argc, argv, &quot;m:iqvhle:&quot;)) != EOF)
    switch (c) &#123;
        case &#39;m&#39;:    /* Procedure mode. 1: phys 2: virt */
            count=sscanf(optarg, &quot;%x&quot;, &amp;m);
            if (count!=1 || (m!=1 &amp;&amp; m!=2)) &#123;
                printf(&quot;Wrong mode number.\n&quot;);
                help();
                return -1;
            &#125;
            mode=m;
            break;
        case &#39;i&#39;:    /* Inject errors */
            do_err_inj=1;
            break;
        case &#39;q&#39;:    /* Query */
            do_query_all=1;
            break;
        case &#39;v&#39;:    /* Verbose */
            verbose=1;
            break;
        case &#39;l&#39;:    /* One lock per cpu */
            one_lock=0;
            break;
        case &#39;e&#39;:    /* error arguments */
            /* Take parameters:
             * #cpu, loop, interval, err_type_info, err_struct_info[, err_data_buffer]
             * err_data_buffer is optional. Recommend not to specify
             * err_data_buffer. Better to use tool to generate it.
             */
            count=sscanf(optarg,
                &quot;%lx, %lx, %lx, %lx, %lx, %lx, %lx, %lx\n&quot;,
                &amp;line_para.cpu,
                &amp;line_para.loop,
                &amp;line_para.interval,
                &amp;line_para.err_type_info,
                &amp;line_para.err_struct_info,
                &amp;line_para.err_data_buffer[0],
                &amp;line_para.err_data_buffer[1],
                &amp;line_para.err_data_buffer[2]);
            if (count!=PARA_FIELD_NUM+3) &#123;
                line_para.err_data_buffer[0]=-1,
                line_para.err_data_buffer[1]=-1,
                 line_para.err_data_buffer[2]=-1;
                count=sscanf(optarg, &quot;%lx, %lx, %lx, %lx, %lx\n&quot;,
                    &amp;line_para.cpu,
                    &amp;line_para.loop,
                    &amp;line_para.interval,
                    &amp;line_para.err_type_info,
                    &amp;line_para.err_struct_info);
                if (count!=PARA_FIELD_NUM) &#123;
                printf(&quot;Wrong error arguments.\n&quot;);
                help();
                return -1;
                &#125;
            &#125;
            para=1;
            break;
        continue;
            break;
        case &#39;h&#39;:
            help();
            return 0;
        default:
            break;
    &#125;

if (do_query_all)
    query_all_capabilities();
if (do_err_inj)
    err_inj();

if (!do_query_all &amp;&amp;  !do_err_inj)
    help();

return 0;
</code></pre>
<p>}</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_err_inject/" title="Kernel-4.18.0-80.el8_err_inject" target="_blank" rel="external">http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_err_inject/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/02/19/Kernel-4.18.0-80.el8_email-clients/" title="Kernel-4.18.0-80.el8_email-clients"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/02/19/Kernel-4.18.0-80.el8_ext2/" title="Kernel-4.18.0-80.el8_ext2"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>