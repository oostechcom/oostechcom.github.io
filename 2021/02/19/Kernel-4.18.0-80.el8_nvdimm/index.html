<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-4.18.0-80.el8_nvdi | oosTech.com</title>
  <meta name="description" content="LIBNVDIMM: Non-Volatile Devices       libnvdimm - kernel &#x2F; libndctl - userspace helper library            linux-nvdimm@lists.01.org                   v13   Glossary Overview     Supporting D">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-4.18.0-80.el8_nvdi">
<meta property="og:url" content="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_nvdimm/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="LIBNVDIMM: Non-Volatile Devices       libnvdimm - kernel &#x2F; libndctl - userspace helper library            linux-nvdimm@lists.01.org                   v13   Glossary Overview     Supporting D">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-18T16:00:00.000Z">
<meta property="article:modified_time" content="2021-02-18T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_nvdimm/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_mpc5200/" class="title">Kernel-3.10.0-957.el7_mpc5200</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_6pack/" class="title">Kernel-3.10.0-957.el7_6pack</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Glossary"><span class="toc-number">1.</span> <span class="toc-text">Glossary</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Overview"><span class="toc-number">2.</span> <span class="toc-text">Overview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LIBNVDIMM-PMEM-and-BLK"><span class="toc-number">3.</span> <span class="toc-text">LIBNVDIMM PMEM and BLK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-BLK"><span class="toc-number">4.</span> <span class="toc-text">Why BLK?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BLK-REGIONs-PMEM-REGIONs-Atomic-Sectors-and-DAX"><span class="toc-number">5.</span> <span class="toc-text">BLK-REGIONs, PMEM-REGIONs, Atomic Sectors, and DAX</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Example-NVDIMM-Platform"><span class="toc-number">6.</span> <span class="toc-text">Example NVDIMM Platform</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LIBNVDIMM-Kernel-Device-Model-and-LIBNDCTL-Userspace-API"><span class="toc-number">7.</span> <span class="toc-text">LIBNVDIMM Kernel Device Model and LIBNDCTL Userspace API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LIBNVDIMM-LIBNDCTL-Bus"><span class="toc-number">8.</span> <span class="toc-text">LIBNVDIMM&#x2F;LIBNDCTL: Bus</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LIBNVDIMM-LIBNDCTL-DIMM-NMEM"><span class="toc-number">9.</span> <span class="toc-text">LIBNVDIMM&#x2F;LIBNDCTL: DIMM (NMEM)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LIBNVDIMM-LIBNDCTL-Region"><span class="toc-number">10.</span> <span class="toc-text">LIBNVDIMM&#x2F;LIBNDCTL: Region</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-Not-Encode-the-Region-Type-into-the-Region-Name"><span class="toc-number">11.</span> <span class="toc-text">Why Not Encode the Region Type into the Region Name?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#How-Do-I-Determine-the-Major-Type-of-a-Region"><span class="toc-number">12.</span> <span class="toc-text">How Do I Determine the Major Type of a Region?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LIBNVDIMM-LIBNDCTL-Namespace"><span class="toc-number">13.</span> <span class="toc-text">LIBNVDIMM&#x2F;LIBNDCTL: Namespace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LIBNVDIMM-LIBNDCTL-Block-Translation-Table-%E2%80%9Cbtt%E2%80%9D"><span class="toc-number">14.</span> <span class="toc-text">LIBNVDIMM&#x2F;LIBNDCTL: Block Translation Table “btt”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Summary-LIBNDCTL-Diagram"><span class="toc-number">15.</span> <span class="toc-text">Summary LIBNDCTL Diagram</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-4.18.0-80.el8_nvdimm" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-4.18.0-80.el8_nvdi
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/02/19/Kernel-4.18.0-80.el8_nvdimm/" class="article-date">
	 published: <time datetime="2021-02-18T16:00:00.000Z" itemprop="datePublished">2021-02-19</time>
	</a>
</span>

        
	<a href="/2021/02/19/Kernel-4.18.0-80.el8_nvdimm/" class="article-date">
	   updated: <time datetime="2021-02-18T16:00:00.000Z" itemprop="dateUpdated">2021-02-19</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/02/19/Kernel-4.18.0-80.el8_nvdimm/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <pre><code>          LIBNVDIMM: Non-Volatile Devices
      libnvdimm - kernel / libndctl - userspace helper library
           linux-nvdimm@lists.01.org
                  v13


Glossary
Overview
    Supporting Documents
    Git Trees
LIBNVDIMM PMEM and BLK
Why BLK?
    PMEM vs BLK
        BLK-REGIONs, PMEM-REGIONs, Atomic Sectors, and DAX
Example NVDIMM Platform
LIBNVDIMM Kernel Device Model and LIBNDCTL Userspace API
    LIBNDCTL: Context
        libndctl: instantiate a new library context example
    LIBNVDIMM/LIBNDCTL: Bus
        libnvdimm: control class device in /sys/class
        libnvdimm: bus
        libndctl: bus enumeration example
    LIBNVDIMM/LIBNDCTL: DIMM (NMEM)
        libnvdimm: DIMM (NMEM)
        libndctl: DIMM enumeration example
    LIBNVDIMM/LIBNDCTL: Region
        libnvdimm: region
        libndctl: region enumeration example
        Why Not Encode the Region Type into the Region Name?
        How Do I Determine the Major Type of a Region?
    LIBNVDIMM/LIBNDCTL: Namespace
        libnvdimm: namespace
        libndctl: namespace enumeration example
        libndctl: namespace creation example
        Why the Term &quot;namespace&quot;?
    LIBNVDIMM/LIBNDCTL: Block Translation Table &quot;btt&quot;
        libnvdimm: btt layout
        libndctl: btt creation example
Summary LIBNDCTL Diagram
</code></pre>
<h2 id="Glossary"><a href="#Glossary" class="headerlink" title="Glossary"></a>Glossary</h2><p>PMEM: A system-physical-address range where writes are persistent.  A<br>block device composed of PMEM is capable of DAX.  A PMEM address range<br>may span an interleave of several DIMMs.</p>
<p>BLK: A set of one or more programmable memory mapped apertures provided<br>by a DIMM to access its media.  This indirection precludes the<br>performance benefit of interleaving, but enables DIMM-bounded failure<br>modes.</p>
<p>DPA: DIMM Physical Address, is a DIMM-relative offset.  With one DIMM in<br>the system there would be a 1:1 system-physical-address:DPA association.<br>Once more DIMMs are added a memory controller interleave must be<br>decoded to determine the DPA associated with a given<br>system-physical-address.  BLK capacity always has a 1:1 relationship<br>with a single-DIMM’s DPA range.</p>
<p>DAX: File system extensions to bypass the page cache and block layer to<br>mmap persistent memory, from a PMEM block device, directly into a<br>process address space.</p>
<p>DSM: Device Specific Method: ACPI method to to control specific<br>device - in this case the firmware.</p>
<p>DCR: NVDIMM Control Region Structure defined in ACPI 6 Section 5.2.25.5.<br>It defines a vendor-id, device-id, and interface format for a given DIMM.</p>
<p>BTT: Block Translation Table: Persistent memory is byte addressable.<br>Existing software may have an expectation that the power-fail-atomicity<br>of writes is at least one sector, 512 bytes.  The BTT is an indirection<br>table with atomic update semantics to front a PMEM/BLK block device<br>driver and present arbitrary atomic sector sizes.</p>
<p>LABEL: Metadata stored on a DIMM device that partitions and identifies<br>(persistently names) storage between PMEM and BLK.  It also partitions<br>BLK storage to host BTTs with different parameters per BLK-partition.<br>Note that traditional partition tables, GPT/MBR, are layered on top of a<br>BLK or PMEM device.</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>The LIBNVDIMM subsystem provides support for three types of NVDIMMs, namely,<br>PMEM, BLK, and NVDIMM devices that can simultaneously support both PMEM<br>and BLK mode access.  These three modes of operation are described by<br>the “NVDIMM Firmware Interface Table” (NFIT) in ACPI 6.  While the LIBNVDIMM<br>implementation is generic and supports pre-NFIT platforms, it was guided<br>by the superset of capabilities need to support this ACPI 6 definition<br>for NVDIMM resources.  The bulk of the kernel implementation is in place<br>to handle the case where DPA accessible via PMEM is aliased with DPA<br>accessible via BLK.  When that occurs a LABEL is needed to reserve DPA<br>for exclusive access via one mode a time.</p>
<p>Supporting Documents<br>ACPI 6: <a target="_blank" rel="noopener" href="http://www.uefi.org/sites/default/files/resources/ACPI_6.0.pdf">http://www.uefi.org/sites/default/files/resources/ACPI_6.0.pdf</a><br>NVDIMM Namespace: <a target="_blank" rel="noopener" href="http://pmem.io/documents/NVDIMM_Namespace_Spec.pdf">http://pmem.io/documents/NVDIMM_Namespace_Spec.pdf</a><br>DSM Interface Example: <a target="_blank" rel="noopener" href="http://pmem.io/documents/NVDIMM_DSM_Interface_Example.pdf">http://pmem.io/documents/NVDIMM_DSM_Interface_Example.pdf</a><br>Driver Writer’s Guide: <a target="_blank" rel="noopener" href="http://pmem.io/documents/NVDIMM_Driver_Writers_Guide.pdf">http://pmem.io/documents/NVDIMM_Driver_Writers_Guide.pdf</a></p>
<p>Git Trees<br>LIBNVDIMM: <a target="_blank" rel="noopener" href="https://git.kernel.org/cgit/linux/kernel/git/djbw/nvdimm.git">https://git.kernel.org/cgit/linux/kernel/git/djbw/nvdimm.git</a><br>LIBNDCTL: <a target="_blank" rel="noopener" href="https://github.com/pmem/ndctl.git">https://github.com/pmem/ndctl.git</a><br>PMEM: <a target="_blank" rel="noopener" href="https://github.com/01org/prd">https://github.com/01org/prd</a></p>
<h2 id="LIBNVDIMM-PMEM-and-BLK"><a href="#LIBNVDIMM-PMEM-and-BLK" class="headerlink" title="LIBNVDIMM PMEM and BLK"></a>LIBNVDIMM PMEM and BLK</h2><p>Prior to the arrival of the NFIT, non-volatile memory was described to a<br>system in various ad-hoc ways.  Usually only the bare minimum was<br>provided, namely, a single system-physical-address range where writes<br>are expected to be durable after a system power loss.  Now, the NFIT<br>specification standardizes not only the description of PMEM, but also<br>BLK and platform message-passing entry points for control and<br>configuration.</p>
<p>For each NVDIMM access method (PMEM, BLK), LIBNVDIMM provides a block<br>device driver:</p>
<pre><code>1. PMEM (nd_pmem.ko): Drives a system-physical-address range.  This
range is contiguous in system memory and may be interleaved (hardware
memory controller striped) across multiple DIMMs.  When interleaved the
platform may optionally provide details of which DIMMs are participating
in the interleave.

Note that while LIBNVDIMM describes system-physical-address ranges that may
alias with BLK access as ND_NAMESPACE_PMEM ranges and those without
alias as ND_NAMESPACE_IO ranges, to the nd_pmem driver there is no
distinction.  The different device-types are an implementation detail
that userspace can exploit to implement policies like &quot;only interface
with address ranges from certain DIMMs&quot;.  It is worth noting that when
aliasing is present and a DIMM lacks a label, then no block device can
be created by default as userspace needs to do at least one allocation
of DPA to the PMEM range.  In contrast ND_NAMESPACE_IO ranges, once
registered, can be immediately attached to nd_pmem.

2. BLK (nd_blk.ko): This driver performs I/O using a set of platform
defined apertures.  A set of apertures will access just one DIMM.
Multiple windows (apertures) allow multiple concurrent accesses, much like
tagged-command-queuing, and would likely be used by different threads or
different CPUs.

The NFIT specification defines a standard format for a BLK-aperture, but
the spec also allows for vendor specific layouts, and non-NFIT BLK
implementations may have other designs for BLK I/O.  For this reason
&quot;nd_blk&quot; calls back into platform-specific code to perform the I/O.
One such implementation is defined in the &quot;Driver Writer&#39;s Guide&quot; and &quot;DSM
Interface Example&quot;.
</code></pre>
<h2 id="Why-BLK"><a href="#Why-BLK" class="headerlink" title="Why BLK?"></a>Why BLK?</h2><p>While PMEM provides direct byte-addressable CPU-load/store access to<br>NVDIMM storage, it does not provide the best system RAS (recovery,<br>availability, and serviceability) model.  An access to a corrupted<br>system-physical-address address causes a CPU exception while an access<br>to a corrupted address through an BLK-aperture causes that block window<br>to raise an error status in a register.  The latter is more aligned with<br>the standard error model that host-bus-adapter attached disks present.<br>Also, if an administrator ever wants to replace a memory it is easier to<br>service a system at DIMM module boundaries.  Compare this to PMEM where<br>data could be interleaved in an opaque hardware specific manner across<br>several DIMMs.</p>
<p>PMEM vs BLK<br>BLK-apertures solve these RAS problems, but their presence is also the<br>major contributing factor to the complexity of the ND subsystem.  They<br>complicate the implementation because PMEM and BLK alias in DPA space.<br>Any given DIMM’s DPA-range may contribute to one or more<br>system-physical-address sets of interleaved DIMMs, <em>and</em> may also be<br>accessed in its entirety through its BLK-aperture.  Accessing a DPA<br>through a system-physical-address while simultaneously accessing the<br>same DPA through a BLK-aperture has undefined results.  For this reason,<br>DIMMs with this dual interface configuration include a DSM function to<br>store/retrieve a LABEL.  The LABEL effectively partitions the DPA-space<br>into exclusive system-physical-address and BLK-aperture accessible<br>regions.  For simplicity a DIMM is allowed a PMEM “region” per each<br>interleave set in which it is a member.  The remaining DPA space can be<br>carved into an arbitrary number of BLK devices with discontiguous<br>extents.</p>
<h2 id="BLK-REGIONs-PMEM-REGIONs-Atomic-Sectors-and-DAX"><a href="#BLK-REGIONs-PMEM-REGIONs-Atomic-Sectors-and-DAX" class="headerlink" title="BLK-REGIONs, PMEM-REGIONs, Atomic Sectors, and DAX"></a>BLK-REGIONs, PMEM-REGIONs, Atomic Sectors, and DAX</h2><p>One of the few<br>reasons to allow multiple BLK namespaces per REGION is so that each<br>BLK-namespace can be configured with a BTT with unique atomic sector<br>sizes.  While a PMEM device can host a BTT the LABEL specification does<br>not provide for a sector size to be specified for a PMEM namespace.<br>This is due to the expectation that the primary usage model for PMEM is<br>via DAX, and the BTT is incompatible with DAX.  However, for the cases<br>where an application or filesystem still needs atomic sector update<br>guarantees it can register a BTT on a PMEM device or partition.  See<br>LIBNVDIMM/NDCTL: Block Translation Table “btt”</p>
<h2 id="Example-NVDIMM-Platform"><a href="#Example-NVDIMM-Platform" class="headerlink" title="Example NVDIMM Platform"></a>Example NVDIMM Platform</h2><p>For the remainder of this document the following diagram will be<br>referenced for any example sysfs layouts.</p>
<pre><code>                         (a)               (b)           DIMM   BLK-REGION
      +-------------------+--------+--------+--------+
</code></pre>
<p>+——+  |       pm0.0       | blk2.0 | pm1.0  | blk2.1 |    0      region2<br>| imc0 +–+- - - region0- - - +——–+        +——–+<br>+–+—+  |       pm0.0       | blk3.0 | pm1.0  | blk3.1 |    1      region3<br>   |      +——————-+——–v        v——–+<br>+–+—+                               |                 |<br>| cpu0 |                                     region1<br>+–+—+                               |                 |<br>   |      +—————————-^        ^——–+<br>+–+—+  |           blk4.0           | pm1.0  | blk4.0 |    2      region4<br>| imc1 +–+—————————-|        +——–+<br>+——+  |           blk5.0           | pm1.0  | blk5.0 |    3      region5<br>          +—————————-+——–+——–+</p>
<p>In this platform we have four DIMMs and two memory controllers in one<br>socket.  Each unique interface (BLK or PMEM) to DPA space is identified<br>by a region device with a dynamically assigned id (REGION0 - REGION5).</p>
<pre><code>1. The first portion of DIMM0 and DIMM1 are interleaved as REGION0. A
single PMEM namespace is created in the REGION0-SPA-range that spans most
of DIMM0 and DIMM1 with a user-specified name of &quot;pm0.0&quot;. Some of that
interleaved system-physical-address range is reclaimed as BLK-aperture
accessed space starting at DPA-offset (a) into each DIMM.  In that
reclaimed space we create two BLK-aperture &quot;namespaces&quot; from REGION2 and
REGION3 where &quot;blk2.0&quot; and &quot;blk3.0&quot; are just human readable names that
could be set to any user-desired name in the LABEL.

2. In the last portion of DIMM0 and DIMM1 we have an interleaved
system-physical-address range, REGION1, that spans those two DIMMs as
well as DIMM2 and DIMM3.  Some of REGION1 is allocated to a PMEM namespace
named &quot;pm1.0&quot;, the rest is reclaimed in 4 BLK-aperture namespaces (for
each DIMM in the interleave set), &quot;blk2.1&quot;, &quot;blk3.1&quot;, &quot;blk4.0&quot;, and
&quot;blk5.0&quot;.

3. The portion of DIMM2 and DIMM3 that do not participate in the REGION1
interleaved system-physical-address range (i.e. the DPA address past
offset (b) are also included in the &quot;blk4.0&quot; and &quot;blk5.0&quot; namespaces.
Note, that this example shows that BLK-aperture namespaces don&#39;t need to
be contiguous in DPA-space.

This bus is provided by the kernel under the device
/sys/devices/platform/nfit_test.0 when CONFIG_NFIT_TEST is enabled and
the nfit_test.ko module is loaded.  This not only test LIBNVDIMM but the
acpi_nfit.ko driver as well.
</code></pre>
<h2 id="LIBNVDIMM-Kernel-Device-Model-and-LIBNDCTL-Userspace-API"><a href="#LIBNVDIMM-Kernel-Device-Model-and-LIBNDCTL-Userspace-API" class="headerlink" title="LIBNVDIMM Kernel Device Model and LIBNDCTL Userspace API"></a>LIBNVDIMM Kernel Device Model and LIBNDCTL Userspace API</h2><p>What follows is a description of the LIBNVDIMM sysfs layout and a<br>corresponding object hierarchy diagram as viewed through the LIBNDCTL<br>API.  The example sysfs paths and diagrams are relative to the Example<br>NVDIMM Platform which is also the LIBNVDIMM bus used in the LIBNDCTL unit<br>test.</p>
<p>LIBNDCTL: Context<br>Every API call in the LIBNDCTL library requires a context that holds the<br>logging parameters and other library instance state.  The library is<br>based on the libabc template:<br><a target="_blank" rel="noopener" href="https://git.kernel.org/cgit/linux/kernel/git/kay/libabc.git">https://git.kernel.org/cgit/linux/kernel/git/kay/libabc.git</a></p>
<p>LIBNDCTL: instantiate a new library context example</p>
<pre><code>struct ndctl_ctx *ctx;

if (ndctl_new(&amp;ctx) == 0)
    return ctx;
else
    return NULL;
</code></pre>
<h2 id="LIBNVDIMM-LIBNDCTL-Bus"><a href="#LIBNVDIMM-LIBNDCTL-Bus" class="headerlink" title="LIBNVDIMM/LIBNDCTL: Bus"></a>LIBNVDIMM/LIBNDCTL: Bus</h2><p>A bus has a 1:1 relationship with an NFIT.  The current expectation for<br>ACPI based systems is that there is only ever one platform-global NFIT.<br>That said, it is trivial to register multiple NFITs, the specification<br>does not preclude it.  The infrastructure supports multiple busses and<br>we we use this capability to test multiple NFIT configurations in the<br>unit test.</p>
<p>LIBNVDIMM: control class device in /sys/class</p>
<p>This character device accepts DSM messages to be passed to DIMM<br>identified by its NFIT handle.</p>
<pre><code>/sys/class/nd/ndctl0
|-- dev
|-- device -&gt; ../../../ndbus0
|-- subsystem -&gt; ../../../../../../../class/nd
</code></pre>
<p>LIBNVDIMM: bus</p>
<pre><code>struct nvdimm_bus *nvdimm_bus_register(struct device *parent,
       struct nvdimm_bus_descriptor *nfit_desc);

/sys/devices/platform/nfit_test.0/ndbus0
|-- commands
|-- nd
|-- nfit
|-- nmem0
|-- nmem1
|-- nmem2
|-- nmem3
|-- power
|-- provider
|-- region0
|-- region1
|-- region2
|-- region3
|-- region4
|-- region5
|-- uevent
`-- wait_probe
</code></pre>
<p>LIBNDCTL: bus enumeration example<br>Find the bus handle that describes the bus from Example NVDIMM Platform</p>
<pre><code>static struct ndctl_bus *get_bus_by_provider(struct ndctl_ctx *ctx,
        const char *provider)
&#123;
    struct ndctl_bus *bus;

    ndctl_bus_foreach(ctx, bus)
        if (strcmp(provider, ndctl_bus_get_provider(bus)) == 0)
            return bus;

    return NULL;
&#125;

bus = get_bus_by_provider(ctx, &quot;nfit_test.0&quot;);
</code></pre>
<h2 id="LIBNVDIMM-LIBNDCTL-DIMM-NMEM"><a href="#LIBNVDIMM-LIBNDCTL-DIMM-NMEM" class="headerlink" title="LIBNVDIMM/LIBNDCTL: DIMM (NMEM)"></a>LIBNVDIMM/LIBNDCTL: DIMM (NMEM)</h2><p>The DIMM device provides a character device for sending commands to<br>hardware, and it is a container for LABELs.  If the DIMM is defined by<br>NFIT then an optional ‘nfit’ attribute sub-directory is available to add<br>NFIT-specifics.</p>
<p>Note that the kernel device name for “DIMMs” is “nmemX”.  The NFIT<br>describes these devices via “Memory Device to System Physical Address<br>Range Mapping Structure”, and there is no requirement that they actually<br>be physical DIMMs, so we use a more generic name.</p>
<p>LIBNVDIMM: DIMM (NMEM)</p>
<pre><code>struct nvdimm *nvdimm_create(struct nvdimm_bus *nvdimm_bus, void *provider_data,
        const struct attribute_group **groups, unsigned long flags,
        unsigned long *dsm_mask);

/sys/devices/platform/nfit_test.0/ndbus0
|-- nmem0
|   |-- available_slots
|   |-- commands
|   |-- dev
|   |-- devtype
|   |-- driver -&gt; ../../../../../bus/nd/drivers/nvdimm
|   |-- modalias
|   |-- nfit
|   |   |-- device
|   |   |-- format
|   |   |-- handle
|   |   |-- phys_id
|   |   |-- rev_id
|   |   |-- serial
|   |   `-- vendor
|   |-- state
|   |-- subsystem -&gt; ../../../../../bus/nd
|   `-- uevent
|-- nmem1
[..]
</code></pre>
<p>LIBNDCTL: DIMM enumeration example</p>
<p>Note, in this example we are assuming NFIT-defined DIMMs which are<br>identified by an “nfit_handle” a 32-bit value where:<br>Bit 3:0 DIMM number within the memory channel<br>Bit 7:4 memory channel number<br>Bit 11:8 memory controller ID<br>Bit 15:12 socket ID (within scope of a Node controller if node controller is present)<br>Bit 27:16 Node Controller ID<br>Bit 31:28 Reserved</p>
<pre><code>static struct ndctl_dimm *get_dimm_by_handle(struct ndctl_bus *bus,
       unsigned int handle)
&#123;
    struct ndctl_dimm *dimm;

    ndctl_dimm_foreach(bus, dimm)
        if (ndctl_dimm_get_handle(dimm) == handle)
            return dimm;

    return NULL;
&#125;

#define DIMM_HANDLE(n, s, i, c, d) \
    (((n &amp; 0xfff) &lt;&lt; 16) | ((s &amp; 0xf) &lt;&lt; 12) | ((i &amp; 0xf) &lt;&lt; 8) \
     | ((c &amp; 0xf) &lt;&lt; 4) | (d &amp; 0xf))

dimm = get_dimm_by_handle(bus, DIMM_HANDLE(0, 0, 0, 0, 0));
</code></pre>
<h2 id="LIBNVDIMM-LIBNDCTL-Region"><a href="#LIBNVDIMM-LIBNDCTL-Region" class="headerlink" title="LIBNVDIMM/LIBNDCTL: Region"></a>LIBNVDIMM/LIBNDCTL: Region</h2><p>A generic REGION device is registered for each PMEM range or BLK-aperture<br>set.  Per the example there are 6 regions: 2 PMEM and 4 BLK-aperture<br>sets on the “nfit_test.0” bus.  The primary role of regions are to be a<br>container of “mappings”.  A mapping is a tuple of &lt;DIMM,<br>DPA-start-offset, length&gt;.</p>
<p>LIBNVDIMM provides a built-in driver for these REGION devices.  This driver<br>is responsible for reconciling the aliased DPA mappings across all<br>regions, parsing the LABEL, if present, and then emitting NAMESPACE<br>devices with the resolved/exclusive DPA-boundaries for the nd_pmem or<br>nd_blk device driver to consume.</p>
<p>In addition to the generic attributes of “mapping”s, “interleave_ways”<br>and “size” the REGION device also exports some convenience attributes.<br>“nstype” indicates the integer type of namespace-device this region<br>emits, “devtype” duplicates the DEVTYPE variable stored by udev at the<br>‘add’ event, “modalias” duplicates the MODALIAS variable stored by udev<br>at the ‘add’ event, and finally, the optional “spa_index” is provided in<br>the case where the region is defined by a SPA.</p>
<p>LIBNVDIMM: region</p>
<pre><code>struct nd_region *nvdimm_pmem_region_create(struct nvdimm_bus *nvdimm_bus,
        struct nd_region_desc *ndr_desc);
struct nd_region *nvdimm_blk_region_create(struct nvdimm_bus *nvdimm_bus,
        struct nd_region_desc *ndr_desc);

/sys/devices/platform/nfit_test.0/ndbus0
|-- region0
|   |-- available_size
|   |-- btt0
|   |-- btt_seed
|   |-- devtype
|   |-- driver -&gt; ../../../../../bus/nd/drivers/nd_region
|   |-- init_namespaces
|   |-- mapping0
|   |-- mapping1
|   |-- mappings
|   |-- modalias
|   |-- namespace0.0
|   |-- namespace_seed
|   |-- numa_node
|   |-- nfit
|   |   `-- spa_index
|   |-- nstype
|   |-- set_cookie
|   |-- size
|   |-- subsystem -&gt; ../../../../../bus/nd
|   `-- uevent
|-- region1
[..]
</code></pre>
<p>LIBNDCTL: region enumeration example</p>
<p>Sample region retrieval routines based on NFIT-unique data like<br>“spa_index” (interleave set id) for PMEM and “nfit_handle” (dimm id) for<br>BLK.</p>
<pre><code>static struct ndctl_region *get_pmem_region_by_spa_index(struct ndctl_bus *bus,
        unsigned int spa_index)
&#123;
    struct ndctl_region *region;

    ndctl_region_foreach(bus, region) &#123;
        if (ndctl_region_get_type(region) != ND_DEVICE_REGION_PMEM)
            continue;
        if (ndctl_region_get_spa_index(region) == spa_index)
            return region;
    &#125;
    return NULL;
&#125;

static struct ndctl_region *get_blk_region_by_dimm_handle(struct ndctl_bus *bus,
        unsigned int handle)
&#123;
    struct ndctl_region *region;

    ndctl_region_foreach(bus, region) &#123;
        struct ndctl_mapping *map;

        if (ndctl_region_get_type(region) != ND_DEVICE_REGION_BLOCK)
            continue;
        ndctl_mapping_foreach(region, map) &#123;
            struct ndctl_dimm *dimm = ndctl_mapping_get_dimm(map);

            if (ndctl_dimm_get_handle(dimm) == handle)
                return region;
        &#125;
    &#125;
    return NULL;
&#125;
</code></pre>
<h2 id="Why-Not-Encode-the-Region-Type-into-the-Region-Name"><a href="#Why-Not-Encode-the-Region-Type-into-the-Region-Name" class="headerlink" title="Why Not Encode the Region Type into the Region Name?"></a>Why Not Encode the Region Type into the Region Name?</h2><p>At first glance it seems since NFIT defines just PMEM and BLK interface<br>types that we should simply name REGION devices with something derived<br>from those type names.  However, the ND subsystem explicitly keeps the<br>REGION name generic and expects userspace to always consider the<br>region-attributes for four reasons:</p>
<pre><code>1. There are already more than two REGION and &quot;namespace&quot; types.  For
PMEM there are two subtypes.  As mentioned previously we have PMEM where
the constituent DIMM devices are known and anonymous PMEM.  For BLK
regions the NFIT specification already anticipates vendor specific
implementations.  The exact distinction of what a region contains is in
the region-attributes not the region-name or the region-devtype.

2. A region with zero child-namespaces is a possible configuration.  For
example, the NFIT allows for a DCR to be published without a
corresponding BLK-aperture.  This equates to a DIMM that can only accept
control/configuration messages, but no i/o through a descendant block
device.  Again, this &quot;type&quot; is advertised in the attributes (&#39;mappings&#39;
== 0) and the name does not tell you much.

3. What if a third major interface type arises in the future?  Outside
of vendor specific implementations, it&#39;s not difficult to envision a
third class of interface type beyond BLK and PMEM.  With a generic name
for the REGION level of the device-hierarchy old userspace
implementations can still make sense of new kernel advertised
region-types.  Userspace can always rely on the generic region
attributes like &quot;mappings&quot;, &quot;size&quot;, etc and the expected child devices
named &quot;namespace&quot;.  This generic format of the device-model hierarchy
allows the LIBNVDIMM and LIBNDCTL implementations to be more uniform and
future-proof.

4. There are more robust mechanisms for determining the major type of a
region than a device name.  See the next section, How Do I Determine the
Major Type of a Region?
</code></pre>
<h2 id="How-Do-I-Determine-the-Major-Type-of-a-Region"><a href="#How-Do-I-Determine-the-Major-Type-of-a-Region" class="headerlink" title="How Do I Determine the Major Type of a Region?"></a>How Do I Determine the Major Type of a Region?</h2><p>Outside of the blanket recommendation of “use libndctl”, or simply<br>looking at the kernel header (/usr/include/linux/ndctl.h) to decode the<br>“nstype” integer attribute, here are some other options.</p>
<pre><code>1. module alias lookup:

The whole point of region/namespace device type differentiation is to
decide which block-device driver will attach to a given LIBNVDIMM namespace.
One can simply use the modalias to lookup the resulting module.  It&#39;s
important to note that this method is robust in the presence of a
vendor-specific driver down the road.  If a vendor-specific
implementation wants to supplant the standard nd_blk driver it can with
minimal impact to the rest of LIBNVDIMM.

In fact, a vendor may also want to have a vendor-specific region-driver
(outside of nd_region).  For example, if a vendor defined its own LABEL
format it would need its own region driver to parse that LABEL and emit
the resulting namespaces.  The output from module resolution is more
accurate than a region-name or region-devtype.

2. udev:

The kernel &quot;devtype&quot; is registered in the udev database
# udevadm info --path=/devices/platform/nfit_test.0/ndbus0/region0
P: /devices/platform/nfit_test.0/ndbus0/region0
E: DEVPATH=/devices/platform/nfit_test.0/ndbus0/region0
E: DEVTYPE=nd_pmem
E: MODALIAS=nd:t2
E: SUBSYSTEM=nd

# udevadm info --path=/devices/platform/nfit_test.0/ndbus0/region4
P: /devices/platform/nfit_test.0/ndbus0/region4
E: DEVPATH=/devices/platform/nfit_test.0/ndbus0/region4
E: DEVTYPE=nd_blk
E: MODALIAS=nd:t3
E: SUBSYSTEM=nd

...and is available as a region attribute, but keep in mind that the
&quot;devtype&quot; does not indicate sub-type variations and scripts should
really be understanding the other attributes.

3. type specific attributes:

As it currently stands a BLK-aperture region will never have a
&quot;nfit/spa_index&quot; attribute, but neither will a non-NFIT PMEM region.  A
BLK region with a &quot;mappings&quot; value of 0 is, as mentioned above, a DIMM
that does not allow I/O.  A PMEM region with a &quot;mappings&quot; value of zero
is a simple system-physical-address range.
</code></pre>
<h2 id="LIBNVDIMM-LIBNDCTL-Namespace"><a href="#LIBNVDIMM-LIBNDCTL-Namespace" class="headerlink" title="LIBNVDIMM/LIBNDCTL: Namespace"></a>LIBNVDIMM/LIBNDCTL: Namespace</h2><p>A REGION, after resolving DPA aliasing and LABEL specified boundaries,<br>surfaces one or more “namespace” devices.  The arrival of a “namespace”<br>device currently triggers either the nd_blk or nd_pmem driver to load<br>and register a disk/block device.</p>
<p>LIBNVDIMM: namespace<br>Here is a sample layout from the three major types of NAMESPACE where<br>namespace0.0 represents DIMM-info-backed PMEM (note that it has a ‘uuid’<br>attribute), namespace2.0 represents a BLK namespace (note it has a<br>‘sector_size’ attribute) that, and namespace6.0 represents an anonymous<br>PMEM namespace (note that has no ‘uuid’ attribute due to not support a<br>LABEL).</p>
<pre><code>/sys/devices/platform/nfit_test.0/ndbus0/region0/namespace0.0
|-- alt_name
|-- devtype
|-- dpa_extents
|-- force_raw
|-- modalias
|-- numa_node
|-- resource
|-- size
|-- subsystem -&gt; ../../../../../../bus/nd
|-- type
|-- uevent
`-- uuid
/sys/devices/platform/nfit_test.0/ndbus0/region2/namespace2.0
|-- alt_name
|-- devtype
|-- dpa_extents
|-- force_raw
|-- modalias
|-- numa_node
|-- sector_size
|-- size
|-- subsystem -&gt; ../../../../../../bus/nd
|-- type
|-- uevent
`-- uuid
/sys/devices/platform/nfit_test.1/ndbus1/region6/namespace6.0
|-- block
|   `-- pmem0
|-- devtype
|-- driver -&gt; ../../../../../../bus/nd/drivers/pmem
|-- force_raw
|-- modalias
|-- numa_node
|-- resource
|-- size
|-- subsystem -&gt; ../../../../../../bus/nd
|-- type
`-- uevent
</code></pre>
<p>LIBNDCTL: namespace enumeration example<br>Namespaces are indexed relative to their parent region, example below.<br>These indexes are mostly static from boot to boot, but subsystem makes<br>no guarantees in this regard.  For a static namespace identifier use its<br>‘uuid’ attribute.</p>
<p>static struct ndctl_namespace *get_namespace_by_id(struct ndctl_region *region,<br>                unsigned int id)<br>{<br>        struct ndctl_namespace *ndns;</p>
<pre><code>    ndctl_namespace_foreach(region, ndns)
            if (ndctl_namespace_get_id(ndns) == id)
                    return ndns;

    return NULL;
</code></pre>
<p>}</p>
<p>LIBNDCTL: namespace creation example<br>Idle namespaces are automatically created by the kernel if a given<br>region has enough available capacity to create a new namespace.<br>Namespace instantiation involves finding an idle namespace and<br>configuring it.  For the most part the setting of namespace attributes<br>can occur in any order, the only constraint is that ‘uuid’ must be set<br>before ‘size’.  This enables the kernel to track DPA allocations<br>internally with a static identifier.</p>
<p>static int configure_namespace(struct ndctl_region *region,<br>                struct ndctl_namespace *ndns,<br>                struct namespace_parameters *parameters)<br>{<br>        char devname[50];</p>
<pre><code>    snprintf(devname, sizeof(devname), &quot;namespace%d.%d&quot;,
                    ndctl_region_get_id(region), paramaters-&gt;id);

    ndctl_namespace_set_alt_name(ndns, devname);
    /* &#39;uuid&#39; must be set prior to setting size! */
    ndctl_namespace_set_uuid(ndns, paramaters-&gt;uuid);
    ndctl_namespace_set_size(ndns, paramaters-&gt;size);
    /* unlike pmem namespaces, blk namespaces have a sector size */
    if (parameters-&gt;lbasize)
            ndctl_namespace_set_sector_size(ndns, parameters-&gt;lbasize);
    ndctl_namespace_enable(ndns);
</code></pre>
<p>}</p>
<p>Why the Term “namespace”?</p>
<pre><code>1. Why not &quot;volume&quot; for instance?  &quot;volume&quot; ran the risk of confusing
ND (libnvdimm subsystem) to a volume manager like device-mapper.

2. The term originated to describe the sub-devices that can be created
within a NVME controller (see the nvme specification:
http://www.nvmexpress.org/specifications/), and NFIT namespaces are
meant to parallel the capabilities and configurability of
NVME-namespaces.
</code></pre>
<h2 id="LIBNVDIMM-LIBNDCTL-Block-Translation-Table-“btt”"><a href="#LIBNVDIMM-LIBNDCTL-Block-Translation-Table-“btt”" class="headerlink" title="LIBNVDIMM/LIBNDCTL: Block Translation Table “btt”"></a>LIBNVDIMM/LIBNDCTL: Block Translation Table “btt”</h2><p>A BTT (design document: <a target="_blank" rel="noopener" href="http://pmem.io/2014/09/23/btt.html">http://pmem.io/2014/09/23/btt.html</a>) is a stacked<br>block device driver that fronts either the whole block device or a<br>partition of a block device emitted by either a PMEM or BLK NAMESPACE.</p>
<p>LIBNVDIMM: btt layout<br>Every region will start out with at least one BTT device which is the<br>seed device.  To activate it set the “namespace”, “uuid”, and<br>“sector_size” attributes and then bind the device to the nd_pmem or<br>nd_blk driver depending on the region type.</p>
<pre><code>/sys/devices/platform/nfit_test.1/ndbus0/region0/btt0/
|-- namespace
|-- delete
|-- devtype
|-- modalias
|-- numa_node
|-- sector_size
|-- subsystem -&gt; ../../../../../bus/nd
|-- uevent
`-- uuid
</code></pre>
<p>LIBNDCTL: btt creation example<br>Similar to namespaces an idle BTT device is automatically created per<br>region.  Each time this “seed” btt device is configured and enabled a new<br>seed is created.  Creating a BTT configuration involves two steps of<br>finding and idle BTT and assigning it to consume a PMEM or BLK namespace.</p>
<pre><code>static struct ndctl_btt *get_idle_btt(struct ndctl_region *region)
&#123;
    struct ndctl_btt *btt;

    ndctl_btt_foreach(region, btt)
        if (!ndctl_btt_is_enabled(btt)
                &amp;&amp; !ndctl_btt_is_configured(btt))
            return btt;

    return NULL;
&#125;

static int configure_btt(struct ndctl_region *region,
        struct btt_parameters *parameters)
&#123;
    btt = get_idle_btt(region);

    ndctl_btt_set_uuid(btt, parameters-&gt;uuid);
    ndctl_btt_set_sector_size(btt, parameters-&gt;sector_size);
    ndctl_btt_set_namespace(btt, parameters-&gt;ndns);
    /* turn off raw mode device */
    ndctl_namespace_disable(parameters-&gt;ndns);
    /* turn on btt access */
    ndctl_btt_enable(btt);
&#125;
</code></pre>
<p>Once instantiated a new inactive btt seed device will appear underneath<br>the region.</p>
<p>Once a “namespace” is removed from a BTT that instance of the BTT device<br>will be deleted or otherwise reset to default values.  This deletion is<br>only at the device model level.  In order to destroy a BTT the “info<br>block” needs to be destroyed.  Note, that to destroy a BTT the media<br>needs to be written in raw mode.  By default, the kernel will autodetect<br>the presence of a BTT and disable raw mode.  This autodetect behavior<br>can be suppressed by enabling raw mode for the namespace via the<br>ndctl_namespace_set_raw_mode() API.</p>
<h2 id="Summary-LIBNDCTL-Diagram"><a href="#Summary-LIBNDCTL-Diagram" class="headerlink" title="Summary LIBNDCTL Diagram"></a>Summary LIBNDCTL Diagram</h2><p>For the given example above, here is the view of the objects as seen by the<br>LIBNDCTL API:<br>            +—+<br>            |CTX|    +———+   +————–+  +—————+<br>            +-+-+  +-&gt; REGION0 +—&gt; NAMESPACE0.0 +–&gt; PMEM8 “pm0.0” |<br>              |    | +———+   +————–+  +—————+<br>+——-+     |    | +———+   +————–+  +—————+<br>| DIMM0 &lt;-+   |    +-&gt; REGION1 +—&gt; NAMESPACE1.0 +–&gt; PMEM6 “pm1.0” |<br>+——-+ |   |    | +———+   +————–+  +—————+<br>| DIMM1 &lt;-+ +-v–+ | +———+   +————–+  +—————+<br>+——-+ +-+BUS0+—&gt; REGION2 +-+-&gt; NAMESPACE2.0 +–&gt; ND6  “blk2.0” |<br>| DIMM2 &lt;-+ +—-+ | +———+ | +————–+  +———————-+<br>+——-+ |        |             +-&gt; NAMESPACE2.1 +–&gt; ND5  “blk2.1” | BTT2 |<br>| DIMM3 &lt;-+        |               +————–+  +———————-+<br>+——-+          | +———+   +————–+  +—————+<br>                   +-&gt; REGION3 +-+-&gt; NAMESPACE3.0 +–&gt; ND4  “blk3.0” |<br>                   | +———+ | +————–+  +———————-+<br>                   |             +-&gt; NAMESPACE3.1 +–&gt; ND3  “blk3.1” | BTT1 |<br>                   |               +————–+  +———————-+<br>                   | +———+   +————–+  +—————+<br>                   +-&gt; REGION4 +—&gt; NAMESPACE4.0 +–&gt; ND2  “blk4.0” |<br>                   | +———+   +————–+  +—————+<br>                   | +———+   +————–+  +———————-+<br>                   +-&gt; REGION5 +—&gt; NAMESPACE5.0 +–&gt; ND1  “blk5.0” | BTT0 |<br>                     +———+   +————–+  +—————+——+</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_nvdimm/" title="Kernel-4.18.0-80.el8_nvdi" target="_blank" rel="external">http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_nvdimm/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/02/19/Kernel-4.18.0-80.el8_ntfs/" title="Kernel-4.18.0-80.el8_ntfs"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/02/19/Kernel-4.18.0-80.el8_nvidia,tegra20-pcie/" title="Kernel-4.18.0-80.el8_nvidia,tegra20-pcie"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>