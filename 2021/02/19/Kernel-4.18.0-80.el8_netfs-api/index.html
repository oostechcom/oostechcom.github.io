<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-4.18.0-80.el8_netfs-api | oosTech.com</title>
  <meta name="description" content="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;         FS-CACHE NETWORK FILESYSTEM API         &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  There’s an API by which a network filesystem can make use of the FS-Cachefacili">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-4.18.0-80.el8_netfs-api">
<meta property="og:url" content="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_netfs-api/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;         FS-CACHE NETWORK FILESYSTEM API         &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  There’s an API by which a network filesystem can make use of the FS-Cachefacili">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-18T16:00:00.000Z">
<meta property="article:modified_time" content="2021-02-18T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_netfs-api/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_mpc5200/" class="title">Kernel-3.10.0-957.el7_mpc5200</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_6pack/" class="title">Kernel-3.10.0-957.el7_6pack</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#PAGE-READ"><span class="toc-number">1.</span> <span class="toc-text">PAGE READ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PAGE-ALLOCATE"><span class="toc-number">2.</span> <span class="toc-text">PAGE ALLOCATE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PAGE-WRITE"><span class="toc-number">3.</span> <span class="toc-text">PAGE WRITE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MULTIPLE-PAGE-READ"><span class="toc-number">4.</span> <span class="toc-text">MULTIPLE PAGE READ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CANCELLATION-OF-UNREAD-PAGES"><span class="toc-number">5.</span> <span class="toc-text">CANCELLATION OF UNREAD PAGES</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BULK-INODE-PAGE-UNCACHE"><span class="toc-number">6.</span> <span class="toc-text">BULK INODE PAGE UNCACHE</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-4.18.0-80.el8_netfs-api" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-4.18.0-80.el8_netfs-api
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/02/19/Kernel-4.18.0-80.el8_netfs-api/" class="article-date">
	 published: <time datetime="2021-02-18T16:00:00.000Z" itemprop="datePublished">2021-02-19</time>
	</a>
</span>

        
	<a href="/2021/02/19/Kernel-4.18.0-80.el8_netfs-api/" class="article-date">
	   updated: <time datetime="2021-02-18T16:00:00.000Z" itemprop="dateUpdated">2021-02-19</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/02/19/Kernel-4.18.0-80.el8_netfs-api/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <pre><code>        ===============================
        FS-CACHE NETWORK FILESYSTEM API
        ===============================
</code></pre>
<p>There’s an API by which a network filesystem can make use of the FS-Cache<br>facilities.  This is based around a number of principles:</p>
<p> (1) Caches can store a number of different object types.  There are two main<br>     object types: indices and files.  The first is a special type used by<br>     FS-Cache to make finding objects faster and to make retiring of groups of<br>     objects easier.</p>
<p> (2) Every index, file or other object is represented by a cookie.  This cookie<br>     may or may not have anything associated with it, but the netfs doesn’t<br>     need to care.</p>
<p> (3) Barring the top-level index (one entry per cached netfs), the index<br>     hierarchy for each netfs is structured according the whim of the netfs.</p>
<p>This API is declared in &lt;linux/fscache.h&gt;.</p>
<p>This document contains the following sections:</p>
<pre><code> (1) Network filesystem definition
 (2) Index definition
 (3) Object definition
 (4) Network filesystem (un)registration
 (5) Cache tag lookup
 (6) Index registration
 (7) Data file registration
 (8) Miscellaneous object registration
  (9) Setting the data file size
(10) Page alloc/read/write
(11) Page uncaching
(12) Index and data file consistency
(13) Cookie enablement
(14) Miscellaneous cookie operations
(15) Cookie unregistration
(16) Index invalidation
(17) Data file invalidation
(18) FS-Cache specific page flags.
</code></pre>
<p>=============================<br>NETWORK FILESYSTEM DEFINITION<br>=============================</p>
<p>FS-Cache needs a description of the network filesystem.  This is specified<br>using a record of the following structure:</p>
<pre><code>struct fscache_netfs &#123;
    uint32_t            version;
    const char            *name;
    struct fscache_cookie        *primary_index;
    ...
&#125;;
</code></pre>
<p>This first two fields should be filled in before registration, and the third<br>will be filled in by the registration function; any other fields should just be<br>ignored and are for internal use only.</p>
<p>The fields are:</p>
<p> (1) The name of the netfs (used as the key in the toplevel index).</p>
<p> (2) The version of the netfs (if the name matches but the version doesn’t, the<br>     entire in-cache hierarchy for this netfs will be scrapped and begun<br>     afresh).</p>
<p> (3) The cookie representing the primary index will be allocated according to<br>     another parameter passed into the registration function.</p>
<p>For example, kAFS (linux/fs/afs/) uses the following definitions to describe<br>itself:</p>
<pre><code>struct fscache_netfs afs_cache_netfs = &#123;
    .version    = 0,
    .name        = &quot;afs&quot;,
&#125;;
</code></pre>
<p>================<br>INDEX DEFINITION<br>================</p>
<p>Indices are used for two purposes:</p>
<p> (1) To aid the finding of a file based on a series of keys (such as AFS’s<br>     “cell”, “volume ID”, “vnode ID”).</p>
<p> (2) To make it easier to discard a subset of all the files cached based around<br>     a particular key - for instance to mirror the removal of an AFS volume.</p>
<p>However, since it’s unlikely that any two netfs’s are going to want to define<br>their index hierarchies in quite the same way, FS-Cache tries to impose as few<br>restraints as possible on how an index is structured and where it is placed in<br>the tree.  The netfs can even mix indices and data files at the same level, but<br>it’s not recommended.</p>
<p>Each index entry consists of a key of indeterminate length plus some auxiliary<br>data, also of indeterminate length.</p>
<p>There are some limits on indices:</p>
<p> (1) Any index containing non-index objects should be restricted to a single<br>     cache.  Any such objects created within an index will be created in the<br>     first cache only.  The cache in which an index is created can be<br>     controlled by cache tags (see below).</p>
<p> (2) The entry data must be atomically journallable, so it is limited to about<br>     400 bytes at present.  At least 400 bytes will be available.</p>
<p> (3) The depth of the index tree should be judged with care as the search<br>     function is recursive.  Too many layers will run the kernel out of stack.</p>
<p>=================<br>OBJECT DEFINITION<br>=================</p>
<p>To define an object, a structure of the following type should be filled out:</p>
<pre><code>struct fscache_cookie_def
&#123;
    uint8_t name[16];
    uint8_t type;

    struct fscache_cache_tag *(*select_cache)(
        const void *parent_netfs_data,
        const void *cookie_netfs_data);

    enum fscache_checkaux (*check_aux)(void *cookie_netfs_data,
                       const void *data,
                       uint16_t datalen,
                       loff_t object_size);

    void (*get_context)(void *cookie_netfs_data, void *context);

    void (*put_context)(void *cookie_netfs_data, void *context);

    void (*mark_pages_cached)(void *cookie_netfs_data,
                  struct address_space *mapping,
                  struct pagevec *cached_pvec);
&#125;;
</code></pre>
<p>This has the following fields:</p>
<p> (1) The type of the object [mandatory].</p>
<pre><code> This is one of the following values:

(*) FSCACHE_COOKIE_TYPE_INDEX

    This defines an index, which is a special FS-Cache type.

(*) FSCACHE_COOKIE_TYPE_DATAFILE

    This defines an ordinary data file.

(*) Any other value between 2 and 255

    This defines an extraordinary object such as an XATTR.
</code></pre>
<p> (2) The name of the object type (NUL terminated unless all 16 chars are used)<br>     [optional].</p>
<p> (3) A function to select the cache in which to store an index [optional].</p>
<pre><code> This function is invoked when an index needs to be instantiated in a cache
 during the instantiation of a non-index object.  Only the immediate index
 parent for the non-index object will be queried.  Any indices above that
 in the hierarchy may be stored in multiple caches.  This function does not
 need to be supplied for any non-index object or any index that will only
 have index children.

 If this function is not supplied or if it returns NULL then the first
 cache in the parent&#39;s list will be chosen, or failing that, the first
 cache in the master list.
</code></pre>
<p> (4) A function to check the auxiliary data [optional].</p>
<pre><code> This function will be called to check that a match found in the cache for
 this object is valid.  For instance with AFS it could check the auxiliary
 data against the data version number returned by the server to determine
 whether the index entry in a cache is still valid.

 If this function is absent, it will be assumed that matching objects in a
 cache are always valid.

 The function is also passed the cache&#39;s idea of the object size and may
 use this to manage coherency also.

 If present, the function should return one of the following values:

(*) FSCACHE_CHECKAUX_OKAY        - the entry is okay as is
(*) FSCACHE_CHECKAUX_NEEDS_UPDATE    - the entry requires update
(*) FSCACHE_CHECKAUX_OBSOLETE        - the entry should be deleted

 This function can also be used to extract data from the auxiliary data in
 the cache and copy it into the netfs&#39;s structures.
</code></pre>
<p> (5) A pair of functions to manage contexts for the completion callback<br>     [optional].</p>
<pre><code> The cache read/write functions are passed a context which is then passed
 to the I/O completion callback function.  To ensure this context remains
 valid until after the I/O completion is called, two functions may be
 provided: one to get an extra reference on the context, and one to drop a
 reference to it.

 If the context is not used or is a type of object that won&#39;t go out of
 scope, then these functions are not required.  These functions are not
 required for indices as indices may not contain data.  These functions may
 be called in interrupt context and so may not sleep.
</code></pre>
<p> (6) A function to mark a page as retaining cache metadata [optional].</p>
<pre><code> This is called by the cache to indicate that it is retaining in-memory
 information for this page and that the netfs should uncache the page when
 it has finished.  This does not indicate whether there&#39;s data on the disk
 or not.  Note that several pages at once may be presented for marking.

 The PG_fscache bit is set on the pages before this function would be
 called, so the function need not be provided if this is sufficient.

 This function is not required for indices as they&#39;re not permitted data.
</code></pre>
<p> (7) A function to unmark all the pages retaining cache metadata [mandatory].</p>
<pre><code> This is called by FS-Cache to indicate that a backing store is being
 unbound from a cookie and that all the marks on the pages should be
 cleared to prevent confusion.  Note that the cache will have torn down all
 its tracking information so that the pages don&#39;t need to be explicitly
 uncached.

 This function is not required for indices as they&#39;re not permitted data.
</code></pre>
<p>===================================<br>NETWORK FILESYSTEM (UN)REGISTRATION<br>===================================</p>
<p>The first step is to declare the network filesystem to the cache.  This also<br>involves specifying the layout of the primary index (for AFS, this would be the<br>“cell” level).</p>
<p>The registration function is:</p>
<pre><code>int fscache_register_netfs(struct fscache_netfs *netfs);
</code></pre>
<p>It just takes a pointer to the netfs definition.  It returns 0 or an error as<br>appropriate.</p>
<p>For kAFS, registration is done as follows:</p>
<pre><code>ret = fscache_register_netfs(&amp;afs_cache_netfs);
</code></pre>
<p>The last step is, of course, unregistration:</p>
<pre><code>void fscache_unregister_netfs(struct fscache_netfs *netfs);
</code></pre>
<p>================<br>CACHE TAG LOOKUP<br>================</p>
<p>FS-Cache permits the use of more than one cache.  To permit particular index<br>subtrees to be bound to particular caches, the second step is to look up cache<br>representation tags.  This step is optional; it can be left entirely up to<br>FS-Cache as to which cache should be used.  The problem with doing that is that<br>FS-Cache will always pick the first cache that was registered.</p>
<p>To get the representation for a named tag:</p>
<pre><code>struct fscache_cache_tag *fscache_lookup_cache_tag(const char *name);
</code></pre>
<p>This takes a text string as the name and returns a representation of a tag.  It<br>will never return an error.  It may return a dummy tag, however, if it runs out<br>of memory; this will inhibit caching with this tag.</p>
<p>Any representation so obtained must be released by passing it to this function:</p>
<pre><code>void fscache_release_cache_tag(struct fscache_cache_tag *tag);
</code></pre>
<p>The tag will be retrieved by FS-Cache when it calls the object definition<br>operation select_cache().</p>
<p>==================<br>INDEX REGISTRATION<br>==================</p>
<p>The third step is to inform FS-Cache about part of an index hierarchy that can<br>be used to locate files.  This is done by requesting a cookie for each index in<br>the path to the file:</p>
<pre><code>struct fscache_cookie *
fscache_acquire_cookie(struct fscache_cookie *parent,
               const struct fscache_object_def *def,
               const void *index_key,
               size_t index_key_len,
               const void *aux_data,
               size_t aux_data_len,
               void *netfs_data,
               loff_t object_size,
               bool enable);
</code></pre>
<p>This function creates an index entry in the index represented by parent,<br>filling in the index entry by calling the operations pointed to by def.</p>
<p>A unique key that represents the object within the parent must be pointed to by<br>index_key and is of length index_key_len.</p>
<p>An optional blob of auxiliary data that is to be stored within the cache can be<br>pointed to with aux_data and should be of length aux_data_len.  This would<br>typically be used for storing coherency data.</p>
<p>The netfs may pass an arbitrary value in netfs_data and this will be presented<br>to it in the event of any calling back.  This may also be used in tracing or<br>logging of messages.</p>
<p>The cache tracks the size of the data attached to an object and this set to be<br>object_size.  For indices, this should be 0.  This value will be passed to the<br>-&gt;check_aux() callback.</p>
<p>Note that this function never returns an error - all errors are handled<br>internally.  It may, however, return NULL to indicate no cookie.  It is quite<br>acceptable to pass this token back to this function as the parent to another<br>acquisition (or even to the relinquish cookie, read page and write page<br>functions - see below).</p>
<p>Note also that no indices are actually created in a cache until a non-index<br>object needs to be created somewhere down the hierarchy.  Furthermore, an index<br>may be created in several different caches independently at different times.<br>This is all handled transparently, and the netfs doesn’t see any of it.</p>
<p>A cookie will be created in the disabled state if enabled is false.  A cookie<br>must be enabled to do anything with it.  A disabled cookie can be enabled by<br>calling fscache_enable_cookie() (see below).</p>
<p>For example, with AFS, a cell would be added to the primary index.  This index<br>entry would have a dependent inode containing volume mappings within this cell:</p>
<pre><code>cell-&gt;cache =
    fscache_acquire_cookie(afs_cache_netfs.primary_index,
                   &amp;afs_cell_cache_index_def,
                   cell-&gt;name, strlen(cell-&gt;name),
                   NULL, 0,
                   cell, 0, true);
</code></pre>
<p>And then a particular volume could be added to that index by ID, creating<br>another index for vnodes (AFS inode equivalents):</p>
<pre><code>volume-&gt;cache =
    fscache_acquire_cookie(volume-&gt;cell-&gt;cache,
                   &amp;afs_volume_cache_index_def,
                   &amp;volume-&gt;vid, sizeof(volume-&gt;vid),
                   NULL, 0,
                   volume, 0, true);
</code></pre>
<p>======================<br>DATA FILE REGISTRATION<br>======================</p>
<p>The fourth step is to request a data file be created in the cache.  This is<br>identical to index cookie acquisition.  The only difference is that the type in<br>the object definition should be something other than index type.</p>
<pre><code>vnode-&gt;cache =
    fscache_acquire_cookie(volume-&gt;cache,
                   &amp;afs_vnode_cache_object_def,
                   &amp;key, sizeof(key),
                   &amp;aux, sizeof(aux),
                   vnode, vnode-&gt;status.size, true);
</code></pre>
<p>=================================<br>MISCELLANEOUS OBJECT REGISTRATION<br>=================================</p>
<p>An optional step is to request an object of miscellaneous type be created in<br>the cache.  This is almost identical to index cookie acquisition.  The only<br>difference is that the type in the object definition should be something other<br>than index type.  Whilst the parent object could be an index, it’s more likely<br>it would be some other type of object such as a data file.</p>
<pre><code>xattr-&gt;cache =
    fscache_acquire_cookie(vnode-&gt;cache,
                   &amp;afs_xattr_cache_object_def,
                   &amp;xattr-&gt;name, strlen(xattr-&gt;name),
                   NULL, 0,
                   xattr, strlen(xattr-&gt;val), true);
</code></pre>
<p>Miscellaneous objects might be used to store extended attributes or directory<br>entries for example.</p>
<p>==========================<br>SETTING THE DATA FILE SIZE<br>==========================</p>
<p>The fifth step is to set the physical attributes of the file, such as its size.<br>This doesn’t automatically reserve any space in the cache, but permits the<br>cache to adjust its metadata for data tracking appropriately:</p>
<pre><code>int fscache_attr_changed(struct fscache_cookie *cookie);
</code></pre>
<p>The cache will return -ENOBUFS if there is no backing cache or if there is no<br>space to allocate any extra metadata required in the cache.</p>
<p>Note that attempts to read or write data pages in the cache over this size may<br>be rebuffed with -ENOBUFS.</p>
<p>This operation schedules an attribute adjustment to happen asynchronously at<br>some point in the future, and as such, it may happen after the function returns<br>to the caller.  The attribute adjustment excludes read and write operations.</p>
<p>=====================<br>PAGE ALLOC/READ/WRITE<br>=====================</p>
<p>And the sixth step is to store and retrieve pages in the cache.  There are<br>three functions that are used to do this.</p>
<p>Note:</p>
<p> (1) A page should not be re-read or re-allocated without uncaching it first.</p>
<p> (2) A read or allocated page must be uncached when the netfs page is released<br>     from the pagecache.</p>
<p> (3) A page should only be written to the cache if previous read or allocated.</p>
<p>This permits the cache to maintain its page tracking in proper order.</p>
<h2 id="PAGE-READ"><a href="#PAGE-READ" class="headerlink" title="PAGE READ"></a>PAGE READ</h2><p>Firstly, the netfs should ask FS-Cache to examine the caches and read the<br>contents cached for a particular page of a particular file if present, or else<br>allocate space to store the contents if not:</p>
<pre><code>typedef
void (*fscache_rw_complete_t)(struct page *page,
                  void *context,
                  int error);

int fscache_read_or_alloc_page(struct fscache_cookie *cookie,
                   struct page *page,
                   fscache_rw_complete_t end_io_func,
                   void *context,
                   gfp_t gfp);
</code></pre>
<p>The cookie argument must specify a cookie for an object that isn’t an index,<br>the page specified will have the data loaded into it (and is also used to<br>specify the page number), and the gfp argument is used to control how any<br>memory allocations made are satisfied.</p>
<p>If the cookie indicates the inode is not cached:</p>
<p> (1) The function will return -ENOBUFS.</p>
<p>Else if there’s a copy of the page resident in the cache:</p>
<p> (1) The mark_pages_cached() cookie operation will be called on that page.</p>
<p> (2) The function will submit a request to read the data from the cache’s<br>     backing device directly into the page specified.</p>
<p> (3) The function will return 0.</p>
<p> (4) When the read is complete, end_io_func() will be invoked with:</p>
<pre><code> (*) The netfs data supplied when the cookie was created.

 (*) The page descriptor.

 (*) The context argument passed to the above function.  This will be
     maintained with the get_context/put_context functions mentioned above.

 (*) An argument that&#39;s 0 on success or negative for an error code.

 If an error occurs, it should be assumed that the page contains no usable
 data.  fscache_readpages_cancel() may need to be called.

 end_io_func() will be called in process context if the read is results in
 an error, but it might be called in interrupt context if the read is
 successful.
</code></pre>
<p>Otherwise, if there’s not a copy available in cache, but the cache may be able<br>to store the page:</p>
<p> (1) The mark_pages_cached() cookie operation will be called on that page.</p>
<p> (2) A block may be reserved in the cache and attached to the object at the<br>     appropriate place.</p>
<p> (3) The function will return -ENODATA.</p>
<p>This function may also return -ENOMEM or -EINTR, in which case it won’t have<br>read any data from the cache.</p>
<h2 id="PAGE-ALLOCATE"><a href="#PAGE-ALLOCATE" class="headerlink" title="PAGE ALLOCATE"></a>PAGE ALLOCATE</h2><p>Alternatively, if there’s not expected to be any data in the cache for a page<br>because the file has been extended, a block can simply be allocated instead:</p>
<pre><code>int fscache_alloc_page(struct fscache_cookie *cookie,
               struct page *page,
               gfp_t gfp);
</code></pre>
<p>This is similar to the fscache_read_or_alloc_page() function, except that it<br>never reads from the cache.  It will return 0 if a block has been allocated,<br>rather than -ENODATA as the other would.  One or the other must be performed<br>before writing to the cache.</p>
<p>The mark_pages_cached() cookie operation will be called on the page if<br>successful.</p>
<h2 id="PAGE-WRITE"><a href="#PAGE-WRITE" class="headerlink" title="PAGE WRITE"></a>PAGE WRITE</h2><p>Secondly, if the netfs changes the contents of the page (either due to an<br>initial download or if a user performs a write), then the page should be<br>written back to the cache:</p>
<pre><code>int fscache_write_page(struct fscache_cookie *cookie,
               struct page *page,
               loff_t object_size,
               gfp_t gfp);
</code></pre>
<p>The cookie argument must specify a data file cookie, the page specified should<br>contain the data to be written (and is also used to specify the page number),<br>object_size is the revised size of the object and the gfp argument is used to<br>control how any memory allocations made are satisfied.</p>
<p>The page must have first been read or allocated successfully and must not have<br>been uncached before writing is performed.</p>
<p>If the cookie indicates the inode is not cached then:</p>
<p> (1) The function will return -ENOBUFS.</p>
<p>Else if space can be allocated in the cache to hold this page:</p>
<p> (1) PG_fscache_write will be set on the page.</p>
<p> (2) The function will submit a request to write the data to cache’s backing<br>     device directly from the page specified.</p>
<p> (3) The function will return 0.</p>
<p> (4) When the write is complete PG_fscache_write is cleared on the page and<br>     anyone waiting for that bit will be woken up.</p>
<p>Else if there’s no space available in the cache, -ENOBUFS will be returned.  It<br>is also possible for the PG_fscache_write bit to be cleared when no write took<br>place if unforeseen circumstances arose (such as a disk error).</p>
<p>Writing takes place asynchronously.</p>
<h2 id="MULTIPLE-PAGE-READ"><a href="#MULTIPLE-PAGE-READ" class="headerlink" title="MULTIPLE PAGE READ"></a>MULTIPLE PAGE READ</h2><p>A facility is provided to read several pages at once, as requested by the<br>readpages() address space operation:</p>
<pre><code>int fscache_read_or_alloc_pages(struct fscache_cookie *cookie,
                struct address_space *mapping,
                struct list_head *pages,
                int *nr_pages,
                fscache_rw_complete_t end_io_func,
                void *context,
                gfp_t gfp);
</code></pre>
<p>This works in a similar way to fscache_read_or_alloc_page(), except:</p>
<p> (1) Any page it can retrieve data for is removed from pages and nr_pages and<br>     dispatched for reading to the disk.  Reads of adjacent pages on disk may<br>     be merged for greater efficiency.</p>
<p> (2) The mark_pages_cached() cookie operation will be called on several pages<br>     at once if they’re being read or allocated.</p>
<p> (3) If there was an general error, then that error will be returned.</p>
<pre><code> Else if some pages couldn&#39;t be allocated or read, then -ENOBUFS will be
 returned.

 Else if some pages couldn&#39;t be read but were allocated, then -ENODATA will
 be returned.

 Otherwise, if all pages had reads dispatched, then 0 will be returned, the
 list will be empty and *nr_pages will be 0.
</code></pre>
<p> (4) end_io_func will be called once for each page being read as the reads<br>     complete.  It will be called in process context if error != 0, but it may<br>     be called in interrupt context if there is no error.</p>
<p>Note that a return of -ENODATA, -ENOBUFS or any other error does not preclude<br>some of the pages being read and some being allocated.  Those pages will have<br>been marked appropriately and will need uncaching.</p>
<h2 id="CANCELLATION-OF-UNREAD-PAGES"><a href="#CANCELLATION-OF-UNREAD-PAGES" class="headerlink" title="CANCELLATION OF UNREAD PAGES"></a>CANCELLATION OF UNREAD PAGES</h2><p>If one or more pages are passed to fscache_read_or_alloc_pages() but not then<br>read from the cache and also not read from the underlying filesystem then<br>those pages will need to have any marks and reservations removed.  This can be<br>done by calling:</p>
<pre><code>void fscache_readpages_cancel(struct fscache_cookie *cookie,
                  struct list_head *pages);
</code></pre>
<p>prior to returning to the caller.  The cookie argument should be as passed to<br>fscache_read_or_alloc_pages().  Every page in the pages list will be examined<br>and any that have PG_fscache set will be uncached.</p>
<p>==============<br>PAGE UNCACHING<br>==============</p>
<p>To uncache a page, this function should be called:</p>
<pre><code>void fscache_uncache_page(struct fscache_cookie *cookie,
              struct page *page);
</code></pre>
<p>This function permits the cache to release any in-memory representation it<br>might be holding for this netfs page.  This function must be called once for<br>each page on which the read or write page functions above have been called to<br>make sure the cache’s in-memory tracking information gets torn down.</p>
<p>Note that pages can’t be explicitly deleted from the a data file.  The whole<br>data file must be retired (see the relinquish cookie function below).</p>
<p>Furthermore, note that this does not cancel the asynchronous read or write<br>operation started by the read/alloc and write functions, so the page<br>invalidation functions must use:</p>
<pre><code>bool fscache_check_page_write(struct fscache_cookie *cookie,
                  struct page *page);
</code></pre>
<p>to see if a page is being written to the cache, and:</p>
<pre><code>void fscache_wait_on_page_write(struct fscache_cookie *cookie,
                struct page *page);
</code></pre>
<p>to wait for it to finish if it is.</p>
<p>When releasepage() is being implemented, a special FS-Cache function exists to<br>manage the heuristics of coping with vmscan trying to eject pages, which may<br>conflict with the cache trying to write pages to the cache (which may itself<br>need to allocate memory):</p>
<pre><code>bool fscache_maybe_release_page(struct fscache_cookie *cookie,
                struct page *page,
                gfp_t gfp);
</code></pre>
<p>This takes the netfs cookie, and the page and gfp arguments as supplied to<br>releasepage().  It will return false if the page cannot be released yet for<br>some reason and if it returns true, the page has been uncached and can now be<br>released.</p>
<p>To make a page available for release, this function may wait for an outstanding<br>storage request to complete, or it may attempt to cancel the storage request -<br>in which case the page will not be stored in the cache this time.</p>
<h2 id="BULK-INODE-PAGE-UNCACHE"><a href="#BULK-INODE-PAGE-UNCACHE" class="headerlink" title="BULK INODE PAGE UNCACHE"></a>BULK INODE PAGE UNCACHE</h2><p>A convenience routine is provided to perform an uncache on all the pages<br>attached to an inode.  This assumes that the pages on the inode correspond on a<br>1:1 basis with the pages in the cache.</p>
<pre><code>void fscache_uncache_all_inode_pages(struct fscache_cookie *cookie,
                     struct inode *inode);
</code></pre>
<p>This takes the netfs cookie that the pages were cached with and the inode that<br>the pages are attached to.  This function will wait for pages to finish being<br>written to the cache and for the cache to finish with the page generally.  No<br>error is returned.</p>
<p>===============================<br>INDEX AND DATA FILE CONSISTENCY<br>===============================</p>
<p>To find out whether auxiliary data for an object is up to data within the<br>cache, the following function can be called:</p>
<pre><code>int fscache_check_consistency(struct fscache_cookie *cookie,
                  const void *aux_data);
</code></pre>
<p>This will call back to the netfs to check whether the auxiliary data associated<br>with a cookie is correct; if aux_data is non-NULL, it will update the auxiliary<br>data buffer first.  It returns 0 if it is and -ESTALE if it isn’t; it may also<br>return -ENOMEM and -ERESTARTSYS.</p>
<p>To request an update of the index data for an index or other object, the<br>following function should be called:</p>
<pre><code>void fscache_update_cookie(struct fscache_cookie *cookie,
               const void *aux_data);
</code></pre>
<p>This function will update the cookie’s auxiliary data buffer from aux_data if<br>that is non-NULL and then schedule this to be stored on disk.  The update<br>method in the parent index definition will be called to transfer the data.</p>
<p>Note that partial updates may happen automatically at other times, such as when<br>data blocks are added to a data file object.</p>
<p>=================<br>COOKIE ENABLEMENT<br>=================</p>
<p>Cookies exist in one of two states: enabled and disabled.  If a cookie is<br>disabled, it ignores all attempts to acquire child cookies; check, update or<br>invalidate its state; allocate, read or write backing pages - though it is<br>still possible to uncache pages and relinquish the cookie.</p>
<p>The initial enablement state is set by fscache_acquire_cookie(), but the cookie<br>can be enabled or disabled later.  To disable a cookie, call:</p>
<pre><code>void fscache_disable_cookie(struct fscache_cookie *cookie,
                const void *aux_data,
                    bool invalidate);
</code></pre>
<p>If the cookie is not already disabled, this locks the cookie against other<br>enable and disable ops, marks the cookie as being disabled, discards or<br>invalidates any backing objects and waits for cessation of activity on any<br>associated object before unlocking the cookie.</p>
<p>All possible failures are handled internally.  The caller should consider<br>calling fscache_uncache_all_inode_pages() afterwards to make sure all page<br>markings are cleared up.</p>
<p>Cookies can be enabled or reenabled with:</p>
<pre><code>    void fscache_enable_cookie(struct fscache_cookie *cookie,
               const void *aux_data,
               loff_t object_size,
                   bool (*can_enable)(void *data),
                   void *data)
</code></pre>
<p>If the cookie is not already enabled, this locks the cookie against other<br>enable and disable ops, invokes can_enable() and, if the cookie is not an index<br>cookie, will begin the procedure of acquiring backing objects.</p>
<p>The optional can_enable() function is passed the data argument and returns a<br>ruling as to whether or not enablement should actually be permitted to begin.</p>
<p>All possible failures are handled internally.  The cookie will only be marked<br>as enabled if provisional backing objects are allocated.</p>
<p>The object’s data size is updated from object_size and is passed to the<br>-&gt;check_aux() function.</p>
<p>In both cases, the cookie’s auxiliary data buffer is updated from aux_data if<br>that is non-NULL inside the enablement lock before proceeding.</p>
<p>===============================<br>MISCELLANEOUS COOKIE OPERATIONS<br>===============================</p>
<p>There are a number of operations that can be used to control cookies:</p>
<p> (*) Cookie pinning:</p>
<pre><code>int fscache_pin_cookie(struct fscache_cookie *cookie);
void fscache_unpin_cookie(struct fscache_cookie *cookie);

 These operations permit data cookies to be pinned into the cache and to
 have the pinning removed.  They are not permitted on index cookies.

 The pinning function will return 0 if successful, -ENOBUFS in the cookie
 isn&#39;t backed by a cache, -EOPNOTSUPP if the cache doesn&#39;t support pinning,
 -ENOSPC if there isn&#39;t enough space to honour the operation, -ENOMEM or
 -EIO if there&#39;s any other problem.
</code></pre>
<p> (*) Data space reservation:</p>
<pre><code>int fscache_reserve_space(struct fscache_cookie *cookie, loff_t size);

 This permits a netfs to request cache space be reserved to store up to the
 given amount of a file.  It is permitted to ask for more than the current
 size of the file to allow for future file expansion.

 If size is given as zero then the reservation will be cancelled.

 The function will return 0 if successful, -ENOBUFS in the cookie isn&#39;t
 backed by a cache, -EOPNOTSUPP if the cache doesn&#39;t support reservations,
 -ENOSPC if there isn&#39;t enough space to honour the operation, -ENOMEM or
 -EIO if there&#39;s any other problem.

 Note that this doesn&#39;t pin an object in a cache; it can still be culled to
 make space if it&#39;s not in use.
</code></pre>
<p>=====================<br>COOKIE UNREGISTRATION<br>=====================</p>
<p>To get rid of a cookie, this function should be called.</p>
<pre><code>void fscache_relinquish_cookie(struct fscache_cookie *cookie,
                   const void *aux_data,
                   bool retire);
</code></pre>
<p>If retire is non-zero, then the object will be marked for recycling, and all<br>copies of it will be removed from all active caches in which it is present.<br>Not only that but all child objects will also be retired.</p>
<p>If retire is zero, then the object may be available again when next the<br>acquisition function is called.  Retirement here will overrule the pinning on a<br>cookie.</p>
<p>The cookie’s auxiliary data will be updated from aux_data if that is non-NULL<br>so that the cache can lazily update it on disk.</p>
<p>One very important note - relinquish must NOT be called for a cookie unless all<br>the cookies for “child” indices, objects and pages have been relinquished<br>first.</p>
<p>==================<br>INDEX INVALIDATION<br>==================</p>
<p>There is no direct way to invalidate an index subtree.  To do this, the caller<br>should relinquish and retire the cookie they have, and then acquire a new one.</p>
<p>======================<br>DATA FILE INVALIDATION<br>======================</p>
<p>Sometimes it will be necessary to invalidate an object that contains data.<br>Typically this will be necessary when the server tells the netfs of a foreign<br>change - at which point the netfs has to throw away all the state it had for an<br>inode and reload from the server.</p>
<p>To indicate that a cache object should be invalidated, the following function<br>can be called:</p>
<pre><code>void fscache_invalidate(struct fscache_cookie *cookie);
</code></pre>
<p>This can be called with spinlocks held as it defers the work to a thread pool.<br>All extant storage, retrieval and attribute change ops at this point are<br>cancelled and discarded.  Some future operations will be rejected until the<br>cache has had a chance to insert a barrier in the operations queue.  After<br>that, operations will be queued again behind the invalidation operation.</p>
<p>The invalidation operation will perform an attribute change operation and an<br>auxiliary data update operation as it is very likely these will have changed.</p>
<p>Using the following function, the netfs can wait for the invalidation operation<br>to have reached a point at which it can start submitting ordinary operations<br>once again:</p>
<pre><code>void fscache_wait_on_invalidate(struct fscache_cookie *cookie);
</code></pre>
<p>===========================<br>FS-CACHE SPECIFIC PAGE FLAG<br>===========================</p>
<p>FS-Cache makes use of a page flag, PG_private_2, for its own purpose.  This is<br>given the alternative name PG_fscache.</p>
<p>PG_fscache is used to indicate that the page is known by the cache, and that<br>the cache must be informed if the page is going to go away.  It’s an indication<br>to the netfs that the cache has an interest in this page, where an interest may<br>be a pointer to it, resources allocated or reserved for it, or I/O in progress<br>upon it.</p>
<p>The netfs can use this information in methods such as releasepage() to<br>determine whether it needs to uncache a page or update it.</p>
<p>Furthermore, if this bit is set, releasepage() and invalidatepage() operations<br>will be called on a page to get rid of it, even if PG_private is not set.  This<br>allows caching to attempted on a page before read_cache_pages() to be called<br>after fscache_read_or_alloc_pages() as the former will try and release pages it<br>was given under certain circumstances.</p>
<p>This bit does not overlap with such as PG_private.  This means that FS-Cache<br>can be used with a filesystem that uses the block buffering code.</p>
<p>There are a number of operations defined on this flag:</p>
<pre><code>int PageFsCache(struct page *page);
void SetPageFsCache(struct page *page)
void ClearPageFsCache(struct page *page)
int TestSetPageFsCache(struct page *page)
int TestClearPageFsCache(struct page *page)
</code></pre>
<p>These functions are bit test, bit set, bit clear, bit test and set and bit<br>test and clear operations on PG_fscache.</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_netfs-api/" title="Kernel-4.18.0-80.el8_netfs-api" target="_blank" rel="external">http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_netfs-api/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/02/19/Kernel-4.18.0-80.el8_makefiles/" title="Kernel-4.18.0-80.el8_makefiles"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/02/19/Kernel-4.18.0-80.el8_packet_mmap/" title="Kernel-4.18.0-80.el8_packet_mmap"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>