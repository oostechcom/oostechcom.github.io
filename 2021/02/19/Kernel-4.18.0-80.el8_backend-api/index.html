<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-4.18.0-80.el8_backend-api | oosTech.com</title>
  <meta name="description" content="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;           FS-CACHE CACHE BACKEND API           &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  The FS-Cache system provides an API by which actual caches can be supplied toFS-Cache fo">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-4.18.0-80.el8_backend-api">
<meta property="og:url" content="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_backend-api/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;           FS-CACHE CACHE BACKEND API           &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  The FS-Cache system provides an API by which actual caches can be supplied toFS-Cache fo">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-18T16:00:00.000Z">
<meta property="article:modified_time" content="2021-02-18T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_backend-api/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_mpc5200/" class="title">Kernel-3.10.0-957.el7_mpc5200</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_6pack/" class="title">Kernel-3.10.0-957.el7_6pack</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-4.18.0-80.el8_backend-api" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-4.18.0-80.el8_backend-api
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/02/19/Kernel-4.18.0-80.el8_backend-api/" class="article-date">
	 published: <time datetime="2021-02-18T16:00:00.000Z" itemprop="datePublished">2021-02-19</time>
	</a>
</span>

        
	<a href="/2021/02/19/Kernel-4.18.0-80.el8_backend-api/" class="article-date">
	   updated: <time datetime="2021-02-18T16:00:00.000Z" itemprop="dateUpdated">2021-02-19</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/02/19/Kernel-4.18.0-80.el8_backend-api/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <pre><code>          ==========================
          FS-CACHE CACHE BACKEND API
          ==========================
</code></pre>
<p>The FS-Cache system provides an API by which actual caches can be supplied to<br>FS-Cache for it to then serve out to network filesystems and other interested<br>parties.</p>
<p>This API is declared in &lt;linux/fscache-cache.h&gt;.</p>
<p>====================================<br>INITIALISING AND REGISTERING A CACHE<br>====================================</p>
<p>To start off, a cache definition must be initialised and registered for each<br>cache the backend wants to make available.  For instance, CacheFS does this in<br>the fill_super() operation on mounting.</p>
<p>The cache definition (struct fscache_cache) should be initialised by calling:</p>
<pre><code>void fscache_init_cache(struct fscache_cache *cache,
            struct fscache_cache_ops *ops,
            const char *idfmt,
            ...);
</code></pre>
<p>Where:</p>
<p> (*) “cache” is a pointer to the cache definition;</p>
<p> (*) “ops” is a pointer to the table of operations that the backend supports on<br>     this cache; and</p>
<p> (*) “idfmt” is a format and printf-style arguments for constructing a label<br>     for the cache.</p>
<p>The cache should then be registered with FS-Cache by passing a pointer to the<br>previously initialised cache definition to:</p>
<pre><code>int fscache_add_cache(struct fscache_cache *cache,
              struct fscache_object *fsdef,
              const char *tagname);
</code></pre>
<p>Two extra arguments should also be supplied:</p>
<p> (*) “fsdef” which should point to the object representation for the FS-Cache<br>     master index in this cache.  Netfs primary index entries will be created<br>     here.  FS-Cache keeps the caller’s reference to the index object if<br>     successful and will release it upon withdrawal of the cache.</p>
<p> (*) “tagname” which, if given, should be a text string naming this cache.  If<br>     this is NULL, the identifier will be used instead.  For CacheFS, the<br>     identifier is set to name the underlying block device and the tag can be<br>     supplied by mount.</p>
<p>This function may return -ENOMEM if it ran out of memory or -EEXIST if the tag<br>is already in use.  0 will be returned on success.</p>
<p>=====================<br>UNREGISTERING A CACHE<br>=====================</p>
<p>A cache can be withdrawn from the system by calling this function with a<br>pointer to the cache definition:</p>
<pre><code>void fscache_withdraw_cache(struct fscache_cache *cache);
</code></pre>
<p>In CacheFS’s case, this is called by put_super().</p>
<p>========<br>SECURITY<br>========</p>
<p>The cache methods are executed one of two contexts:</p>
<p> (1) that of the userspace process that issued the netfs operation that caused<br>     the cache method to be invoked, or</p>
<p> (2) that of one of the processes in the FS-Cache thread pool.</p>
<p>In either case, this may not be an appropriate context in which to access the<br>cache.</p>
<p>The calling process’s fsuid, fsgid and SELinux security identities may need to<br>be masqueraded for the duration of the cache driver’s access to the cache.<br>This is left to the cache to handle; FS-Cache makes no effort in this regard.</p>
<p>===================================<br>CONTROL AND STATISTICS PRESENTATION<br>===================================</p>
<p>The cache may present data to the outside world through FS-Cache’s interfaces<br>in sysfs and procfs - the former for control and the latter for statistics.</p>
<p>A sysfs directory called /sys/fs/fscache/<cachetag>/ is created if CONFIG_SYSFS<br>is enabled.  This is accessible through the kobject struct fscache_cache::kobj<br>and is for use by the cache as it sees fit.</p>
<p>========================<br>RELEVANT DATA STRUCTURES<br>========================</p>
<p> (*) Index/Data file FS-Cache representation cookie:</p>
<pre><code>struct fscache_cookie &#123;
    struct fscache_object_def    *def;
    struct fscache_netfs        *netfs;
    void                *netfs_data;
    ...
&#125;;

 The fields that might be of use to the backend describe the object
 definition, the netfs definition and the netfs&#39;s data for this cookie.
 The object definition contain functions supplied by the netfs for loading
 and matching index entries; these are required to provide some of the
 cache operations.
</code></pre>
<p> (*) In-cache object representation:</p>
<pre><code>struct fscache_object &#123;
    int                debug_id;
    enum &#123;
        FSCACHE_OBJECT_RECYCLING,
        ...
    &#125;                state;
    spinlock_t            lock
    struct fscache_cache        *cache;
    struct fscache_cookie        *cookie;
    ...
&#125;;

 Structures of this type should be allocated by the cache backend and
 passed to FS-Cache when requested by the appropriate cache operation.  In
 the case of CacheFS, they&#39;re embedded in CacheFS&#39;s internal object
 structures.

 The debug_id is a simple integer that can be used in debugging messages
 that refer to a particular object.  In such a case it should be printed
 using &quot;OBJ%x&quot; to be consistent with FS-Cache.

 Each object contains a pointer to the cookie that represents the object it
 is backing.  An object should retired when put_object() is called if it is
 in state FSCACHE_OBJECT_RECYCLING.  The fscache_object struct should be
 initialised by calling fscache_object_init(object).
</code></pre>
<p> (*) FS-Cache operation record:</p>
<pre><code>struct fscache_operation &#123;
    atomic_t        usage;
    struct fscache_object    *object;
    unsigned long        flags;
#define FSCACHE_OP_EXCLUSIVE
    void (*processor)(struct fscache_operation *op);
    void (*release)(struct fscache_operation *op);
    ...
&#125;;

 FS-Cache has a pool of threads that it uses to give CPU time to the
 various asynchronous operations that need to be done as part of driving
 the cache.  These are represented by the above structure.  The processor
 method is called to give the op CPU time, and the release method to get
 rid of it when its usage count reaches 0.

 An operation can be made exclusive upon an object by setting the
 appropriate flag before enqueuing it with fscache_enqueue_operation().  If
 an operation needs more processing time, it should be enqueued again.
</code></pre>
<p> (*) FS-Cache retrieval operation record:</p>
<pre><code>struct fscache_retrieval &#123;
    struct fscache_operation op;
    struct address_space    *mapping;
    struct list_head    *to_do;
    ...
&#125;;

 A structure of this type is allocated by FS-Cache to record retrieval and
 allocation requests made by the netfs.  This struct is then passed to the
 backend to do the operation.  The backend may get extra refs to it by
 calling fscache_get_retrieval() and refs may be discarded by calling
 fscache_put_retrieval().

 A retrieval operation can be used by the backend to do retrieval work.  To
 do this, the retrieval-&gt;op.processor method pointer should be set
 appropriately by the backend and fscache_enqueue_retrieval() called to
 submit it to the thread pool.  CacheFiles, for example, uses this to queue
 page examination when it detects PG_lock being cleared.

 The to_do field is an empty list available for the cache backend to use as
 it sees fit.
</code></pre>
<p> (*) FS-Cache storage operation record:</p>
<pre><code>struct fscache_storage &#123;
    struct fscache_operation op;
    pgoff_t            store_limit;
    ...
&#125;;

 A structure of this type is allocated by FS-Cache to record outstanding
 writes to be made.  FS-Cache itself enqueues this operation and invokes
 the write_page() method on the object at appropriate times to effect
 storage.
</code></pre>
<p>================<br>CACHE OPERATIONS<br>================</p>
<p>The cache backend provides FS-Cache with a table of operations that can be<br>performed on the denizens of the cache.  These are held in a structure of type:</p>
<pre><code>struct fscache_cache_ops
</code></pre>
<p> (*) Name of cache provider [mandatory]:</p>
<pre><code>const char *name

 This isn&#39;t strictly an operation, but should be pointed at a string naming
 the backend.
</code></pre>
<p> (*) Allocate a new object [mandatory]:</p>
<pre><code>struct fscache_object *(*alloc_object)(struct fscache_cache *cache,
                       struct fscache_cookie *cookie)

 This method is used to allocate a cache object representation to back a
 cookie in a particular cache.  fscache_object_init() should be called on
 the object to initialise it prior to returning.

 This function may also be used to parse the index key to be used for
 multiple lookup calls to turn it into a more convenient form.  FS-Cache
 will call the lookup_complete() method to allow the cache to release the
 form once lookup is complete or aborted.
</code></pre>
<p> (*) Look up and create object [mandatory]:</p>
<pre><code>void (*lookup_object)(struct fscache_object *object)

 This method is used to look up an object, given that the object is already
 allocated and attached to the cookie.  This should instantiate that object
 in the cache if it can.

 The method should call fscache_object_lookup_negative() as soon as
 possible if it determines the object doesn&#39;t exist in the cache.  If the
 object is found to exist and the netfs indicates that it is valid then
 fscache_obtained_object() should be called once the object is in a
 position to have data stored in it.  Similarly, fscache_obtained_object()
 should also be called once a non-present object has been created.

 If a lookup error occurs, fscache_object_lookup_error() should be called
 to abort the lookup of that object.
</code></pre>
<p> (*) Release lookup data [mandatory]:</p>
<pre><code>void (*lookup_complete)(struct fscache_object *object)

 This method is called to ask the cache to release any resources it was
 using to perform a lookup.
</code></pre>
<p> (*) Increment object refcount [mandatory]:</p>
<pre><code>struct fscache_object *(*grab_object)(struct fscache_object *object)

 This method is called to increment the reference count on an object.  It
 may fail (for instance if the cache is being withdrawn) by returning NULL.
 It should return the object pointer if successful.
</code></pre>
<p> (*) Lock/Unlock object [mandatory]:</p>
<pre><code>void (*lock_object)(struct fscache_object *object)
void (*unlock_object)(struct fscache_object *object)

 These methods are used to exclusively lock an object.  It must be possible
 to schedule with the lock held, so a spinlock isn&#39;t sufficient.
</code></pre>
<p> (*) Pin/Unpin object [optional]:</p>
<pre><code>int (*pin_object)(struct fscache_object *object)
void (*unpin_object)(struct fscache_object *object)

 These methods are used to pin an object into the cache.  Once pinned an
 object cannot be reclaimed to make space.  Return -ENOSPC if there&#39;s not
 enough space in the cache to permit this.
</code></pre>
<p> (*) Check coherency state of an object [mandatory]:</p>
<pre><code>int (*check_consistency)(struct fscache_object *object)

 This method is called to have the cache check the saved auxiliary data of
 the object against the netfs&#39;s idea of the state.  0 should be returned
 if they&#39;re consistent and -ESTALE otherwise.  -ENOMEM and -ERESTARTSYS
 may also be returned.
</code></pre>
<p> (*) Update object [mandatory]:</p>
<pre><code>int (*update_object)(struct fscache_object *object)

 This is called to update the index entry for the specified object.  The
 new information should be in object-&gt;cookie-&gt;netfs_data.  This can be
 obtained by calling object-&gt;cookie-&gt;def-&gt;get_aux()/get_attr().
</code></pre>
<p> (*) Invalidate data object [mandatory]:</p>
<pre><code>int (*invalidate_object)(struct fscache_operation *op)

 This is called to invalidate a data object (as pointed to by op-&gt;object).
 All the data stored for this object should be discarded and an
 attr_changed operation should be performed.  The caller will follow up
 with an object update operation.

 fscache_op_complete() must be called on op before returning.
</code></pre>
<p> (*) Discard object [mandatory]:</p>
<pre><code>void (*drop_object)(struct fscache_object *object)

 This method is called to indicate that an object has been unbound from its
 cookie, and that the cache should release the object&#39;s resources and
 retire it if it&#39;s in state FSCACHE_OBJECT_RECYCLING.

 This method should not attempt to release any references held by the
 caller.  The caller will invoke the put_object() method as appropriate.
</code></pre>
<p> (*) Release object reference [mandatory]:</p>
<pre><code>void (*put_object)(struct fscache_object *object)

 This method is used to discard a reference to an object.  The object may
 be freed when all the references to it are released.
</code></pre>
<p> (*) Synchronise a cache [mandatory]:</p>
<pre><code>void (*sync)(struct fscache_cache *cache)

 This is called to ask the backend to synchronise a cache with its backing
 device.
</code></pre>
<p> (*) Dissociate a cache [mandatory]:</p>
<pre><code>void (*dissociate_pages)(struct fscache_cache *cache)

 This is called to ask a cache to perform any page dissociations as part of
 cache withdrawal.
</code></pre>
<p> (*) Notification that the attributes on a netfs file changed [mandatory]:</p>
<pre><code>int (*attr_changed)(struct fscache_object *object);

 This is called to indicate to the cache that certain attributes on a netfs
 file have changed (for example the maximum size a file may reach).  The
 cache can read these from the netfs by calling the cookie&#39;s get_attr()
 method.

 The cache may use the file size information to reserve space on the cache.
 It should also call fscache_set_store_limit() to indicate to FS-Cache the
 highest byte it&#39;s willing to store for an object.

 This method may return -ve if an error occurred or the cache object cannot
 be expanded.  In such a case, the object will be withdrawn from service.

 This operation is run asynchronously from FS-Cache&#39;s thread pool, and
 storage and retrieval operations from the netfs are excluded during the
 execution of this operation.
</code></pre>
<p> (*) Reserve cache space for an object’s data [optional]:</p>
<pre><code>int (*reserve_space)(struct fscache_object *object, loff_t size);

 This is called to request that cache space be reserved to hold the data
 for an object and the metadata used to track it.  Zero size should be
 taken as request to cancel a reservation.

 This should return 0 if successful, -ENOSPC if there isn&#39;t enough space
 available, or -ENOMEM or -EIO on other errors.

 The reservation may exceed the current size of the object, thus permitting
 future expansion.  If the amount of space consumed by an object would
 exceed the reservation, it&#39;s permitted to refuse requests to allocate
 pages, but not required.  An object may be pruned down to its reservation
 size if larger than that already.
</code></pre>
<p> (*) Request page be read from cache [mandatory]:</p>
<pre><code>int (*read_or_alloc_page)(struct fscache_retrieval *op,
              struct page *page,
              gfp_t gfp)

 This is called to attempt to read a netfs page from the cache, or to
 reserve a backing block if not.  FS-Cache will have done as much checking
 as it can before calling, but most of the work belongs to the backend.

 If there&#39;s no page in the cache, then -ENODATA should be returned if the
 backend managed to reserve a backing block; -ENOBUFS or -ENOMEM if it
 didn&#39;t.

 If there is suitable data in the cache, then a read operation should be
 queued and 0 returned.  When the read finishes, fscache_end_io() should be
 called.

 The fscache_mark_pages_cached() should be called for the page if any cache
 metadata is retained.  This will indicate to the netfs that the page needs
 explicit uncaching.  This operation takes a pagevec, thus allowing several
 pages to be marked at once.

 The retrieval record pointed to by op should be retained for each page
 queued and released when I/O on the page has been formally ended.
 fscache_get/put_retrieval() are available for this purpose.

 The retrieval record may be used to get CPU time via the FS-Cache thread
 pool.  If this is desired, the op-&gt;op.processor should be set to point to
 the appropriate processing routine, and fscache_enqueue_retrieval() should
 be called at an appropriate point to request CPU time.  For instance, the
 retrieval routine could be enqueued upon the completion of a disk read.
 The to_do field in the retrieval record is provided to aid in this.

 If an I/O error occurs, fscache_io_error() should be called and -ENOBUFS
 returned if possible or fscache_end_io() called with a suitable error
 code.

 fscache_put_retrieval() should be called after a page or pages are dealt
 with.  This will complete the operation when all pages are dealt with.
</code></pre>
<p> (*) Request pages be read from cache [mandatory]:</p>
<pre><code>int (*read_or_alloc_pages)(struct fscache_retrieval *op,
               struct list_head *pages,
               unsigned *nr_pages,
               gfp_t gfp)

 This is like the read_or_alloc_page() method, except it is handed a list
 of pages instead of one page.  Any pages on which a read operation is
 started must be added to the page cache for the specified mapping and also
 to the LRU.  Such pages must also be removed from the pages list and
 *nr_pages decremented per page.

 If there was an error such as -ENOMEM, then that should be returned; else
 if one or more pages couldn&#39;t be read or allocated, then -ENOBUFS should
 be returned; else if one or more pages couldn&#39;t be read, then -ENODATA
 should be returned.  If all the pages are dispatched then 0 should be
 returned.
</code></pre>
<p> (*) Request page be allocated in the cache [mandatory]:</p>
<pre><code>int (*allocate_page)(struct fscache_retrieval *op,
             struct page *page,
             gfp_t gfp)

 This is like the read_or_alloc_page() method, except that it shouldn&#39;t
 read from the cache, even if there&#39;s data there that could be retrieved.
 It should, however, set up any internal metadata required such that
 the write_page() method can write to the cache.

 If there&#39;s no backing block available, then -ENOBUFS should be returned
 (or -ENOMEM if there were other problems).  If a block is successfully
 allocated, then the netfs page should be marked and 0 returned.
</code></pre>
<p> (*) Request pages be allocated in the cache [mandatory]:</p>
<pre><code>int (*allocate_pages)(struct fscache_retrieval *op,
              struct list_head *pages,
              unsigned *nr_pages,
              gfp_t gfp)

 This is an multiple page version of the allocate_page() method.  pages and
 nr_pages should be treated as for the read_or_alloc_pages() method.
</code></pre>
<p> (*) Request page be written to cache [mandatory]:</p>
<pre><code>int (*write_page)(struct fscache_storage *op,
          struct page *page);

 This is called to write from a page on which there was a previously
 successful read_or_alloc_page() call or similar.  FS-Cache filters out
 pages that don&#39;t have mappings.

 This method is called asynchronously from the FS-Cache thread pool.  It is
 not required to actually store anything, provided -ENODATA is then
 returned to the next read of this page.

 If an error occurred, then a negative error code should be returned,
 otherwise zero should be returned.  FS-Cache will take appropriate action
 in response to an error, such as withdrawing this object.

 If this method returns success then FS-Cache will inform the netfs
 appropriately.
</code></pre>
<p> (*) Discard retained per-page metadata [mandatory]:</p>
<pre><code>void (*uncache_page)(struct fscache_object *object, struct page *page)

 This is called when a netfs page is being evicted from the pagecache.  The
 cache backend should tear down any internal representation or tracking it
 maintains for this page.
</code></pre>
<p>==================<br>FS-CACHE UTILITIES<br>==================</p>
<p>FS-Cache provides some utilities that a cache backend may make use of:</p>
<p> (*) Note occurrence of an I/O error in a cache:</p>
<pre><code>void fscache_io_error(struct fscache_cache *cache)

 This tells FS-Cache that an I/O error occurred in the cache.  After this
 has been called, only resource dissociation operations (object and page
 release) will be passed from the netfs to the cache backend for the
 specified cache.

 This does not actually withdraw the cache.  That must be done separately.
</code></pre>
<p> (*) Invoke the retrieval I/O completion function:</p>
<pre><code>void fscache_end_io(struct fscache_retrieval *op, struct page *page,
            int error);

 This is called to note the end of an attempt to retrieve a page.  The
 error value should be 0 if successful and an error otherwise.
</code></pre>
<p> (*) Record that one or more pages being retrieved or allocated have been dealt<br>     with:</p>
<pre><code>void fscache_retrieval_complete(struct fscache_retrieval *op,
                int n_pages);

 This is called to record the fact that one or more pages have been dealt
 with and are no longer the concern of this operation.  When the number of
 pages remaining in the operation reaches 0, the operation will be
 completed.
</code></pre>
<p> (*) Record operation completion:</p>
<pre><code>void fscache_op_complete(struct fscache_operation *op);

 This is called to record the completion of an operation.  This deducts
 this operation from the parent object&#39;s run state, potentially permitting
 one or more pending operations to start running.
</code></pre>
<p> (*) Set highest store limit:</p>
<pre><code>void fscache_set_store_limit(struct fscache_object *object,
                 loff_t i_size);

 This sets the limit FS-Cache imposes on the highest byte it&#39;s willing to
 try and store for a netfs.  Any page over this limit is automatically
 rejected by fscache_read_alloc_page() and co with -ENOBUFS.
</code></pre>
<p> (*) Mark pages as being cached:</p>
<pre><code>void fscache_mark_pages_cached(struct fscache_retrieval *op,
                   struct pagevec *pagevec);

 This marks a set of pages as being cached.  After this has been called,
 the netfs must call fscache_uncache_page() to unmark the pages.
</code></pre>
<p> (*) Perform coherency check on an object:</p>
<pre><code>enum fscache_checkaux fscache_check_aux(struct fscache_object *object,
                    const void *data,
                    uint16_t datalen);

 This asks the netfs to perform a coherency check on an object that has
 just been looked up.  The cookie attached to the object will determine the
 netfs to use.  data and datalen should specify where the auxiliary data
 retrieved from the cache can be found.

 One of three values will be returned:

(*) FSCACHE_CHECKAUX_OKAY

    The coherency data indicates the object is valid as is.

(*) FSCACHE_CHECKAUX_NEEDS_UPDATE

    The coherency data needs updating, but otherwise the object is
    valid.

(*) FSCACHE_CHECKAUX_OBSOLETE

    The coherency data indicates that the object is obsolete and should
    be discarded.
</code></pre>
<p> (*) Initialise a freshly allocated object:</p>
<pre><code>void fscache_object_init(struct fscache_object *object);

 This initialises all the fields in an object representation.
</code></pre>
<p> (*) Indicate the destruction of an object:</p>
<pre><code>void fscache_object_destroyed(struct fscache_cache *cache);

 This must be called to inform FS-Cache that an object that belonged to a
 cache has been destroyed and deallocated.  This will allow continuation
 of the cache withdrawal process when it is stopped pending destruction of
 all the objects.
</code></pre>
<p> (*) Indicate negative lookup on an object:</p>
<pre><code>void fscache_object_lookup_negative(struct fscache_object *object);

 This is called to indicate to FS-Cache that a lookup process for an object
 found a negative result.

 This changes the state of an object to permit reads pending on lookup
 completion to go off and start fetching data from the netfs server as it&#39;s
 known at this point that there can&#39;t be any data in the cache.

 This may be called multiple times on an object.  Only the first call is
 significant - all subsequent calls are ignored.
</code></pre>
<p> (*) Indicate an object has been obtained:</p>
<pre><code>void fscache_obtained_object(struct fscache_object *object);

 This is called to indicate to FS-Cache that a lookup process for an object
 produced a positive result, or that an object was created.  This should
 only be called once for any particular object.

 This changes the state of an object to indicate:

(1) if no call to fscache_object_lookup_negative() has been made on
    this object, that there may be data available, and that reads can
    now go and look for it; and

    (2) that writes may now proceed against this object.
</code></pre>
<p> (*) Indicate that object lookup failed:</p>
<pre><code>void fscache_object_lookup_error(struct fscache_object *object);

 This marks an object as having encountered a fatal error (usually EIO)
 and causes it to move into a state whereby it will be withdrawn as soon
 as possible.
</code></pre>
<p> (*) Indicate that a stale object was found and discarded:</p>
<pre><code>void fscache_object_retrying_stale(struct fscache_object *object);

 This is called to indicate that the lookup procedure found an object in
 the cache that the netfs decided was stale.  The object has been
 discarded from the cache and the lookup will be performed again.
</code></pre>
<p> (*) Indicate that the caching backend killed an object:</p>
<pre><code>void fscache_object_mark_killed(struct fscache_object *object,
                enum fscache_why_object_killed why);

 This is called to indicate that the cache backend preemptively killed an
 object.  The why parameter should be set to indicate the reason:

FSCACHE_OBJECT_IS_STALE - the object was stale and needs discarding.
FSCACHE_OBJECT_NO_SPACE - there was insufficient cache space
FSCACHE_OBJECT_WAS_RETIRED - the object was retired when relinquished.
FSCACHE_OBJECT_WAS_CULLED - the object was culled to make space.
</code></pre>
<p> (*) Get and release references on a retrieval record:</p>
<pre><code>void fscache_get_retrieval(struct fscache_retrieval *op);
void fscache_put_retrieval(struct fscache_retrieval *op);

 These two functions are used to retain a retrieval record whilst doing
 asynchronous data retrieval and block allocation.
</code></pre>
<p> (*) Enqueue a retrieval record for processing.</p>
<pre><code>void fscache_enqueue_retrieval(struct fscache_retrieval *op);

 This enqueues a retrieval record for processing by the FS-Cache thread
 pool.  One of the threads in the pool will invoke the retrieval record&#39;s
 op-&gt;op.processor callback function.  This function may be called from
 within the callback function.
</code></pre>
<p> (*) List of object state names:</p>
<pre><code>const char *fscache_object_states[];

 For debugging purposes, this may be used to turn the state that an object
 is in into a text string for display purposes.
</code></pre>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_backend-api/" title="Kernel-4.18.0-80.el8_backend-api" target="_blank" rel="external">http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_backend-api/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/02/19/Kernel-4.18.0-80.el8_autofs/" title="Kernel-4.18.0-80.el8_autofs"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/02/19/Kernel-4.18.0-80.el8_bfq-iosched/" title="Kernel-4.18.0-80.el8_bfq-iosche"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>