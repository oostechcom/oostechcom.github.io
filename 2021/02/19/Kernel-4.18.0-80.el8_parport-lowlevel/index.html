<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-4.18.0-80.el8_parport-lowlevel | oosTech.com</title>
  <meta name="description" content="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PARPORT interface documentation&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; :Time-stamp: &lt;2000-02-24 13:30:20 twaugh&gt; Described here are the following functions: Global functio">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-4.18.0-80.el8_parport-lowlevel">
<meta property="og:url" content="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_parport-lowlevel/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PARPORT interface documentation&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; :Time-stamp: &lt;2000-02-24 13:30:20 twaugh&gt; Described here are the following functions: Global functio">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-18T16:00:00.000Z">
<meta property="article:modified_time" content="2021-02-18T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_parport-lowlevel/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#parport-register-driver-register-a-device-driver-with-parport"><span class="toc-number">1.</span> <span class="toc-text">parport_register_driver - register a device driver with parport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parport-unregister-driver-tell-parport-to-forget-about-this-driver"><span class="toc-number">2.</span> <span class="toc-text">parport_unregister_driver - tell parport to forget about this driver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parport-enumerate-retrieve-a-list-of-parallel-ports-DEPRECATED"><span class="toc-number">3.</span> <span class="toc-text">parport_enumerate - retrieve a list of parallel ports (DEPRECATED)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parport-register-device-register-to-use-a-port"><span class="toc-number">4.</span> <span class="toc-text">parport_register_device - register to use a port</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parport-yield-parport-yield-blocking-temporarily-release-a-parallel-port"><span class="toc-number">5.</span> <span class="toc-text">parport_yield, parport_yield_blocking - temporarily release a parallel port</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parport-wait-event-wait-for-an-event-on-a-port"><span class="toc-number">6.</span> <span class="toc-text">parport_wait_event - wait for an event on a port</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parport-negotiate-perform-IEEE-1284-negotiation"><span class="toc-number">7.</span> <span class="toc-text">parport_negotiate - perform IEEE 1284 negotiation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parport-read-read-data-from-device"><span class="toc-number">8.</span> <span class="toc-text">parport_read - read data from device</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parport-write-write-data-to-device"><span class="toc-number">9.</span> <span class="toc-text">parport_write - write data to device</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parport-close-unregister-device-for-particular-device-number"><span class="toc-number">10.</span> <span class="toc-text">parport_close - unregister device for particular device number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parport-device-id-obtain-IEEE-1284-Device-ID"><span class="toc-number">11.</span> <span class="toc-text">parport_device_id - obtain IEEE 1284 Device ID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parport-device-coords-convert-device-number-to-device-coordinates"><span class="toc-number">12.</span> <span class="toc-text">parport_device_coords - convert device number to device coordinates</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parport-find-class-find-a-device-by-its-class"><span class="toc-number">13.</span> <span class="toc-text">parport_find_class - find a device by its class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parport-find-device-find-a-device-by-its-class"><span class="toc-number">14.</span> <span class="toc-text">parport_find_device - find a device by its class</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PORT-FUNCTIONS"><span class="toc-number"></span> <span class="toc-text">PORT FUNCTIONS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#port-gt-ops-gt-read-data-read-the-data-register"><span class="toc-number">1.</span> <span class="toc-text">port-&gt;ops-&gt;read_data - read the data register</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#port-gt-ops-gt-data-forward-enable-data-drivers"><span class="toc-number">2.</span> <span class="toc-text">port-&gt;ops-&gt;data_forward - enable data drivers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#port-gt-ops-gt-epp-write-data-write-EPP-data"><span class="toc-number">3.</span> <span class="toc-text">port-&gt;ops-&gt;epp_write_data - write EPP data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#port-gt-ops-gt-epp-write-addr-write-EPP-address"><span class="toc-number">4.</span> <span class="toc-text">port-&gt;ops-&gt;epp_write_addr - write EPP address</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#port-gt-ops-gt-ecp-read-data-read-a-block-of-ECP-data"><span class="toc-number">5.</span> <span class="toc-text">port-&gt;ops-&gt;ecp_read_data - read a block of ECP data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#port-gt-ops-gt-ecp-write-addr-write-a-block-of-ECP-addresses"><span class="toc-number">6.</span> <span class="toc-text">port-&gt;ops-&gt;ecp_write_addr - write a block of ECP addresses</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#port-gt-ops-gt-nibble-read-data-read-a-block-of-data-in-nibble-mode"><span class="toc-number">7.</span> <span class="toc-text">port-&gt;ops-&gt;nibble_read_data - read a block of data in nibble mode</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-4.18.0-80.el8_parport-lowlevel" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-4.18.0-80.el8_parport-lowlevel
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/02/19/Kernel-4.18.0-80.el8_parport-lowlevel/" class="article-date">
	 published: <time datetime="2021-02-18T16:00:00.000Z" itemprop="datePublished">2021-02-19</time>
	</a>
</span>

        
	<a href="/2021/02/19/Kernel-4.18.0-80.el8_parport-lowlevel/" class="article-date">
	   updated: <time datetime="2021-02-18T16:00:00.000Z" itemprop="dateUpdated">2021-02-19</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/02/19/Kernel-4.18.0-80.el8_parport-lowlevel/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>===============================<br>PARPORT interface documentation<br>===============================</p>
<p>:Time-stamp: &lt;2000-02-24 13:30:20 twaugh&gt;</p>
<p>Described here are the following functions:</p>
<p>Global functions::<br>  parport_register_driver<br>  parport_unregister_driver<br>  parport_enumerate<br>  parport_register_device<br>  parport_unregister_device<br>  parport_claim<br>  parport_claim_or_block<br>  parport_release<br>  parport_yield<br>  parport_yield_blocking<br>  parport_wait_peripheral<br>  parport_poll_peripheral<br>  parport_wait_event<br>  parport_negotiate<br>  parport_read<br>  parport_write<br>  parport_open<br>  parport_close<br>  parport_device_id<br>  parport_device_coords<br>  parport_find_class<br>  parport_find_device<br>  parport_set_timeout</p>
<p>Port functions (can be overridden by low-level drivers):</p>
<p>  SPP::<br>    port-&gt;ops-&gt;read_data<br>    port-&gt;ops-&gt;write_data<br>    port-&gt;ops-&gt;read_status<br>    port-&gt;ops-&gt;read_control<br>    port-&gt;ops-&gt;write_control<br>    port-&gt;ops-&gt;frob_control<br>    port-&gt;ops-&gt;enable_irq<br>    port-&gt;ops-&gt;disable_irq<br>    port-&gt;ops-&gt;data_forward<br>    port-&gt;ops-&gt;data_reverse</p>
<p>  EPP::<br>    port-&gt;ops-&gt;epp_write_data<br>    port-&gt;ops-&gt;epp_read_data<br>    port-&gt;ops-&gt;epp_write_addr<br>    port-&gt;ops-&gt;epp_read_addr</p>
<p>  ECP::<br>    port-&gt;ops-&gt;ecp_write_data<br>    port-&gt;ops-&gt;ecp_read_data<br>    port-&gt;ops-&gt;ecp_write_addr</p>
<p>  Other::<br>    port-&gt;ops-&gt;nibble_read_data<br>    port-&gt;ops-&gt;byte_read_data<br>    port-&gt;ops-&gt;compat_write_data</p>
<p>The parport subsystem comprises <code>parport</code> (the core port-sharing<br>code), and a variety of low-level drivers that actually do the port<br>accesses.  Each low-level driver handles a particular style of port<br>(PC, Amiga, and so on).</p>
<p>The parport interface to the device driver author can be broken down<br>into global functions and port functions.</p>
<p>The global functions are mostly for communicating between the device<br>driver and the parport subsystem: acquiring a list of available ports,<br>claiming a port for exclusive use, and so on.  They also include<br><code>generic</code> functions for doing standard things that will work on any<br>IEEE 1284-capable architecture.</p>
<p>The port functions are provided by the low-level drivers, although the<br>core parport module provides generic <code>defaults</code> for some routines.<br>The port functions can be split into three groups: SPP, EPP, and ECP.</p>
<p>SPP (Standard Parallel Port) functions modify so-called <code>SPP</code><br>registers: data, status, and control.  The hardware may not actually<br>have registers exactly like that, but the PC does and this interface is<br>modelled after common PC implementations.  Other low-level drivers may<br>be able to emulate most of the functionality.</p>
<p>EPP (Enhanced Parallel Port) functions are provided for reading and<br>writing in IEEE 1284 EPP mode, and ECP (Extended Capabilities Port)<br>functions are used for IEEE 1284 ECP mode. (What about BECP? Does<br>anyone care?)</p>
<p>Hardware assistance for EPP and/or ECP transfers may or may not be<br>available, and if it is available it may or may not be used.  If<br>hardware is not used, the transfer will be software-driven.  In order<br>to cope with peripherals that only tenuously support IEEE 1284, a<br>low-level driver specific function is provided, for altering ‘fudge<br>factors’.<br><br>Global functions<br>================</p>
<h2 id="parport-register-driver-register-a-device-driver-with-parport"><a href="#parport-register-driver-register-a-device-driver-with-parport" class="headerlink" title="parport_register_driver - register a device driver with parport"></a>parport_register_driver - register a device driver with parport</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_driver &#123;
    const char *name;
    void (*attach) (struct parport *);
    void (*detach) (struct parport *);
    struct parport_driver *next;
&#125;;
int parport_register_driver (struct parport_driver *driver);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>In order to be notified about parallel ports when they are detected,<br>parport_register_driver should be called.  Your driver will<br>immediately be notified of all ports that have already been detected,<br>and of each new port as low-level drivers are loaded.</p>
<p>A <code>struct parport_driver</code> contains the textual name of your driver,<br>a pointer to a function to handle new ports, and a pointer to a<br>function to handle ports going away due to a low-level driver<br>unloading.  Ports will only be detached if they are not being used<br>(i.e. there are no devices registered on them).</p>
<p>The visible parts of the <code>struct parport *</code> argument given to<br>attach/detach are::</p>
<pre><code>struct parport
&#123;
    struct parport *next; /* next parport in list */
    const char *name;     /* port&#39;s name */
    unsigned int modes;   /* bitfield of hardware modes */
    struct parport_device_info probe_info;
            /* IEEE1284 info */
    int number;           /* parport index */
    struct parport_operations *ops;
    ...
&#125;;
</code></pre>
<p>There are other members of the structure, but they should not be<br>touched.</p>
<p>The <code>modes</code> member summarises the capabilities of the underlying<br>hardware.  It consists of flags which may be bitwise-ored together:</p>
<p>  ============================= ===============================================<br>  PARPORT_MODE_PCSPP        IBM PC registers are available,<br>                i.e. functions that act on data,<br>                control and status registers are<br>                probably writing directly to the<br>                hardware.<br>  PARPORT_MODE_TRISTATE        The data drivers may be turned off.<br>                This allows the data lines to be used<br>                for reverse (peripheral to host)<br>                transfers.<br>  PARPORT_MODE_COMPAT        The hardware can assist with<br>                compatibility-mode (printer)<br>                transfers, i.e. compat_write_block.<br>  PARPORT_MODE_EPP        The hardware can assist with EPP<br>                transfers.<br>  PARPORT_MODE_ECP        The hardware can assist with ECP<br>                transfers.<br>  PARPORT_MODE_DMA        The hardware can use DMA, so you might<br>                want to pass ISA DMA-able memory<br>                (i.e. memory allocated using the<br>                GFP_DMA flag with kmalloc) to the<br>                low-level driver in order to take<br>                advantage of it.<br>  ============================= ===============================================</p>
<p>There may be other flags in <code>modes</code> as well.</p>
<p>The contents of <code>modes</code> is advisory only.  For example, if the<br>hardware is capable of DMA, and PARPORT_MODE_DMA is in <code>modes</code>, it<br>doesn’t necessarily mean that DMA will always be used when possible.<br>Similarly, hardware that is capable of assisting ECP transfers won’t<br>necessarily be used.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>Zero on success, otherwise an error code.</p>
<p>ERRORS<br>^^^^^^</p>
<p>None. (Can it fail? Why return int?)</p>
<p>EXAMPLE<br>^^^^^^^</p>
<p>::</p>
<pre><code>static void lp_attach (struct parport *port)
&#123;
    ...
    private = kmalloc (...);
    dev[count++] = parport_register_device (...);
    ...
&#125;

static void lp_detach (struct parport *port)
&#123;
    ...
&#125;

static struct parport_driver lp_driver = &#123;
    &quot;lp&quot;,
    lp_attach,
    lp_detach,
    NULL /* always put NULL here */
&#125;;

int lp_init (void)
&#123;
    ...
    if (parport_register_driver (&amp;lp_driver)) &#123;
        /* Failed; nothing we can do. */
        return -EIO;
    &#125;
    ...
&#125;
</code></pre>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>parport_unregister_driver, parport_register_device, parport_enumerate</p>
<h2 id="parport-unregister-driver-tell-parport-to-forget-about-this-driver"><a href="#parport-unregister-driver-tell-parport-to-forget-about-this-driver" class="headerlink" title="parport_unregister_driver - tell parport to forget about this driver"></a>parport_unregister_driver - tell parport to forget about this driver</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_driver &#123;
    const char *name;
    void (*attach) (struct parport *);
    void (*detach) (struct parport *);
    struct parport_driver *next;
&#125;;
void parport_unregister_driver (struct parport_driver *driver);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>This tells parport not to notify the device driver of new ports or of<br>ports going away.  Registered devices belonging to that driver are NOT<br>unregistered: parport_unregister_device must be used for each one.</p>
<p>EXAMPLE<br>^^^^^^^</p>
<p>::</p>
<pre><code>void cleanup_module (void)
&#123;
    ...
    /* Stop notifications. */
    parport_unregister_driver (&amp;lp_driver);

    /* Unregister devices. */
    for (i = 0; i &lt; NUM_DEVS; i++)
        parport_unregister_device (dev[i]);
    ...
&#125;
</code></pre>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>parport_register_driver, parport_enumerate</p>
<h2 id="parport-enumerate-retrieve-a-list-of-parallel-ports-DEPRECATED"><a href="#parport-enumerate-retrieve-a-list-of-parallel-ports-DEPRECATED" class="headerlink" title="parport_enumerate - retrieve a list of parallel ports (DEPRECATED)"></a>parport_enumerate - retrieve a list of parallel ports (DEPRECATED)</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport *parport_enumerate (void);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Retrieve the first of a list of valid parallel ports for this machine.<br>Successive parallel ports can be found using the <code>struct parport *next</code> element of the <code>struct parport *</code> that is returned.  If <code>next</code><br>is NULL, there are no more parallel ports in the list.  The number of<br>ports in the list will not exceed PARPORT_MAX.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>A <code>struct parport *</code> describing a valid parallel port for the machine,<br>or NULL if there are none.</p>
<p>ERRORS<br>^^^^^^</p>
<p>This function can return NULL to indicate that there are no parallel<br>ports to use.</p>
<p>EXAMPLE<br>^^^^^^^</p>
<p>::</p>
<pre><code>int detect_device (void)
&#123;
    struct parport *port;

    for (port = parport_enumerate ();
    port != NULL;
    port = port-&gt;next) &#123;
        /* Try to detect a device on the port... */
        ...
    &#125;
    &#125;

    ...
&#125;
</code></pre>
<p>NOTES<br>^^^^^</p>
<p>parport_enumerate is deprecated; parport_register_driver should be<br>used instead.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>parport_register_driver, parport_unregister_driver</p>
<h2 id="parport-register-device-register-to-use-a-port"><a href="#parport-register-device-register-to-use-a-port" class="headerlink" title="parport_register_device - register to use a port"></a>parport_register_device - register to use a port</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

typedef int (*preempt_func) (void *handle);
typedef void (*wakeup_func) (void *handle);
typedef int (*irq_func) (int irq, void *handle, struct pt_regs *);

struct pardevice *parport_register_device(struct parport *port,
                      const char *name,
                      preempt_func preempt,
                      wakeup_func wakeup,
                      irq_func irq,
                      int flags,
                      void *handle);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Use this function to register your device driver on a parallel port<br>(<code>port</code>).  Once you have done that, you will be able to use<br>parport_claim and parport_release in order to use the port.</p>
<p>The (<code>name</code>) argument is the name of the device that appears in /proc<br>filesystem. The string must be valid for the whole lifetime of the<br>device (until parport_unregister_device is called).</p>
<p>This function will register three callbacks into your driver:<br><code>preempt</code>, <code>wakeup</code> and <code>irq</code>.  Each of these may be NULL in order to<br>indicate that you do not want a callback.</p>
<p>When the <code>preempt</code> function is called, it is because another driver<br>wishes to use the parallel port.  The <code>preempt</code> function should return<br>non-zero if the parallel port cannot be released yet – if zero is<br>returned, the port is lost to another driver and the port must be<br>re-claimed before use.</p>
<p>The <code>wakeup</code> function is called once another driver has released the<br>port and no other driver has yet claimed it.  You can claim the<br>parallel port from within the <code>wakeup</code> function (in which case the<br>claim is guaranteed to succeed), or choose not to if you don’t need it<br>now.</p>
<p>If an interrupt occurs on the parallel port your driver has claimed,<br>the <code>irq</code> function will be called. (Write something about shared<br>interrupts here.)</p>
<p>The <code>handle</code> is a pointer to driver-specific data, and is passed to<br>the callback functions.</p>
<p><code>flags</code> may be a bitwise combination of the following flags:</p>
<p>  ===================== =================================================<br>        Flag            Meaning<br>  ===================== =================================================<br>  PARPORT_DEV_EXCL    The device cannot share the parallel port at all.<br>            Use this only when absolutely necessary.<br>  ===================== =================================================</p>
<p>The typedefs are not actually defined – they are only shown in order<br>to make the function prototype more readable.</p>
<p>The visible parts of the returned <code>struct pardevice</code> are::</p>
<pre><code>struct pardevice &#123;
    struct parport *port;    /* Associated port */
    void *private;        /* Device driver&#39;s &#39;handle&#39; */
    ...
&#125;;
</code></pre>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>A <code>struct pardevice *</code>: a handle to the registered parallel port<br>device that can be used for parport_claim, parport_release, etc.</p>
<p>ERRORS<br>^^^^^^</p>
<p>A return value of NULL indicates that there was a problem registering<br>a device on that port.</p>
<p>EXAMPLE<br>^^^^^^^</p>
<p>::</p>
<pre><code>static int preempt (void *handle)
&#123;
    if (busy_right_now)
        return 1;

    must_reclaim_port = 1;
    return 0;
&#125;

static void wakeup (void *handle)
&#123;
    struct toaster *private = handle;
    struct pardevice *dev = private-&gt;dev;
    if (!dev) return; /* avoid races */

    if (want_port)
        parport_claim (dev);
&#125;

static int toaster_detect (struct toaster *private, struct parport *port)
&#123;
    private-&gt;dev = parport_register_device (port, &quot;toaster&quot;, preempt,
                        wakeup, NULL, 0,
                        private);
    if (!private-&gt;dev)
        /* Couldn&#39;t register with parport. */
        return -EIO;

    must_reclaim_port = 0;
    busy_right_now = 1;
    parport_claim_or_block (private-&gt;dev);
    ...
    /* Don&#39;t need the port while the toaster warms up. */
    busy_right_now = 0;
    ...
    busy_right_now = 1;
    if (must_reclaim_port) &#123;
        parport_claim_or_block (private-&gt;dev);
        must_reclaim_port = 0;
    &#125;
    ...
&#125;
</code></pre>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>parport_unregister_device, parport_claim</p>
<p><br>parport_unregister_device - finish using a port</p>
<hr>
<p>SYNPOPSIS</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

void parport_unregister_device (struct pardevice *dev);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>This function is the opposite of parport_register_device.  After using<br>parport_unregister_device, <code>dev</code> is no longer a valid device handle.</p>
<p>You should not unregister a device that is currently claimed, although<br>if you do it will be released automatically.</p>
<p>EXAMPLE<br>^^^^^^^</p>
<p>::</p>
<pre><code>...
kfree (dev-&gt;private); /* before we lose the pointer */
parport_unregister_device (dev);
...
</code></pre>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>parport_unregister_driver<br><br>parport_claim, parport_claim_or_block - claim the parallel port for a device</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

int parport_claim (struct pardevice *dev);
int parport_claim_or_block (struct pardevice *dev);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>These functions attempt to gain control of the parallel port on which<br><code>dev</code> is registered.  <code>parport_claim</code> does not block, but<br><code>parport_claim_or_block</code> may do. (Put something here about blocking<br>interruptibly or non-interruptibly.)</p>
<p>You should not try to claim a port that you have already claimed.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>A return value of zero indicates that the port was successfully<br>claimed, and the caller now has possession of the parallel port.</p>
<p>If <code>parport_claim_or_block</code> blocks before returning successfully, the<br>return value is positive.</p>
<p>ERRORS<br>^^^^^^</p>
<p>========== ==========================================================<br>  -EAGAIN  The port is unavailable at the moment, but another attempt<br>           to claim it may succeed.<br>========== ==========================================================</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>parport_release<br><br>parport_release - release the parallel port</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

void parport_release (struct pardevice *dev);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Once a parallel port device has been claimed, it can be released using<br><code>parport_release</code>.  It cannot fail, but you should not release a<br>device that you do not have possession of.</p>
<p>EXAMPLE<br>^^^^^^^</p>
<p>::</p>
<pre><code>static size_t write (struct pardevice *dev, const void *buf,
        size_t len)
&#123;
    ...
    written = dev-&gt;port-&gt;ops-&gt;write_ecp_data (dev-&gt;port, buf,
                        len);
    parport_release (dev);
    ...
&#125;
</code></pre>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>change_mode, parport_claim, parport_claim_or_block, parport_yield</p>
<h2 id="parport-yield-parport-yield-blocking-temporarily-release-a-parallel-port"><a href="#parport-yield-parport-yield-blocking-temporarily-release-a-parallel-port" class="headerlink" title="parport_yield, parport_yield_blocking - temporarily release a parallel port"></a>parport_yield, parport_yield_blocking - temporarily release a parallel port</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

int parport_yield (struct pardevice *dev)
int parport_yield_blocking (struct pardevice *dev);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>When a driver has control of a parallel port, it may allow another<br>driver to temporarily <code>borrow</code> it.  <code>parport_yield</code> does not block;<br><code>parport_yield_blocking</code> may do.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>A return value of zero indicates that the caller still owns the port<br>and the call did not block.</p>
<p>A positive return value from <code>parport_yield_blocking</code> indicates that<br>the caller still owns the port and the call blocked.</p>
<p>A return value of -EAGAIN indicates that the caller no longer owns the<br>port, and it must be re-claimed before use.</p>
<p>ERRORS<br>^^^^^^</p>
<p>========= ==========================================================<br>  -EAGAIN  Ownership of the parallel port was given away.<br>========= ==========================================================</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>parport_release</p>
<p><br>parport_wait_peripheral - wait for status lines, up to 35ms</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

int parport_wait_peripheral (struct parport *port,
                 unsigned char mask,
                 unsigned char val);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Wait for the status lines in mask to match the values in val.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>======== ==========================================================<br> -EINTR  a signal is pending<br>      0  the status lines in mask have values in val<br>      1  timed out while waiting (35ms elapsed)<br>======== ==========================================================</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>parport_poll_peripheral</p>
<p><br>parport_poll_peripheral - wait for status lines, in usec</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

int parport_poll_peripheral (struct parport *port,
                 unsigned char mask,
                 unsigned char val,
                 int usec);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Wait for the status lines in mask to match the values in val.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>======== ==========================================================<br> -EINTR  a signal is pending<br>      0  the status lines in mask have values in val<br>      1  timed out while waiting (usec microseconds have elapsed)<br>======== ==========================================================</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>parport_wait_peripheral</p>
<h2 id="parport-wait-event-wait-for-an-event-on-a-port"><a href="#parport-wait-event-wait-for-an-event-on-a-port" class="headerlink" title="parport_wait_event - wait for an event on a port"></a>parport_wait_event - wait for an event on a port</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

int parport_wait_event (struct parport *port, signed long timeout)
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Wait for an event (e.g. interrupt) on a port.  The timeout is in<br>jiffies.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>======= ==========================================================<br>      0  success<br>     &lt;0  error (exit as soon as possible)<br>     &gt;0  timed out<br>======= ==========================================================</p>
<h2 id="parport-negotiate-perform-IEEE-1284-negotiation"><a href="#parport-negotiate-perform-IEEE-1284-negotiation" class="headerlink" title="parport_negotiate - perform IEEE 1284 negotiation"></a>parport_negotiate - perform IEEE 1284 negotiation</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

int parport_negotiate (struct parport *, int mode);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Perform IEEE 1284 negotiation.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>======= ==========================================================<br>     0  handshake OK; IEEE 1284 peripheral and mode available<br>    -1  handshake failed; peripheral not compliant (or none present)<br>     1  handshake OK; IEEE 1284 peripheral present but mode not<br>        available<br>======= ==========================================================</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>parport_read, parport_write</p>
<h2 id="parport-read-read-data-from-device"><a href="#parport-read-read-data-from-device" class="headerlink" title="parport_read - read data from device"></a>parport_read - read data from device</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

ssize_t parport_read (struct parport *, void *buf, size_t len);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Read data from device in current IEEE 1284 transfer mode.  This only<br>works for modes that support reverse data transfer.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>If negative, an error code; otherwise the number of bytes transferred.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>parport_write, parport_negotiate</p>
<h2 id="parport-write-write-data-to-device"><a href="#parport-write-write-data-to-device" class="headerlink" title="parport_write - write data to device"></a>parport_write - write data to device</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

ssize_t parport_write (struct parport *, const void *buf, size_t len);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Write data to device in current IEEE 1284 transfer mode.  This only<br>works for modes that support forward data transfer.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>If negative, an error code; otherwise the number of bytes transferred.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>parport_read, parport_negotiate</p>
<p><br>parport_open - register device for particular device number</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct pardevice *parport_open (int devnum, const char *name,
                    int (*pf) (void *),
                void (*kf) (void *),
                void (*irqf) (int, void *,
                          struct pt_regs *),
                int flags, void *handle);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>This is like parport_register_device but takes a device number instead<br>of a pointer to a struct parport.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>See parport_register_device.  If no device is associated with devnum,<br>NULL is returned.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>parport_register_device</p>
<h2 id="parport-close-unregister-device-for-particular-device-number"><a href="#parport-close-unregister-device-for-particular-device-number" class="headerlink" title="parport_close - unregister device for particular device number"></a>parport_close - unregister device for particular device number</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

void parport_close (struct pardevice *dev);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>This is the equivalent of parport_unregister_device for parport_open.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>parport_unregister_device, parport_open</p>
<h2 id="parport-device-id-obtain-IEEE-1284-Device-ID"><a href="#parport-device-id-obtain-IEEE-1284-Device-ID" class="headerlink" title="parport_device_id - obtain IEEE 1284 Device ID"></a>parport_device_id - obtain IEEE 1284 Device ID</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

ssize_t parport_device_id (int devnum, char *buffer, size_t len);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Obtains the IEEE 1284 Device ID associated with a given device.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>If negative, an error code; otherwise, the number of bytes of buffer<br>that contain the device ID.  The format of the device ID is as<br>follows::</p>
<pre><code>[length][ID]
</code></pre>
<p>The first two bytes indicate the inclusive length of the entire Device<br>ID, and are in big-endian order.  The ID is a sequence of pairs of the<br>form::</p>
<pre><code>key:value;
</code></pre>
<p>NOTES<br>^^^^^</p>
<p>Many devices have ill-formed IEEE 1284 Device IDs.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>parport_find_class, parport_find_device</p>
<h2 id="parport-device-coords-convert-device-number-to-device-coordinates"><a href="#parport-device-coords-convert-device-number-to-device-coordinates" class="headerlink" title="parport_device_coords - convert device number to device coordinates"></a>parport_device_coords - convert device number to device coordinates</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

int parport_device_coords (int devnum, int *parport, int *mux,
               int *daisy);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Convert between device number (zero-based) and device coordinates<br>(port, multiplexor, daisy chain address).</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>Zero on success, in which case the coordinates are (<code>*parport</code>, <code>*mux</code>,<br><code>*daisy</code>).</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>parport_open, parport_device_id</p>
<h2 id="parport-find-class-find-a-device-by-its-class"><a href="#parport-find-class-find-a-device-by-its-class" class="headerlink" title="parport_find_class - find a device by its class"></a>parport_find_class - find a device by its class</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

typedef enum &#123;
    PARPORT_CLASS_LEGACY = 0,       /* Non-IEEE1284 device */
    PARPORT_CLASS_PRINTER,
    PARPORT_CLASS_MODEM,
    PARPORT_CLASS_NET,
    PARPORT_CLASS_HDC,              /* Hard disk controller */
    PARPORT_CLASS_PCMCIA,
    PARPORT_CLASS_MEDIA,            /* Multimedia device */
    PARPORT_CLASS_FDC,              /* Floppy disk controller */
    PARPORT_CLASS_PORTS,
    PARPORT_CLASS_SCANNER,
    PARPORT_CLASS_DIGCAM,
    PARPORT_CLASS_OTHER,            /* Anything else */
    PARPORT_CLASS_UNSPEC,           /* No CLS field in ID */
    PARPORT_CLASS_SCSIADAPTER
&#125; parport_device_class;

int parport_find_class (parport_device_class cls, int from);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Find a device by class.  The search starts from device number from+1.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>The device number of the next device in that class, or -1 if no such<br>device exists.</p>
<p>NOTES<br>^^^^^</p>
<p>Example usage::</p>
<pre><code>int devnum = -1;
while ((devnum = parport_find_class (PARPORT_CLASS_DIGCAM, devnum)) != -1) &#123;
    struct pardevice *dev = parport_open (devnum, ...);
    ...
&#125;
</code></pre>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>parport_find_device, parport_open, parport_device_id</p>
<h2 id="parport-find-device-find-a-device-by-its-class"><a href="#parport-find-device-find-a-device-by-its-class" class="headerlink" title="parport_find_device - find a device by its class"></a>parport_find_device - find a device by its class</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

int parport_find_device (const char *mfg, const char *mdl, int from);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Find a device by vendor and model.  The search starts from device<br>number from+1.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>The device number of the next device matching the specifications, or<br>-1 if no such device exists.</p>
<p>NOTES<br>^^^^^</p>
<p>Example usage::</p>
<pre><code>int devnum = -1;
while ((devnum = parport_find_device (&quot;IOMEGA&quot;, &quot;ZIP+&quot;, devnum)) != -1) &#123;
    struct pardevice *dev = parport_open (devnum, ...);
    ...
&#125;
</code></pre>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>parport_find_class, parport_open, parport_device_id</p>
<p><br>parport_set_timeout - set the inactivity timeout</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

long parport_set_timeout (struct pardevice *dev, long inactivity);
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Set the inactivity timeout, in jiffies, for a registered device.  The<br>previous timeout is returned.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>The previous timeout, in jiffies.</p>
<p>NOTES<br>^^^^^</p>
<p>Some of the port-&gt;ops functions for a parport may take time, owing to<br>delays at the peripheral.  After the peripheral has not responded for<br><code>inactivity</code> jiffies, a timeout will occur and the blocking function<br>will return.</p>
<p>A timeout of 0 jiffies is a special case: the function must do as much<br>as it can without blocking or leaving the hardware in an unknown<br>state.  If port operations are performed from within an interrupt<br>handler, for instance, a timeout of 0 jiffies should be used.</p>
<p>Once set for a registered device, the timeout will remain at the set<br>value until set again.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>port-&gt;ops-&gt;xxx_read/write_yyy</p>
<h1 id="PORT-FUNCTIONS"><a href="#PORT-FUNCTIONS" class="headerlink" title="PORT FUNCTIONS"></a>PORT FUNCTIONS</h1><p>The functions in the port-&gt;ops structure (struct parport_operations)<br>are provided by the low-level driver responsible for that port.</p>
<h2 id="port-gt-ops-gt-read-data-read-the-data-register"><a href="#port-gt-ops-gt-read-data-read-the-data-register" class="headerlink" title="port-&gt;ops-&gt;read_data - read the data register"></a>port-&gt;ops-&gt;read_data - read the data register</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    unsigned char (*read_data) (struct parport *port);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>If port-&gt;modes contains the PARPORT_MODE_TRISTATE flag and the<br>PARPORT_CONTROL_DIRECTION bit in the control register is set, this<br>returns the value on the data pins.  If port-&gt;modes contains the<br>PARPORT_MODE_TRISTATE flag and the PARPORT_CONTROL_DIRECTION bit is<br>not set, the return value <em>may</em> be the last value written to the data<br>register.  Otherwise the return value is undefined.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>write_data, read_status, write_control</p>
<p><br>port-&gt;ops-&gt;write_data - write the data register</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    void (*write_data) (struct parport *port, unsigned char d);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Writes to the data register.  May have side-effects (a STROBE pulse,<br>for instance).</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>read_data, read_status, write_control</p>
<p><br>port-&gt;ops-&gt;read_status - read the status register</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    unsigned char (*read_status) (struct parport *port);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Reads from the status register.  This is a bitmask:</p>
<ul>
<li>PARPORT_STATUS_ERROR (printer fault, “nFault”)</li>
<li>PARPORT_STATUS_SELECT (on-line, “Select”)</li>
<li>PARPORT_STATUS_PAPEROUT (no paper, “PError”)</li>
<li>PARPORT_STATUS_ACK (handshake, “nAck”)</li>
<li>PARPORT_STATUS_BUSY (busy, “Busy”)</li>
</ul>
<p>There may be other bits set.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>read_data, write_data, write_control</p>
<p><br>port-&gt;ops-&gt;read_control - read the control register</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    unsigned char (*read_control) (struct parport *port);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Returns the last value written to the control register (either from<br>write_control or frob_control).  No port access is performed.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>read_data, write_data, read_status, write_control</p>
<p><br>port-&gt;ops-&gt;write_control - write the control register</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    void (*write_control) (struct parport *port, unsigned char s);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Writes to the control register. This is a bitmask::</p>
<pre><code>              _______
- PARPORT_CONTROL_STROBE (nStrobe)
              _______
- PARPORT_CONTROL_AUTOFD (nAutoFd)
            _____
- PARPORT_CONTROL_INIT (nInit)
              _________
- PARPORT_CONTROL_SELECT (nSelectIn)
</code></pre>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>read_data, write_data, read_status, frob_control</p>
<p><br>port-&gt;ops-&gt;frob_control - write control register bits</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    unsigned char (*frob_control) (struct parport *port,
                unsigned char mask,
                unsigned char val);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>This is equivalent to reading from the control register, masking out<br>the bits in mask, exclusive-or’ing with the bits in val, and writing<br>the result to the control register.</p>
<p>As some ports don’t allow reads from the control port, a software copy<br>of its contents is maintained, so frob_control is in fact only one<br>port access.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>read_data, write_data, read_status, write_control</p>
<p><br>port-&gt;ops-&gt;enable_irq - enable interrupt generation</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    void (*enable_irq) (struct parport *port);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>The parallel port hardware is instructed to generate interrupts at<br>appropriate moments, although those moments are<br>architecture-specific.  For the PC architecture, interrupts are<br>commonly generated on the rising edge of nAck.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>disable_irq</p>
<p><br>port-&gt;ops-&gt;disable_irq - disable interrupt generation</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    void (*disable_irq) (struct parport *port);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>The parallel port hardware is instructed not to generate interrupts.<br>The interrupt itself is not masked.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>enable_irq
</p>
<h2 id="port-gt-ops-gt-data-forward-enable-data-drivers"><a href="#port-gt-ops-gt-data-forward-enable-data-drivers" class="headerlink" title="port-&gt;ops-&gt;data_forward - enable data drivers"></a>port-&gt;ops-&gt;data_forward - enable data drivers</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    void (*data_forward) (struct parport *port);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Enables the data line drivers, for 8-bit host-to-peripheral<br>communications.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>data_reverse</p>
<p><br>port-&gt;ops-&gt;data_reverse - tristate the buffer</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    void (*data_reverse) (struct parport *port);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Places the data bus in a high impedance state, if port-&gt;modes has the<br>PARPORT_MODE_TRISTATE bit set.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>data_forward</p>
<h2 id="port-gt-ops-gt-epp-write-data-write-EPP-data"><a href="#port-gt-ops-gt-epp-write-data-write-EPP-data" class="headerlink" title="port-&gt;ops-&gt;epp_write_data - write EPP data"></a>port-&gt;ops-&gt;epp_write_data - write EPP data</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    size_t (*epp_write_data) (struct parport *port, const void *buf,
                size_t len, int flags);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Writes data in EPP mode, and returns the number of bytes written.</p>
<p>The <code>flags</code> parameter may be one or more of the following,<br>bitwise-or’ed together:</p>
<p>======================= =================================================<br>PARPORT_EPP_FAST    Use fast transfers. Some chips provide 16-bit and<br>            32-bit registers.  However, if a transfer<br>            times out, the return value may be unreliable.<br>======================= =================================================</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>epp_read_data, epp_write_addr, epp_read_addr</p>
<p><br>port-&gt;ops-&gt;epp_read_data - read EPP data</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    size_t (*epp_read_data) (struct parport *port, void *buf,
                size_t len, int flags);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Reads data in EPP mode, and returns the number of bytes read.</p>
<p>The <code>flags</code> parameter may be one or more of the following,<br>bitwise-or’ed together:</p>
<p>======================= =================================================<br>PARPORT_EPP_FAST    Use fast transfers. Some chips provide 16-bit and<br>            32-bit registers.  However, if a transfer<br>            times out, the return value may be unreliable.<br>======================= =================================================</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>epp_write_data, epp_write_addr, epp_read_addr</p>
<h2 id="port-gt-ops-gt-epp-write-addr-write-EPP-address"><a href="#port-gt-ops-gt-epp-write-addr-write-EPP-address" class="headerlink" title="port-&gt;ops-&gt;epp_write_addr - write EPP address"></a>port-&gt;ops-&gt;epp_write_addr - write EPP address</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    size_t (*epp_write_addr) (struct parport *port,
                const void *buf, size_t len, int flags);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Writes EPP addresses (8 bits each), and returns the number written.</p>
<p>The <code>flags</code> parameter may be one or more of the following,<br>bitwise-or’ed together:</p>
<p>======================= =================================================<br>PARPORT_EPP_FAST    Use fast transfers. Some chips provide 16-bit and<br>            32-bit registers.  However, if a transfer<br>            times out, the return value may be unreliable.<br>======================= =================================================</p>
<p>(Does PARPORT_EPP_FAST make sense for this function?)</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>epp_write_data, epp_read_data, epp_read_addr</p>
<p><br>port-&gt;ops-&gt;epp_read_addr - read EPP address</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    size_t (*epp_read_addr) (struct parport *port, void *buf,
                size_t len, int flags);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Reads EPP addresses (8 bits each), and returns the number read.</p>
<p>The <code>flags</code> parameter may be one or more of the following,<br>bitwise-or’ed together:</p>
<p>======================= =================================================<br>PARPORT_EPP_FAST    Use fast transfers. Some chips provide 16-bit and<br>            32-bit registers.  However, if a transfer<br>            times out, the return value may be unreliable.<br>======================= =================================================</p>
<p>(Does PARPORT_EPP_FAST make sense for this function?)</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>epp_write_data, epp_read_data, epp_write_addr</p>
<p><br>port-&gt;ops-&gt;ecp_write_data - write a block of ECP data</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    size_t (*ecp_write_data) (struct parport *port,
                const void *buf, size_t len, int flags);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Writes a block of ECP data.  The <code>flags</code> parameter is ignored.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>The number of bytes written.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>ecp_read_data, ecp_write_addr
</p>
<h2 id="port-gt-ops-gt-ecp-read-data-read-a-block-of-ECP-data"><a href="#port-gt-ops-gt-ecp-read-data-read-a-block-of-ECP-data" class="headerlink" title="port-&gt;ops-&gt;ecp_read_data - read a block of ECP data"></a>port-&gt;ops-&gt;ecp_read_data - read a block of ECP data</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    size_t (*ecp_read_data) (struct parport *port,
                void *buf, size_t len, int flags);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Reads a block of ECP data.  The <code>flags</code> parameter is ignored.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>The number of bytes read.  NB. There may be more unread data in a<br>FIFO.  Is there a way of stunning the FIFO to prevent this?</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>ecp_write_block, ecp_write_addr</p>
<h2 id="port-gt-ops-gt-ecp-write-addr-write-a-block-of-ECP-addresses"><a href="#port-gt-ops-gt-ecp-write-addr-write-a-block-of-ECP-addresses" class="headerlink" title="port-&gt;ops-&gt;ecp_write_addr - write a block of ECP addresses"></a>port-&gt;ops-&gt;ecp_write_addr - write a block of ECP addresses</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    size_t (*ecp_write_addr) (struct parport *port,
                const void *buf, size_t len, int flags);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Writes a block of ECP addresses.  The <code>flags</code> parameter is ignored.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>The number of bytes written.</p>
<p>NOTES<br>^^^^^</p>
<p>This may use a FIFO, and if so shall not return until the FIFO is empty.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>ecp_read_data, ecp_write_data</p>
<h2 id="port-gt-ops-gt-nibble-read-data-read-a-block-of-data-in-nibble-mode"><a href="#port-gt-ops-gt-nibble-read-data-read-a-block-of-data-in-nibble-mode" class="headerlink" title="port-&gt;ops-&gt;nibble_read_data - read a block of data in nibble mode"></a>port-&gt;ops-&gt;nibble_read_data - read a block of data in nibble mode</h2><p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    size_t (*nibble_read_data) (struct parport *port,
                void *buf, size_t len, int flags);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Reads a block of data in nibble mode.  The <code>flags</code> parameter is ignored.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>The number of whole bytes read.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>byte_read_data, compat_write_data</p>
<p><br>port-&gt;ops-&gt;byte_read_data - read a block of data in byte mode</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    size_t (*byte_read_data) (struct parport *port,
                void *buf, size_t len, int flags);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Reads a block of data in byte mode.  The <code>flags</code> parameter is ignored.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>The number of bytes read.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>nibble_read_data, compat_write_data</p>
<p><br>port-&gt;ops-&gt;compat_write_data - write a block of data in compatibility mode</p>
<hr>
<p>SYNOPSIS<br>^^^^^^^^</p>
<p>::</p>
<pre><code>#include &lt;linux/parport.h&gt;

struct parport_operations &#123;
    ...
    size_t (*compat_write_data) (struct parport *port,
                const void *buf, size_t len, int flags);
    ...
&#125;;
</code></pre>
<p>DESCRIPTION<br>^^^^^^^^^^^</p>
<p>Writes a block of data in compatibility mode.  The <code>flags</code> parameter<br>is ignored.</p>
<p>RETURN VALUE<br>^^^^^^^^^^^^</p>
<p>The number of bytes written.</p>
<p>SEE ALSO<br>^^^^^^^^</p>
<p>nibble_read_data, byte_read_data</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_parport-lowlevel/" title="Kernel-4.18.0-80.el8_parport-lowlevel" target="_blank" rel="external">http://www.oostech.com/2021/02/19/Kernel-4.18.0-80.el8_parport-lowlevel/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/02/19/Kernel-4.18.0-80.el8_packet_mmap/" title="Kernel-4.18.0-80.el8_packet_mmap"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/02/19/Kernel-4.18.0-80.el8_runtime_pm/" title="Kernel-4.18.0-80.el8_runtime_p"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>