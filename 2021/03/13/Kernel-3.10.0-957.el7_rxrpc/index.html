<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-3.10.0-957.el7_rxrpc | oosTech.com</title>
  <meta name="description" content="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;             RxRPC NETWORK PROTOCOL             &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  The RxRPC protocol driver provides a reliable two-phase transport on top of UDPthat can be use">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-3.10.0-957.el7_rxrpc">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_rxrpc/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;             RxRPC NETWORK PROTOCOL             &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  The RxRPC protocol driver provides a reliable two-phase transport on top of UDPthat can be use">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_rxrpc/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_mpc5200/" class="title">Kernel-3.10.0-957.el7_mpc5200</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_6pack/" class="title">Kernel-3.10.0-957.el7_6pack</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-3.10.0-957.el7_rxrpc" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-3.10.0-957.el7_rxrpc
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_rxrpc/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_rxrpc/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-3.10.0-957.el7_rxrpc/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <pre><code>            ======================
            RxRPC NETWORK PROTOCOL
            ======================
</code></pre>
<p>The RxRPC protocol driver provides a reliable two-phase transport on top of UDP<br>that can be used to perform RxRPC remote operations.  This is done over sockets<br>of AF_RXRPC family, using sendmsg() and recvmsg() with control data to send and<br>receive data, aborts and errors.</p>
<p>Contents of this document:</p>
<p> (*) Overview.</p>
<p> (*) RxRPC protocol summary.</p>
<p> (*) AF_RXRPC driver model.</p>
<p> (*) Control messages.</p>
<p> (*) Socket options.</p>
<p> (*) Security.</p>
<p> (*) Example client usage.</p>
<p> (*) Example server usage.</p>
<p> (*) AF_RXRPC kernel interface.</p>
<p>========<br>OVERVIEW<br>========</p>
<p>RxRPC is a two-layer protocol.  There is a session layer which provides<br>reliable virtual connections using UDP over IPv4 (or IPv6) as the transport<br>layer, but implements a real network protocol; and there’s the presentation<br>layer which renders structured data to binary blobs and back again using XDR<br>(as does SunRPC):</p>
<pre><code>    +-------------+
    | Application |
    +-------------+
    |     XDR     |        Presentation
    +-------------+
    |    RxRPC    |        Session
    +-------------+
    |     UDP     |        Transport
    +-------------+
</code></pre>
<p>AF_RXRPC provides:</p>
<p> (1) Part of an RxRPC facility for both kernel and userspace applications by<br>     making the session part of it a Linux network protocol (AF_RXRPC).</p>
<p> (2) A two-phase protocol.  The client transmits a blob (the request) and then<br>     receives a blob (the reply), and the server receives the request and then<br>     transmits the reply.</p>
<p> (3) Retention of the reusable bits of the transport system set up for one call<br>     to speed up subsequent calls.</p>
<p> (4) A secure protocol, using the Linux kernel’s key retention facility to<br>     manage security on the client end.  The server end must of necessity be<br>     more active in security negotiations.</p>
<p>AF_RXRPC does not provide XDR marshalling/presentation facilities.  That is<br>left to the application.  AF_RXRPC only deals in blobs.  Even the operation ID<br>is just the first four bytes of the request blob, and as such is beyond the<br>kernel’s interest.</p>
<p>Sockets of AF_RXRPC family are:</p>
<p> (1) created as type SOCK_DGRAM;</p>
<p> (2) provided with a protocol of the type of underlying transport they’re going<br>     to use - currently only PF_INET is supported.</p>
<p>The Andrew File System (AFS) is an example of an application that uses this and<br>that has both kernel (filesystem) and userspace (utility) components.</p>
<p>======================<br>RXRPC PROTOCOL SUMMARY<br>======================</p>
<p>An overview of the RxRPC protocol:</p>
<p> (*) RxRPC sits on top of another networking protocol (UDP is the only option<br>     currently), and uses this to provide network transport.  UDP ports, for<br>     example, provide transport endpoints.</p>
<p> (*) RxRPC supports multiple virtual “connections” from any given transport<br>     endpoint, thus allowing the endpoints to be shared, even to the same<br>     remote endpoint.</p>
<p> (*) Each connection goes to a particular “service”.  A connection may not go<br>     to multiple services.  A service may be considered the RxRPC equivalent of<br>     a port number.  AF_RXRPC permits multiple services to share an endpoint.</p>
<p> (*) Client-originating packets are marked, thus a transport endpoint can be<br>     shared between client and server connections (connections have a<br>     direction).</p>
<p> (*) Up to a billion connections may be supported concurrently between one<br>     local transport endpoint and one service on one remote endpoint.  An RxRPC<br>     connection is described by seven numbers:</p>
<pre><code>Local address    &#125;
Local port    &#125; Transport (UDP) address
Remote address    &#125;
Remote port    &#125;
Direction
Connection ID
Service ID
</code></pre>
<p> (*) Each RxRPC operation is a “call”.  A connection may make up to four<br>     billion calls, but only up to four calls may be in progress on a<br>     connection at any one time.</p>
<p> (*) Calls are two-phase and asymmetric: the client sends its request data,<br>     which the service receives; then the service transmits the reply data<br>     which the client receives.</p>
<p> (*) The data blobs are of indefinite size, the end of a phase is marked with a<br>     flag in the packet.  The number of packets of data making up one blob may<br>     not exceed 4 billion, however, as this would cause the sequence number to<br>     wrap.</p>
<p> (*) The first four bytes of the request data are the service operation ID.</p>
<p> (*) Security is negotiated on a per-connection basis.  The connection is<br>     initiated by the first data packet on it arriving.  If security is<br>     requested, the server then issues a “challenge” and then the client<br>     replies with a “response”.  If the response is successful, the security is<br>     set for the lifetime of that connection, and all subsequent calls made<br>     upon it use that same security.  In the event that the server lets a<br>     connection lapse before the client, the security will be renegotiated if<br>     the client uses the connection again.</p>
<p> (*) Calls use ACK packets to handle reliability.  Data packets are also<br>     explicitly sequenced per call.</p>
<p> (*) There are two types of positive acknowledgement: hard-ACKs and soft-ACKs.<br>     A hard-ACK indicates to the far side that all the data received to a point<br>     has been received and processed; a soft-ACK indicates that the data has<br>     been received but may yet be discarded and re-requested.  The sender may<br>     not discard any transmittable packets until they’ve been hard-ACK’d.</p>
<p> (*) Reception of a reply data packet implicitly hard-ACK’s all the data<br>     packets that make up the request.</p>
<p> (*) An call is complete when the request has been sent, the reply has been<br>     received and the final hard-ACK on the last packet of the reply has<br>     reached the server.</p>
<p> (*) An call may be aborted by either end at any time up to its completion.</p>
<p>=====================<br>AF_RXRPC DRIVER MODEL<br>=====================</p>
<p>About the AF_RXRPC driver:</p>
<p> (*) The AF_RXRPC protocol transparently uses internal sockets of the transport<br>     protocol to represent transport endpoints.</p>
<p> (*) AF_RXRPC sockets map onto RxRPC connection bundles.  Actual RxRPC<br>     connections are handled transparently.  One client socket may be used to<br>     make multiple simultaneous calls to the same service.  One server socket<br>     may handle calls from many clients.</p>
<p> (*) Additional parallel client connections will be initiated to support extra<br>     concurrent calls, up to a tunable limit.</p>
<p> (*) Each connection is retained for a certain amount of time [tunable] after<br>     the last call currently using it has completed in case a new call is made<br>     that could reuse it.</p>
<p> (*) Each internal UDP socket is retained [tunable] for a certain amount of<br>     time [tunable] after the last connection using it discarded, in case a new<br>     connection is made that could use it.</p>
<p> (*) A client-side connection is only shared between calls if they have have<br>     the same key struct describing their security (and assuming the calls<br>     would otherwise share the connection).  Non-secured calls would also be<br>     able to share connections with each other.</p>
<p> (*) A server-side connection is shared if the client says it is.</p>
<p> (*) ACK’ing is handled by the protocol driver automatically, including ping<br>     replying.</p>
<p> (*) SO_KEEPALIVE automatically pings the other side to keep the connection<br>     alive [TODO].</p>
<p> (*) If an ICMP error is received, all calls affected by that error will be<br>     aborted with an appropriate network error passed through recvmsg().</p>
<p>Interaction with the user of the RxRPC socket:</p>
<p> (*) A socket is made into a server socket by binding an address with a<br>     non-zero service ID.</p>
<p> (*) In the client, sending a request is achieved with one or more sendmsgs,<br>     followed by the reply being received with one or more recvmsgs.</p>
<p> (*) The first sendmsg for a request to be sent from a client contains a tag to<br>     be used in all other sendmsgs or recvmsgs associated with that call.  The<br>     tag is carried in the control data.</p>
<p> (*) connect() is used to supply a default destination address for a client<br>     socket.  This may be overridden by supplying an alternate address to the<br>     first sendmsg() of a call (struct msghdr::msg_name).</p>
<p> (*) If connect() is called on an unbound client, a random local port will<br>     bound before the operation takes place.</p>
<p> (*) A server socket may also be used to make client calls.  To do this, the<br>     first sendmsg() of the call must specify the target address.  The server’s<br>     transport endpoint is used to send the packets.</p>
<p> (*) Once the application has received the last message associated with a call,<br>     the tag is guaranteed not to be seen again, and so it can be used to pin<br>     client resources.  A new call can then be initiated with the same tag<br>     without fear of interference.</p>
<p> (*) In the server, a request is received with one or more recvmsgs, then the<br>     the reply is transmitted with one or more sendmsgs, and then the final ACK<br>     is received with a last recvmsg.</p>
<p> (*) When sending data for a call, sendmsg is given MSG_MORE if there’s more<br>     data to come on that call.</p>
<p> (*) When receiving data for a call, recvmsg flags MSG_MORE if there’s more<br>     data to come for that call.</p>
<p> (*) When receiving data or messages for a call, MSG_EOR is flagged by recvmsg<br>     to indicate the terminal message for that call.</p>
<p> (*) A call may be aborted by adding an abort control message to the control<br>     data.  Issuing an abort terminates the kernel’s use of that call’s tag.<br>     Any messages waiting in the receive queue for that call will be discarded.</p>
<p> (*) Aborts, busy notifications and challenge packets are delivered by recvmsg,<br>     and control data messages will be set to indicate the context.  Receiving<br>     an abort or a busy message terminates the kernel’s use of that call’s tag.</p>
<p> (*) The control data part of the msghdr struct is used for a number of things:</p>
<pre><code> (*) The tag of the intended or affected call.

 (*) Sending or receiving errors, aborts and busy notifications.

 (*) Notifications of incoming calls.

 (*) Sending debug requests and receiving debug replies [TODO].
</code></pre>
<p> (*) When the kernel has received and set up an incoming call, it sends a<br>     message to server application to let it know there’s a new call awaiting<br>     its acceptance [recvmsg reports a special control message].  The server<br>     application then uses sendmsg to assign a tag to the new call.  Once that<br>     is done, the first part of the request data will be delivered by recvmsg.</p>
<p> (*) The server application has to provide the server socket with a keyring of<br>     secret keys corresponding to the security types it permits.  When a secure<br>     connection is being set up, the kernel looks up the appropriate secret key<br>     in the keyring and then sends a challenge packet to the client and<br>     receives a response packet.  The kernel then checks the authorisation of<br>     the packet and either aborts the connection or sets up the security.</p>
<p> (*) The name of the key a client will use to secure its communications is<br>     nominated by a socket option.</p>
<p>Notes on recvmsg:</p>
<p> (*) If there’s a sequence of data messages belonging to a particular call on<br>     the receive queue, then recvmsg will keep working through them until:</p>
<pre><code> (a) it meets the end of that call&#39;s received data,

 (b) it meets a non-data message,

 (c) it meets a message belonging to a different call, or

 (d) it fills the user buffer.

 If recvmsg is called in blocking mode, it will keep sleeping, awaiting the
 reception of further data, until one of the above four conditions is met.
</code></pre>
<p> (2) MSG_PEEK operates similarly, but will return immediately if it has put any<br>     data in the buffer rather than sleeping until it can fill the buffer.</p>
<p> (3) If a data message is only partially consumed in filling a user buffer,<br>     then the remainder of that message will be left on the front of the queue<br>     for the next taker.  MSG_TRUNC will never be flagged.</p>
<p> (4) If there is more data to be had on a call (it hasn’t copied the last byte<br>     of the last data message in that phase yet), then MSG_MORE will be<br>     flagged.</p>
<p>================<br>CONTROL MESSAGES<br>================</p>
<p>AF_RXRPC makes use of control messages in sendmsg() and recvmsg() to multiplex<br>calls, to invoke certain actions and to report certain conditions.  These are:</p>
<pre><code>MESSAGE ID        SRT DATA    MEANING
=======================    === ===========    ===============================
RXRPC_USER_CALL_ID    sr- User ID    App&#39;s call specifier
RXRPC_ABORT        srt Abort code    Abort code to issue/received
RXRPC_ACK        -rt n/a        Final ACK received
RXRPC_NET_ERROR        -rt error num    Network error on call
RXRPC_BUSY        -rt n/a        Call rejected (server busy)
RXRPC_LOCAL_ERROR    -rt error num    Local error encountered
RXRPC_NEW_CALL        -r- n/a        New call received
RXRPC_ACCEPT        s-- n/a        Accept new call

(SRT = usable in Sendmsg / delivered by Recvmsg / Terminal message)
</code></pre>
<p> (*) RXRPC_USER_CALL_ID</p>
<pre><code> This is used to indicate the application&#39;s call ID.  It&#39;s an unsigned long
 that the app specifies in the client by attaching it to the first data
 message or in the server by passing it in association with an RXRPC_ACCEPT
 message.  recvmsg() passes it in conjunction with all messages except
 those of the RXRPC_NEW_CALL message.
</code></pre>
<p> (*) RXRPC_ABORT</p>
<pre><code> This is can be used by an application to abort a call by passing it to
 sendmsg, or it can be delivered by recvmsg to indicate a remote abort was
 received.  Either way, it must be associated with an RXRPC_USER_CALL_ID to
 specify the call affected.  If an abort is being sent, then error EBADSLT
 will be returned if there is no call with that user ID.
</code></pre>
<p> (*) RXRPC_ACK</p>
<pre><code> This is delivered to a server application to indicate that the final ACK
 of a call was received from the client.  It will be associated with an
 RXRPC_USER_CALL_ID to indicate the call that&#39;s now complete.
</code></pre>
<p> (*) RXRPC_NET_ERROR</p>
<pre><code> This is delivered to an application to indicate that an ICMP error message
 was encountered in the process of trying to talk to the peer.  An
 errno-class integer value will be included in the control message data
 indicating the problem, and an RXRPC_USER_CALL_ID will indicate the call
 affected.
</code></pre>
<p> (*) RXRPC_BUSY</p>
<pre><code> This is delivered to a client application to indicate that a call was
 rejected by the server due to the server being busy.  It will be
 associated with an RXRPC_USER_CALL_ID to indicate the rejected call.
</code></pre>
<p> (*) RXRPC_LOCAL_ERROR</p>
<pre><code> This is delivered to an application to indicate that a local error was
 encountered and that a call has been aborted because of it.  An
 errno-class integer value will be included in the control message data
 indicating the problem, and an RXRPC_USER_CALL_ID will indicate the call
 affected.
</code></pre>
<p> (*) RXRPC_NEW_CALL</p>
<pre><code> This is delivered to indicate to a server application that a new call has
 arrived and is awaiting acceptance.  No user ID is associated with this,
 as a user ID must subsequently be assigned by doing an RXRPC_ACCEPT.
</code></pre>
<p> (*) RXRPC_ACCEPT</p>
<pre><code> This is used by a server application to attempt to accept a call and
 assign it a user ID.  It should be associated with an RXRPC_USER_CALL_ID
 to indicate the user ID to be assigned.  If there is no call to be
 accepted (it may have timed out, been aborted, etc.), then sendmsg will
 return error ENODATA.  If the user ID is already in use by another call,
 then error EBADSLT will be returned.
</code></pre>
<p>==============<br>SOCKET OPTIONS<br>==============</p>
<p>AF_RXRPC sockets support a few socket options at the SOL_RXRPC level:</p>
<p> (*) RXRPC_SECURITY_KEY</p>
<pre><code> This is used to specify the description of the key to be used.  The key is
 extracted from the calling process&#39;s keyrings with request_key() and
 should be of &quot;rxrpc&quot; type.

 The optval pointer points to the description string, and optlen indicates
 how long the string is, without the NUL terminator.
</code></pre>
<p> (*) RXRPC_SECURITY_KEYRING</p>
<pre><code> Similar to above but specifies a keyring of server secret keys to use (key
 type &quot;keyring&quot;).  See the &quot;Security&quot; section.
</code></pre>
<p> (*) RXRPC_EXCLUSIVE_CONNECTION</p>
<pre><code> This is used to request that new connections should be used for each call
 made subsequently on this socket.  optval should be NULL and optlen 0.
</code></pre>
<p> (*) RXRPC_MIN_SECURITY_LEVEL</p>
<pre><code> This is used to specify the minimum security level required for calls on
 this socket.  optval must point to an int containing one of the following
 values:

 (a) RXRPC_SECURITY_PLAIN

 Encrypted checksum only.

 (b) RXRPC_SECURITY_AUTH

 Encrypted checksum plus packet padded and first eight bytes of packet
 encrypted - which includes the actual packet length.

 (c) RXRPC_SECURITY_ENCRYPTED

 Encrypted checksum plus entire packet padded and encrypted, including
 actual packet length.
</code></pre>
<p>========<br>SECURITY<br>========</p>
<p>Currently, only the kerberos 4 equivalent protocol has been implemented<br>(security index 2 - rxkad).  This requires the rxkad module to be loaded and,<br>on the client, tickets of the appropriate type to be obtained from the AFS<br>kaserver or the kerberos server and installed as “rxrpc” type keys.  This is<br>normally done using the klog program.  An example simple klog program can be<br>found at:</p>
<pre><code>http://people.redhat.com/~dhowells/rxrpc/klog.c
</code></pre>
<p>The payload provided to add_key() on the client should be of the following<br>form:</p>
<pre><code>struct rxrpc_key_sec2_v1 &#123;
    uint16_t    security_index;    /* 2 */
    uint16_t    ticket_length;    /* length of ticket[] */
    uint32_t    expiry;        /* time at which expires */
    uint8_t        kvno;        /* key version number */
    uint8_t        __pad[3];
    uint8_t        session_key[8];    /* DES session key */
    uint8_t        ticket[0];    /* the encrypted ticket */
&#125;;
</code></pre>
<p>Where the ticket blob is just appended to the above structure.</p>
<p>For the server, keys of type “rxrpc_s” must be made available to the server.<br>They have a description of “<serviceID>:<securityIndex>“ (eg: “52:2” for an<br>rxkad key for the AFS VL service).  When such a key is created, it should be<br>given the server’s secret key as the instantiation data (see the example<br>below).</p>
<pre><code>add_key(&quot;rxrpc_s&quot;, &quot;52:2&quot;, secret_key, 8, keyring);
</code></pre>
<p>A keyring is passed to the server socket by naming it in a sockopt.  The server<br>socket then looks the server secret keys up in this keyring when secure<br>incoming connections are made.  This can be seen in an example program that can<br>be found at:</p>
<pre><code>http://people.redhat.com/~dhowells/rxrpc/listen.c
</code></pre>
<p>====================<br>EXAMPLE CLIENT USAGE<br>====================</p>
<p>A client would issue an operation by:</p>
<p> (1) An RxRPC socket is set up by:</p>
<pre><code>client = socket(AF_RXRPC, SOCK_DGRAM, PF_INET);

 Where the third parameter indicates the protocol family of the transport
 socket used - usually IPv4 but it can also be IPv6 [TODO].
</code></pre>
<p> (2) A local address can optionally be bound:</p>
<pre><code>struct sockaddr_rxrpc srx = &#123;
    .srx_family    = AF_RXRPC,
    .srx_service    = 0,  /* we&#39;re a client */
    .transport_type    = SOCK_DGRAM,    /* type of transport socket */
    .transport.sin_family    = AF_INET,
    .transport.sin_port    = htons(7000), /* AFS callback */
    .transport.sin_address    = 0,  /* all local interfaces */
&#125;;
bind(client, &amp;srx, sizeof(srx));

 This specifies the local UDP port to be used.  If not given, a random
 non-privileged port will be used.  A UDP port may be shared between
 several unrelated RxRPC sockets.  Security is handled on a basis of
 per-RxRPC virtual connection.
</code></pre>
<p> (3) The security is set:</p>
<pre><code>const char *key = &quot;AFS:cambridge.redhat.com&quot;;
setsockopt(client, SOL_RXRPC, RXRPC_SECURITY_KEY, key, strlen(key));

 This issues a request_key() to get the key representing the security
 context.  The minimum security level can be set:

unsigned int sec = RXRPC_SECURITY_ENCRYPTED;
setsockopt(client, SOL_RXRPC, RXRPC_MIN_SECURITY_LEVEL,
       &amp;sec, sizeof(sec));
</code></pre>
<p> (4) The server to be contacted can then be specified (alternatively this can<br>     be done through sendmsg):</p>
<pre><code>struct sockaddr_rxrpc srx = &#123;
    .srx_family    = AF_RXRPC,
    .srx_service    = VL_SERVICE_ID,
    .transport_type    = SOCK_DGRAM,    /* type of transport socket */
    .transport.sin_family    = AF_INET,
    .transport.sin_port    = htons(7005), /* AFS volume manager */
    .transport.sin_address    = ...,
&#125;;
connect(client, &amp;srx, sizeof(srx));
</code></pre>
<p> (5) The request data should then be posted to the server socket using a series<br>     of sendmsg() calls, each with the following control message attached:</p>
<pre><code>RXRPC_USER_CALL_ID    - specifies the user ID for this call

 MSG_MORE should be set in msghdr::msg_flags on all but the last part of
 the request.  Multiple requests may be made simultaneously.

 If a call is intended to go to a destination other than the default
 specified through connect(), then msghdr::msg_name should be set on the
 first request message of that call.
</code></pre>
<p> (6) The reply data will then be posted to the server socket for recvmsg() to<br>     pick up.  MSG_MORE will be flagged by recvmsg() if there’s more reply data<br>     for a particular call to be read.  MSG_EOR will be set on the terminal<br>     read for a call.</p>
<pre><code> All data will be delivered with the following control message attached:

RXRPC_USER_CALL_ID    - specifies the user ID for this call

 If an abort or error occurred, this will be returned in the control data
 buffer instead, and MSG_EOR will be flagged to indicate the end of that
 call.
</code></pre>
<p>====================<br>EXAMPLE SERVER USAGE<br>====================</p>
<p>A server would be set up to accept operations in the following manner:</p>
<p> (1) An RxRPC socket is created by:</p>
<pre><code>server = socket(AF_RXRPC, SOCK_DGRAM, PF_INET);

 Where the third parameter indicates the address type of the transport
 socket used - usually IPv4.
</code></pre>
<p> (2) Security is set up if desired by giving the socket a keyring with server<br>     secret keys in it:</p>
<pre><code>keyring = add_key(&quot;keyring&quot;, &quot;AFSkeys&quot;, NULL, 0,
          KEY_SPEC_PROCESS_KEYRING);

const char secret_key[8] = &#123;
    0xa7, 0x83, 0x8a, 0xcb, 0xc7, 0x83, 0xec, 0x94 &#125;;
add_key(&quot;rxrpc_s&quot;, &quot;52:2&quot;, secret_key, 8, keyring);

setsockopt(server, SOL_RXRPC, RXRPC_SECURITY_KEYRING, &quot;AFSkeys&quot;, 7);

 The keyring can be manipulated after it has been given to the socket. This
 permits the server to add more keys, replace keys, etc. whilst it is live.
</code></pre>
<p> (2) A local address must then be bound:</p>
<pre><code>struct sockaddr_rxrpc srx = &#123;
    .srx_family    = AF_RXRPC,
    .srx_service    = VL_SERVICE_ID, /* RxRPC service ID */
    .transport_type    = SOCK_DGRAM,    /* type of transport socket */
    .transport.sin_family    = AF_INET,
    .transport.sin_port    = htons(7000), /* AFS callback */
    .transport.sin_address    = 0,  /* all local interfaces */
&#125;;
bind(server, &amp;srx, sizeof(srx));
</code></pre>
<p> (3) The server is then set to listen out for incoming calls:</p>
<pre><code>listen(server, 100);
</code></pre>
<p> (4) The kernel notifies the server of pending incoming connections by sending<br>     it a message for each.  This is received with recvmsg() on the server<br>     socket.  It has no data, and has a single dataless control message<br>     attached:</p>
<pre><code>RXRPC_NEW_CALL

 The address that can be passed back by recvmsg() at this point should be
 ignored since the call for which the message was posted may have gone by
 the time it is accepted - in which case the first call still on the queue
 will be accepted.
</code></pre>
<p> (5) The server then accepts the new call by issuing a sendmsg() with two<br>     pieces of control data and no actual data:</p>
<pre><code>RXRPC_ACCEPT        - indicate connection acceptance
RXRPC_USER_CALL_ID    - specify user ID for this call
</code></pre>
<p> (6) The first request data packet will then be posted to the server socket for<br>     recvmsg() to pick up.  At that point, the RxRPC address for the call can<br>     be read from the address fields in the msghdr struct.</p>
<pre><code> Subsequent request data will be posted to the server socket for recvmsg()
 to collect as it arrives.  All but the last piece of the request data will
 be delivered with MSG_MORE flagged.

 All data will be delivered with the following control message attached:

RXRPC_USER_CALL_ID    - specifies the user ID for this call
</code></pre>
<p> (8) The reply data should then be posted to the server socket using a series<br>     of sendmsg() calls, each with the following control messages attached:</p>
<pre><code>RXRPC_USER_CALL_ID    - specifies the user ID for this call

 MSG_MORE should be set in msghdr::msg_flags on all but the last message
 for a particular call.
</code></pre>
<p> (9) The final ACK from the client will be posted for retrieval by recvmsg()<br>     when it is received.  It will take the form of a dataless message with two<br>     control messages attached:</p>
<pre><code>RXRPC_USER_CALL_ID    - specifies the user ID for this call
RXRPC_ACK        - indicates final ACK (no data)

 MSG_EOR will be flagged to indicate that this is the final message for
 this call.
</code></pre>
<p>(10) Up to the point the final packet of reply data is sent, the call can be<br>     aborted by calling sendmsg() with a dataless message with the following<br>     control messages attached:</p>
<pre><code>RXRPC_USER_CALL_ID    - specifies the user ID for this call
RXRPC_ABORT        - indicates abort code (4 byte data)

 Any packets waiting in the socket&#39;s receive queue will be discarded if
 this is issued.
</code></pre>
<p>Note that all the communications for a particular service take place through<br>the one server socket, using control messages on sendmsg() and recvmsg() to<br>determine the call affected.</p>
<p>=========================<br>AF_RXRPC KERNEL INTERFACE<br>=========================</p>
<p>The AF_RXRPC module also provides an interface for use by in-kernel utilities<br>such as the AFS filesystem.  This permits such a utility to:</p>
<p> (1) Use different keys directly on individual client calls on one socket<br>     rather than having to open a whole slew of sockets, one for each key it<br>     might want to use.</p>
<p> (2) Avoid having RxRPC call request_key() at the point of issue of a call or<br>     opening of a socket.  Instead the utility is responsible for requesting a<br>     key at the appropriate point.  AFS, for instance, would do this during VFS<br>     operations such as open() or unlink().  The key is then handed through<br>     when the call is initiated.</p>
<p> (3) Request the use of something other than GFP_KERNEL to allocate memory.</p>
<p> (4) Avoid the overhead of using the recvmsg() call.  RxRPC messages can be<br>     intercepted before they get put into the socket Rx queue and the socket<br>     buffers manipulated directly.</p>
<p>To use the RxRPC facility, a kernel utility must still open an AF_RXRPC socket,<br>bind an address as appropriate and listen if it’s to be a server socket, but<br>then it passes this to the kernel interface functions.</p>
<p>The kernel interface functions are as follows:</p>
<p> (*) Begin a new client call.</p>
<pre><code>struct rxrpc_call *
rxrpc_kernel_begin_call(struct socket *sock,
            struct sockaddr_rxrpc *srx,
            struct key *key,
            unsigned long user_call_ID,
            gfp_t gfp);

 This allocates the infrastructure to make a new RxRPC call and assigns
 call and connection numbers.  The call will be made on the UDP port that
 the socket is bound to.  The call will go to the destination address of a
 connected client socket unless an alternative is supplied (srx is
 non-NULL).

 If a key is supplied then this will be used to secure the call instead of
 the key bound to the socket with the RXRPC_SECURITY_KEY sockopt.  Calls
 secured in this way will still share connections if at all possible.

 The user_call_ID is equivalent to that supplied to sendmsg() in the
 control data buffer.  It is entirely feasible to use this to point to a
 kernel data structure.

 If this function is successful, an opaque reference to the RxRPC call is
 returned.  The caller now holds a reference on this and it must be
 properly ended.
</code></pre>
<p> (*) End a client call.</p>
<pre><code>void rxrpc_kernel_end_call(struct rxrpc_call *call);

 This is used to end a previously begun call.  The user_call_ID is expunged
 from AF_RXRPC&#39;s knowledge and will not be seen again in association with
 the specified call.
</code></pre>
<p> (*) Send data through a call.</p>
<pre><code>int rxrpc_kernel_send_data(struct rxrpc_call *call, struct msghdr *msg,
               size_t len);

 This is used to supply either the request part of a client call or the
 reply part of a server call.  msg.msg_iovlen and msg.msg_iov specify the
 data buffers to be used.  msg_iov may not be NULL and must point
 exclusively to in-kernel virtual addresses.  msg.msg_flags may be given
 MSG_MORE if there will be subsequent data sends for this call.

 The msg must not specify a destination address, control data or any flags
 other than MSG_MORE.  len is the total amount of data to transmit.
</code></pre>
<p> (*) Abort a call.</p>
<pre><code>void rxrpc_kernel_abort_call(struct rxrpc_call *call, u32 abort_code);

 This is used to abort a call if it&#39;s still in an abortable state.  The
 abort code specified will be placed in the ABORT message sent.
</code></pre>
<p> (*) Intercept received RxRPC messages.</p>
<pre><code>typedef void (*rxrpc_interceptor_t)(struct sock *sk,
                    unsigned long user_call_ID,
                    struct sk_buff *skb);

void
rxrpc_kernel_intercept_rx_messages(struct socket *sock,
                   rxrpc_interceptor_t interceptor);

 This installs an interceptor function on the specified AF_RXRPC socket.
 All messages that would otherwise wind up in the socket&#39;s Rx queue are
 then diverted to this function.  Note that care must be taken to process
 the messages in the right order to maintain DATA message sequentiality.

 The interceptor function itself is provided with the address of the socket
 and handling the incoming message, the ID assigned by the kernel utility
 to the call and the socket buffer containing the message.

 The skb-&gt;mark field indicates the type of message:

MARK                MEANING
===============================    =======================================
RXRPC_SKB_MARK_DATA        Data message
RXRPC_SKB_MARK_FINAL_ACK    Final ACK received for an incoming call
RXRPC_SKB_MARK_BUSY        Client call rejected as server busy
RXRPC_SKB_MARK_REMOTE_ABORT    Call aborted by peer
RXRPC_SKB_MARK_NET_ERROR    Network error detected
RXRPC_SKB_MARK_LOCAL_ERROR    Local error encountered
RXRPC_SKB_MARK_NEW_CALL        New incoming call awaiting acceptance

 The remote abort message can be probed with rxrpc_kernel_get_abort_code().
 The two error messages can be probed with rxrpc_kernel_get_error_number().
 A new call can be accepted with rxrpc_kernel_accept_call().

 Data messages can have their contents extracted with the usual bunch of
 socket buffer manipulation functions.  A data message can be determined to
 be the last one in a sequence with rxrpc_kernel_is_data_last().  When a
 data message has been used up, rxrpc_kernel_data_delivered() should be
 called on it..

 Non-data messages should be handled to rxrpc_kernel_free_skb() to dispose
 of.  It is possible to get extra refs on all types of message for later
 freeing, but this may pin the state of a call until the message is finally
 freed.
</code></pre>
<p> (*) Accept an incoming call.</p>
<pre><code>struct rxrpc_call *
rxrpc_kernel_accept_call(struct socket *sock,
             unsigned long user_call_ID);

 This is used to accept an incoming call and to assign it a call ID.  This
 function is similar to rxrpc_kernel_begin_call() and calls accepted must
 be ended in the same way.

 If this function is successful, an opaque reference to the RxRPC call is
 returned.  The caller now holds a reference on this and it must be
 properly ended.
</code></pre>
<p> (*) Reject an incoming call.</p>
<pre><code>int rxrpc_kernel_reject_call(struct socket *sock);

 This is used to reject the first incoming call on the socket&#39;s queue with
 a BUSY message.  -ENODATA is returned if there were no incoming calls.
 Other errors may be returned if the call had been aborted (-ECONNABORTED)
 or had timed out (-ETIME).
</code></pre>
<p> (*) Record the delivery of a data message and free it.</p>
<pre><code>void rxrpc_kernel_data_delivered(struct sk_buff *skb);

 This is used to record a data message as having been delivered and to
 update the ACK state for the call.  The socket buffer will be freed.
</code></pre>
<p> (*) Free a message.</p>
<pre><code>void rxrpc_kernel_free_skb(struct sk_buff *skb);

 This is used to free a non-DATA socket buffer intercepted from an AF_RXRPC
 socket.
</code></pre>
<p> (*) Determine if a data message is the last one on a call.</p>
<pre><code>bool rxrpc_kernel_is_data_last(struct sk_buff *skb);

 This is used to determine if a socket buffer holds the last data message
 to be received for a call (true will be returned if it does, false
 if not).

 The data message will be part of the reply on a client call and the
 request on an incoming call.  In the latter case there will be more
 messages, but in the former case there will not.
</code></pre>
<p> (*) Get the abort code from an abort message.</p>
<pre><code>u32 rxrpc_kernel_get_abort_code(struct sk_buff *skb);

 This is used to extract the abort code from a remote abort message.
</code></pre>
<p> (*) Get the error number from a local or network error message.</p>
<pre><code>int rxrpc_kernel_get_error_number(struct sk_buff *skb);

 This is used to extract the error number from a message indicating either
 a local error occurred or a network error occurred.
</code></pre>
<p> (*) Allocate a null key for doing anonymous security.</p>
<pre><code>struct key *rxrpc_get_null_key(const char *keyname);

 This is used to allocate a null RxRPC key that can be used to indicate
 anonymous security for a particular domain.
</code></pre>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_rxrpc/" title="Kernel-3.10.0-957.el7_rxrpc" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_rxrpc/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_rt-mutex-design/" title="Kernel-3.10.0-957.el7_rt-mutex-design"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_runtime_pm/" title="Kernel-3.10.0-957.el7_runtime_p"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>