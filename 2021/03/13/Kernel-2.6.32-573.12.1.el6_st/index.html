<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-2.6.32-573.12.1.el6_st | oosTech.com</title>
  <meta name="description" content="This file contains brief information about the SCSI tape driver.The driver is currently maintained by Kai MÃ¤kisara (email&amp;#x4b;&amp;#97;&amp;#105;&amp;#x2e;&amp;#x4d;&amp;#x61;&amp;#x6b;&amp;#105;&amp;#x73;&amp;#x61;&amp;#x72;&amp;#97;&amp;#64;&amp;#1">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-2.6.32-573.12.1.el6_st">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_st/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="This file contains brief information about the SCSI tape driver.The driver is currently maintained by Kai MÃ¤kisara (email&amp;#x4b;&amp;#97;&amp;#105;&amp;#x2e;&amp;#x4d;&amp;#x61;&amp;#x6b;&amp;#105;&amp;#x73;&amp;#x61;&amp;#x72;&amp;#97;&amp;#64;&amp;#1">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_st/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-2.6.32-573.12.1.el6_st" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-2.6.32-573.12.1.el6_st
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_st/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_st/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_st/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>This file contains brief information about the SCSI tape driver.<br>The driver is currently maintained by Kai MÃ¤kisara (email<br><a href="mailto:&#x4b;&#97;&#105;&#x2e;&#x4d;&#x61;&#x6b;&#105;&#x73;&#x61;&#x72;&#97;&#64;&#107;&#x6f;&#108;&#x75;&#x6d;&#98;&#x75;&#x73;&#46;&#x66;&#105;">&#x4b;&#97;&#105;&#x2e;&#x4d;&#x61;&#x6b;&#105;&#x73;&#x61;&#x72;&#97;&#64;&#107;&#x6f;&#108;&#x75;&#x6d;&#98;&#x75;&#x73;&#46;&#x66;&#105;</a>)</p>
<p>Last modified: Sun Aug 29 18:25:47 2010 by kai.makisara</p>
<p>BASICS</p>
<p>The driver is generic, i.e., it does not contain any code tailored<br>to any specific tape drive. The tape parameters can be specified with<br>one of the following three methods:</p>
<ol>
<li><p>Each user can specify the tape parameters he/she wants to use<br>directly with ioctls. This is administratively a very simple and<br>flexible method and applicable to single-user workstations. However,<br>in a multiuser environment the next user finds the tape parameters in<br>state the previous user left them.</p>
</li>
<li><p>The system manager (root) can define default values for some tape<br>parameters, like block size and density using the MTSETDRVBUFFER ioctl.<br>These parameters can be programmed to come into effect either when a<br>new tape is loaded into the drive or if writing begins at the<br>beginning of the tape. The second method is applicable if the tape<br>drive performs auto-detection of the tape format well (like some<br>QIC-drives). The result is that any tape can be read, writing can be<br>continued using existing format, and the default format is used if<br>the tape is rewritten from the beginning (or a new tape is written<br>for the first time). The first method is applicable if the drive<br>does not perform auto-detection well enough and there is a single<br>“sensible” mode for the device. An example is a DAT drive that is<br>used only in variable block mode (I don’t know if this is sensible<br>or not :-).</p>
</li>
</ol>
<p>The user can override the parameters defined by the system<br>manager. The changes persist until the defaults again come into<br>effect.</p>
<ol start="3">
<li>By default, up to four modes can be defined and selected using the minor<br>number (bits 5 and 6). The number of modes can be changed by changing<br>ST_NBR_MODE_BITS in st.h. Mode 0 corresponds to the defaults discussed<br>above. Additional modes are dormant until they are defined by the<br>system manager (root). When specification of a new mode is started,<br>the configuration of mode 0 is used to provide a starting point for<br>definition of the new mode.</li>
</ol>
<p>Using the modes allows the system manager to give the users choices<br>over some of the buffering parameters not directly accessible to the<br>users (buffered and asynchronous writes). The modes also allow choices<br>between formats in multi-tape operations (the explicitly overridden<br>parameters are reset when a new tape is loaded).</p>
<p>If more than one mode is used, all modes should contain definitions<br>for the same set of parameters.</p>
<p>Many Unices contain internal tables that associate different modes to<br>supported devices. The Linux SCSI tape driver does not contain such<br>tables (and will not do that in future). Instead of that, a utility<br>program can be made that fetches the inquiry data sent by the device,<br>scans its database, and sets up the modes using the ioctls. Another<br>alternative is to make a small script that uses mt to set the defaults<br>tailored to the system.</p>
<p>The driver supports fixed and variable block size (within buffer<br>limits). Both the auto-rewind (minor equals device number) and<br>non-rewind devices (minor is 128 + device number) are implemented.</p>
<p>In variable block mode, the byte count in write() determines the size<br>of the physical block on tape. When reading, the drive reads the next<br>tape block and returns to the user the data if the read() byte count<br>is at least the block size. Otherwise, error ENOMEM is returned.</p>
<p>In fixed block mode, the data transfer between the drive and the<br>driver is in multiples of the block size. The write() byte count must<br>be a multiple of the block size. This is not required when reading but<br>may be advisable for portability.</p>
<p>Support is provided for changing the tape partition and partitioning<br>of the tape with one or two partitions. By default support for<br>partitioned tape is disabled for each driver and it can be enabled<br>with the ioctl MTSETDRVBUFFER.</p>
<p>By default the driver writes one filemark when the device is closed after<br>writing and the last operation has been a write. Two filemarks can be<br>optionally written. In both cases end of data is signified by<br>returning zero bytes for two consecutive reads.</p>
<p>Writing filemarks without the immediate bit set in the SCSI command block acts<br>as a synchronization point, i.e., all remaining data form the drive buffers is<br>written to tape before the command returns. This makes sure that write errors<br>are caught at that point, but this takes time. In some applications, several<br>consecutive files must be written fast. The MTWEOFI operation can be used to<br>write the filemarks without flushing the drive buffer. Writing filemark at<br>close() is always flushing the drive buffers. However, if the previous<br>operation is MTWEOFI, close() does not write a filemark. This can be used if<br>the program wants to close/open the tape device between files and wants to<br>skip waiting.</p>
<p>If rewind, offline, bsf, or seek is done and previous tape operation was<br>write, a filemark is written before moving tape.</p>
<p>The compile options are defined in the file linux/drivers/scsi/st_options.h.</p>
<ol start="4">
<li>If the open option O_NONBLOCK is used, open succeeds even if the<br>drive is not ready. If O_NONBLOCK is not used, the driver waits for<br>the drive to become ready. If this does not happen in ST_BLOCK_SECONDS<br>seconds, open fails with the errno value EIO. With O_NONBLOCK the<br>device can be opened for writing even if there is a write protected<br>tape in the drive (commands trying to write something return error if<br>attempted).</li>
</ol>
<p>MINOR NUMBERS</p>
<p>The tape driver currently supports 128 drives by default. This number<br>can be increased by editing st.h and recompiling the driver if<br>necessary. The upper limit is 2^17 drives if 4 modes for each drive<br>are used.</p>
<p>The minor numbers consist of the following bit fields:</p>
<p>dev_upper non-rew mode dev-lower<br>  20 -  8     7    6 5  4      0<br>The non-rewind bit is always bit 7 (the uppermost bit in the lowermost<br>byte). The bits defining the mode are below the non-rewind bit. The<br>remaining bits define the tape device number. This numbering is<br>backward compatible with the numbering used when the minor number was<br>only 8 bits wide.</p>
<p>SYSFS SUPPORT</p>
<p>The driver creates the directory /sys/class/scsi_tape and populates it with<br>directories corresponding to the existing tape devices. There are autorewind<br>and non-rewind entries for each mode. The names are stxy and nstxy, where x<br>is the tape number and y a character corresponding to the mode (none, l, m,<br>a). For example, the directories for the first tape device are (assuming four<br>modes): st0  nst0  st0l  nst0l  st0m  nst0m  st0a  nst0a.</p>
<p>Each directory contains the entries: default_blksize  default_compression<br>default_density  defined  dev  device  driver. The file ‘defined’ contains 1<br>if the mode is defined and zero if not defined. The files ‘default_*’ contain<br>the defaults set by the user. The value -1 means the default is not set. The<br>file ‘dev’ contains the device numbers corresponding to this device. The links<br>‘device’ and ‘driver’ point to the SCSI device and driver entries.</p>
<p>Each directory also contains the entry ‘options’ which shows the currently<br>enabled driver and mode options. The value in the file is a bit mask where the<br>bit definitions are the same as those used with MTSETDRVBUFFER in setting the<br>options.</p>
<p>A link named ‘tape’ is made from the SCSI device directory to the class<br>directory corresponding to the mode 0 auto-rewind device (e.g., st0). </p>
<p>BSD AND SYS V SEMANTICS</p>
<p>The user can choose between these two behaviours of the tape driver by<br>defining the value of the symbol ST_SYSV. The semantics differ when a<br>file being read is closed. The BSD semantics leaves the tape where it<br>currently is whereas the SYS V semantics moves the tape past the next<br>filemark unless the filemark has just been crossed.</p>
<p>The default is BSD semantics.</p>
<p>BUFFERING</p>
<p>The driver tries to do transfers directly to/from user space. If this<br>is not possible, a driver buffer allocated at run-time is used. If<br>direct i/o is not possible for the whole transfer, the driver buffer<br>is used (i.e., bounce buffers for individual pages are not<br>used). Direct i/o can be impossible because of several reasons, e.g.:</p>
<ul>
<li>one or more pages are at addresses not reachable by the HBA</li>
<li>the number of pages in the transfer exceeds the number of<br>scatter/gather segments permitted by the HBA</li>
<li>one or more pages can’t be locked into memory (should not happen in<br>any reasonable situation)</li>
</ul>
<p>The size of the driver buffers is always at least one tape block. In fixed<br>block mode, the minimum buffer size is defined (in 1024 byte units) by<br>ST_FIXED_BUFFER_BLOCKS. With small block size this allows buffering of<br>several blocks and using one SCSI read or write to transfer all of the<br>blocks. Buffering of data across write calls in fixed block mode is<br>allowed if ST_BUFFER_WRITES is non-zero and direct i/o is not used.<br>Buffer allocation uses chunks of memory having sizes 2^n * (page<br>size). Because of this the actual buffer size may be larger than the<br>minimum allowable buffer size.</p>
<p>NOTE that if direct i/o is used, the small writes are not buffered. This may<br>cause a surprise when moving from 2.4. There small writes (e.g., tar without<br>-b option) may have had good throughput but this is not true any more with<br>2.6. Direct i/o can be turned off to solve this problem but a better solution<br>is to use bigger write() byte counts (e.g., tar -b 64).</p>
<p>Asynchronous writing. Writing the buffer contents to the tape is<br>started and the write call returns immediately. The status is checked<br>at the next tape operation. Asynchronous writes are not done with<br>direct i/o and not in fixed block mode.</p>
<p>Buffered writes and asynchronous writes may in some rare cases cause<br>problems in multivolume operations if there is not enough space on the<br>tape after the early-warning mark to flush the driver buffer.</p>
<p>Read ahead for fixed block mode (ST_READ_AHEAD). Filling the buffer is<br>attempted even if the user does not want to get all of the data at<br>this read command. Should be disabled for those drives that don’t like<br>a filemark to truncate a read request or that don’t like backspacing.</p>
<p>Scatter/gather buffers (buffers that consist of chunks non-contiguous<br>in the physical memory) are used if contiguous buffers can’t be<br>allocated. To support all SCSI adapters (including those not<br>supporting scatter/gather), buffer allocation is using the following<br>three kinds of chunks:</p>
<ol>
<li>The initial segment that is used for all SCSI adapters including<br>those not supporting scatter/gather. The size of this buffer will be<br>(PAGE_SIZE &lt;&lt; ST_FIRST_ORDER) bytes if the system can give a chunk of<br>this size (and it is not larger than the buffer size specified by<br>ST_BUFFER_BLOCKS). If this size is not available, the driver halves<br>the size and tries again until the size of one page. The default<br>settings in st_options.h make the driver to try to allocate all of the<br>buffer as one chunk.</li>
<li>The scatter/gather segments to fill the specified buffer size are<br>allocated so that as many segments as possible are used but the number<br>of segments does not exceed ST_FIRST_SG.</li>
<li>The remaining segments between ST_MAX_SG (or the module parameter<br>max_sg_segs) and the number of segments used in phases 1 and 2<br>are used to extend the buffer at run-time if this is necessary. The<br>number of scatter/gather segments allowed for the SCSI adapter is not<br>exceeded if it is smaller than the maximum number of scatter/gather<br>segments specified. If the maximum number allowed for the SCSI adapter<br>is smaller than the number of segments used in phases 1 and 2,<br>extending the buffer will always fail.</li>
</ol>
<p>EOM BEHAVIOUR WHEN WRITING</p>
<p>When the end of medium early warning is encountered, the current write<br>is finished and the number of bytes is returned. The next write<br>returns -1 and errno is set to ENOSPC. To enable writing a trailer,<br>the next write is allowed to proceed and, if successful, the number of<br>bytes is returned. After this, -1 and the number of bytes are<br>alternately returned until the physical end of medium (or some other<br>error) is encountered.</p>
<p>MODULE PARAMETERS</p>
<p>The buffer size, write threshold, and the maximum number of allocated buffers<br>are configurable when the driver is loaded as a module. The keywords are:</p>
<p>buffer_kbs=xxx             the buffer size for fixed block mode is set<br>               to xxx kilobytes<br>write_threshold_kbs=xxx    the write threshold in kilobytes set to xxx<br>max_sg_segs=xxx           the maximum number of scatter/gather<br>               segments<br>try_direct_io=x           try direct transfer between user buffer and<br>               tape drive if this is non-zero</p>
<p>Note that if the buffer size is changed but the write threshold is not<br>set, the write threshold is set to the new buffer size - 2 kB.</p>
<p>BOOT TIME CONFIGURATION</p>
<p>If the driver is compiled into the kernel, the same parameters can be<br>also set using, e.g., the LILO command line. The preferred syntax is<br>to use the same keyword used when loading as module but prepended<br>with ‘st.’. For instance, to set the maximum number of scatter/gather<br>segments, the parameter ‘st.max_sg_segs=xx’ should be used (xx is the<br>number of scatter/gather segments).</p>
<p>For compatibility, the old syntax from early 2.5 and 2.4 kernel<br>versions is supported. The same keywords can be used as when loading<br>the driver as module. If several parameters are set, the keyword-value<br>pairs are separated with a comma (no spaces allowed). A colon can be<br>used instead of the equal mark. The definition is prepended by the<br>string st=. Here is an example:</p>
<pre><code>st=buffer_kbs:64,write_threshold_kbs:60
</code></pre>
<p>The following syntax used by the old kernel versions is also supported:</p>
<pre><code>       st=aa[,bb[,dd]]
</code></pre>
<p>where<br>  aa is the buffer size for fixed block mode in 1024 byte units<br>  bb is the write threshold in 1024 byte units<br>  dd is the maximum number of scatter/gather segments</p>
<p>IOCTLS</p>
<p>The tape is positioned and the drive parameters are set with ioctls<br>defined in mtio.h The tape control program ‘mt’ uses these ioctls. Try<br>to find an mt that supports all of the Linux SCSI tape ioctls and<br>opens the device for writing if the tape contents will be modified<br>(look for a package mt-st* from the Linux ftp sites; the GNU mt does<br>not open for writing for, e.g., erase).</p>
<p>The supported ioctls are:</p>
<p>The following use the structure mtop:</p>
<p>MTFSF   Space forward over count filemarks. Tape positioned after filemark.<br>MTFSFM  As above but tape positioned before filemark.<br>MTBSF    Space backward over count filemarks. Tape positioned before<br>        filemark.<br>MTBSFM  As above but ape positioned after filemark.<br>MTFSR   Space forward over count records.<br>MTBSR   Space backward over count records.<br>MTFSS   Space forward over count setmarks.<br>MTBSS   Space backward over count setmarks.<br>MTWEOF  Write count filemarks.<br>MTWEOFI    Write count filemarks with immediate bit set (i.e., does not<br>    wait until data is on tape)<br>MTWSM   Write count setmarks.<br>MTREW   Rewind tape.<br>MTOFFL  Set device off line (often rewind plus eject).<br>MTNOP   Do nothing except flush the buffers.<br>MTRETEN Re-tension tape.<br>MTEOM   Space to end of recorded data.<br>MTERASE Erase tape. If the argument is zero, the short erase command<br>    is used. The long erase command is used with all other values<br>    of the argument.<br>MTSEEK    Seek to tape block count. Uses Tandberg-compatible seek (QFA)<br>        for SCSI-1 drives and SCSI-2 seek for SCSI-2 drives. The file and<br>    block numbers in the status are not valid after a seek.<br>MTSETBLK Set the drive block size. Setting to zero sets the drive into<br>        variable block mode (if applicable).<br>MTSETDENSITY Sets the drive density code to arg. See drive<br>        documentation for available codes.<br>MTLOCK and MTUNLOCK Explicitly lock/unlock the tape drive door.<br>MTLOAD and MTUNLOAD Explicitly load and unload the tape. If the<br>    command argument x is between MT_ST_HPLOADER_OFFSET + 1 and<br>    MT_ST_HPLOADER_OFFSET + 6, the number x is used sent to the<br>    drive with the command and it selects the tape slot to use of<br>    HP C1553A changer.<br>MTCOMPRESSION Sets compressing or uncompressing drive mode using the<br>    SCSI mode page 15. Note that some drives other methods for<br>    control of compression. Some drives (like the Exabytes) use<br>    density codes for compression control. Some drives use another<br>    mode page but this page has not been implemented in the<br>    driver. Some drives without compression capability will accept<br>    any compression mode without error.<br>MTSETPART Moves the tape to the partition given by the argument at the<br>    next tape operation. The block at which the tape is positioned<br>    is the block where the tape was previously positioned in the<br>    new active partition unless the next tape operation is<br>    MTSEEK. In this case the tape is moved directly to the block<br>    specified by MTSEEK. MTSETPART is inactive unless<br>    MT_ST_CAN_PARTITIONS set.<br>MTMKPART Formats the tape with one partition (argument zero) or two<br>    partitions (the argument gives in megabytes the size of<br>    partition 1 that is physically the first partition of the<br>    tape). The drive has to support partitions with size specified<br>    by the initiator. Inactive unless MT_ST_CAN_PARTITIONS set.<br>MTSETDRVBUFFER<br>    Is used for several purposes. The command is obtained from count<br>        with mask MT_SET_OPTIONS, the low order bits are used as argument.<br>    This command is only allowed for the superuser (root). The<br>    subcommands are:<br>    0<br>           The drive buffer option is set to the argument. Zero means<br>           no buffering.<br>        MT_ST_BOOLEANS<br>           Sets the buffering options. The bits are the new states<br>           (enabled/disabled) the following options (in the<br>       parenthesis is specified whether the option is global or<br>       can be specified differently for each mode):<br>         MT_ST_BUFFER_WRITES write buffering (mode)<br>         MT_ST_ASYNC_WRITES asynchronous writes (mode)<br>             MT_ST_READ_AHEAD  read ahead (mode)<br>             MT_ST_TWO_FM writing of two filemarks (global)<br>         MT_ST_FAST_EOM using the SCSI spacing to EOD (global)<br>         MT_ST_AUTO_LOCK automatic locking of the drive door (global)<br>             MT_ST_DEF_WRITES the defaults are meant only for writes (mode)<br>         MT_ST_CAN_BSR backspacing over more than one records can<br>        be used for repositioning the tape (global)<br>         MT_ST_NO_BLKLIMS the driver does not ask the block limits<br>        from the drive (block size can be changed only to<br>        variable) (global)<br>         MT_ST_CAN_PARTITIONS enables support for partitioned<br>        tapes (global)<br>         MT_ST_SCSI2LOGICAL the logical block number is used in<br>        the MTSEEK and MTIOCPOS for SCSI-2 drives instead of<br>        the device dependent address. It is recommended to set<br>        this flag unless there are tapes using the device<br>        dependent (from the old times) (global)<br>         MT_ST_SYSV sets the SYSV semantics (mode)<br>         MT_ST_NOWAIT enables immediate mode (i.e., don’t wait for<br>            the command to finish) for some commands (e.g., rewind)<br>         MT_ST_SILI enables setting the SILI bit in SCSI commands when<br>        reading in variable block mode to enhance performance when<br>        reading blocks shorter than the byte count; set this only<br>        if you are sure that the drive supports SILI and the HBA<br>        correctly returns transfer residuals<br>         MT_ST_DEBUGGING debugging (global; debugging must be<br>        compiled into the driver)<br>    MT_ST_SETBOOLEANS<br>    MT_ST_CLEARBOOLEANS<br>       Sets or clears the option bits.<br>        MT_ST_WRITE_THRESHOLD<br>           Sets the write threshold for this device to kilobytes<br>           specified by the lowest bits.<br>    MT_ST_DEF_BLKSIZE<br>       Defines the default block size set automatically. Value<br>       0xffffff means that the default is not used any more.<br>    MT_ST_DEF_DENSITY<br>    MT_ST_DEF_DRVBUFFER<br>       Used to set or clear the density (8 bits), and drive buffer<br>       state (3 bits). If the value is MT_ST_CLEAR_DEFAULT<br>       (0xfffff) the default will not be used any more. Otherwise<br>       the lowermost bits of the value contain the new value of<br>       the parameter.<br>    MT_ST_DEF_COMPRESSION<br>       The compression default will not be used if the value of<br>       the lowermost byte is 0xff. Otherwise the lowermost bit<br>       contains the new default. If the bits 8-15 are set to a<br>       non-zero number, and this number is not 0xff, the number is<br>       used as the compression algorithm. The value<br>       MT_ST_CLEAR_DEFAULT can be used to clear the compression<br>       default.<br>    MT_ST_SET_TIMEOUT<br>       Set the normal timeout in seconds for this device. The<br>       default is 900 seconds (15 minutes). The timeout should be<br>       long enough for the retries done by the device while<br>       reading/writing.<br>    MT_ST_SET_LONG_TIMEOUT<br>       Set the long timeout that is used for operations that are<br>       known to take a long time. The default is 14000 seconds<br>       (3.9 hours). For erase this value is further multiplied by<br>       eight.<br>    MT_ST_SET_CLN<br>       Set the cleaning request interpretation parameters using<br>       the lowest 24 bits of the argument. The driver can set the<br>       generic status bit GMT_CLN if a cleaning request bit pattern<br>       is found from the extended sense data. Many drives set one or<br>       more bits in the extended sense data when the drive needs<br>       cleaning. The bits are device-dependent. The driver is<br>       given the number of the sense data byte (the lowest eight<br>       bits of the argument; must be &gt;= 18 (values 1 - 17<br>       reserved) and &lt;= the maximum requested sense data sixe),<br>       a mask to select the relevant bits (the bits 9-16), and the<br>       bit pattern (bits 17-23). If the bit pattern is zero, one<br>       or more bits under the mask indicate cleaning request. If<br>       the pattern is non-zero, the pattern must match the masked<br>       sense data byte.</p>
<pre><code>   (The cleaning bit is set if the additional sense code and
   qualifier 00h 17h are seen regardless of the setting of
   MT_ST_SET_CLN.)
</code></pre>
<p>The following ioctl uses the structure mtpos:<br>MTIOCPOS Reads the current position from the drive. Uses<br>        Tandberg-compatible QFA for SCSI-1 drives and the SCSI-2<br>        command for the SCSI-2 drives.</p>
<p>The following ioctl uses the structure mtget to return the status:<br>MTIOCGET Returns some status information.<br>        The file number and block number within file are returned. The<br>        block is -1 when it can’t be determined (e.g., after MTBSF).<br>        The drive type is either MTISSCSI1 or MTISSCSI2.<br>        The number of recovered errors since the previous status call<br>        is stored in the lower word of the field mt_erreg.<br>        The current block size and the density code are stored in the field<br>        mt_dsreg (shifts for the subfields are MT_ST_BLKSIZE_SHIFT and<br>        MT_ST_DENSITY_SHIFT).<br>    The GMT_xxx status bits reflect the drive status. GMT_DR_OPEN<br>    is set if there is no tape in the drive. GMT_EOD means either<br>    end of recorded data or end of tape. GMT_EOT means end of tape.</p>
<p>MISCELLANEOUS COMPILE OPTIONS</p>
<p>The recovered write errors are considered fatal if ST_RECOVERED_WRITE_FATAL<br>is defined.</p>
<p>The maximum number of tape devices is determined by the define<br>ST_MAX_TAPES. If more tapes are detected at driver initialization, the<br>maximum is adjusted accordingly.</p>
<p>Immediate return from tape positioning SCSI commands can be enabled by<br>defining ST_NOWAIT. If this is defined, the user should take care that<br>the next tape operation is not started before the previous one has<br>finished. The drives and SCSI adapters should handle this condition<br>gracefully, but some drive/adapter combinations are known to hang the<br>SCSI bus in this case.</p>
<p>The MTEOM command is by default implemented as spacing over 32767<br>filemarks. With this method the file number in the status is<br>correct. The user can request using direct spacing to EOD by setting<br>ST_FAST_EOM 1 (or using the MT_ST_OPTIONS ioctl). In this case the file<br>number will be invalid.</p>
<p>When using read ahead or buffered writes the position within the file<br>may not be correct after the file is closed (correct position may<br>require backspacing over more than one record). The correct position<br>within file can be obtained if ST_IN_FILE_POS is defined at compile<br>time or the MT_ST_CAN_BSR bit is set for the drive with an ioctl.<br>(The driver always backs over a filemark crossed by read ahead if the<br>user does not request data that far.)</p>
<p>DEBUGGING HINTS</p>
<p>Debugging code is now compiled in by default but debugging is turned off<br>with the kernel module parameter debug_flag defaulting to 0.  Debugging<br>can still be switched on and off with an ioctl.  To enable debug at<br>module load time add debug_flag=1 to the module load options, the<br>debugging output is not voluminous.</p>
<p>If the tape seems to hang, I would be very interested to hear where<br>the driver is waiting. With the command ‘ps -l’ you can see the state<br>of the process using the tape. If the state is D, the process is<br>waiting for something. The field WCHAN tells where the driver is<br>waiting. If you have the current System.map in the correct place (in<br>/boot for the procps I use) or have updated /etc/psdatabase (for kmem<br>ps), ps writes the function name in the WCHAN field. If not, you have<br>to look up the function from System.map.</p>
<p>Note also that the timeouts are very long compared to most other<br>drivers. This means that the Linux driver may appear hung although the<br>real reason is that the tape firmware has got confused.</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_st/" title="Kernel-2.6.32-573.12.1.el6_st" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_st/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_stallion/" title="Kernel-2.6.32-573.12.1.el6_stallion"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_spufs/" title="Kernel-2.6.32-573.12.1.el6_spufs"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>