<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-3.10.0-957.el7_kmemcheck | oosTech.com</title>
  <meta name="description" content="GETTING STARTED WITH KMEMCHECKVegard Nossum &amp;#x76;&amp;#x65;&amp;#x67;&amp;#97;&amp;#114;&amp;#x64;&amp;#x6e;&amp;#111;&amp;#x40;&amp;#105;&amp;#102;&amp;#x69;&amp;#x2e;&amp;#117;&amp;#105;&amp;#111;&amp;#46;&amp;#x6e;&amp;#x6f; Contents Introduction Downloading Configuri">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-3.10.0-957.el7_kmemcheck">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_kmemcheck/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="GETTING STARTED WITH KMEMCHECKVegard Nossum &amp;#x76;&amp;#x65;&amp;#x67;&amp;#97;&amp;#114;&amp;#x64;&amp;#x6e;&amp;#111;&amp;#x40;&amp;#105;&amp;#102;&amp;#x69;&amp;#x2e;&amp;#117;&amp;#105;&amp;#111;&amp;#46;&amp;#x6e;&amp;#x6f; Contents Introduction Downloading Configuri">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_kmemcheck/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#GETTING-STARTED-WITH-KMEMCHECK"><span class="toc-number">1.</span> <span class="toc-text">GETTING STARTED WITH KMEMCHECK</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Contents"><span class="toc-number">2.</span> <span class="toc-text">Contents</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-number">3.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Downloading"><span class="toc-number">4.</span> <span class="toc-text">Downloading</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Configuring-and-compiling"><span class="toc-number">5.</span> <span class="toc-text">Configuring and compiling</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#How-to-use"><span class="toc-number">6.</span> <span class="toc-text">How to use</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-1-Booting"><span class="toc-number">7.</span> <span class="toc-text">3.1. Booting</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-2-Run-time-enable-disable"><span class="toc-number">8.</span> <span class="toc-text">3.2. Run-time enable&#x2F;disable</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-3-Debugging"><span class="toc-number">9.</span> <span class="toc-text">3.3. Debugging</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-4-Annotating-false-positives"><span class="toc-number">10.</span> <span class="toc-text">3.4. Annotating false positives</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reporting-errors"><span class="toc-number">11.</span> <span class="toc-text">Reporting errors</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Technical-description"><span class="toc-number">12.</span> <span class="toc-text">Technical description</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-3.10.0-957.el7_kmemcheck" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-3.10.0-957.el7_kmemcheck
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_kmemcheck/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_kmemcheck/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-3.10.0-957.el7_kmemcheck/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="GETTING-STARTED-WITH-KMEMCHECK"><a href="#GETTING-STARTED-WITH-KMEMCHECK" class="headerlink" title="GETTING STARTED WITH KMEMCHECK"></a>GETTING STARTED WITH KMEMCHECK</h1><p>Vegard Nossum <a href="mailto:&#x76;&#x65;&#x67;&#97;&#114;&#x64;&#x6e;&#111;&#x40;&#105;&#102;&#x69;&#x2e;&#117;&#105;&#111;&#46;&#x6e;&#x6f;">&#x76;&#x65;&#x67;&#97;&#114;&#x64;&#x6e;&#111;&#x40;&#105;&#102;&#x69;&#x2e;&#117;&#105;&#111;&#46;&#x6e;&#x6f;</a></p>
<h1 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h1><ol start="0">
<li>Introduction</li>
<li>Downloading</li>
<li>Configuring and compiling</li>
<li>How to use</li>
<li><ol>
<li>Booting</li>
</ol>
</li>
<li><ol start="2">
<li>Run-time enable/disable</li>
</ol>
</li>
<li><ol start="3">
<li>Debugging</li>
</ol>
</li>
<li><ol start="4">
<li>Annotating false positives</li>
</ol>
</li>
<li>Reporting errors</li>
<li>Technical description</li>
</ol>
<ol start="0">
<li><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1></li>
</ol>
<p>kmemcheck is a debugging feature for the Linux Kernel. More specifically, it<br>is a dynamic checker that detects and warns about some uses of uninitialized<br>memory.</p>
<p>Userspace programmers might be familiar with Valgrind’s memcheck. The main<br>difference between memcheck and kmemcheck is that memcheck works for userspace<br>programs only, and kmemcheck works for the kernel only. The implementations<br>are of course vastly different. Because of this, kmemcheck is not as accurate<br>as memcheck, but it turns out to be good enough in practice to discover real<br>programmer errors that the compiler is not able to find through static<br>analysis.</p>
<p>Enabling kmemcheck on a kernel will probably slow it down to the extent that<br>the machine will not be usable for normal workloads such as e.g. an<br>interactive desktop. kmemcheck will also cause the kernel to use about twice<br>as much memory as normal. For this reason, kmemcheck is strictly a debugging<br>feature.</p>
<ol>
<li><h1 id="Downloading"><a href="#Downloading" class="headerlink" title="Downloading"></a>Downloading</h1></li>
</ol>
<p>As of version 2.6.31-rc1, kmemcheck is included in the mainline kernel.</p>
<ol start="2">
<li><h1 id="Configuring-and-compiling"><a href="#Configuring-and-compiling" class="headerlink" title="Configuring and compiling"></a>Configuring and compiling</h1></li>
</ol>
<p>kmemcheck only works for the x86 (both 32- and 64-bit) platform. A number of<br>configuration variables must have specific settings in order for the kmemcheck<br>menu to even appear in “menuconfig”. These are:</p>
<p>  o CONFIG_CC_OPTIMIZE_FOR_SIZE=n</p>
<pre><code>This option is located under &quot;General setup&quot; / &quot;Optimize for size&quot;.

Without this, gcc will use certain optimizations that usually lead to
false positive warnings from kmemcheck. An example of this is a 16-bit
field in a struct, where gcc may load 32 bits, then discard the upper
16 bits. kmemcheck sees only the 32-bit load, and may trigger a
warning for the upper 16 bits (if they&#39;re uninitialized).
</code></pre>
<p>  o CONFIG_SLAB=y or CONFIG_SLUB=y</p>
<pre><code>This option is located under &quot;General setup&quot; / &quot;Choose SLAB
allocator&quot;.
</code></pre>
<p>  o CONFIG_FUNCTION_TRACER=n</p>
<pre><code>This option is located under &quot;Kernel hacking&quot; / &quot;Tracers&quot; / &quot;Kernel
Function Tracer&quot;

When function tracing is compiled in, gcc emits a call to another
function at the beginning of every function. This means that when the
page fault handler is called, the ftrace framework will be called
before kmemcheck has had a chance to handle the fault. If ftrace then
modifies memory that was tracked by kmemcheck, the result is an
endless recursive page fault.
</code></pre>
<p>  o CONFIG_DEBUG_PAGEALLOC=n</p>
<pre><code>This option is located under &quot;Kernel hacking&quot; / &quot;Debug page memory
allocations&quot;.
</code></pre>
<p>In addition, I highly recommend turning on CONFIG_DEBUG_INFO=y. This is also<br>located under “Kernel hacking”. With this, you will be able to get line number<br>information from the kmemcheck warnings, which is extremely valuable in<br>debugging a problem. This option is not mandatory, however, because it slows<br>down the compilation process and produces a much bigger kernel image.</p>
<p>Now the kmemcheck menu should be visible (under “Kernel hacking” / “kmemcheck:<br>trap use of uninitialized memory”). Here follows a description of the<br>kmemcheck configuration variables:</p>
<p>  o CONFIG_KMEMCHECK</p>
<pre><code>This must be enabled in order to use kmemcheck at all...
</code></pre>
<p>  o CONFIG_KMEMCHECK_[DISABLED | ENABLED | ONESHOT]_BY_DEFAULT</p>
<pre><code>This option controls the status of kmemcheck at boot-time. &quot;Enabled&quot;
will enable kmemcheck right from the start, &quot;disabled&quot; will boot the
kernel as normal (but with the kmemcheck code compiled in, so it can
be enabled at run-time after the kernel has booted), and &quot;one-shot&quot; is
a special mode which will turn kmemcheck off automatically after
detecting the first use of uninitialized memory.

If you are using kmemcheck to actively debug a problem, then you
probably want to choose &quot;enabled&quot; here.

The one-shot mode is mostly useful in automated test setups because it
can prevent floods of warnings and increase the chances of the machine
surviving in case something is really wrong. In other cases, the one-
shot mode could actually be counter-productive because it would turn
itself off at the very first error -- in the case of a false positive
too -- and this would come in the way of debugging the specific
problem you were interested in.

If you would like to use your kernel as normal, but with a chance to
enable kmemcheck in case of some problem, it might be a good idea to
choose &quot;disabled&quot; here. When kmemcheck is disabled, most of the run-
time overhead is not incurred, and the kernel will be almost as fast
as normal.
</code></pre>
<p>  o CONFIG_KMEMCHECK_QUEUE_SIZE</p>
<pre><code>Select the maximum number of error reports to store in an internal
(fixed-size) buffer. Since errors can occur virtually anywhere and in
any context, we need a temporary storage area which is guaranteed not
to generate any other page faults when accessed. The queue will be
emptied as soon as a tasklet may be scheduled. If the queue is full,
new error reports will be lost.

The default value of 64 is probably fine. If some code produces more
than 64 errors within an irqs-off section, then the code is likely to
produce many, many more, too, and these additional reports seldom give
any more information (the first report is usually the most valuable
anyway).

This number might have to be adjusted if you are not using serial
console or similar to capture the kernel log. If you are using the
&quot;dmesg&quot; command to save the log, then getting a lot of kmemcheck
warnings might overflow the kernel log itself, and the earlier reports
will get lost in that way instead. Try setting this to 10 or so on
such a setup.
</code></pre>
<p>  o CONFIG_KMEMCHECK_SHADOW_COPY_SHIFT</p>
<pre><code>Select the number of shadow bytes to save along with each entry of the
error-report queue. These bytes indicate what parts of an allocation
are initialized, uninitialized, etc. and will be displayed when an
error is detected to help the debugging of a particular problem.

The number entered here is actually the logarithm of the number of
bytes that will be saved. So if you pick for example 5 here, kmemcheck
will save 2^5 = 32 bytes.

The default value should be fine for debugging most problems. It also
fits nicely within 80 columns.
</code></pre>
<p>  o CONFIG_KMEMCHECK_PARTIAL_OK</p>
<pre><code>This option (when enabled) works around certain GCC optimizations that
produce 32-bit reads from 16-bit variables where the upper 16 bits are
thrown away afterwards.

The default value (enabled) is recommended. This may of course hide
some real errors, but disabling it would probably produce a lot of
false positives.
</code></pre>
<p>  o CONFIG_KMEMCHECK_BITOPS_OK</p>
<pre><code>This option silences warnings that would be generated for bit-field
accesses where not all the bits are initialized at the same time. This
may also hide some real bugs.

This option is probably obsolete, or it should be replaced with
the kmemcheck-/bitfield-annotations for the code in question. The
default value is therefore fine.
</code></pre>
<p>Now compile the kernel as usual.</p>
<ol start="3">
<li><h1 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use"></a>How to use</h1></li>
</ol>
<h1 id="3-1-Booting"><a href="#3-1-Booting" class="headerlink" title="3.1. Booting"></a>3.1. Booting</h1><p>First some information about the command-line options. There is only one<br>option specific to kmemcheck, and this is called “kmemcheck”. It can be used<br>to override the default mode as chosen by the CONFIG_KMEMCHECK_*_BY_DEFAULT<br>option. Its possible settings are:</p>
<p>  o kmemcheck=0 (disabled)<br>  o kmemcheck=1 (enabled)<br>  o kmemcheck=2 (one-shot mode)</p>
<p>If SLUB debugging has been enabled in the kernel, it may take precedence over<br>kmemcheck in such a way that the slab caches which are under SLUB debugging<br>will not be tracked by kmemcheck. In order to ensure that this doesn’t happen<br>(even though it shouldn’t by default), use SLUB’s boot option “slub_debug”,<br>like this: slub_debug=-</p>
<p>In fact, this option may also be used for fine-grained control over SLUB vs.<br>kmemcheck. For example, if the command line includes “kmemcheck=1<br>slub_debug=,dentry”, then SLUB debugging will be used only for the “dentry”<br>slab cache, and with kmemcheck tracking all the other caches. This is advanced<br>usage, however, and is not generally recommended.</p>
<h1 id="3-2-Run-time-enable-disable"><a href="#3-2-Run-time-enable-disable" class="headerlink" title="3.2. Run-time enable/disable"></a>3.2. Run-time enable/disable</h1><p>When the kernel has booted, it is possible to enable or disable kmemcheck at<br>run-time. WARNING: This feature is still experimental and may cause false<br>positive warnings to appear. Therefore, try not to use this. If you find that<br>it doesn’t work properly (e.g. you see an unreasonable amount of warnings), I<br>will be happy to take bug reports.</p>
<p>Use the file /proc/sys/kernel/kmemcheck for this purpose, e.g.:</p>
<pre><code>$ echo 0 &gt; /proc/sys/kernel/kmemcheck # disables kmemcheck
</code></pre>
<p>The numbers are the same as for the kmemcheck= command-line option.</p>
<h1 id="3-3-Debugging"><a href="#3-3-Debugging" class="headerlink" title="3.3. Debugging"></a>3.3. Debugging</h1><p>A typical report will look something like this:</p>
<p>WARNING: kmemcheck: Caught 32-bit read from uninitialized memory (ffff88003e4a2024)<br>80000000000000000000000000000000000000000088ffff0000000000000000<br> i i i i u u u u i i i i i i i i u u u u u u u u u u u u u u u u<br>         ^</p>
<p>Pid: 1856, comm: ntpdate Not tainted 2.6.29-rc5 #264 945P-A<br>RIP: 0010:[<ffffffff8104ede8>]  [<ffffffff8104ede8>] __dequeue_signal+0xc8/0x190<br>RSP: 0018:ffff88003cdf7d98  EFLAGS: 00210002<br>RAX: 0000000000000030 RBX: ffff88003d4ea968 RCX: 0000000000000009<br>RDX: ffff88003e5d6018 RSI: ffff88003e5d6024 RDI: ffff88003cdf7e84<br>RBP: ffff88003cdf7db8 R08: ffff88003e5d6000 R09: 0000000000000000<br>R10: 0000000000000080 R11: 0000000000000000 R12: 000000000000000e<br>R13: ffff88003cdf7e78 R14: ffff88003d530710 R15: ffff88003d5a98c8<br>FS:  0000000000000000(0000) GS:ffff880001982000(0063) knlGS:00000<br>CS:  0010 DS: 002b ES: 002b CR0: 0000000080050033<br>CR2: ffff88003f806ea0 CR3: 000000003c036000 CR4: 00000000000006a0<br>DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000<br>DR3: 0000000000000000 DR6: 00000000ffff4ff0 DR7: 0000000000000400<br> [<ffffffff8104f04e>] dequeue_signal+0x8e/0x170<br> [<ffffffff81050bd8>] get_signal_to_deliver+0x98/0x390<br> [<ffffffff8100b87d>] do_notify_resume+0xad/0x7d0<br> [<ffffffff8100c7b5>] int_signal+0x12/0x17<br> [<ffffffffffffffff>] 0xffffffffffffffff</p>
<p>The single most valuable information in this report is the RIP (or EIP on 32-<br>bit) value. This will help us pinpoint exactly which instruction that caused<br>the warning.</p>
<p>If your kernel was compiled with CONFIG_DEBUG_INFO=y, then all we have to do<br>is give this address to the addr2line program, like this:</p>
<pre><code>$ addr2line -e vmlinux -i ffffffff8104ede8
arch/x86/include/asm/string_64.h:12
include/asm-generic/siginfo.h:287
kernel/signal.c:380
kernel/signal.c:410
</code></pre>
<p>The “-e vmlinux” tells addr2line which file to look in. IMPORTANT: This must<br>be the vmlinux of the kernel that produced the warning in the first place! If<br>not, the line number information will almost certainly be wrong.</p>
<p>The “-i” tells addr2line to also print the line numbers of inlined functions.<br>In this case, the flag was very important, because otherwise, it would only<br>have printed the first line, which is just a call to memcpy(), which could be<br>called from a thousand places in the kernel, and is therefore not very useful.<br>These inlined functions would not show up in the stack trace above, simply<br>because the kernel doesn’t load the extra debugging information. This<br>technique can of course be used with ordinary kernel oopses as well.</p>
<p>In this case, it’s the caller of memcpy() that is interesting, and it can be<br>found in include/asm-generic/siginfo.h, line 287:</p>
<p>281 static inline void copy_siginfo(struct siginfo *to, struct siginfo *from)<br>282 {<br>283         if (from-&gt;si_code &lt; 0)<br>284                 memcpy(to, from, sizeof(*to));<br>285         else<br>286                 /* _sigchld is currently the largest know union member */<br>287                 memcpy(to, from, __ARCH_SI_PREAMBLE_SIZE + sizeof(from-&gt;_sifields._sigchld));<br>288 }</p>
<p>Since this was a read (kmemcheck usually warns about reads only, though it can<br>warn about writes to unallocated or freed memory as well), it was probably the<br>“from” argument which contained some uninitialized bytes. Following the chain<br>of calls, we move upwards to see where “from” was allocated or initialized,<br>kernel/signal.c, line 380:</p>
<p>359 static void collect_signal(int sig, struct sigpending *list, siginfo_t *info)<br>360 {<br>…<br>367         list_for_each_entry(q, &amp;list-&gt;list, list) {<br>368                 if (q-&gt;info.si_signo == sig) {<br>369                         if (first)<br>370                                 goto still_pending;<br>371                         first = q;<br>…<br>377         if (first) {<br>378 still_pending:<br>379                 list_del_init(&amp;first-&gt;list);<br>380                 copy_siginfo(info, &amp;first-&gt;info);<br>381                 __sigqueue_free(first);<br>…<br>392         }<br>393 }</p>
<p>Here, it is &amp;first-&gt;info that is being passed on to copy_siginfo(). The<br>variable “first” was found on a list – passed in as the second argument to<br>collect_signal(). We  continue our journey through the stack, to figure out<br>where the item on “list” was allocated or initialized. We move to line 410:</p>
<p>395 static int __dequeue_signal(struct sigpending *pending, sigset_t *mask,<br>396                         siginfo_t *info)<br>397 {<br>…<br>410                 collect_signal(sig, pending, info);<br>…<br>414 }</p>
<p>Now we need to follow the “pending” pointer, since that is being passed on to<br>collect_signal() as “list”. At this point, we’ve run out of lines from the<br>“addr2line” output. Not to worry, we just paste the next addresses from the<br>kmemcheck stack dump, i.e.:</p>
<p> [<ffffffff8104f04e>] dequeue_signal+0x8e/0x170<br> [<ffffffff81050bd8>] get_signal_to_deliver+0x98/0x390<br> [<ffffffff8100b87d>] do_notify_resume+0xad/0x7d0<br> [<ffffffff8100c7b5>] int_signal+0x12/0x17</p>
<pre><code>$ addr2line -e vmlinux -i ffffffff8104f04e ffffffff81050bd8 \
    ffffffff8100b87d ffffffff8100c7b5
kernel/signal.c:446
kernel/signal.c:1806
arch/x86/kernel/signal.c:805
arch/x86/kernel/signal.c:871
arch/x86/kernel/entry_64.S:694
</code></pre>
<p>Remember that since these addresses were found on the stack and not as the<br>RIP value, they actually point to the <em>next</em> instruction (they are return<br>addresses). This becomes obvious when we look at the code for line 446:</p>
<p>422 int dequeue_signal(struct task_struct <em>tsk, sigset_t *mask, siginfo_t *info)<br>423 {<br>…<br>431                 signr = __dequeue_signal(&amp;tsk-&gt;signal-&gt;shared_pending,<br>432                                          mask, info);<br>433                 /</em><br>434                  * itimer signal ?<br>435                  *<br>436                  * itimers are process shared and we restart periodic<br>437                  * itimers in the signal delivery path to prevent DoS<br>438                  * attacks in the high resolution timer case. This is<br>439                  * compliant with the old way of self restarting<br>440                  * itimers, as the SIGALRM is a legacy signal and only<br>441                  * queued once. Changing the restart behaviour to<br>442                  * restart the timer in the signal dequeue path is<br>443                  * reducing the timer noise on heavy loaded !highres<br>444                  * systems too.<br>445                  */<br>446                 if (unlikely(signr == SIGALRM)) {<br>…<br>489 }</p>
<p>So instead of looking at 446, we should be looking at 431, which is the line<br>that executes just before 446. Here we see that what we are looking for is<br>&amp;tsk-&gt;signal-&gt;shared_pending.</p>
<p>Our next task is now to figure out which function that puts items on this<br>“shared_pending” list. A crude, but efficient tool, is git grep:</p>
<pre><code>$ git grep -n &#39;shared_pending&#39; kernel/
...
kernel/signal.c:828:    pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;
kernel/signal.c:1339:   pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;
...
</code></pre>
<p>There were more results, but none of them were related to list operations,<br>and these were the only assignments. We inspect the line numbers more closely<br>and find that this is indeed where items are being added to the list:</p>
<p>816 static int send_signal(int sig, struct siginfo *info, struct task_struct *t,<br>817                         int group)<br>818 {<br>…<br>828         pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;<br>…<br>851         q = __sigqueue_alloc(t, GFP_ATOMIC, (sig &lt; SIGRTMIN &amp;&amp;<br>852                                              (is_si_special(info) ||<br>853                                               info-&gt;si_code &gt;= 0)));<br>854         if (q) {<br>855                 list_add_tail(&amp;q-&gt;list, &amp;pending-&gt;list);<br>…<br>890 }</p>
<p>and:</p>
<p>1309 int send_sigqueue(struct sigqueue *q, struct task_struct *t, int group)<br>1310 {<br>….<br>1339         pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;<br>1340         list_add_tail(&amp;q-&gt;list, &amp;pending-&gt;list);<br>….<br>1347 }</p>
<p>In the first case, the list element we are looking for, “q”, is being returned<br>from the function __sigqueue_alloc(), which looks like an allocation function.<br>Let’s take a look at it:</p>
<p>187 static struct sigqueue *__sigqueue_alloc(struct task_struct <em>t, gfp_t flags,<br>188                                          int override_rlimit)<br>189 {<br>190         struct sigqueue *q = NULL;<br>191         struct user_struct *user;<br>192<br>193         /</em><br>194          * We won’t get problems with the target’s UID changing under us<br>195          * because changing it requires RCU be used, and if t != current, the<br>196          * caller must be holding the RCU readlock (by way of a spinlock) and<br>197          * we use RCU protection here<br>198          */<br>199         user = get_uid(__task_cred(t)-&gt;user);<br>200         atomic_inc(&amp;user-&gt;sigpending);<br>201         if (override_rlimit ||<br>202             atomic_read(&amp;user-&gt;sigpending) &lt;=<br>203                         t-&gt;signal-&gt;rlim[RLIMIT_SIGPENDING].rlim_cur)<br>204                 q = kmem_cache_alloc(sigqueue_cachep, flags);<br>205         if (unlikely(q == NULL)) {<br>206                 atomic_dec(&amp;user-&gt;sigpending);<br>207                 free_uid(user);<br>208         } else {<br>209                 INIT_LIST_HEAD(&amp;q-&gt;list);<br>210                 q-&gt;flags = 0;<br>211                 q-&gt;user = user;<br>212         }<br>213<br>214         return q;<br>215 }</p>
<p>We see that this function initializes q-&gt;list, q-&gt;flags, and q-&gt;user. It seems<br>that now is the time to look at the definition of “struct sigqueue”, e.g.:</p>
<p>14 struct sigqueue {<br>15         struct list_head list;<br>16         int flags;<br>17         siginfo_t info;<br>18         struct user_struct *user;<br>19 };</p>
<p>And, you might remember, it was a memcpy() on &amp;first-&gt;info that caused the<br>warning, so this makes perfect sense. It also seems reasonable to assume that<br>it is the caller of __sigqueue_alloc() that has the responsibility of filling<br>out (initializing) this member.</p>
<p>But just which fields of the struct were uninitialized? Let’s look at<br>kmemcheck’s report again:</p>
<p>WARNING: kmemcheck: Caught 32-bit read from uninitialized memory (ffff88003e4a2024)<br>80000000000000000000000000000000000000000088ffff0000000000000000<br> i i i i u u u u i i i i i i i i u u u u u u u u u u u u u u u u<br>         ^</p>
<p>These first two lines are the memory dump of the memory object itself, and the<br>shadow bytemap, respectively. The memory object itself is in this case<br>&amp;first-&gt;info. Just beware that the start of this dump is NOT the start of the<br>object itself! The position of the caret (^) corresponds with the address of<br>the read (ffff88003e4a2024).</p>
<p>The shadow bytemap dump legend is as follows:</p>
<p>  i - initialized<br>  u - uninitialized<br>  a - unallocated (memory has been allocated by the slab layer, but has not<br>      yet been handed off to anybody)<br>  f - freed (memory has been allocated by the slab layer, but has been freed<br>      by the previous owner)</p>
<p>In order to figure out where (relative to the start of the object) the<br>uninitialized memory was located, we have to look at the disassembly. For<br>that, we’ll need the RIP address again:</p>
<p>RIP: 0010:[<ffffffff8104ede8>]  [<ffffffff8104ede8>] __dequeue_signal+0xc8/0x190</p>
<pre><code>$ objdump -d --no-show-raw-insn vmlinux | grep -C 8 ffffffff8104ede8:
ffffffff8104edc8:       mov    %r8,0x8(%r8)
ffffffff8104edcc:       test   %r10d,%r10d
ffffffff8104edcf:       js     ffffffff8104ee88 &lt;__dequeue_signal+0x168&gt;
ffffffff8104edd5:       mov    %rax,%rdx
ffffffff8104edd8:       mov    $0xc,%ecx
ffffffff8104eddd:       mov    %r13,%rdi
ffffffff8104ede0:       mov    $0x30,%eax
ffffffff8104ede5:       mov    %rdx,%rsi
ffffffff8104ede8:       rep movsl %ds:(%rsi),%es:(%rdi)
ffffffff8104edea:       test   $0x2,%al
ffffffff8104edec:       je     ffffffff8104edf0 &lt;__dequeue_signal+0xd0&gt;
ffffffff8104edee:       movsw  %ds:(%rsi),%es:(%rdi)
ffffffff8104edf0:       test   $0x1,%al
ffffffff8104edf2:       je     ffffffff8104edf5 &lt;__dequeue_signal+0xd5&gt;
ffffffff8104edf4:       movsb  %ds:(%rsi),%es:(%rdi)
ffffffff8104edf5:       mov    %r8,%rdi
ffffffff8104edf8:       callq  ffffffff8104de60 &lt;__sigqueue_free&gt;
</code></pre>
<p>As expected, it’s the “rep movsl” instruction from the memcpy() that causes<br>the warning. We know about REP MOVSL that it uses the register RCX to count<br>the number of remaining iterations. By taking a look at the register dump<br>again (from the kmemcheck report), we can figure out how many bytes were left<br>to copy:</p>
<p>RAX: 0000000000000030 RBX: ffff88003d4ea968 RCX: 0000000000000009</p>
<p>By looking at the disassembly, we also see that %ecx is being loaded with the<br>value $0xc just before (ffffffff8104edd8), so we are very lucky. Keep in mind<br>that this is the number of iterations, not bytes. And since this is a “long”<br>operation, we need to multiply by 4 to get the number of bytes. So this means<br>that the uninitialized value was encountered at 4 * (0xc - 0x9) = 12 bytes<br>from the start of the object.</p>
<p>We can now try to figure out which field of the “struct siginfo” that was not<br>initialized. This is the beginning of the struct:</p>
<p>40 typedef struct siginfo {<br>41         int si_signo;<br>42         int si_errno;<br>43         int si_code;<br>44<br>45         union {<br>..<br>92         } _sifields;<br>93 } siginfo_t;</p>
<p>On 64-bit, the int is 4 bytes long, so it must the the union member that has<br>not been initialized. We can verify this using gdb:</p>
<pre><code>$ gdb vmlinux
...
(gdb) p &amp;((struct siginfo *) 0)-&gt;_sifields
$1 = (union &#123;...&#125; *) 0x10
</code></pre>
<p>Actually, it seems that the union member is located at offset 0x10 – which<br>means that gcc has inserted 4 bytes of padding between the members si_code<br>and _sifields. We can now get a fuller picture of the memory dump:</p>
<pre><code>     _----------------------------=&gt; si_code
    /        _--------------------=&gt; (padding)
   |        /        _------------=&gt; _sifields(._kill._pid)
   |       |        /        _----=&gt; _sifields(._kill._uid)
   |       |       |        / 
</code></pre>
<p>——-|——-|——-|——-|<br>80000000000000000000000000000000000000000088ffff0000000000000000<br> i i i i u u u u i i i i i i i i u u u u u u u u u u u u u u u u</p>
<p>This allows us to realize another important fact: si_code contains the value<br>0x80. Remember that x86 is little endian, so the first 4 bytes “80000000” are<br>really the number 0x00000080. With a bit of research, we find that this is<br>actually the constant SI_KERNEL defined in include/asm-generic/siginfo.h:</p>
<p>144 #define SI_KERNEL       0x80            /* sent by the kernel from somewhere     */</p>
<p>This macro is used in exactly one place in the x86 kernel: In send_signal()<br>in kernel/signal.c:</p>
<p>816 static int send_signal(int sig, struct siginfo *info, struct task_struct *t,<br>817                         int group)<br>818 {<br>…<br>828         pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;<br>…<br>851         q = __sigqueue_alloc(t, GFP_ATOMIC, (sig &lt; SIGRTMIN &amp;&amp;<br>852                                              (is_si_special(info) ||<br>853                                               info-&gt;si_code &gt;= 0)));<br>854         if (q) {<br>855                 list_add_tail(&amp;q-&gt;list, &amp;pending-&gt;list);<br>856                 switch ((unsigned long) info) {<br>…<br>865                 case (unsigned long) SEND_SIG_PRIV:<br>866                         q-&gt;info.si_signo = sig;<br>867                         q-&gt;info.si_errno = 0;<br>868                         q-&gt;info.si_code = SI_KERNEL;<br>869                         q-&gt;info.si_pid = 0;<br>870                         q-&gt;info.si_uid = 0;<br>871                         break;<br>…<br>890 }</p>
<p>Not only does this match with the .si_code member, it also matches the place<br>we found earlier when looking for where siginfo_t objects are enqueued on the<br>“shared_pending” list.</p>
<p>So to sum up: It seems that it is the padding introduced by the compiler<br>between two struct fields that is uninitialized, and this gets reported when<br>we do a memcpy() on the struct. This means that we have identified a false<br>positive warning.</p>
<p>Normally, kmemcheck will not report uninitialized accesses in memcpy() calls<br>when both the source and destination addresses are tracked. (Instead, we copy<br>the shadow bytemap as well). In this case, the destination address clearly<br>was not tracked. We can dig a little deeper into the stack trace from above:</p>
<pre><code>arch/x86/kernel/signal.c:805
arch/x86/kernel/signal.c:871
arch/x86/kernel/entry_64.S:694
</code></pre>
<p>And we clearly see that the destination siginfo object is located on the<br>stack:</p>
<p>782 static void do_signal(struct pt_regs *regs)<br>783 {<br>784         struct k_sigaction ka;<br>785         siginfo_t info;<br>…<br>804         signr = get_signal_to_deliver(&amp;info, &amp;ka, regs, NULL);<br>…<br>854 }</p>
<p>And this &amp;info is what eventually gets passed to copy_siginfo() as the<br>destination argument.</p>
<p>Now, even though we didn’t find an actual error here, the example is still a<br>good one, because it shows how one would go about to find out what the report<br>was all about.</p>
<h1 id="3-4-Annotating-false-positives"><a href="#3-4-Annotating-false-positives" class="headerlink" title="3.4. Annotating false positives"></a>3.4. Annotating false positives</h1><p>There are a few different ways to make annotations in the source code that<br>will keep kmemcheck from checking and reporting certain allocations. Here<br>they are:</p>
<p>  o __GFP_NOTRACK_FALSE_POSITIVE</p>
<pre><code>This flag can be passed to kmalloc() or kmem_cache_alloc() (therefore
also to other functions that end up calling one of these) to indicate
that the allocation should not be tracked because it would lead to
a false positive report. This is a &quot;big hammer&quot; way of silencing
kmemcheck; after all, even if the false positive pertains to 
particular field in a struct, for example, we will now lose the
ability to find (real) errors in other parts of the same struct.

Example:

    /* No warnings will ever trigger on accessing any part of x */
    x = kmalloc(sizeof *x, GFP_KERNEL | __GFP_NOTRACK_FALSE_POSITIVE);
</code></pre>
<p>  o kmemcheck_bitfield_begin(name)/kmemcheck_bitfield_end(name) and<br>    kmemcheck_annotate_bitfield(ptr, name)</p>
<pre><code>The first two of these three macros can be used inside struct
definitions to signal, respectively, the beginning and end of a
bitfield. Additionally, this will assign the bitfield a name, which
is given as an argument to the macros.

Having used these markers, one can later use
kmemcheck_annotate_bitfield() at the point of allocation, to indicate
which parts of the allocation is part of a bitfield.

Example:

    struct foo &#123;
    int x;

    kmemcheck_bitfield_begin(flags);
    int flag_a:1;
    int flag_b:1;
    kmemcheck_bitfield_end(flags);

    int y;
    &#125;;

    struct foo *x = kmalloc(sizeof *x);

    /* No warnings will trigger on accessing the bitfield of x */
    kmemcheck_annotate_bitfield(x, flags);

Note that kmemcheck_annotate_bitfield() can be used even before the
return value of kmalloc() is checked -- in other words, passing NULL
as the first argument is legal (and will do nothing).
</code></pre>
<ol start="4">
<li><h1 id="Reporting-errors"><a href="#Reporting-errors" class="headerlink" title="Reporting errors"></a>Reporting errors</h1></li>
</ol>
<p>As we have seen, kmemcheck will produce false positive reports. Therefore, it<br>is not very wise to blindly post kmemcheck warnings to mailing lists and<br>maintainers. Instead, I encourage maintainers and developers to find errors<br>in their own code. If you get a warning, you can try to work around it, try<br>to figure out if it’s a real error or not, or simply ignore it. Most<br>developers know their own code and will quickly and efficiently determine the<br>root cause of a kmemcheck report. This is therefore also the most efficient<br>way to work with kmemcheck.</p>
<p>That said, we (the kmemcheck maintainers) will always be on the lookout for<br>false positives that we can annotate and silence. So whatever you find,<br>please drop us a note privately! Kernel configs and steps to reproduce (if<br>available) are of course a great help too.</p>
<p>Happy hacking!</p>
<ol start="5">
<li><h1 id="Technical-description"><a href="#Technical-description" class="headerlink" title="Technical description"></a>Technical description</h1></li>
</ol>
<p>kmemcheck works by marking memory pages non-present. This means that whenever<br>somebody attempts to access the page, a page fault is generated. The page<br>fault handler notices that the page was in fact only hidden, and so it calls<br>on the kmemcheck code to make further investigations.</p>
<p>When the investigations are completed, kmemcheck “shows” the page by marking<br>it present (as it would be under normal circumstances). This way, the<br>interrupted code can continue as usual.</p>
<p>But after the instruction has been executed, we should hide the page again, so<br>that we can catch the next access too! Now kmemcheck makes use of a debugging<br>feature of the processor, namely single-stepping. When the processor has<br>finished the one instruction that generated the memory access, a debug<br>exception is raised. From here, we simply hide the page again and continue<br>execution, this time with the single-stepping feature turned off.</p>
<p>kmemcheck requires some assistance from the memory allocator in order to work.<br>The memory allocator needs to</p>
<ol>
<li><p>Tell kmemcheck about newly allocated pages and pages that are about to<br>be freed. This allows kmemcheck to set up and tear down the shadow memory<br>for the pages in question. The shadow memory stores the status of each<br>byte in the allocation proper, e.g. whether it is initialized or<br>uninitialized.</p>
</li>
<li><p>Tell kmemcheck which parts of memory should be marked uninitialized.<br>There are actually a few more states, such as “not yet allocated” and<br>“recently freed”.</p>
</li>
</ol>
<p>If a slab cache is set up using the SLAB_NOTRACK flag, it will never return<br>memory that can take page faults because of kmemcheck.</p>
<p>If a slab cache is NOT set up using the SLAB_NOTRACK flag, callers can still<br>request memory with the __GFP_NOTRACK or __GFP_NOTRACK_FALSE_POSITIVE flags.<br>This does not prevent the page faults from occurring, however, but marks the<br>object in question as being initialized so that no warnings will ever be<br>produced for this object.</p>
<p>Currently, the SLAB and SLUB allocators are supported by kmemcheck.</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_kmemcheck/" title="Kernel-3.10.0-957.el7_kmemcheck" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_kmemcheck/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_kobject/" title="Kernel-3.10.0-957.el7_kobject"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_kdump/" title="Kernel-3.10.0-957.el7_kdump"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>