<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-3.10.0-957.el7_v4l2-controls | oosTech.com</title>
  <meta name="description" content="IntroductionThe V4L2 control API seems simple enough, but quickly becomes very hard toimplement correctly in drivers. But much of the code needed to handle controlsis actually not driver specific and">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-3.10.0-957.el7_v4l2-controls">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_v4l2-controls/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="IntroductionThe V4L2 control API seems simple enough, but quickly becomes very hard toimplement correctly in drivers. But much of the code needed to handle controlsis actually not driver specific and">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_v4l2-controls/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Objects-in-the-framework"><span class="toc-number">2.</span> <span class="toc-text">Objects in the framework</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Basic-usage-for-V4L2-and-sub-device-drivers"><span class="toc-number">3.</span> <span class="toc-text">Basic usage for V4L2 and sub-device drivers</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Inheriting-Controls"><span class="toc-number">4.</span> <span class="toc-text">Inheriting Controls</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Accessing-Control-Values"><span class="toc-number">5.</span> <span class="toc-text">Accessing Control Values</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Menu-Controls"><span class="toc-number">6.</span> <span class="toc-text">Menu Controls</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Custom-Controls"><span class="toc-number">7.</span> <span class="toc-text">Custom Controls</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Active-and-Grabbed-Controls"><span class="toc-number">8.</span> <span class="toc-text">Active and Grabbed Controls</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Control-Clusters"><span class="toc-number">9.</span> <span class="toc-text">Control Clusters</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Handling-autogain-gain-type-Controls-with-Auto-Clusters"><span class="toc-number">10.</span> <span class="toc-text">Handling autogain&#x2F;gain-type Controls with Auto Clusters</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VIDIOC-LOG-STATUS-Support"><span class="toc-number">11.</span> <span class="toc-text">VIDIOC_LOG_STATUS Support</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Different-Handlers-for-Different-Video-Nodes"><span class="toc-number">12.</span> <span class="toc-text">Different Handlers for Different Video Nodes</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Finding-Controls"><span class="toc-number">13.</span> <span class="toc-text">Finding Controls</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Inheriting-Controls-1"><span class="toc-number">14.</span> <span class="toc-text">Inheriting Controls</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#V4L2-CTRL-TYPE-CTRL-CLASS-Controls"><span class="toc-number">15.</span> <span class="toc-text">V4L2_CTRL_TYPE_CTRL_CLASS Controls</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Adding-Notify-Callbacks"><span class="toc-number">16.</span> <span class="toc-text">Adding Notify Callbacks</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-3.10.0-957.el7_v4l2-controls" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-3.10.0-957.el7_v4l2-controls
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_v4l2-controls/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_v4l2-controls/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-3.10.0-957.el7_v4l2-controls/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>The V4L2 control API seems simple enough, but quickly becomes very hard to<br>implement correctly in drivers. But much of the code needed to handle controls<br>is actually not driver specific and can be moved to the V4L core framework.</p>
<p>After all, the only part that a driver developer is interested in is:</p>
<ol>
<li>How do I add a control?</li>
<li>How do I set the control’s value? (i.e. s_ctrl)</li>
</ol>
<p>And occasionally:</p>
<ol start="3">
<li>How do I get the control’s value? (i.e. g_volatile_ctrl)</li>
<li>How do I validate the user’s proposed control value? (i.e. try_ctrl)</li>
</ol>
<p>All the rest is something that can be done centrally.</p>
<p>The control framework was created in order to implement all the rules of the<br>V4L2 specification with respect to controls in a central place. And to make<br>life as easy as possible for the driver developer.</p>
<p>Note that the control framework relies on the presence of a struct v4l2_device<br>for V4L2 drivers and struct v4l2_subdev for sub-device drivers.</p>
<h1 id="Objects-in-the-framework"><a href="#Objects-in-the-framework" class="headerlink" title="Objects in the framework"></a>Objects in the framework</h1><p>There are two main objects:</p>
<p>The v4l2_ctrl object describes the control properties and keeps track of the<br>control’s value (both the current value and the proposed new value).</p>
<p>v4l2_ctrl_handler is the object that keeps track of controls. It maintains a<br>list of v4l2_ctrl objects that it owns and another list of references to<br>controls, possibly to controls owned by other handlers.</p>
<h1 id="Basic-usage-for-V4L2-and-sub-device-drivers"><a href="#Basic-usage-for-V4L2-and-sub-device-drivers" class="headerlink" title="Basic usage for V4L2 and sub-device drivers"></a>Basic usage for V4L2 and sub-device drivers</h1><ol>
<li>Prepare the driver:</li>
</ol>
<p>1.1) Add the handler to your driver’s top-level struct:</p>
<pre><code>struct foo_dev &#123;
    ...
    struct v4l2_ctrl_handler ctrl_handler;
    ...
&#125;;

struct foo_dev *foo;
</code></pre>
<p>1.2) Initialize the handler:</p>
<pre><code>v4l2_ctrl_handler_init(&amp;foo-&gt;ctrl_handler, nr_of_controls);
</code></pre>
<p>  The second argument is a hint telling the function how many controls this<br>  handler is expected to handle. It will allocate a hashtable based on this<br>  information. It is a hint only.</p>
<p>1.3) Hook the control handler into the driver:</p>
<p>1.3.1) For V4L2 drivers do this:</p>
<pre><code>struct foo_dev &#123;
    ...
    struct v4l2_device v4l2_dev;
    ...
    struct v4l2_ctrl_handler ctrl_handler;
    ...
&#125;;

foo-&gt;v4l2_dev.ctrl_handler = &amp;foo-&gt;ctrl_handler;
</code></pre>
<p>  Where foo-&gt;v4l2_dev is of type struct v4l2_device.</p>
<p>  Finally, remove all control functions from your v4l2_ioctl_ops:<br>  vidioc_queryctrl, vidioc_querymenu, vidioc_g_ctrl, vidioc_s_ctrl,<br>  vidioc_g_ext_ctrls, vidioc_try_ext_ctrls and vidioc_s_ext_ctrls.<br>  Those are now no longer needed.</p>
<p>1.3.2) For sub-device drivers do this:</p>
<pre><code>struct foo_dev &#123;
    ...
    struct v4l2_subdev sd;
    ...
    struct v4l2_ctrl_handler ctrl_handler;
    ...
&#125;;

foo-&gt;sd.ctrl_handler = &amp;foo-&gt;ctrl_handler;
</code></pre>
<p>  Where foo-&gt;sd is of type struct v4l2_subdev.</p>
<p>  And set all core control ops in your struct v4l2_subdev_core_ops to these<br>  helpers:</p>
<pre><code>.queryctrl = v4l2_subdev_queryctrl,
.querymenu = v4l2_subdev_querymenu,
.g_ctrl = v4l2_subdev_g_ctrl,
.s_ctrl = v4l2_subdev_s_ctrl,
.g_ext_ctrls = v4l2_subdev_g_ext_ctrls,
.try_ext_ctrls = v4l2_subdev_try_ext_ctrls,
.s_ext_ctrls = v4l2_subdev_s_ext_ctrls,
</code></pre>
<p>  Note: this is a temporary solution only. Once all V4L2 drivers that depend<br>  on subdev drivers are converted to the control framework these helpers will<br>  no longer be needed.</p>
<p>1.4) Clean up the handler at the end:</p>
<pre><code>v4l2_ctrl_handler_free(&amp;foo-&gt;ctrl_handler);
</code></pre>
<ol start="2">
<li>Add controls:</li>
</ol>
<p>You add non-menu controls by calling v4l2_ctrl_new_std:</p>
<pre><code>struct v4l2_ctrl *v4l2_ctrl_new_std(struct v4l2_ctrl_handler *hdl,
        const struct v4l2_ctrl_ops *ops,
        u32 id, s32 min, s32 max, u32 step, s32 def);
</code></pre>
<p>Menu controls are added by calling v4l2_ctrl_new_std_menu:</p>
<pre><code>struct v4l2_ctrl *v4l2_ctrl_new_std_menu(struct v4l2_ctrl_handler *hdl,
        const struct v4l2_ctrl_ops *ops,
        u32 id, s32 max, s32 skip_mask, s32 def);
</code></pre>
<p>Or alternatively for integer menu controls, by calling v4l2_ctrl_new_int_menu:</p>
<pre><code>struct v4l2_ctrl *v4l2_ctrl_new_int_menu(struct v4l2_ctrl_handler *hdl,
        const struct v4l2_ctrl_ops *ops,
        u32 id, s32 max, s32 def, const s64 *qmenu_int);
</code></pre>
<p>Standard menu controls with a driver specific menu are added by calling<br>v4l2_ctrl_new_std_menu_items:</p>
<pre><code>struct v4l2_ctrl *v4l2_ctrl_new_std_menu_items(
    struct v4l2_ctrl_handler *hdl,
    const struct v4l2_ctrl_ops *ops, u32 id, s32 max,
    s32 skip_mask, s32 def, const char * const *qmenu);
</code></pre>
<p>These functions are typically called right after the v4l2_ctrl_handler_init:</p>
<pre><code>static const s64 exp_bias_qmenu[] = &#123;
       -2, -1, 0, 1, 2
&#125;;
static const char * const test_pattern[] = &#123;
    &quot;Disabled&quot;,
    &quot;Vertical Bars&quot;,
    &quot;Solid Black&quot;,
    &quot;Solid White&quot;,
&#125;;

v4l2_ctrl_handler_init(&amp;foo-&gt;ctrl_handler, nr_of_controls);
v4l2_ctrl_new_std(&amp;foo-&gt;ctrl_handler, &amp;foo_ctrl_ops,
        V4L2_CID_BRIGHTNESS, 0, 255, 1, 128);
v4l2_ctrl_new_std(&amp;foo-&gt;ctrl_handler, &amp;foo_ctrl_ops,
        V4L2_CID_CONTRAST, 0, 255, 1, 128);
v4l2_ctrl_new_std_menu(&amp;foo-&gt;ctrl_handler, &amp;foo_ctrl_ops,
        V4L2_CID_POWER_LINE_FREQUENCY,
        V4L2_CID_POWER_LINE_FREQUENCY_60HZ, 0,
        V4L2_CID_POWER_LINE_FREQUENCY_DISABLED);
v4l2_ctrl_new_int_menu(&amp;foo-&gt;ctrl_handler, &amp;foo_ctrl_ops,
        V4L2_CID_EXPOSURE_BIAS,
        ARRAY_SIZE(exp_bias_qmenu) - 1,
        ARRAY_SIZE(exp_bias_qmenu) / 2 - 1,
        exp_bias_qmenu);
v4l2_ctrl_new_std_menu_items(&amp;foo-&gt;ctrl_handler, &amp;foo_ctrl_ops,
        V4L2_CID_TEST_PATTERN, ARRAY_SIZE(test_pattern) - 1, 0,
        0, test_pattern);
...
if (foo-&gt;ctrl_handler.error) &#123;
    int err = foo-&gt;ctrl_handler.error;

    v4l2_ctrl_handler_free(&amp;foo-&gt;ctrl_handler);
    return err;
&#125;
</code></pre>
<p>The v4l2_ctrl_new_std function returns the v4l2_ctrl pointer to the new<br>control, but if you do not need to access the pointer outside the control ops,<br>then there is no need to store it.</p>
<p>The v4l2_ctrl_new_std function will fill in most fields based on the control<br>ID except for the min, max, step and default values. These are passed in the<br>last four arguments. These values are driver specific while control attributes<br>like type, name, flags are all global. The control’s current value will be set<br>to the default value.</p>
<p>The v4l2_ctrl_new_std_menu function is very similar but it is used for menu<br>controls. There is no min argument since that is always 0 for menu controls,<br>and instead of a step there is a skip_mask argument: if bit X is 1, then menu<br>item X is skipped.</p>
<p>The v4l2_ctrl_new_int_menu function creates a new standard integer menu<br>control with driver-specific items in the menu. It differs from<br>v4l2_ctrl_new_std_menu in that it doesn’t have the mask argument and takes<br>as the last argument an array of signed 64-bit integers that form an exact<br>menu item list.</p>
<p>The v4l2_ctrl_new_std_menu_items function is very similar to<br>v4l2_ctrl_new_std_menu but takes an extra parameter qmenu, which is the driver<br>specific menu for an otherwise standard menu control. A good example for this<br>control is the test pattern control for capture/display/sensors devices that<br>have the capability to generate test patterns. These test patterns are hardware<br>specific, so the contents of the menu will vary from device to device.</p>
<p>Note that if something fails, the function will return NULL or an error and<br>set ctrl_handler-&gt;error to the error code. If ctrl_handler-&gt;error was already<br>set, then it will just return and do nothing. This is also true for<br>v4l2_ctrl_handler_init if it cannot allocate the internal data structure.</p>
<p>This makes it easy to init the handler and just add all controls and only check<br>the error code at the end. Saves a lot of repetitive error checking.</p>
<p>It is recommended to add controls in ascending control ID order: it will be<br>a bit faster that way.</p>
<ol start="3">
<li><p>Optionally force initial control setup:</p>
<p> v4l2_ctrl_handler_setup(&amp;foo-&gt;ctrl_handler);</p>
</li>
</ol>
<p>This will call s_ctrl for all controls unconditionally. Effectively this<br>initializes the hardware to the default control values. It is recommended<br>that you do this as this ensures that both the internal data structures and<br>the hardware are in sync.</p>
<ol start="4">
<li><p>Finally: implement the v4l2_ctrl_ops</p>
<p> static const struct v4l2_ctrl_ops foo_ctrl_ops = {</p>
<pre><code> .s_ctrl = foo_s_ctrl,
</code></pre>
<p> };</p>
</li>
</ol>
<p>Usually all you need is s_ctrl:</p>
<pre><code>static int foo_s_ctrl(struct v4l2_ctrl *ctrl)
&#123;
    struct foo *state = container_of(ctrl-&gt;handler, struct foo, ctrl_handler);

    switch (ctrl-&gt;id) &#123;
    case V4L2_CID_BRIGHTNESS:
        write_reg(0x123, ctrl-&gt;val);
        break;
    case V4L2_CID_CONTRAST:
        write_reg(0x456, ctrl-&gt;val);
        break;
    &#125;
    return 0;
&#125;
</code></pre>
<p>The control ops are called with the v4l2_ctrl pointer as argument.<br>The new control value has already been validated, so all you need to do is<br>to actually update the hardware registers.</p>
<p>You’re done! And this is sufficient for most of the drivers we have. No need<br>to do any validation of control values, or implement QUERYCTRL/QUERYMENU. And<br>G/S_CTRL as well as G/TRY/S_EXT_CTRLS are automatically supported.</p>
<p>==============================================================================</p>
<p>The remainder of this document deals with more advanced topics and scenarios.<br>In practice the basic usage as described above is sufficient for most drivers.</p>
<p>===============================================================================</p>
<h1 id="Inheriting-Controls"><a href="#Inheriting-Controls" class="headerlink" title="Inheriting Controls"></a>Inheriting Controls</h1><p>When a sub-device is registered with a V4L2 driver by calling<br>v4l2_device_register_subdev() and the ctrl_handler fields of both v4l2_subdev<br>and v4l2_device are set, then the controls of the subdev will become<br>automatically available in the V4L2 driver as well. If the subdev driver<br>contains controls that already exist in the V4L2 driver, then those will be<br>skipped (so a V4L2 driver can always override a subdev control).</p>
<p>What happens here is that v4l2_device_register_subdev() calls<br>v4l2_ctrl_add_handler() adding the controls of the subdev to the controls<br>of v4l2_device.</p>
<h1 id="Accessing-Control-Values"><a href="#Accessing-Control-Values" class="headerlink" title="Accessing Control Values"></a>Accessing Control Values</h1><p>The v4l2_ctrl struct contains these two unions:</p>
<pre><code>/* The current control value. */
union &#123;
    s32 val;
    s64 val64;
    char *string;
&#125; cur;

/* The new control value. */
union &#123;
    s32 val;
    s64 val64;
    char *string;
&#125;;
</code></pre>
<p>Within the control ops you can freely use these. The val and val64 speak for<br>themselves. The string pointers point to character buffers of length<br>ctrl-&gt;maximum + 1, and are always 0-terminated.</p>
<p>In most cases ‘cur’ contains the current cached control value. When you create<br>a new control this value is made identical to the default value. After calling<br>v4l2_ctrl_handler_setup() this value is passed to the hardware. It is generally<br>a good idea to call this function.</p>
<p>Whenever a new value is set that new value is automatically cached. This means<br>that most drivers do not need to implement the g_volatile_ctrl() op. The<br>exception is for controls that return a volatile register such as a signal<br>strength read-out that changes continuously. In that case you will need to<br>implement g_volatile_ctrl like this:</p>
<pre><code>static int foo_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
&#123;
    switch (ctrl-&gt;id) &#123;
    case V4L2_CID_BRIGHTNESS:
        ctrl-&gt;val = read_reg(0x123);
        break;
    &#125;
&#125;
</code></pre>
<p>Note that you use the ‘new value’ union as well in g_volatile_ctrl. In general<br>controls that need to implement g_volatile_ctrl are read-only controls.</p>
<p>To mark a control as volatile you have to set V4L2_CTRL_FLAG_VOLATILE:</p>
<pre><code>ctrl = v4l2_ctrl_new_std(&amp;sd-&gt;ctrl_handler, ...);
if (ctrl)
    ctrl-&gt;flags |= V4L2_CTRL_FLAG_VOLATILE;
</code></pre>
<p>For try/s_ctrl the new values (i.e. as passed by the user) are filled in and<br>you can modify them in try_ctrl or set them in s_ctrl. The ‘cur’ union<br>contains the current value, which you can use (but not change!) as well.</p>
<p>If s_ctrl returns 0 (OK), then the control framework will copy the new final<br>values to the ‘cur’ union.</p>
<p>While in g_volatile/s/try_ctrl you can access the value of all controls owned<br>by the same handler since the handler’s lock is held. If you need to access<br>the value of controls owned by other handlers, then you have to be very careful<br>not to introduce deadlocks.</p>
<p>Outside of the control ops you have to go through to helper functions to get<br>or set a single control value safely in your driver:</p>
<pre><code>s32 v4l2_ctrl_g_ctrl(struct v4l2_ctrl *ctrl);
int v4l2_ctrl_s_ctrl(struct v4l2_ctrl *ctrl, s32 val);
</code></pre>
<p>These functions go through the control framework just as VIDIOC_G/S_CTRL ioctls<br>do. Don’t use these inside the control ops g_volatile/s/try_ctrl, though, that<br>will result in a deadlock since these helpers lock the handler as well.</p>
<p>You can also take the handler lock yourself:</p>
<pre><code>mutex_lock(&amp;state-&gt;ctrl_handler.lock);
printk(KERN_INFO &quot;String value is &#39;%s&#39;\n&quot;, ctrl1-&gt;cur.string);
printk(KERN_INFO &quot;Integer value is &#39;%s&#39;\n&quot;, ctrl2-&gt;cur.val);
mutex_unlock(&amp;state-&gt;ctrl_handler.lock);
</code></pre>
<h1 id="Menu-Controls"><a href="#Menu-Controls" class="headerlink" title="Menu Controls"></a>Menu Controls</h1><p>The v4l2_ctrl struct contains this union:</p>
<pre><code>union &#123;
    u32 step;
    u32 menu_skip_mask;
&#125;;
</code></pre>
<p>For menu controls menu_skip_mask is used. What it does is that it allows you<br>to easily exclude certain menu items. This is used in the VIDIOC_QUERYMENU<br>implementation where you can return -EINVAL if a certain menu item is not<br>present. Note that VIDIOC_QUERYCTRL always returns a step value of 1 for<br>menu controls.</p>
<p>A good example is the MPEG Audio Layer II Bitrate menu control where the<br>menu is a list of standardized possible bitrates. But in practice hardware<br>implementations will only support a subset of those. By setting the skip<br>mask you can tell the framework which menu items should be skipped. Setting<br>it to 0 means that all menu items are supported.</p>
<p>You set this mask either through the v4l2_ctrl_config struct for a custom<br>control, or by calling v4l2_ctrl_new_std_menu().</p>
<h1 id="Custom-Controls"><a href="#Custom-Controls" class="headerlink" title="Custom Controls"></a>Custom Controls</h1><p>Driver specific controls can be created using v4l2_ctrl_new_custom():</p>
<pre><code>static const struct v4l2_ctrl_config ctrl_filter = &#123;
    .ops = &amp;ctrl_custom_ops,
    .id = V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER,
    .name = &quot;Spatial Filter&quot;,
    .type = V4L2_CTRL_TYPE_INTEGER,
    .flags = V4L2_CTRL_FLAG_SLIDER,
    .max = 15,
    .step = 1,
&#125;;

ctrl = v4l2_ctrl_new_custom(&amp;foo-&gt;ctrl_handler, &amp;ctrl_filter, NULL);
</code></pre>
<p>The last argument is the priv pointer which can be set to driver-specific<br>private data.</p>
<p>The v4l2_ctrl_config struct also has a field to set the is_private flag.</p>
<p>If the name field is not set, then the framework will assume this is a standard<br>control and will fill in the name, type and flags fields accordingly.</p>
<h1 id="Active-and-Grabbed-Controls"><a href="#Active-and-Grabbed-Controls" class="headerlink" title="Active and Grabbed Controls"></a>Active and Grabbed Controls</h1><p>If you get more complex relationships between controls, then you may have to<br>activate and deactivate controls. For example, if the Chroma AGC control is<br>on, then the Chroma Gain control is inactive. That is, you may set it, but<br>the value will not be used by the hardware as long as the automatic gain<br>control is on. Typically user interfaces can disable such input fields.</p>
<p>You can set the ‘active’ status using v4l2_ctrl_activate(). By default all<br>controls are active. Note that the framework does not check for this flag.<br>It is meant purely for GUIs. The function is typically called from within<br>s_ctrl.</p>
<p>The other flag is the ‘grabbed’ flag. A grabbed control means that you cannot<br>change it because it is in use by some resource. Typical examples are MPEG<br>bitrate controls that cannot be changed while capturing is in progress.</p>
<p>If a control is set to ‘grabbed’ using v4l2_ctrl_grab(), then the framework<br>will return -EBUSY if an attempt is made to set this control. The<br>v4l2_ctrl_grab() function is typically called from the driver when it<br>starts or stops streaming.</p>
<h1 id="Control-Clusters"><a href="#Control-Clusters" class="headerlink" title="Control Clusters"></a>Control Clusters</h1><p>By default all controls are independent from the others. But in more<br>complex scenarios you can get dependencies from one control to another.<br>In that case you need to ‘cluster’ them:</p>
<pre><code>struct foo &#123;
    struct v4l2_ctrl_handler ctrl_handler;
</code></pre>
<p>#define AUDIO_CL_VOLUME (0)<br>#define AUDIO_CL_MUTE   (1)<br>        struct v4l2_ctrl *audio_cluster[2];<br>        …<br>    };</p>
<pre><code>state-&gt;audio_cluster[AUDIO_CL_VOLUME] =
    v4l2_ctrl_new_std(&amp;state-&gt;ctrl_handler, ...);
state-&gt;audio_cluster[AUDIO_CL_MUTE] =
    v4l2_ctrl_new_std(&amp;state-&gt;ctrl_handler, ...);
v4l2_ctrl_cluster(ARRAY_SIZE(state-&gt;audio_cluster), state-&gt;audio_cluster);
</code></pre>
<p>From now on whenever one or more of the controls belonging to the same<br>cluster is set (or ‘gotten’, or ‘tried’), only the control ops of the first<br>control (‘volume’ in this example) is called. You effectively create a new<br>composite control. Similar to how a ‘struct’ works in C.</p>
<p>So when s_ctrl is called with V4L2_CID_AUDIO_VOLUME as argument, you should set<br>all two controls belonging to the audio_cluster:</p>
<pre><code>static int foo_s_ctrl(struct v4l2_ctrl *ctrl)
&#123;
    struct foo *state = container_of(ctrl-&gt;handler, struct foo, ctrl_handler);

    switch (ctrl-&gt;id) &#123;
    case V4L2_CID_AUDIO_VOLUME: &#123;
        struct v4l2_ctrl *mute = ctrl-&gt;cluster[AUDIO_CL_MUTE];

        write_reg(0x123, mute-&gt;val ? 0 : ctrl-&gt;val);
        break;
    &#125;
    case V4L2_CID_CONTRAST:
        write_reg(0x456, ctrl-&gt;val);
        break;
    &#125;
    return 0;
&#125;
</code></pre>
<p>In the example above the following are equivalent for the VOLUME case:</p>
<pre><code>ctrl == ctrl-&gt;cluster[AUDIO_CL_VOLUME] == state-&gt;audio_cluster[AUDIO_CL_VOLUME]
ctrl-&gt;cluster[AUDIO_CL_MUTE] == state-&gt;audio_cluster[AUDIO_CL_MUTE]
</code></pre>
<p>In practice using cluster arrays like this becomes very tiresome. So instead<br>the following equivalent method is used:</p>
<pre><code>struct &#123;
    /* audio cluster */
    struct v4l2_ctrl *volume;
    struct v4l2_ctrl *mute;
&#125;;
</code></pre>
<p>The anonymous struct is used to clearly ‘cluster’ these two control pointers,<br>but it serves no other purpose. The effect is the same as creating an<br>array with two control pointers. So you can just do:</p>
<pre><code>state-&gt;volume = v4l2_ctrl_new_std(&amp;state-&gt;ctrl_handler, ...);
state-&gt;mute = v4l2_ctrl_new_std(&amp;state-&gt;ctrl_handler, ...);
v4l2_ctrl_cluster(2, &amp;state-&gt;volume);
</code></pre>
<p>And in foo_s_ctrl you can use these pointers directly: state-&gt;mute-&gt;val.</p>
<p>Note that controls in a cluster may be NULL. For example, if for some<br>reason mute was never added (because the hardware doesn’t support that<br>particular feature), then mute will be NULL. So in that case we have a<br>cluster of 2 controls, of which only 1 is actually instantiated. The<br>only restriction is that the first control of the cluster must always be<br>present, since that is the ‘master’ control of the cluster. The master<br>control is the one that identifies the cluster and that provides the<br>pointer to the v4l2_ctrl_ops struct that is used for that cluster.</p>
<p>Obviously, all controls in the cluster array must be initialized to either<br>a valid control or to NULL.</p>
<p>In rare cases you might want to know which controls of a cluster actually<br>were set explicitly by the user. For this you can check the ‘is_new’ flag of<br>each control. For example, in the case of a volume/mute cluster the ‘is_new’<br>flag of the mute control would be set if the user called VIDIOC_S_CTRL for<br>mute only. If the user would call VIDIOC_S_EXT_CTRLS for both mute and volume<br>controls, then the ‘is_new’ flag would be 1 for both controls.</p>
<p>The ‘is_new’ flag is always 1 when called from v4l2_ctrl_handler_setup().</p>
<h1 id="Handling-autogain-gain-type-Controls-with-Auto-Clusters"><a href="#Handling-autogain-gain-type-Controls-with-Auto-Clusters" class="headerlink" title="Handling autogain/gain-type Controls with Auto Clusters"></a>Handling autogain/gain-type Controls with Auto Clusters</h1><p>A common type of control cluster is one that handles ‘auto-foo/foo’-type<br>controls. Typical examples are autogain/gain, autoexposure/exposure,<br>autowhitebalance/red balance/blue balance. In all cases you have one control<br>that determines whether another control is handled automatically by the hardware,<br>or whether it is under manual control from the user.</p>
<p>If the cluster is in automatic mode, then the manual controls should be<br>marked inactive and volatile. When the volatile controls are read the<br>g_volatile_ctrl operation should return the value that the hardware’s automatic<br>mode set up automatically.</p>
<p>If the cluster is put in manual mode, then the manual controls should become<br>active again and the volatile flag is cleared (so g_volatile_ctrl is no longer<br>called while in manual mode). In addition just before switching to manual mode<br>the current values as determined by the auto mode are copied as the new manual<br>values.</p>
<p>Finally the V4L2_CTRL_FLAG_UPDATE should be set for the auto control since<br>changing that control affects the control flags of the manual controls.</p>
<p>In order to simplify this a special variation of v4l2_ctrl_cluster was<br>introduced:</p>
<p>void v4l2_ctrl_auto_cluster(unsigned ncontrols, struct v4l2_ctrl **controls,<br>            u8 manual_val, bool set_volatile);</p>
<p>The first two arguments are identical to v4l2_ctrl_cluster. The third argument<br>tells the framework which value switches the cluster into manual mode. The<br>last argument will optionally set V4L2_CTRL_FLAG_VOLATILE for the non-auto controls.<br>If it is false, then the manual controls are never volatile. You would typically<br>use that if the hardware does not give you the option to read back to values as<br>determined by the auto mode (e.g. if autogain is on, the hardware doesn’t allow<br>you to obtain the current gain value).</p>
<p>The first control of the cluster is assumed to be the ‘auto’ control.</p>
<p>Using this function will ensure that you don’t need to handle all the complex<br>flag and volatile handling.</p>
<h1 id="VIDIOC-LOG-STATUS-Support"><a href="#VIDIOC-LOG-STATUS-Support" class="headerlink" title="VIDIOC_LOG_STATUS Support"></a>VIDIOC_LOG_STATUS Support</h1><p>This ioctl allow you to dump the current status of a driver to the kernel log.<br>The v4l2_ctrl_handler_log_status(ctrl_handler, prefix) can be used to dump the<br>value of the controls owned by the given handler to the log. You can supply a<br>prefix as well. If the prefix didn’t end with a space, then ‘: ‘ will be added<br>for you.</p>
<h1 id="Different-Handlers-for-Different-Video-Nodes"><a href="#Different-Handlers-for-Different-Video-Nodes" class="headerlink" title="Different Handlers for Different Video Nodes"></a>Different Handlers for Different Video Nodes</h1><p>Usually the V4L2 driver has just one control handler that is global for<br>all video nodes. But you can also specify different control handlers for<br>different video nodes. You can do that by manually setting the ctrl_handler<br>field of struct video_device.</p>
<p>That is no problem if there are no subdevs involved but if there are, then<br>you need to block the automatic merging of subdev controls to the global<br>control handler. You do that by simply setting the ctrl_handler field in<br>struct v4l2_device to NULL. Now v4l2_device_register_subdev() will no longer<br>merge subdev controls.</p>
<p>After each subdev was added, you will then have to call v4l2_ctrl_add_handler<br>manually to add the subdev’s control handler (sd-&gt;ctrl_handler) to the desired<br>control handler. This control handler may be specific to the video_device or<br>for a subset of video_device’s. For example: the radio device nodes only have<br>audio controls, while the video and vbi device nodes share the same control<br>handler for the audio and video controls.</p>
<p>If you want to have one handler (e.g. for a radio device node) have a subset<br>of another handler (e.g. for a video device node), then you should first add<br>the controls to the first handler, add the other controls to the second<br>handler and finally add the first handler to the second. For example:</p>
<pre><code>v4l2_ctrl_new_std(&amp;radio_ctrl_handler, &amp;radio_ops, V4L2_CID_AUDIO_VOLUME, ...);
v4l2_ctrl_new_std(&amp;radio_ctrl_handler, &amp;radio_ops, V4L2_CID_AUDIO_MUTE, ...);
v4l2_ctrl_new_std(&amp;video_ctrl_handler, &amp;video_ops, V4L2_CID_BRIGHTNESS, ...);
v4l2_ctrl_new_std(&amp;video_ctrl_handler, &amp;video_ops, V4L2_CID_CONTRAST, ...);
v4l2_ctrl_add_handler(&amp;video_ctrl_handler, &amp;radio_ctrl_handler, NULL);
</code></pre>
<p>The last argument to v4l2_ctrl_add_handler() is a filter function that allows<br>you to filter which controls will be added. Set it to NULL if you want to add<br>all controls.</p>
<p>Or you can add specific controls to a handler:</p>
<pre><code>volume = v4l2_ctrl_new_std(&amp;video_ctrl_handler, &amp;ops, V4L2_CID_AUDIO_VOLUME, ...);
v4l2_ctrl_new_std(&amp;video_ctrl_handler, &amp;ops, V4L2_CID_BRIGHTNESS, ...);
v4l2_ctrl_new_std(&amp;video_ctrl_handler, &amp;ops, V4L2_CID_CONTRAST, ...);
v4l2_ctrl_add_ctrl(&amp;radio_ctrl_handler, volume);
</code></pre>
<p>What you should not do is make two identical controls for two handlers.<br>For example:</p>
<pre><code>v4l2_ctrl_new_std(&amp;radio_ctrl_handler, &amp;radio_ops, V4L2_CID_AUDIO_MUTE, ...);
v4l2_ctrl_new_std(&amp;video_ctrl_handler, &amp;video_ops, V4L2_CID_AUDIO_MUTE, ...);
</code></pre>
<p>This would be bad since muting the radio would not change the video mute<br>control. The rule is to have one control for each hardware ‘knob’ that you<br>can twiddle.</p>
<h1 id="Finding-Controls"><a href="#Finding-Controls" class="headerlink" title="Finding Controls"></a>Finding Controls</h1><p>Normally you have created the controls yourself and you can store the struct<br>v4l2_ctrl pointer into your own struct.</p>
<p>But sometimes you need to find a control from another handler that you do<br>not own. For example, if you have to find a volume control from a subdev.</p>
<p>You can do that by calling v4l2_ctrl_find:</p>
<pre><code>struct v4l2_ctrl *volume;

volume = v4l2_ctrl_find(sd-&gt;ctrl_handler, V4L2_CID_AUDIO_VOLUME);
</code></pre>
<p>Since v4l2_ctrl_find will lock the handler you have to be careful where you<br>use it. For example, this is not a good idea:</p>
<pre><code>struct v4l2_ctrl_handler ctrl_handler;

v4l2_ctrl_new_std(&amp;ctrl_handler, &amp;video_ops, V4L2_CID_BRIGHTNESS, ...);
v4l2_ctrl_new_std(&amp;ctrl_handler, &amp;video_ops, V4L2_CID_CONTRAST, ...);
</code></pre>
<p>…and in video_ops.s_ctrl:</p>
<pre><code>case V4L2_CID_BRIGHTNESS:
    contrast = v4l2_find_ctrl(&amp;ctrl_handler, V4L2_CID_CONTRAST);
    ...
</code></pre>
<p>When s_ctrl is called by the framework the ctrl_handler.lock is already taken, so<br>attempting to find another control from the same handler will deadlock.</p>
<p>It is recommended not to use this function from inside the control ops.</p>
<h1 id="Inheriting-Controls-1"><a href="#Inheriting-Controls-1" class="headerlink" title="Inheriting Controls"></a>Inheriting Controls</h1><p>When one control handler is added to another using v4l2_ctrl_add_handler, then<br>by default all controls from one are merged to the other. But a subdev might<br>have low-level controls that make sense for some advanced embedded system, but<br>not when it is used in consumer-level hardware. In that case you want to keep<br>those low-level controls local to the subdev. You can do this by simply<br>setting the ‘is_private’ flag of the control to 1:</p>
<pre><code>static const struct v4l2_ctrl_config ctrl_private = &#123;
    .ops = &amp;ctrl_custom_ops,
    .id = V4L2_CID_...,
    .name = &quot;Some Private Control&quot;,
    .type = V4L2_CTRL_TYPE_INTEGER,
    .max = 15,
    .step = 1,
    .is_private = 1,
&#125;;

ctrl = v4l2_ctrl_new_custom(&amp;foo-&gt;ctrl_handler, &amp;ctrl_private, NULL);
</code></pre>
<p>These controls will now be skipped when v4l2_ctrl_add_handler is called.</p>
<h1 id="V4L2-CTRL-TYPE-CTRL-CLASS-Controls"><a href="#V4L2-CTRL-TYPE-CTRL-CLASS-Controls" class="headerlink" title="V4L2_CTRL_TYPE_CTRL_CLASS Controls"></a>V4L2_CTRL_TYPE_CTRL_CLASS Controls</h1><p>Controls of this type can be used by GUIs to get the name of the control class.<br>A fully featured GUI can make a dialog with multiple tabs with each tab<br>containing the controls belonging to a particular control class. The name of<br>each tab can be found by querying a special control with ID &lt;control class | 1&gt;.</p>
<p>Drivers do not have to care about this. The framework will automatically add<br>a control of this type whenever the first control belonging to a new control<br>class is added.</p>
<h1 id="Adding-Notify-Callbacks"><a href="#Adding-Notify-Callbacks" class="headerlink" title="Adding Notify Callbacks"></a>Adding Notify Callbacks</h1><p>Sometimes the platform or bridge driver needs to be notified when a control<br>from a sub-device driver changes. You can set a notify callback by calling<br>this function:</p>
<p>void v4l2_ctrl_notify(struct v4l2_ctrl *ctrl,<br>    void (*notify)(struct v4l2_ctrl *ctrl, void *priv), void *priv);</p>
<p>Whenever the give control changes value the notify callback will be called<br>with a pointer to the control and the priv pointer that was passed with<br>v4l2_ctrl_notify. Note that the control’s handler lock is held when the<br>notify function is called.</p>
<p>There can be only one notify function per control handler. Any attempt<br>to set another notify function will cause a WARN_ON.</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_v4l2-controls/" title="Kernel-3.10.0-957.el7_v4l2-controls" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_v4l2-controls/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_vm/" title="Kernel-3.10.0-957.el7_v"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_usb-serial/" title="Kernel-3.10.0-957.el7_usb-serial"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>