<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-2.6.32-573.12.1.el6_v4l2-framework | oosTech.com</title>
  <meta name="description" content="Overview of the V4L2 driver frameworkThis text documents the various structures provided by the V4L2 framework andtheir relationships. IntroductionThe V4L2 drivers tend to be very complex due to the c">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-2.6.32-573.12.1.el6_v4l2-framework">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_v4l2-framework/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="Overview of the V4L2 driver frameworkThis text documents the various structures provided by the V4L2 framework andtheir relationships. IntroductionThe V4L2 drivers tend to be very complex due to the c">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_v4l2-framework/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Overview-of-the-V4L2-driver-framework"><span class="toc-number">1.</span> <span class="toc-text">Overview of the V4L2 driver framework</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Structure-of-a-driver"><span class="toc-number">1.2.</span> <span class="toc-text">Structure of a driver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Structure-of-the-framework"><span class="toc-number">1.3.</span> <span class="toc-text">Structure of the framework</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-v4l2-device"><span class="toc-number">1.4.</span> <span class="toc-text">struct v4l2_device</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-v4l2-subdev"><span class="toc-number">1.5.</span> <span class="toc-text">struct v4l2_subdev</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I2C-sub-device-drivers"><span class="toc-number">1.6.</span> <span class="toc-text">I2C sub-device drivers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-video-device"><span class="toc-number">1.7.</span> <span class="toc-text">struct video_device</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#video-device-registration"><span class="toc-number">1.8.</span> <span class="toc-text">video_device registration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#video-device-cleanup"><span class="toc-number">1.9.</span> <span class="toc-text">video_device cleanup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#video-device-helper-functions"><span class="toc-number">1.10.</span> <span class="toc-text">video_device helper functions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#video-buffer-helper-functions"><span class="toc-number">1.11.</span> <span class="toc-text">video buffer helper functions</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-2.6.32-573.12.1.el6_v4l2-framework" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-2.6.32-573.12.1.el6_v4l2-framework
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_v4l2-framework/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_v4l2-framework/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_v4l2-framework/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="Overview-of-the-V4L2-driver-framework"><a href="#Overview-of-the-V4L2-driver-framework" class="headerlink" title="Overview of the V4L2 driver framework"></a>Overview of the V4L2 driver framework</h1><p>This text documents the various structures provided by the V4L2 framework and<br>their relationships.</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The V4L2 drivers tend to be very complex due to the complexity of the<br>hardware: most devices have multiple ICs, export multiple device nodes in<br>/dev, and create also non-V4L2 devices such as DVB, ALSA, FB, I2C and input<br>(IR) devices.</p>
<p>Especially the fact that V4L2 drivers have to setup supporting ICs to<br>do audio/video muxing/encoding/decoding makes it more complex than most.<br>Usually these ICs are connected to the main bridge driver through one or<br>more I2C busses, but other busses can also be used. Such devices are<br>called ‘sub-devices’.</p>
<p>For a long time the framework was limited to the video_device struct for<br>creating V4L device nodes and video_buf for handling the video buffers<br>(note that this document does not discuss the video_buf framework).</p>
<p>This meant that all drivers had to do the setup of device instances and<br>connecting to sub-devices themselves. Some of this is quite complicated<br>to do right and many drivers never did do it correctly.</p>
<p>There is also a lot of common code that could never be refactored due to<br>the lack of a framework.</p>
<p>So this framework sets up the basic building blocks that all drivers<br>need and this same framework should make it much easier to refactor<br>common code into utility functions shared by all drivers.</p>
<h2 id="Structure-of-a-driver"><a href="#Structure-of-a-driver" class="headerlink" title="Structure of a driver"></a>Structure of a driver</h2><p>All drivers have the following structure:</p>
<ol>
<li><p>A struct for each device instance containing the device state.</p>
</li>
<li><p>A way of initializing and commanding sub-devices (if any).</p>
</li>
<li><p>Creating V4L2 device nodes (/dev/videoX, /dev/vbiX, /dev/radioX and<br>/dev/vtxX) and keeping track of device-node specific data.</p>
</li>
<li><p>Filehandle-specific structs containing per-filehandle data;</p>
</li>
<li><p>video buffer handling.</p>
</li>
</ol>
<p>This is a rough schematic of how it all relates:</p>
<pre><code>device instances
  |
  +-sub-device instances
  |
  \-V4L2 device nodes
  |
  \-filehandle instances
</code></pre>
<h2 id="Structure-of-the-framework"><a href="#Structure-of-the-framework" class="headerlink" title="Structure of the framework"></a>Structure of the framework</h2><p>The framework closely resembles the driver structure: it has a v4l2_device<br>struct for the device instance data, a v4l2_subdev struct to refer to<br>sub-device instances, the video_device struct stores V4L2 device node data<br>and in the future a v4l2_fh struct will keep track of filehandle instances<br>(this is not yet implemented).</p>
<h2 id="struct-v4l2-device"><a href="#struct-v4l2-device" class="headerlink" title="struct v4l2_device"></a>struct v4l2_device</h2><p>Each device instance is represented by a struct v4l2_device (v4l2-device.h).<br>Very simple devices can just allocate this struct, but most of the time you<br>would embed this struct inside a larger struct.</p>
<p>You must register the device instance:</p>
<pre><code>v4l2_device_register(struct device *dev, struct v4l2_device *v4l2_dev);
</code></pre>
<p>Registration will initialize the v4l2_device struct and link dev-&gt;driver_data<br>to v4l2_dev. If v4l2_dev-&gt;name is empty then it will be set to a value derived<br>from dev (driver name followed by the bus_id, to be precise). If you set it<br>up before calling v4l2_device_register then it will be untouched. If dev is<br>NULL, then you <em>must</em> setup v4l2_dev-&gt;name before calling v4l2_device_register.</p>
<p>You can use v4l2_device_set_name() to set the name based on a driver name and<br>a driver-global atomic_t instance. This will generate names like ivtv0, ivtv1,<br>etc. If the name ends with a digit, then it will insert a dash: cx18-0,<br>cx18-1, etc. This function returns the instance number.</p>
<p>The first ‘dev’ argument is normally the struct device pointer of a pci_dev,<br>usb_interface or platform_device. It is rare for dev to be NULL, but it happens<br>with ISA devices or when one device creates multiple PCI devices, thus making<br>it impossible to associate v4l2_dev with a particular parent.</p>
<p>You can also supply a notify() callback that can be called by sub-devices to<br>notify you of events. Whether you need to set this depends on the sub-device.<br>Any notifications a sub-device supports must be defined in a header in<br>include/media/<subdevice>.h.</p>
<p>You unregister with:</p>
<pre><code>v4l2_device_unregister(struct v4l2_device *v4l2_dev);
</code></pre>
<p>Unregistering will also automatically unregister all subdevs from the device.</p>
<p>If you have a hotpluggable device (e.g. a USB device), then when a disconnect<br>happens the parent device becomes invalid. Since v4l2_device has a pointer to<br>that parent device it has to be cleared as well to mark that the parent is<br>gone. To do this call:</p>
<pre><code>v4l2_device_disconnect(struct v4l2_device *v4l2_dev);
</code></pre>
<p>This does <em>not</em> unregister the subdevs, so you still need to call the<br>v4l2_device_unregister() function for that. If your driver is not hotpluggable,<br>then there is no need to call v4l2_device_disconnect().</p>
<p>Sometimes you need to iterate over all devices registered by a specific<br>driver. This is usually the case if multiple device drivers use the same<br>hardware. E.g. the ivtvfb driver is a framebuffer driver that uses the ivtv<br>hardware. The same is true for alsa drivers for example.</p>
<p>You can iterate over all registered devices as follows:</p>
<p>static int callback(struct device *dev, void *p)<br>{<br>    struct v4l2_device *v4l2_dev = dev_get_drvdata(dev);</p>
<pre><code>/* test if this device was inited */
if (v4l2_dev == NULL)
    return 0;
...
return 0;
</code></pre>
<p>}</p>
<p>int iterate(void *p)<br>{<br>    struct device_driver *drv;<br>    int err;</p>
<pre><code>/* Find driver &#39;ivtv&#39; on the PCI bus.
   pci_bus_type is a global. For USB busses use usb_bus_type. */
drv = driver_find(&quot;ivtv&quot;, &amp;pci_bus_type);
/* iterate over all ivtv device instances */
err = driver_for_each_device(drv, NULL, p, callback);
put_driver(drv);
return err;
</code></pre>
<p>}</p>
<p>Sometimes you need to keep a running counter of the device instance. This is<br>commonly used to map a device instance to an index of a module option array.</p>
<p>The recommended approach is as follows:</p>
<p>static atomic_t drv_instance = ATOMIC_INIT(0);</p>
<p>static int __devinit drv_probe(struct pci_dev *pdev,<br>                const struct pci_device_id *pci_id)<br>{<br>    …<br>    state-&gt;instance = atomic_inc_return(&amp;drv_instance) - 1;<br>}</p>
<h2 id="struct-v4l2-subdev"><a href="#struct-v4l2-subdev" class="headerlink" title="struct v4l2_subdev"></a>struct v4l2_subdev</h2><p>Many drivers need to communicate with sub-devices. These devices can do all<br>sort of tasks, but most commonly they handle audio and/or video muxing,<br>encoding or decoding. For webcams common sub-devices are sensors and camera<br>controllers.</p>
<p>Usually these are I2C devices, but not necessarily. In order to provide the<br>driver with a consistent interface to these sub-devices the v4l2_subdev struct<br>(v4l2-subdev.h) was created.</p>
<p>Each sub-device driver must have a v4l2_subdev struct. This struct can be<br>stand-alone for simple sub-devices or it might be embedded in a larger struct<br>if more state information needs to be stored. Usually there is a low-level<br>device struct (e.g. i2c_client) that contains the device data as setup<br>by the kernel. It is recommended to store that pointer in the private<br>data of v4l2_subdev using v4l2_set_subdevdata(). That makes it easy to go<br>from a v4l2_subdev to the actual low-level bus-specific device data.</p>
<p>You also need a way to go from the low-level struct to v4l2_subdev. For the<br>common i2c_client struct the i2c_set_clientdata() call is used to store a<br>v4l2_subdev pointer, for other busses you may have to use other methods.</p>
<p>From the bridge driver perspective you load the sub-device module and somehow<br>obtain the v4l2_subdev pointer. For i2c devices this is easy: you call<br>i2c_get_clientdata(). For other busses something similar needs to be done.<br>Helper functions exists for sub-devices on an I2C bus that do most of this<br>tricky work for you.</p>
<p>Each v4l2_subdev contains function pointers that sub-device drivers can<br>implement (or leave NULL if it is not applicable). Since sub-devices can do<br>so many different things and you do not want to end up with a huge ops struct<br>of which only a handful of ops are commonly implemented, the function pointers<br>are sorted according to category and each category has its own ops struct.</p>
<p>The top-level ops struct contains pointers to the category ops structs, which<br>may be NULL if the subdev driver does not support anything from that category.</p>
<p>It looks like this:</p>
<p>struct v4l2_subdev_core_ops {<br>    int (*g_chip_ident)(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip);<br>    int (*log_status)(struct v4l2_subdev *sd);<br>    int (*init)(struct v4l2_subdev *sd, u32 val);<br>    …<br>};</p>
<p>struct v4l2_subdev_tuner_ops {<br>    …<br>};</p>
<p>struct v4l2_subdev_audio_ops {<br>    …<br>};</p>
<p>struct v4l2_subdev_video_ops {<br>    …<br>};</p>
<p>struct v4l2_subdev_ops {<br>    const struct v4l2_subdev_core_ops  *core;<br>    const struct v4l2_subdev_tuner_ops *tuner;<br>    const struct v4l2_subdev_audio_ops *audio;<br>    const struct v4l2_subdev_video_ops *video;<br>};</p>
<p>The core ops are common to all subdevs, the other categories are implemented<br>depending on the sub-device. E.g. a video device is unlikely to support the<br>audio ops and vice versa.</p>
<p>This setup limits the number of function pointers while still making it easy<br>to add new ops and categories.</p>
<p>A sub-device driver initializes the v4l2_subdev struct using:</p>
<pre><code>v4l2_subdev_init(sd, &amp;ops);
</code></pre>
<p>Afterwards you need to initialize subdev-&gt;name with a unique name and set the<br>module owner. This is done for you if you use the i2c helper functions.</p>
<p>A device (bridge) driver needs to register the v4l2_subdev with the<br>v4l2_device:</p>
<pre><code>int err = v4l2_device_register_subdev(v4l2_dev, sd);
</code></pre>
<p>This can fail if the subdev module disappeared before it could be registered.<br>After this function was called successfully the subdev-&gt;dev field points to<br>the v4l2_device.</p>
<p>You can unregister a sub-device using:</p>
<pre><code>v4l2_device_unregister_subdev(sd);
</code></pre>
<p>Afterwards the subdev module can be unloaded and sd-&gt;dev == NULL.</p>
<p>You can call an ops function either directly:</p>
<pre><code>err = sd-&gt;ops-&gt;core-&gt;g_chip_ident(sd, &amp;chip);
</code></pre>
<p>but it is better and easier to use this macro:</p>
<pre><code>err = v4l2_subdev_call(sd, core, g_chip_ident, &amp;chip);
</code></pre>
<p>The macro will to the right NULL pointer checks and returns -ENODEV if subdev<br>is NULL, -ENOIOCTLCMD if either subdev-&gt;core or subdev-&gt;core-&gt;g_chip_ident is<br>NULL, or the actual result of the subdev-&gt;ops-&gt;core-&gt;g_chip_ident ops.</p>
<p>It is also possible to call all or a subset of the sub-devices:</p>
<pre><code>v4l2_device_call_all(v4l2_dev, 0, core, g_chip_ident, &amp;chip);
</code></pre>
<p>Any subdev that does not support this ops is skipped and error results are<br>ignored. If you want to check for errors use this:</p>
<pre><code>err = v4l2_device_call_until_err(v4l2_dev, 0, core, g_chip_ident, &amp;chip);
</code></pre>
<p>Any error except -ENOIOCTLCMD will exit the loop with that error. If no<br>errors (except -ENOIOCTLCMD) occured, then 0 is returned.</p>
<p>The second argument to both calls is a group ID. If 0, then all subdevs are<br>called. If non-zero, then only those whose group ID match that value will<br>be called. Before a bridge driver registers a subdev it can set sd-&gt;grp_id<br>to whatever value it wants (it’s 0 by default). This value is owned by the<br>bridge driver and the sub-device driver will never modify or use it.</p>
<p>The group ID gives the bridge driver more control how callbacks are called.<br>For example, there may be multiple audio chips on a board, each capable of<br>changing the volume. But usually only one will actually be used when the<br>user want to change the volume. You can set the group ID for that subdev to<br>e.g. AUDIO_CONTROLLER and specify that as the group ID value when calling<br>v4l2_device_call_all(). That ensures that it will only go to the subdev<br>that needs it.</p>
<p>If the sub-device needs to notify its v4l2_device parent of an event, then<br>it can call v4l2_subdev_notify(sd, notification, arg). This macro checks<br>whether there is a notify() callback defined and returns -ENODEV if not.<br>Otherwise the result of the notify() call is returned.</p>
<p>The advantage of using v4l2_subdev is that it is a generic struct and does<br>not contain any knowledge about the underlying hardware. So a driver might<br>contain several subdevs that use an I2C bus, but also a subdev that is<br>controlled through GPIO pins. This distinction is only relevant when setting<br>up the device, but once the subdev is registered it is completely transparent.</p>
<h2 id="I2C-sub-device-drivers"><a href="#I2C-sub-device-drivers" class="headerlink" title="I2C sub-device drivers"></a>I2C sub-device drivers</h2><p>Since these drivers are so common, special helper functions are available to<br>ease the use of these drivers (v4l2-common.h).</p>
<p>The recommended method of adding v4l2_subdev support to an I2C driver is to<br>embed the v4l2_subdev struct into the state struct that is created for each<br>I2C device instance. Very simple devices have no state struct and in that case<br>you can just create a v4l2_subdev directly.</p>
<p>A typical state struct would look like this (where ‘chipname’ is replaced by<br>the name of the chip):</p>
<p>struct chipname_state {<br>    struct v4l2_subdev sd;<br>    …  /* additional state fields */<br>};</p>
<p>Initialize the v4l2_subdev struct as follows:</p>
<pre><code>v4l2_i2c_subdev_init(&amp;state-&gt;sd, client, subdev_ops);
</code></pre>
<p>This function will fill in all the fields of v4l2_subdev and ensure that the<br>v4l2_subdev and i2c_client both point to one another.</p>
<p>You should also add a helper inline function to go from a v4l2_subdev pointer<br>to a chipname_state struct:</p>
<p>static inline struct chipname_state *to_state(struct v4l2_subdev *sd)<br>{<br>    return container_of(sd, struct chipname_state, sd);<br>}</p>
<p>Use this to go from the v4l2_subdev struct to the i2c_client struct:</p>
<pre><code>struct i2c_client *client = v4l2_get_subdevdata(sd);
</code></pre>
<p>And this to go from an i2c_client to a v4l2_subdev struct:</p>
<pre><code>struct v4l2_subdev *sd = i2c_get_clientdata(client);
</code></pre>
<p>Make sure to call v4l2_device_unregister_subdev(sd) when the remove() callback<br>is called. This will unregister the sub-device from the bridge driver. It is<br>safe to call this even if the sub-device was never registered.</p>
<p>You need to do this because when the bridge driver destroys the i2c adapter<br>the remove() callbacks are called of the i2c devices on that adapter.<br>After that the corresponding v4l2_subdev structures are invalid, so they<br>have to be unregistered first. Calling v4l2_device_unregister_subdev(sd)<br>from the remove() callback ensures that this is always done correctly.</p>
<p>The bridge driver also has some helper functions it can use:</p>
<p>struct v4l2_subdev *sd = v4l2_i2c_new_subdev(v4l2_dev, adapter,<br>           “module_foo”, “chipid”, 0x36, NULL);</p>
<p>This loads the given module (can be NULL if no module needs to be loaded) and<br>calls i2c_new_device() with the given i2c_adapter and chip/address arguments.<br>If all goes well, then it registers the subdev with the v4l2_device.</p>
<p>You can also use the last argument of v4l2_i2c_new_subdev() to pass an array<br>of possible I2C addresses that it should probe. These probe addresses are<br>only used if the previous argument is 0. A non-zero argument means that you<br>know the exact i2c address so in that case no probing will take place.</p>
<p>Both functions return NULL if something went wrong.</p>
<p>Note that the chipid you pass to v4l2_i2c_new_subdev() is usually<br>the same as the module name. It allows you to specify a chip variant, e.g.<br>“saa7114” or “saa7115”. In general though the i2c driver autodetects this.<br>The use of chipid is something that needs to be looked at more closely at a<br>later date. It differs between i2c drivers and as such can be confusing.<br>To see which chip variants are supported you can look in the i2c driver code<br>for the i2c_device_id table. This lists all the possibilities.</p>
<p>There are two more helper functions:</p>
<p>v4l2_i2c_new_subdev_cfg: this function adds new irq and platform_data<br>arguments and has both ‘addr’ and ‘probed_addrs’ arguments: if addr is not<br>0 then that will be used (non-probing variant), otherwise the probed_addrs<br>are probed.</p>
<p>For example: this will probe for address 0x10:</p>
<p>struct v4l2_subdev *sd = v4l2_i2c_new_subdev_cfg(v4l2_dev, adapter,<br>           “module_foo”, “chipid”, 0, NULL, 0, I2C_ADDRS(0x10));</p>
<p>v4l2_i2c_new_subdev_board uses an i2c_board_info struct which is passed<br>to the i2c driver and replaces the irq, platform_data and addr arguments.</p>
<p>If the subdev supports the s_config core ops, then that op is called with<br>the irq and platform_data arguments after the subdev was setup. The older<br>v4l2_i2c_new_(probed_)subdev functions will call s_config as well, but with<br>irq set to 0 and platform_data set to NULL.</p>
<h2 id="struct-video-device"><a href="#struct-video-device" class="headerlink" title="struct video_device"></a>struct video_device</h2><p>The actual device nodes in the /dev directory are created using the<br>video_device struct (v4l2-dev.h). This struct can either be allocated<br>dynamically or embedded in a larger struct.</p>
<p>To allocate it dynamically use:</p>
<pre><code>struct video_device *vdev = video_device_alloc();

if (vdev == NULL)
    return -ENOMEM;

vdev-&gt;release = video_device_release;
</code></pre>
<p>If you embed it in a larger struct, then you must set the release()<br>callback to your own function:</p>
<pre><code>struct video_device *vdev = &amp;my_vdev-&gt;vdev;

vdev-&gt;release = my_vdev_release;
</code></pre>
<p>The release callback must be set and it is called when the last user<br>of the video device exits.</p>
<p>The default video_device_release() callback just calls kfree to free the<br>allocated memory.</p>
<p>You should also set these fields:</p>
<ul>
<li><p>v4l2_dev: set to the v4l2_device parent device.</p>
</li>
<li><p>name: set to something descriptive and unique.</p>
</li>
<li><p>fops: set to the v4l2_file_operations struct.</p>
</li>
<li><p>ioctl_ops: if you use the v4l2_ioctl_ops to simplify ioctl maintenance<br>(highly recommended to use this and it might become compulsory in the<br>future!), then set this to your v4l2_ioctl_ops struct.</p>
</li>
<li><p>parent: you only set this if v4l2_device was registered with NULL as<br>the parent device struct. This only happens in cases where one hardware<br>device has multiple PCI devices that all share the same v4l2_device core.</p>
<p>The cx88 driver is an example of this: one core v4l2_device struct, but<br>it is used by both an raw video PCI device (cx8800) and a MPEG PCI device<br>(cx8802). Since the v4l2_device cannot be associated with a particular<br>PCI device it is setup without a parent device. But when the struct<br>video_device is setup you do know which parent PCI device to use.</p>
</li>
</ul>
<p>If you use v4l2_ioctl_ops, then you should set either .unlocked_ioctl or<br>.ioctl to video_ioctl2 in your v4l2_file_operations struct.</p>
<p>The v4l2_file_operations struct is a subset of file_operations. The main<br>difference is that the inode argument is omitted since it is never used.</p>
<h2 id="video-device-registration"><a href="#video-device-registration" class="headerlink" title="video_device registration"></a>video_device registration</h2><p>Next you register the video device: this will create the character device<br>for you.</p>
<pre><code>err = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
if (err) &#123;
    video_device_release(vdev); /* or kfree(my_vdev); */
    return err;
&#125;
</code></pre>
<p>Which device is registered depends on the type argument. The following<br>types exist:</p>
<p>VFL_TYPE_GRABBER: videoX for video input/output devices<br>VFL_TYPE_VBI: vbiX for vertical blank data (i.e. closed captions, teletext)<br>VFL_TYPE_RADIO: radioX for radio tuners<br>VFL_TYPE_VTX: vtxX for teletext devices (deprecated, don’t use)</p>
<p>The last argument gives you a certain amount of control over the device<br>device node number used (i.e. the X in videoX). Normally you will pass -1<br>to let the v4l2 framework pick the first free number. But sometimes users<br>want to select a specific node number. It is common that drivers allow<br>the user to select a specific device node number through a driver module<br>option. That number is then passed to this function and video_register_device<br>will attempt to select that device node number. If that number was already<br>in use, then the next free device node number will be selected and it<br>will send a warning to the kernel log.</p>
<p>Another use-case is if a driver creates many devices. In that case it can<br>be useful to place different video devices in separate ranges. For example,<br>video capture devices start at 0, video output devices start at 16.<br>So you can use the last argument to specify a minimum device node number<br>and the v4l2 framework will try to pick the first free number that is equal<br>or higher to what you passed. If that fails, then it will just pick the<br>first free number.</p>
<p>Since in this case you do not care about a warning about not being able<br>to select the specified device node number, you can call the function<br>video_register_device_no_warn() instead.</p>
<p>Whenever a device node is created some attributes are also created for you.<br>If you look in /sys/class/video4linux you see the devices. Go into e.g.<br>video0 and you will see ‘name’ and ‘index’ attributes. The ‘name’ attribute<br>is the ‘name’ field of the video_device struct.</p>
<p>The ‘index’ attribute is the index of the device node: for each call to<br>video_register_device() the index is just increased by 1. The first video<br>device node you register always starts with index 0.</p>
<p>Users can setup udev rules that utilize the index attribute to make fancy<br>device names (e.g. ‘mpegX’ for MPEG video capture device nodes).</p>
<p>After the device was successfully registered, then you can use these fields:</p>
<ul>
<li>vfl_type: the device type passed to video_register_device.</li>
<li>minor: the assigned device minor number.</li>
<li>num: the device node number (i.e. the X in videoX).</li>
<li>index: the device index number.</li>
</ul>
<p>If the registration failed, then you need to call video_device_release()<br>to free the allocated video_device struct, or free your own struct if the<br>video_device was embedded in it. The vdev-&gt;release() callback will never<br>be called if the registration failed, nor should you ever attempt to<br>unregister the device if the registration failed.</p>
<h2 id="video-device-cleanup"><a href="#video-device-cleanup" class="headerlink" title="video_device cleanup"></a>video_device cleanup</h2><p>When the video device nodes have to be removed, either during the unload<br>of the driver or because the USB device was disconnected, then you should<br>unregister them:</p>
<pre><code>video_unregister_device(vdev);
</code></pre>
<p>This will remove the device nodes from sysfs (causing udev to remove them<br>from /dev).</p>
<p>After video_unregister_device() returns no new opens can be done.</p>
<p>However, in the case of USB devices some application might still have one<br>of these device nodes open. You should block all new accesses to read,<br>write, poll, etc. except possibly for certain ioctl operations like<br>queueing buffers.</p>
<p>When the last user of the video device node exits, then the vdev-&gt;release()<br>callback is called and you can do the final cleanup there.</p>
<h2 id="video-device-helper-functions"><a href="#video-device-helper-functions" class="headerlink" title="video_device helper functions"></a>video_device helper functions</h2><p>There are a few useful helper functions:</p>
<p>You can set/get driver private data in the video_device struct using:</p>
<p>void *video_get_drvdata(struct video_device *vdev);<br>void video_set_drvdata(struct video_device *vdev, void *data);</p>
<p>Note that you can safely call video_set_drvdata() before calling<br>video_register_device().</p>
<p>And this function:</p>
<p>struct video_device *video_devdata(struct file *file);</p>
<p>returns the video_device belonging to the file struct.</p>
<p>The final helper function combines video_get_drvdata with<br>video_devdata:</p>
<p>void *video_drvdata(struct file *file);</p>
<p>You can go from a video_device struct to the v4l2_device struct using:</p>
<p>struct v4l2_device *v4l2_dev = vdev-&gt;v4l2_dev;</p>
<h2 id="video-buffer-helper-functions"><a href="#video-buffer-helper-functions" class="headerlink" title="video buffer helper functions"></a>video buffer helper functions</h2><p>The v4l2 core API provides a standard method for dealing with video<br>buffers. Those methods allow a driver to implement read(), mmap() and<br>overlay() on a consistent way.</p>
<p>There are currently methods for using video buffers on devices that<br>supports DMA with scatter/gather method (videobuf-dma-sg), DMA with<br>linear access (videobuf-dma-contig), and vmalloced buffers, mostly<br>used on USB drivers (videobuf-vmalloc).</p>
<p>Any driver using videobuf should provide operations (callbacks) for<br>four handlers:</p>
<p>ops-&gt;buf_setup   - calculates the size of the video buffers and avoid they<br>           to waste more than some maximum limit of RAM;<br>ops-&gt;buf_prepare - fills the video buffer structs and calls<br>           videobuf_iolock() to alloc and prepare mmaped memory;<br>ops-&gt;buf_queue   - advices the driver that another buffer were<br>           requested (by read() or by QBUF);<br>ops-&gt;buf_release - frees any buffer that were allocated.</p>
<p>In order to use it, the driver need to have a code (generally called at<br>interrupt context) that will properly handle the buffer request lists,<br>announcing that a new buffer were filled.</p>
<p>The irq handling code should handle the videobuf task lists, in order<br>to advice videobuf that a new frame were filled, in order to honor to a<br>request. The code is generally like this one:<br>    if (list_empty(&amp;dma_q-&gt;active))<br>        return;</p>
<pre><code>buf = list_entry(dma_q-&gt;active.next, struct vbuffer, vb.queue);

if (!waitqueue_active(&amp;buf-&gt;vb.done))
    return;

/* Some logic to handle the buf may be needed here */

list_del(&amp;buf-&gt;vb.queue);
do_gettimeofday(&amp;buf-&gt;vb.ts);
wake_up(&amp;buf-&gt;vb.done);
</code></pre>
<p>Those are the videobuffer functions used on drivers, implemented on<br>videobuf-core:</p>
<ul>
<li><p>Videobuf init functions<br>videobuf_queue_sg_init()</p>
<pre><code>Initializes the videobuf infrastructure. This function should be
called before any other videobuf function on drivers that uses DMA
Scatter/Gather buffers.
</code></pre>
<p>videobuf_queue_dma_contig_init</p>
<pre><code>Initializes the videobuf infrastructure. This function should be
called before any other videobuf function on drivers that need DMA
contiguous buffers.
</code></pre>
<p>videobuf_queue_vmalloc_init()</p>
<pre><code>Initializes the videobuf infrastructure. This function should be
called before any other videobuf function on USB (and other drivers)
that need a vmalloced type of videobuf.
</code></pre>
</li>
<li><p>videobuf_iolock()<br>Prepares the videobuf memory for the proper method (read, mmap, overlay).</p>
</li>
<li><p>videobuf_queue_is_busy()<br>Checks if a videobuf is streaming.</p>
</li>
<li><p>videobuf_queue_cancel()<br>Stops video handling.</p>
</li>
<li><p>videobuf_mmap_free()<br>frees mmap buffers.</p>
</li>
<li><p>videobuf_stop()<br>Stops video handling, ends mmap and frees mmap and other buffers.</p>
</li>
<li><p>V4L2 api functions. Those functions correspond to VIDIOC_foo ioctls:<br> videobuf_reqbufs(), videobuf_querybuf(), videobuf_qbuf(),<br> videobuf_dqbuf(), videobuf_streamon(), videobuf_streamoff().</p>
</li>
<li><p>V4L1 api function (corresponds to VIDIOCMBUF ioctl):<br> videobuf_cgmbuf()</p>
<pre><code>This function is used to provide backward compatibility with V4L1
API.
</code></pre>
</li>
<li><p>Some help functions for read()/poll() operations:<br> videobuf_read_stream()</p>
<pre><code>For continuous stream read()
</code></pre>
<p> videobuf_read_one()</p>
<pre><code>For snapshot read()
</code></pre>
<p> videobuf_poll_stream()</p>
<pre><code>polling help function
</code></pre>
</li>
</ul>
<p>The better way to understand it is to take a look at vivi driver. One<br>of the main reasons for vivi is to be a videobuf usage example. the<br>vivi_thread_tick() does the task that the IRQ callback would do on PCI<br>drivers (or the irq callback on USB).</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_v4l2-framework/" title="Kernel-2.6.32-573.12.1.el6_v4l2-framework" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_v4l2-framework/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_vm/" title="Kernel-2.6.32-573.12.1.el6_v"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_usb-serial/" title="Kernel-2.6.32-573.12.1.el6_usb-serial"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>