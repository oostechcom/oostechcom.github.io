<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-3.10.0-957.el7_can | oosTech.com</title>
  <meta name="description" content="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; can.txt Readme file for the Controller Area Network Protocol Family (aka Socket CAN) This file contains   1 Overview &#x2F; What">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-3.10.0-957.el7_can">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_can/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; can.txt Readme file for the Controller Area Network Protocol Family (aka Socket CAN) This file contains   1 Overview &#x2F; What">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_can/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-3.10.0-957.el7_can" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-3.10.0-957.el7_can
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_can/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_can/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-3.10.0-957.el7_can/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>============================================================================</p>
<p>can.txt</p>
<p>Readme file for the Controller Area Network Protocol Family (aka Socket CAN)</p>
<p>This file contains</p>
<p>  1 Overview / What is Socket CAN</p>
<p>  2 Motivation / Why using the socket API</p>
<p>  3 Socket CAN concept<br>    3.1 receive lists<br>    3.2 local loopback of sent frames<br>    3.3 network security issues (capabilities)<br>    3.4 network problem notifications</p>
<p>  4 How to use Socket CAN<br>    4.1 RAW protocol sockets with can_filters (SOCK_RAW)<br>      4.1.1 RAW socket option CAN_RAW_FILTER<br>      4.1.2 RAW socket option CAN_RAW_ERR_FILTER<br>      4.1.3 RAW socket option CAN_RAW_LOOPBACK<br>      4.1.4 RAW socket option CAN_RAW_RECV_OWN_MSGS<br>      4.1.5 RAW socket option CAN_RAW_FD_FRAMES<br>      4.1.6 RAW socket option CAN_RAW_JOIN_FILTERS<br>      4.1.7 RAW socket returned message flags<br>    4.2 Broadcast Manager protocol sockets (SOCK_DGRAM)<br>    4.3 connected transport protocols (SOCK_SEQPACKET)<br>    4.4 unconnected transport protocols (SOCK_DGRAM)</p>
<p>  5 Socket CAN core module<br>    5.1 can.ko module params<br>    5.2 procfs content<br>    5.3 writing own CAN protocol modules</p>
<p>  6 CAN network drivers<br>    6.1 general settings<br>    6.2 local loopback of sent frames<br>    6.3 CAN controller hardware filters<br>    6.4 The virtual CAN driver (vcan)<br>    6.5 The CAN network device driver interface<br>      6.5.1 Netlink interface to set/get devices properties<br>      6.5.2 Setting the CAN bit-timing<br>      6.5.3 Starting and stopping the CAN network device<br>    6.6 CAN FD (flexible data rate) driver support<br>    6.7 supported CAN hardware</p>
<p>  7 Socket CAN resources</p>
<p>  8 Credits</p>
<p>============================================================================</p>
<ol>
<li>Overview / What is Socket CAN</li>
</ol>
<hr>
<p>The socketcan package is an implementation of CAN protocols<br>(Controller Area Network) for Linux.  CAN is a networking technology<br>which has widespread use in automation, embedded devices, and<br>automotive fields.  While there have been other CAN implementations<br>for Linux based on character devices, Socket CAN uses the Berkeley<br>socket API, the Linux network stack and implements the CAN device<br>drivers as network interfaces.  The CAN socket API has been designed<br>as similar as possible to the TCP/IP protocols to allow programmers,<br>familiar with network programming, to easily learn how to use CAN<br>sockets.</p>
<ol start="2">
<li>Motivation / Why using the socket API</li>
</ol>
<hr>
<p>There have been CAN implementations for Linux before Socket CAN so the<br>question arises, why we have started another project.  Most existing<br>implementations come as a device driver for some CAN hardware, they<br>are based on character devices and provide comparatively little<br>functionality.  Usually, there is only a hardware-specific device<br>driver which provides a character device interface to send and<br>receive raw CAN frames, directly to/from the controller hardware.<br>Queueing of frames and higher-level transport protocols like ISO-TP<br>have to be implemented in user space applications.  Also, most<br>character-device implementations support only one single process to<br>open the device at a time, similar to a serial interface.  Exchanging<br>the CAN controller requires employment of another device driver and<br>often the need for adaption of large parts of the application to the<br>new driver’s API.</p>
<p>Socket CAN was designed to overcome all of these limitations.  A new<br>protocol family has been implemented which provides a socket interface<br>to user space applications and which builds upon the Linux network<br>layer, so to use all of the provided queueing functionality.  A device<br>driver for CAN controller hardware registers itself with the Linux<br>network layer as a network device, so that CAN frames from the<br>controller can be passed up to the network layer and on to the CAN<br>protocol family module and also vice-versa.  Also, the protocol family<br>module provides an API for transport protocol modules to register, so<br>that any number of transport protocols can be loaded or unloaded<br>dynamically.  In fact, the can core module alone does not provide any<br>protocol and cannot be used without loading at least one additional<br>protocol module.  Multiple sockets can be opened at the same time,<br>on different or the same protocol module and they can listen/send<br>frames on different or the same CAN IDs.  Several sockets listening on<br>the same interface for frames with the same CAN ID are all passed the<br>same received matching CAN frames.  An application wishing to<br>communicate using a specific transport protocol, e.g. ISO-TP, just<br>selects that protocol when opening the socket, and then can read and<br>write application data byte streams, without having to deal with<br>CAN-IDs, frames, etc.</p>
<p>Similar functionality visible from user-space could be provided by a<br>character device, too, but this would lead to a technically inelegant<br>solution for a couple of reasons:</p>
<ul>
<li><p>Intricate usage.  Instead of passing a protocol argument to<br>socket(2) and using bind(2) to select a CAN interface and CAN ID, an<br>application would have to do all these operations using ioctl(2)s.</p>
</li>
<li><p>Code duplication.  A character device cannot make use of the Linux<br>network queueing code, so all that code would have to be duplicated<br>for CAN networking.</p>
</li>
<li><p>Abstraction.  In most existing character-device implementations, the<br>hardware-specific device driver for a CAN controller directly<br>provides the character device for the application to work with.<br>This is at least very unusual in Unix systems for both, char and<br>block devices.  For example you don’t have a character device for a<br>certain UART of a serial interface, a certain sound chip in your<br>computer, a SCSI or IDE controller providing access to your hard<br>disk or tape streamer device.  Instead, you have abstraction layers<br>which provide a unified character or block device interface to the<br>application on the one hand, and a interface for hardware-specific<br>device drivers on the other hand.  These abstractions are provided<br>by subsystems like the tty layer, the audio subsystem or the SCSI<br>and IDE subsystems for the devices mentioned above.</p>
<p>The easiest way to implement a CAN device driver is as a character<br>device without such a (complete) abstraction layer, as is done by most<br>existing drivers.  The right way, however, would be to add such a<br>layer with all the functionality like registering for certain CAN<br>IDs, supporting several open file descriptors and (de)multiplexing<br>CAN frames between them, (sophisticated) queueing of CAN frames, and<br>providing an API for device drivers to register with.  However, then<br>it would be no more difficult, or may be even easier, to use the<br>networking framework provided by the Linux kernel, and this is what<br>Socket CAN does.</p>
<p>The use of the networking framework of the Linux kernel is just the<br>natural and most appropriate way to implement CAN for Linux.</p>
</li>
</ul>
<ol start="3">
<li>Socket CAN concept</li>
</ol>
<hr>
<p>  As described in chapter 2 it is the main goal of Socket CAN to<br>  provide a socket interface to user space applications which builds<br>  upon the Linux network layer. In contrast to the commonly known<br>  TCP/IP and ethernet networking, the CAN bus is a broadcast-only(!)<br>  medium that has no MAC-layer addressing like ethernet. The CAN-identifier<br>  (can_id) is used for arbitration on the CAN-bus. Therefore the CAN-IDs<br>  have to be chosen uniquely on the bus. When designing a CAN-ECU<br>  network the CAN-IDs are mapped to be sent by a specific ECU.<br>  For this reason a CAN-ID can be treated best as a kind of source address.</p>
<p>  3.1 receive lists</p>
<p>  The network transparent access of multiple applications leads to the<br>  problem that different applications may be interested in the same<br>  CAN-IDs from the same CAN network interface. The Socket CAN core<br>  module - which implements the protocol family CAN - provides several<br>  high efficient receive lists for this reason. If e.g. a user space<br>  application opens a CAN RAW socket, the raw protocol module itself<br>  requests the (range of) CAN-IDs from the Socket CAN core that are<br>  requested by the user. The subscription and unsubscription of<br>  CAN-IDs can be done for specific CAN interfaces or for all(!) known<br>  CAN interfaces with the can_rx_(un)register() functions provided to<br>  CAN protocol modules by the SocketCAN core (see chapter 5).<br>  To optimize the CPU usage at runtime the receive lists are split up<br>  into several specific lists per device that match the requested<br>  filter complexity for a given use-case.</p>
<p>  3.2 local loopback of sent frames</p>
<p>  As known from other networking concepts the data exchanging<br>  applications may run on the same or different nodes without any<br>  change (except for the according addressing information):</p>
<pre><code>     ___   ___   ___                   _______   ___
    | _ | | _ | | _ |                 | _   _ | | _ |
    ||A|| ||B|| ||C||                 ||A| |B|| ||C||
    |___| |___| |___|                 |_______| |___|
      |     |     |                       |       |
    -----------------(1)- CAN bus -(2)---------------
</code></pre>
<p>  To ensure that application A receives the same information in the<br>  example (2) as it would receive in example (1) there is need for<br>  some kind of local loopback of the sent CAN frames on the appropriate<br>  node.</p>
<p>  The Linux network devices (by default) just can handle the<br>  transmission and reception of media dependent frames. Due to the<br>  arbitration on the CAN bus the transmission of a low prio CAN-ID<br>  may be delayed by the reception of a high prio CAN frame. To<br>  reflect the correct* traffic on the node the loopback of the sent<br>  data has to be performed right after a successful transmission. If<br>  the CAN network interface is not capable of performing the loopback for<br>  some reason the SocketCAN core can do this task as a fallback solution.<br>  See chapter 6.2 for details (recommended).</p>
<p>  The loopback functionality is enabled by default to reflect standard<br>  networking behaviour for CAN applications. Due to some requests from<br>  the RT-SocketCAN group the loopback optionally may be disabled for each<br>  separate socket. See sockopts from the CAN RAW sockets in chapter 4.1.</p>
<ul>
<li>= you really like to have this when you’re running analyser tools<br>  like ‘candump’ or ‘cansniffer’ on the (same) node.</li>
</ul>
<p>  3.3 network security issues (capabilities)</p>
<p>  The Controller Area Network is a local field bus transmitting only<br>  broadcast messages without any routing and security concepts.<br>  In the majority of cases the user application has to deal with<br>  raw CAN frames. Therefore it might be reasonable NOT to restrict<br>  the CAN access only to the user root, as known from other networks.<br>  Since the currently implemented CAN_RAW and CAN_BCM sockets can only<br>  send and receive frames to/from CAN interfaces it does not affect<br>  security of others networks to allow all users to access the CAN.<br>  To enable non-root users to access CAN_RAW and CAN_BCM protocol<br>  sockets the Kconfig options CAN_RAW_USER and/or CAN_BCM_USER may be<br>  selected at kernel compile time.</p>
<p>  3.4 network problem notifications</p>
<p>  The use of the CAN bus may lead to several problems on the physical<br>  and media access control layer. Detecting and logging of these lower<br>  layer problems is a vital requirement for CAN users to identify<br>  hardware issues on the physical transceiver layer as well as<br>  arbitration problems and error frames caused by the different<br>  ECUs. The occurrence of detected errors are important for diagnosis<br>  and have to be logged together with the exact timestamp. For this<br>  reason the CAN interface driver can generate so called Error Message<br>  Frames that can optionally be passed to the user application in the<br>  same way as other CAN frames. Whenever an error on the physical layer<br>  or the MAC layer is detected (e.g. by the CAN controller) the driver<br>  creates an appropriate error message frame. Error messages frames can<br>  be requested by the user application using the common CAN filter<br>  mechanisms. Inside this filter definition the (interested) type of<br>  errors may be selected. The reception of error messages is disabled<br>  by default. The format of the CAN error message frame is briefly<br>  described in the Linux header file “include/linux/can/error.h”.</p>
<ol start="4">
<li>How to use Socket CAN</li>
</ol>
<hr>
<p>  Like TCP/IP, you first need to open a socket for communicating over a<br>  CAN network. Since Socket CAN implements a new protocol family, you<br>  need to pass PF_CAN as the first argument to the socket(2) system<br>  call. Currently, there are two CAN protocols to choose from, the raw<br>  socket protocol and the broadcast manager (BCM). So to open a socket,<br>  you would write</p>
<pre><code>s = socket(PF_CAN, SOCK_RAW, CAN_RAW);
</code></pre>
<p>  and</p>
<pre><code>s = socket(PF_CAN, SOCK_DGRAM, CAN_BCM);
</code></pre>
<p>  respectively.  After the successful creation of the socket, you would<br>  normally use the bind(2) system call to bind the socket to a CAN<br>  interface (which is different from TCP/IP due to different addressing</p>
<ul>
<li><p>see chapter 3). After binding (CAN_RAW) or connecting (CAN_BCM)<br>the socket, you can read(2) and write(2) from/to the socket or use<br>send(2), sendto(2), sendmsg(2) and the recv* counterpart operations<br>on the socket as usual. There are also CAN specific socket options<br>described below.</p>
<p>The basic CAN frame structure and the sockaddr structure are defined<br>in include/linux/can.h:</p>
<p>struct can_frame {</p>
<pre><code>    canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
    __u8    can_dlc; /* frame payload length in byte (0 .. 8) */
    __u8    data[8] __attribute__((aligned(8)));
</code></pre>
<p>};</p>
<p>The alignment of the (linear) payload data[] to a 64bit boundary<br>allows the user to define own structs and unions to easily access the<br>CAN payload. There is no given byteorder on the CAN bus by<br>default. A read(2) system call on a CAN_RAW socket transfers a<br>struct can_frame to the user space.</p>
<p>The sockaddr_can structure has an interface index like the<br>PF_PACKET socket, that also binds to a specific interface:</p>
<p>struct sockaddr_can {</p>
<pre><code>    sa_family_t can_family;
    int         can_ifindex;
    union &#123;
            /* transport protocol class address info (e.g. ISOTP) */
            struct &#123; canid_t rx_id, tx_id; &#125; tp;

            /* reserved for future CAN protocols address information */
    &#125; can_addr;
</code></pre>
<p>};</p>
<p>To determine the interface index an appropriate ioctl() has to<br>be used (example for CAN_RAW sockets without error checking):</p>
<p>int s;<br>struct sockaddr_can addr;<br>struct ifreq ifr;</p>
<p>s = socket(PF_CAN, SOCK_RAW, CAN_RAW);</p>
<p>strcpy(ifr.ifr_name, “can0” );<br>ioctl(s, SIOCGIFINDEX, &amp;ifr);</p>
<p>addr.can_family = AF_CAN;<br>addr.can_ifindex = ifr.ifr_ifindex;</p>
<p>bind(s, (struct sockaddr *)&amp;addr, sizeof(addr));</p>
<p>(..)</p>
<p>To bind a socket to all(!) CAN interfaces the interface index must<br>be 0 (zero). In this case the socket receives CAN frames from every<br>enabled CAN interface. To determine the originating CAN interface<br>the system call recvfrom(2) may be used instead of read(2). To send<br>on a socket that is bound to ‘any’ interface sendto(2) is needed to<br>specify the outgoing interface.</p>
<p>Reading CAN frames from a bound CAN_RAW socket (see above) consists<br>of reading a struct can_frame:</p>
<p>struct can_frame frame;</p>
<p>nbytes = read(s, &amp;frame, sizeof(struct can_frame));</p>
<p>if (nbytes &lt; 0) {</p>
<pre><code>    perror(&quot;can raw socket read&quot;);
    return 1;
</code></pre>
<p>}</p>
<p>/* paranoid check … */<br>if (nbytes &lt; sizeof(struct can_frame)) {</p>
<pre><code>    fprintf(stderr, &quot;read: incomplete CAN frame\n&quot;);
    return 1;
</code></pre>
<p>}</p>
<p>/* do something with the received CAN frame */</p>
<p>Writing CAN frames can be done similarly, with the write(2) system call:</p>
<p>nbytes = write(s, &amp;frame, sizeof(struct can_frame));</p>
<p>When the CAN interface is bound to ‘any’ existing CAN interface<br>(addr.can_ifindex = 0) it is recommended to use recvfrom(2) if the<br>information about the originating CAN interface is needed:</p>
<p>struct sockaddr_can addr;<br>struct ifreq ifr;<br>socklen_t len = sizeof(addr);<br>struct can_frame frame;</p>
<p>nbytes = recvfrom(s, &amp;frame, sizeof(struct can_frame),</p>
<pre><code>              0, (struct sockaddr*)&amp;addr, &amp;len);
</code></pre>
<p>/* get interface name of the received CAN frame */<br>ifr.ifr_ifindex = addr.can_ifindex;<br>ioctl(s, SIOCGIFNAME, &amp;ifr);<br>printf(“Received a CAN frame from interface %s”, ifr.ifr_name);</p>
<p>To write CAN frames on sockets bound to ‘any’ CAN interface the<br>outgoing interface has to be defined certainly.</p>
<p>strcpy(ifr.ifr_name, “can0”);<br>ioctl(s, SIOCGIFINDEX, &amp;ifr);<br>addr.can_ifindex = ifr.ifr_ifindex;<br>addr.can_family  = AF_CAN;</p>
<p>nbytes = sendto(s, &amp;frame, sizeof(struct can_frame),</p>
<pre><code>            0, (struct sockaddr*)&amp;addr, sizeof(addr));
</code></pre>
<p>Remark about CAN FD (flexible data rate) support:</p>
<p>Generally the handling of CAN FD is very similar to the formerly described<br>examples. The new CAN FD capable CAN controllers support two different<br>bitrates for the arbitration phase and the payload phase of the CAN FD frame<br>and up to 64 bytes of payload. This extended payload length breaks all the<br>kernel interfaces (ABI) which heavily rely on the CAN frame with fixed eight<br>bytes of payload (struct can_frame) like the CAN_RAW socket. Therefore e.g.<br>the CAN_RAW socket supports a new socket option CAN_RAW_FD_FRAMES that<br>switches the socket into a mode that allows the handling of CAN FD frames<br>and (legacy) CAN frames simultaneously (see section 4.1.5).</p>
<p>The struct canfd_frame is defined in include/linux/can.h:</p>
<p>struct canfd_frame {</p>
<pre><code>    canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
    __u8    len;     /* frame payload length in byte (0 .. 64) */
    __u8    flags;   /* additional flags for CAN FD */
    __u8    __res0;  /* reserved / padding */
    __u8    __res1;  /* reserved / padding */
    __u8    data[64] __attribute__((aligned(8)));
</code></pre>
<p>};</p>
<p>The struct canfd_frame and the existing struct can_frame have the can_id,<br>the payload length and the payload data at the same offset inside their<br>structures. This allows to handle the different structures very similar.<br>When the content of a struct can_frame is copied into a struct canfd_frame<br>all structure elements can be used as-is - only the data[] becomes extended.</p>
<p>When introducing the struct canfd_frame it turned out that the data length<br>code (DLC) of the struct can_frame was used as a length information as the<br>length and the DLC has a 1:1 mapping in the range of 0 .. 8. To preserve<br>the easy handling of the length information the canfd_frame.len element<br>contains a plain length value from 0 .. 64. So both canfd_frame.len and<br>can_frame.can_dlc are equal and contain a length information and no DLC.<br>For details about the distinction of CAN and CAN FD capable devices and<br>the mapping to the bus-relevant data length code (DLC), see chapter 6.6.</p>
<p>The length of the two CAN(FD) frame structures define the maximum transfer<br>unit (MTU) of the CAN(FD) network interface and skbuff data length. Two<br>definitions are specified for CAN specific MTUs in include/linux/can.h :</p>
<p>#define CAN_MTU   (sizeof(struct can_frame))   == 16  =&gt; ‘legacy’ CAN frame<br>#define CANFD_MTU (sizeof(struct canfd_frame)) == 72  =&gt; CAN FD frame</p>
</li>
</ul>
<p>  4.1 RAW protocol sockets with can_filters (SOCK_RAW)</p>
<p>  Using CAN_RAW sockets is extensively comparable to the commonly<br>  known access to CAN character devices. To meet the new possibilities<br>  provided by the multi user SocketCAN approach, some reasonable<br>  defaults are set at RAW socket binding time:</p>
<ul>
<li><p>The filters are set to exactly one filter receiving everything</p>
</li>
<li><p>The socket only receives valid data frames (=&gt; no error message frames)</p>
</li>
<li><p>The loopback of sent CAN frames is enabled (see chapter 3.2)</p>
</li>
<li><p>The socket does not receive its own sent frames (in loopback mode)</p>
<p>These default settings may be changed before or after binding the socket.<br>To use the referenced definitions of the socket options for CAN_RAW<br>sockets, include &lt;linux/can/raw.h&gt;.</p>
</li>
</ul>
<p>  4.1.1 RAW socket option CAN_RAW_FILTER</p>
<p>  The reception of CAN frames using CAN_RAW sockets can be controlled<br>  by defining 0 .. n filters with the CAN_RAW_FILTER socket option.</p>
<p>  The CAN filter structure is defined in include/linux/can.h:</p>
<pre><code>struct can_filter &#123;
        canid_t can_id;
        canid_t can_mask;
&#125;;
</code></pre>
<p>  A filter matches, when</p>
<pre><code>&lt;received_can_id&gt; &amp; mask == can_id &amp; mask
</code></pre>
<p>  which is analogous to known CAN controllers hardware filter semantics.<br>  The filter can be inverted in this semantic, when the CAN_INV_FILTER<br>  bit is set in can_id element of the can_filter structure. In<br>  contrast to CAN controller hardware filters the user may set 0 .. n<br>  receive filters for each open socket separately:</p>
<pre><code>struct can_filter rfilter[2];

rfilter[0].can_id   = 0x123;
rfilter[0].can_mask = CAN_SFF_MASK;
rfilter[1].can_id   = 0x200;
rfilter[1].can_mask = 0x700;

setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, &amp;rfilter, sizeof(rfilter));
</code></pre>
<p>  To disable the reception of CAN frames on the selected CAN_RAW socket:</p>
<pre><code>setsockopt(s, SOL_CAN_RAW, CAN_RAW_FILTER, NULL, 0);
</code></pre>
<p>  To set the filters to zero filters is quite obsolete as not read<br>  data causes the raw socket to discard the received CAN frames. But<br>  having this ‘send only’ use-case we may remove the receive list in the<br>  Kernel to save a little (really a very little!) CPU usage.</p>
<p>  4.1.2 RAW socket option CAN_RAW_ERR_FILTER</p>
<p>  As described in chapter 3.4 the CAN interface driver can generate so<br>  called Error Message Frames that can optionally be passed to the user<br>  application in the same way as other CAN frames. The possible<br>  errors are divided into different error classes that may be filtered<br>  using the appropriate error mask. To register for every possible<br>  error condition CAN_ERR_MASK can be used as value for the error mask.<br>  The values for the error mask are defined in linux/can/error.h .</p>
<pre><code>can_err_mask_t err_mask = ( CAN_ERR_TX_TIMEOUT | CAN_ERR_BUSOFF );

setsockopt(s, SOL_CAN_RAW, CAN_RAW_ERR_FILTER,
           &amp;err_mask, sizeof(err_mask));
</code></pre>
<p>  4.1.3 RAW socket option CAN_RAW_LOOPBACK</p>
<p>  To meet multi user needs the local loopback is enabled by default<br>  (see chapter 3.2 for details). But in some embedded use-cases<br>  (e.g. when only one application uses the CAN bus) this loopback<br>  functionality can be disabled (separately for each socket):</p>
<pre><code>int loopback = 0; /* 0 = disabled, 1 = enabled (default) */

setsockopt(s, SOL_CAN_RAW, CAN_RAW_LOOPBACK, &amp;loopback, sizeof(loopback));
</code></pre>
<p>  4.1.4 RAW socket option CAN_RAW_RECV_OWN_MSGS</p>
<p>  When the local loopback is enabled, all the sent CAN frames are<br>  looped back to the open CAN sockets that registered for the CAN<br>  frames’ CAN-ID on this given interface to meet the multi user<br>  needs. The reception of the CAN frames on the same socket that was<br>  sending the CAN frame is assumed to be unwanted and therefore<br>  disabled by default. This default behaviour may be changed on<br>  demand:</p>
<pre><code>int recv_own_msgs = 1; /* 0 = disabled (default), 1 = enabled */

setsockopt(s, SOL_CAN_RAW, CAN_RAW_RECV_OWN_MSGS,
           &amp;recv_own_msgs, sizeof(recv_own_msgs));
</code></pre>
<p>  4.1.5 RAW socket option CAN_RAW_FD_FRAMES</p>
<p>  CAN FD support in CAN_RAW sockets can be enabled with a new socket option<br>  CAN_RAW_FD_FRAMES which is off by default. When the new socket option is<br>  not supported by the CAN_RAW socket (e.g. on older kernels), switching the<br>  CAN_RAW_FD_FRAMES option returns the error -ENOPROTOOPT.</p>
<p>  Once CAN_RAW_FD_FRAMES is enabled the application can send both CAN frames<br>  and CAN FD frames. OTOH the application has to handle CAN and CAN FD frames<br>  when reading from the socket.</p>
<pre><code>CAN_RAW_FD_FRAMES enabled:  CAN_MTU and CANFD_MTU are allowed
CAN_RAW_FD_FRAMES disabled: only CAN_MTU is allowed (default)
</code></pre>
<p>  Example:<br>    [ remember: CANFD_MTU == sizeof(struct canfd_frame) ]</p>
<pre><code>struct canfd_frame cfd;

nbytes = read(s, &amp;cfd, CANFD_MTU);

if (nbytes == CANFD_MTU) &#123;
        printf(&quot;got CAN FD frame with length %d\n&quot;, cfd.len);
    /* cfd.flags contains valid data */
&#125; else if (nbytes == CAN_MTU) &#123;
        printf(&quot;got legacy CAN frame with length %d\n&quot;, cfd.len);
    /* cfd.flags is undefined */
&#125; else &#123;
        fprintf(stderr, &quot;read: invalid CAN(FD) frame\n&quot;);
        return 1;
&#125;

/* the content can be handled independently from the received MTU size */

printf(&quot;can_id: %X data length: %d data: &quot;, cfd.can_id, cfd.len);
for (i = 0; i &lt; cfd.len; i++)
        printf(&quot;%02X &quot;, cfd.data[i]);
</code></pre>
<p>  When reading with size CANFD_MTU only returns CAN_MTU bytes that have<br>  been received from the socket a legacy CAN frame has been read into the<br>  provided CAN FD structure. Note that the canfd_frame.flags data field is<br>  not specified in the struct can_frame and therefore it is only valid in<br>  CANFD_MTU sized CAN FD frames.</p>
<p>  As long as the payload length is &lt;=8 the received CAN frames from CAN FD<br>  capable CAN devices can be received and read by legacy sockets too. When<br>  user-generated CAN FD frames have a payload length &lt;=8 these can be send<br>  by legacy CAN network interfaces too. Sending CAN FD frames with payload<br>  length &gt; 8 to a legacy CAN network interface returns an -EMSGSIZE error.</p>
<p>  Implementation hint for new CAN applications:</p>
<p>  To build a CAN FD aware application use struct canfd_frame as basic CAN<br>  data structure for CAN_RAW based applications. When the application is<br>  executed on an older Linux kernel and switching the CAN_RAW_FD_FRAMES<br>  socket option returns an error: No problem. You’ll get legacy CAN frames<br>  or CAN FD frames and can process them the same way.</p>
<p>  When sending to CAN devices make sure that the device is capable to handle<br>  CAN FD frames by checking if the device maximum transfer unit is CANFD_MTU.<br>  The CAN device MTU can be retrieved e.g. with a SIOCGIFMTU ioctl() syscall.</p>
<p>  4.1.6 RAW socket option CAN_RAW_JOIN_FILTERS</p>
<p>  The CAN_RAW socket can set multiple CAN identifier specific filters that<br>  lead to multiple filters in the af_can.c filter processing. These filters<br>  are indenpendent from each other which leads to logical OR’ed filters when<br>  applied (see 4.1.1).</p>
<p>  This socket option joines the given CAN filters in the way that only CAN<br>  frames are passed to user space that matched <em>all</em> given CAN filters. The<br>  semantic for the applied filters is therefore changed to a logical AND.</p>
<p>  This is useful especially when the filterset is a combination of filters<br>  where the CAN_INV_FILTER flag is set in order to notch single CAN IDs or<br>  CAN ID ranges from the incoming traffic.</p>
<p>  4.1.7 RAW socket returned message flags</p>
<p>  When using recvmsg() call, the msg-&gt;msg_flags may contain following flags:</p>
<pre><code>MSG_DONTROUTE: set when the received frame was created on the local host.

MSG_CONFIRM: set when the frame was sent via the socket it is received on.
  This flag can be interpreted as a &#39;transmission confirmation&#39; when the
  CAN driver supports the echo of frames on driver level, see 3.2 and 6.2.
  In order to receive such messages, CAN_RAW_RECV_OWN_MSGS must be set.
</code></pre>
<p>  4.2 Broadcast Manager protocol sockets (SOCK_DGRAM)<br>  4.3 connected transport protocols (SOCK_SEQPACKET)<br>  4.4 unconnected transport protocols (SOCK_DGRAM)</p>
<ol start="5">
<li>Socket CAN core module</li>
</ol>
<hr>
<p>  The Socket CAN core module implements the protocol family<br>  PF_CAN. CAN protocol modules are loaded by the core module at<br>  runtime. The core module provides an interface for CAN protocol<br>  modules to subscribe needed CAN IDs (see chapter 3.1).</p>
<p>  5.1 can.ko module params</p>
<ul>
<li><p>stats_timer: To calculate the Socket CAN core statistics<br>(e.g. current/maximum frames per second) this 1 second timer is<br>invoked at can.ko module start time by default. This timer can be<br>disabled by using stattimer=0 on the module commandline.</p>
</li>
<li><p>debug: (removed since SocketCAN SVN r546)</p>
</li>
</ul>
<p>  5.2 procfs content</p>
<p>  As described in chapter 3.1 the Socket CAN core uses several filter<br>  lists to deliver received CAN frames to CAN protocol modules. These<br>  receive lists, their filters and the count of filter matches can be<br>  checked in the appropriate receive list. All entries contain the<br>  device and a protocol module identifier:</p>
<pre><code>foo@bar:~$ cat /proc/net/can/rcvlist_all

receive list &#39;rx_all&#39;:
  (vcan3: no entry)
  (vcan2: no entry)
  (vcan1: no entry)
  device   can_id   can_mask  function  userdata   matches  ident
   vcan0     000    00000000  f88e6370  f6c6f400         0  raw
  (any: no entry)
</code></pre>
<p>  In this example an application requests any CAN traffic from vcan0.</p>
<pre><code>rcvlist_all - list for unfiltered entries (no filter operations)
rcvlist_eff - list for single extended frame (EFF) entries
rcvlist_err - list for error message frames masks
rcvlist_fil - list for mask/value filters
rcvlist_inv - list for mask/value filters (inverse semantic)
rcvlist_sff - list for single standard frame (SFF) entries
</code></pre>
<p>  Additional procfs files in /proc/net/can</p>
<pre><code>stats       - Socket CAN core statistics (rx/tx frames, match ratios, ...)
reset_stats - manual statistic reset
version     - prints the Socket CAN core version and the ABI version
</code></pre>
<p>  5.3 writing own CAN protocol modules</p>
<p>  To implement a new protocol in the protocol family PF_CAN a new<br>  protocol has to be defined in include/linux/can.h .<br>  The prototypes and definitions to use the Socket CAN core can be<br>  accessed by including include/linux/can/core.h .<br>  In addition to functions that register the CAN protocol and the<br>  CAN device notifier chain there are functions to subscribe CAN<br>  frames received by CAN interfaces and to send CAN frames:</p>
<pre><code>can_rx_register   - subscribe CAN frames from a specific interface
can_rx_unregister - unsubscribe CAN frames from a specific interface
can_send          - transmit a CAN frame (optional with local loopback)
</code></pre>
<p>  For details see the kerneldoc documentation in net/can/af_can.c or<br>  the source code of net/can/raw.c or net/can/bcm.c .</p>
<ol start="6">
<li>CAN network drivers</li>
</ol>
<hr>
<p>  Writing a CAN network device driver is much easier than writing a<br>  CAN character device driver. Similar to other known network device<br>  drivers you mainly have to deal with:</p>
<ul>
<li><p>TX: Put the CAN frame from the socket buffer to the CAN controller.</p>
</li>
<li><p>RX: Put the CAN frame from the CAN controller to the socket buffer.</p>
<p>See e.g. at Documentation/networking/netdevices.txt . The differences<br>for writing CAN network device driver are described below:</p>
</li>
</ul>
<p>  6.1 general settings</p>
<pre><code>dev-&gt;type  = ARPHRD_CAN; /* the netdevice hardware type */
dev-&gt;flags = IFF_NOARP;  /* CAN has no arp */

dev-&gt;mtu = CAN_MTU; /* sizeof(struct can_frame) -&gt; legacy CAN interface */

or alternative, when the controller supports CAN with flexible data rate:
dev-&gt;mtu = CANFD_MTU; /* sizeof(struct canfd_frame) -&gt; CAN FD interface */
</code></pre>
<p>  The struct can_frame or struct canfd_frame is the payload of each socket<br>  buffer (skbuff) in the protocol family PF_CAN.</p>
<p>  6.2 local loopback of sent frames</p>
<p>  As described in chapter 3.2 the CAN network device driver should<br>  support a local loopback functionality similar to the local echo<br>  e.g. of tty devices. In this case the driver flag IFF_ECHO has to be<br>  set to prevent the PF_CAN core from locally echoing sent frames<br>  (aka loopback) as fallback solution:</p>
<pre><code>dev-&gt;flags = (IFF_NOARP | IFF_ECHO);
</code></pre>
<p>  6.3 CAN controller hardware filters</p>
<p>  To reduce the interrupt load on deep embedded systems some CAN<br>  controllers support the filtering of CAN IDs or ranges of CAN IDs.<br>  These hardware filter capabilities vary from controller to<br>  controller and have to be identified as not feasible in a multi-user<br>  networking approach. The use of the very controller specific<br>  hardware filters could make sense in a very dedicated use-case, as a<br>  filter on driver level would affect all users in the multi-user<br>  system. The high efficient filter sets inside the PF_CAN core allow<br>  to set different multiple filters for each socket separately.<br>  Therefore the use of hardware filters goes to the category ‘handmade<br>  tuning on deep embedded systems’. The author is running a MPC603e<br>  @133MHz with four SJA1000 CAN controllers from 2002 under heavy bus<br>  load without any problems …</p>
<p>  6.4 The virtual CAN driver (vcan)</p>
<p>  Similar to the network loopback devices, vcan offers a virtual local<br>  CAN interface. A full qualified address on CAN consists of</p>
<ul>
<li><p>a unique CAN Identifier (CAN ID)</p>
</li>
<li><p>the CAN bus this CAN ID is transmitted on (e.g. can0)</p>
<p>so in common use cases more than one virtual CAN interface is needed.</p>
<p>The virtual CAN interfaces allow the transmission and reception of CAN<br>frames without real CAN controller hardware. Virtual CAN network<br>devices are usually named ‘vcanX’, like vcan0 vcan1 vcan2 …<br>When compiled as a module the virtual CAN driver module is called vcan.ko</p>
<p>Since Linux Kernel version 2.6.24 the vcan driver supports the Kernel<br>netlink interface to create vcan network devices. The creation and<br>removal of vcan network devices can be managed with the ip(8) tool:</p>
</li>
<li><p>Create a virtual CAN network interface:<br>   $ ip link add type vcan</p>
</li>
<li><p>Create a virtual CAN network interface with a specific name ‘vcan42’:<br>   $ ip link add dev vcan42 type vcan</p>
</li>
<li><p>Remove a (virtual CAN) network interface ‘vcan42’:<br>   $ ip link del vcan42</p>
</li>
</ul>
<p>  6.5 The CAN network device driver interface</p>
<p>  The CAN network device driver interface provides a generic interface<br>  to setup, configure and monitor CAN network devices. The user can then<br>  configure the CAN device, like setting the bit-timing parameters, via<br>  the netlink interface using the program “ip” from the “IPROUTE2”<br>  utility suite. The following chapter describes briefly how to use it.<br>  Furthermore, the interface uses a common data structure and exports a<br>  set of common functions, which all real CAN network device drivers<br>  should use. Please have a look to the SJA1000 or MSCAN driver to<br>  understand how to use them. The name of the module is can-dev.ko.</p>
<p>  6.5.1 Netlink interface to set/get devices properties</p>
<p>  The CAN device must be configured via netlink interface. The supported<br>  netlink message types are defined and briefly described in<br>  “include/linux/can/netlink.h”. CAN link support for the program “ip”<br>  of the IPROUTE2 utility suite is available and it can be used as shown<br>  below:</p>
<ul>
<li><p>Setting CAN device properties:</p>
<p>$ ip link set can0 type can help<br>Usage: ip link set DEVICE type can</p>
<pre><code>[ bitrate BITRATE [ sample-point SAMPLE-POINT] ] |
[ tq TQ prop-seg PROP_SEG phase-seg1 PHASE-SEG1
   phase-seg2 PHASE-SEG2 [ sjw SJW ] ]

[ loopback &#123; on | off &#125; ]
[ listen-only &#123; on | off &#125; ]
[ triple-sampling &#123; on | off &#125; ]

[ restart-ms TIME-MS ]
[ restart ]

Where: BITRATE       := &#123; 1..1000000 &#125;
       SAMPLE-POINT  := &#123; 0.000..0.999 &#125;
       TQ            := &#123; NUMBER &#125;
       PROP-SEG      := &#123; 1..8 &#125;
       PHASE-SEG1    := &#123; 1..8 &#125;
       PHASE-SEG2    := &#123; 1..8 &#125;
       SJW           := &#123; 1..4 &#125;
       RESTART-MS    := &#123; 0 | NUMBER &#125;
</code></pre>
</li>
<li><p>Display CAN device details and statistics:</p>
<p>$ ip -details -statistics link show can0<br>2: can0: &lt;NOARP,UP,LOWER_UP,ECHO&gt; mtu 16 qdisc pfifo_fast state UP qlen 10<br>  link/can<br>  can <TRIPLE-SAMPLING> state ERROR-ACTIVE restart-ms 100<br>  bitrate 125000 sample_point 0.875<br>  tq 125 prop-seg 6 phase-seg1 7 phase-seg2 2 sjw 1<br>  sja1000: tseg1 1..16 tseg2 1..8 sjw 1..4 brp 1..64 brp-inc 1<br>  clock 8000000<br>  re-started bus-errors arbit-lost error-warn error-pass bus-off<br>  41         17457      0          41         42         41<br>  RX: bytes  packets  errors  dropped overrun mcast<br>  140859     17608    17457   0       0       0<br>  TX: bytes  packets  errors  dropped carrier collsns<br>  861        112      0       41      0       0</p>
<p>More info to the above output:</p>
<p>“<TRIPLE-SAMPLING>“<br>Shows the list of selected CAN controller modes: LOOPBACK,<br>LISTEN-ONLY, or TRIPLE-SAMPLING.</p>
<p>“state ERROR-ACTIVE”<br>The current state of the CAN controller: “ERROR-ACTIVE”,<br>“ERROR-WARNING”, “ERROR-PASSIVE”, “BUS-OFF” or “STOPPED”</p>
<p>“restart-ms 100”<br>Automatic restart delay time. If set to a non-zero value, a<br>restart of the CAN controller will be triggered automatically<br>in case of a bus-off condition after the specified delay time<br>in milliseconds. By default it’s off.</p>
<p>“bitrate 125000 sample_point 0.875”<br>Shows the real bit-rate in bits/sec and the sample-point in the<br>range 0.000..0.999. If the calculation of bit-timing parameters<br>is enabled in the kernel (CONFIG_CAN_CALC_BITTIMING=y), the<br>bit-timing can be defined by setting the “bitrate” argument.<br>Optionally the “sample-point” can be specified. By default it’s<br>0.000 assuming CIA-recommended sample-points.</p>
<p>“tq 125 prop-seg 6 phase-seg1 7 phase-seg2 2 sjw 1”<br>Shows the time quanta in ns, propagation segment, phase buffer<br>segment 1 and 2 and the synchronisation jump width in units of<br>tq. They allow to define the CAN bit-timing in a hardware<br>independent format as proposed by the Bosch CAN 2.0 spec (see<br>chapter 8 of <a target="_blank" rel="noopener" href="http://www.semiconductors.bosch.de/pdf/can2spec.pdf">http://www.semiconductors.bosch.de/pdf/can2spec.pdf</a>).</p>
<p>“sja1000: tseg1 1..16 tseg2 1..8 sjw 1..4 brp 1..64 brp-inc 1<br> clock 8000000”<br>Shows the bit-timing constants of the CAN controller, here the<br>“sja1000”. The minimum and maximum values of the time segment 1<br>and 2, the synchronisation jump width in units of tq, the<br>bitrate pre-scaler and the CAN system clock frequency in Hz.<br>These constants could be used for user-defined (non-standard)<br>bit-timing calculation algorithms in user-space.</p>
<p>“re-started bus-errors arbit-lost error-warn error-pass bus-off”<br>Shows the number of restarts, bus and arbitration lost errors,<br>and the state changes to the error-warning, error-passive and<br>bus-off state. RX overrun errors are listed in the “overrun”<br>field of the standard network statistics.</p>
</li>
</ul>
<p>  6.5.2 Setting the CAN bit-timing</p>
<p>  The CAN bit-timing parameters can always be defined in a hardware<br>  independent format as proposed in the Bosch CAN 2.0 specification<br>  specifying the arguments “tq”, “prop_seg”, “phase_seg1”, “phase_seg2”<br>  and “sjw”:</p>
<pre><code>$ ip link set canX type can tq 125 prop-seg 6 \
            phase-seg1 7 phase-seg2 2 sjw 1
</code></pre>
<p>  If the kernel option CONFIG_CAN_CALC_BITTIMING is enabled, CIA<br>  recommended CAN bit-timing parameters will be calculated if the bit-<br>  rate is specified with the argument “bitrate”:</p>
<pre><code>$ ip link set canX type can bitrate 125000
</code></pre>
<p>  Note that this works fine for the most common CAN controllers with<br>  standard bit-rates but may <em>fail</em> for exotic bit-rates or CAN system<br>  clock frequencies. Disabling CONFIG_CAN_CALC_BITTIMING saves some<br>  space and allows user-space tools to solely determine and set the<br>  bit-timing parameters. The CAN controller specific bit-timing<br>  constants can be used for that purpose. They are listed by the<br>  following command:</p>
<pre><code>$ ip -details link show can0
...
  sja1000: clock 8000000 tseg1 1..16 tseg2 1..8 sjw 1..4 brp 1..64 brp-inc 1
</code></pre>
<p>  6.5.3 Starting and stopping the CAN network device</p>
<p>  A CAN network device is started or stopped as usual with the command<br>  “ifconfig canX up/down” or “ip link set canX up/down”. Be aware that<br>  you <em>must</em> define proper bit-timing parameters for real CAN devices<br>  before you can start it to avoid error-prone default settings:</p>
<pre><code>$ ip link set canX up type can bitrate 125000
</code></pre>
<p>  A device may enter the “bus-off” state if too much errors occurred on<br>  the CAN bus. Then no more messages are received or sent. An automatic<br>  bus-off recovery can be enabled by setting the “restart-ms” to a<br>  non-zero value, e.g.:</p>
<pre><code>$ ip link set canX type can restart-ms 100
</code></pre>
<p>  Alternatively, the application may realize the “bus-off” condition<br>  by monitoring CAN error message frames and do a restart when<br>  appropriate with the command:</p>
<pre><code>$ ip link set canX type can restart
</code></pre>
<p>  Note that a restart will also create a CAN error message frame (see<br>  also chapter 3.4).</p>
<p>  6.6 CAN FD (flexible data rate) driver support</p>
<p>  CAN FD capable CAN controllers support two different bitrates for the<br>  arbitration phase and the payload phase of the CAN FD frame. Therefore a<br>  second bittiming has to be specified in order to enable the CAN FD bitrate.</p>
<p>  Additionally CAN FD capable CAN controllers support up to 64 bytes of<br>  payload. The representation of this length in can_frame.can_dlc and<br>  canfd_frame.len for userspace applications and inside the Linux network<br>  layer is a plain value from 0 .. 64 instead of the CAN ‘data length code’.<br>  The data length code was a 1:1 mapping to the payload length in the legacy<br>  CAN frames anyway. The payload length to the bus-relevant DLC mapping is<br>  only performed inside the CAN drivers, preferably with the helper<br>  functions can_dlc2len() and can_len2dlc().</p>
<p>  The CAN netdevice driver capabilities can be distinguished by the network<br>  devices maximum transfer unit (MTU):</p>
<p>  MTU = 16 (CAN_MTU)   =&gt; sizeof(struct can_frame)   =&gt; ‘legacy’ CAN device<br>  MTU = 72 (CANFD_MTU) =&gt; sizeof(struct canfd_frame) =&gt; CAN FD capable device</p>
<p>  The CAN device MTU can be retrieved e.g. with a SIOCGIFMTU ioctl() syscall.<br>  N.B. CAN FD capable devices can also handle and send legacy CAN frames.</p>
<p>  FIXME: Add details about the CAN FD controller configuration when available.</p>
<p>  6.7 Supported CAN hardware</p>
<p>  Please check the “Kconfig” file in “drivers/net/can” to get an actual<br>  list of the support CAN hardware. On the Socket CAN project website<br>  (see chapter 7) there might be further drivers available, also for<br>  older kernel versions.</p>
<ol start="7">
<li>Socket CAN resources</li>
</ol>
<hr>
<p>  You can find further resources for Socket CAN like user space tools,<br>  support for old kernel versions, more drivers, mailing lists, etc.<br>  at the BerliOS OSS project website for Socket CAN:</p>
<pre><code>http://developer.berlios.de/projects/socketcan
</code></pre>
<p>  If you have questions, bug fixes, etc., don’t hesitate to post them to<br>  the Socketcan-Users mailing list. But please search the archives first.</p>
<ol start="8">
<li>Credits</li>
</ol>
<hr>
<p>  Oliver Hartkopp (PF_CAN core, filters, drivers, bcm, SJA1000 driver)<br>  Urs Thuermann (PF_CAN core, kernel integration, socket interfaces, raw, vcan)<br>  Jan Kizka (RT-SocketCAN core, Socket-API reconciliation)<br>  Wolfgang Grandegger (RT-SocketCAN core &amp; drivers, Raw Socket-API reviews,<br>                       CAN device driver interface, MSCAN driver)<br>  Robert Schwebel (design reviews, PTXdist integration)<br>  Marc Kleine-Budde (design reviews, Kernel 2.6 cleanups, drivers)<br>  Benedikt Spranger (reviews)<br>  Thomas Gleixner (LKML reviews, coding style, posting hints)<br>  Andrey Volkov (kernel subtree structure, ioctls, MSCAN driver)<br>  Matthias Brukner (first SJA1000 CAN netdevice implementation Q2/2003)<br>  Klaus Hitschler (PEAK driver integration)<br>  Uwe Koppe (CAN netdevices with PF_PACKET approach)<br>  Michael Schulze (driver layer loopback requirement, RT CAN drivers review)<br>  Pavel Pisa (Bit-timing calculation)<br>  Sascha Hauer (SJA1000 platform driver)<br>  Sebastian Haas (SJA1000 EMS PCI driver)<br>  Markus Plessing (SJA1000 EMS PCI driver)<br>  Per Dalen (SJA1000 Kvaser PCI driver)<br>  Sam Ravnborg (reviews, coding style, kbuild help)</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_can/" title="Kernel-3.10.0-957.el7_can" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_can/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_cpusets/" title="Kernel-3.10.0-957.el7_cpusets"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_boot/" title="Kernel-3.10.0-957.el7_boot"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>