<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-3.10.0-957.el7_numa_memory_policy | oosTech.com</title>
  <meta name="description" content="What is Linux Memory Policy? In the Linux kernel, “memory policy” determines from which node the kernel willallocate memory in a NUMA system or in an emulated NUMA system.  Linux hassupported platform">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-3.10.0-957.el7_numa_memory_policy">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_numa_memory_policy/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="What is Linux Memory Policy? In the Linux kernel, “memory policy” determines from which node the kernel willallocate memory in a NUMA system or in an emulated NUMA system.  Linux hassupported platform">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_numa_memory_policy/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-3.10.0-957.el7_numa_memory_policy" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-3.10.0-957.el7_numa_memory_policy
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_numa_memory_policy/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_numa_memory_policy/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-3.10.0-957.el7_numa_memory_policy/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>What is Linux Memory Policy?</p>
<p>In the Linux kernel, “memory policy” determines from which node the kernel will<br>allocate memory in a NUMA system or in an emulated NUMA system.  Linux has<br>supported platforms with Non-Uniform Memory Access architectures since 2.4.?.<br>The current memory policy support was added to Linux 2.6 around May 2004.  This<br>document attempts to describe the concepts and APIs of the 2.6 memory policy<br>support.</p>
<p>Memory policies should not be confused with cpusets<br>(Documentation/cgroups/cpusets.txt)<br>which is an administrative mechanism for restricting the nodes from which<br>memory may be allocated by a set of processes. Memory policies are a<br>programming interface that a NUMA-aware application can take advantage of.  When<br>both cpusets and policies are applied to a task, the restrictions of the cpuset<br>takes priority.  See “MEMORY POLICIES AND CPUSETS” below for more details.</p>
<p>MEMORY POLICY CONCEPTS</p>
<p>Scope of Memory Policies</p>
<p>The Linux kernel supports <em>scopes</em> of memory policy, described here from<br>most general to most specific:</p>
<pre><code>System Default Policy:  this policy is &quot;hard coded&quot; into the kernel.  It
is the policy that governs all page allocations that aren&#39;t controlled
by one of the more specific policy scopes discussed below.  When the
system is &quot;up and running&quot;, the system default policy will use &quot;local
allocation&quot; described below.  However, during boot up, the system
default policy will be set to interleave allocations across all nodes
with &quot;sufficient&quot; memory, so as not to overload the initial boot node
with boot-time allocations.

Task/Process Policy:  this is an optional, per-task policy.  When defined
for a specific task, this policy controls all page allocations made by or
on behalf of the task that aren&#39;t controlled by a more specific scope.
If a task does not define a task policy, then all page allocations that
would have been controlled by the task policy &quot;fall back&quot; to the System
Default Policy.

The task policy applies to the entire address space of a task. Thus,
it is inheritable, and indeed is inherited, across both fork()
[clone() w/o the CLONE_VM flag] and exec*().  This allows a parent task
to establish the task policy for a child task exec()&#39;d from an
executable image that has no awareness of memory policy.  See the
MEMORY POLICY APIS section, below, for an overview of the system call
that a task may use to set/change its task/process policy.

In a multi-threaded task, task policies apply only to the thread
[Linux kernel task] that installs the policy and any threads
subsequently created by that thread.  Any sibling threads existing
at the time a new task policy is installed retain their current
policy.

A task policy applies only to pages allocated after the policy is
installed.  Any pages already faulted in by the task when the task
changes its task policy remain where they were allocated based on
the policy at the time they were allocated.

VMA Policy:  A &quot;VMA&quot; or &quot;Virtual Memory Area&quot; refers to a range of a task&#39;s
virtual address space.  A task may define a specific policy for a range
of its virtual address space.   See the MEMORY POLICIES APIS section,
below, for an overview of the mbind() system call used to set a VMA
policy.

A VMA policy will govern the allocation of pages that back this region of
the address space.  Any regions of the task&#39;s address space that don&#39;t
have an explicit VMA policy will fall back to the task policy, which may
itself fall back to the System Default Policy.

VMA policies have a few complicating details:

VMA policy applies ONLY to anonymous pages.  These include pages
allocated for anonymous segments, such as the task stack and heap, and
any regions of the address space mmap()ed with the MAP_ANONYMOUS flag.
If a VMA policy is applied to a file mapping, it will be ignored if
the mapping used the MAP_SHARED flag.  If the file mapping used the
MAP_PRIVATE flag, the VMA policy will only be applied when an
anonymous page is allocated on an attempt to write to the mapping--
i.e., at Copy-On-Write.

VMA policies are shared between all tasks that share a virtual address
space--a.k.a. threads--independent of when the policy is installed; and
they are inherited across fork().  However, because VMA policies refer
to a specific region of a task&#39;s address space, and because the address
space is discarded and recreated on exec*(), VMA policies are NOT
inheritable across exec().  Thus, only NUMA-aware applications may
use VMA policies.

A task may install a new VMA policy on a sub-range of a previously
mmap()ed region.  When this happens, Linux splits the existing virtual
memory area into 2 or 3 VMAs, each with it&#39;s own policy.

By default, VMA policy applies only to pages allocated after the policy
is installed.  Any pages already faulted into the VMA range remain
where they were allocated based on the policy at the time they were
allocated.  However, since 2.6.16, Linux supports page migration via
the mbind() system call, so that page contents can be moved to match
a newly installed policy.

Shared Policy:  Conceptually, shared policies apply to &quot;memory objects&quot;
mapped shared into one or more tasks&#39; distinct address spaces.  An
application installs a shared policies the same way as VMA policies--using
the mbind() system call specifying a range of virtual addresses that map
the shared object.  However, unlike VMA policies, which can be considered
to be an attribute of a range of a task&#39;s address space, shared policies
apply directly to the shared object.  Thus, all tasks that attach to the
object share the policy, and all pages allocated for the shared object,
by any task, will obey the shared policy.

As of 2.6.22, only shared memory segments, created by shmget() or
mmap(MAP_ANONYMOUS|MAP_SHARED), support shared policy.  When shared
policy support was added to Linux, the associated data structures were
added to hugetlbfs shmem segments.  At the time, hugetlbfs did not
support allocation at fault time--a.k.a lazy allocation--so hugetlbfs
shmem segments were never &quot;hooked up&quot; to the shared policy support.
Although hugetlbfs segments now support lazy allocation, their support
for shared policy has not been completed.

As mentioned above [re: VMA policies], allocations of page cache
pages for regular files mmap()ed with MAP_SHARED ignore any VMA
policy installed on the virtual address range backed by the shared
file mapping.  Rather, shared page cache pages, including pages backing
private mappings that have not yet been written by the task, follow
task policy, if any, else System Default Policy.

The shared policy infrastructure supports different policies on subset
ranges of the shared object.  However, Linux still splits the VMA of
the task that installs the policy for each range of distinct policy.
Thus, different tasks that attach to a shared memory segment can have
different VMA configurations mapping that one shared object.  This
can be seen by examining the /proc/&lt;pid&gt;/numa_maps of tasks sharing
a shared memory region, when one task has installed shared policy on
one or more ranges of the region.
</code></pre>
<p>Components of Memory Policies</p>
<pre><code>A Linux memory policy consists of a &quot;mode&quot;, optional mode flags, and an
optional set of nodes.  The mode determines the behavior of the policy,
the optional mode flags determine the behavior of the mode, and the
optional set of nodes can be viewed as the arguments to the policy
behavior.
</code></pre>
<p>   Internally, memory policies are implemented by a reference counted<br>   structure, struct mempolicy.  Details of this structure will be discussed<br>   in context, below, as required to explain the behavior.</p>
<p>   Linux memory policy supports the following 4 behavioral modes:</p>
<pre><code>Default Mode--MPOL_DEFAULT:  This mode is only used in the memory
policy APIs.  Internally, MPOL_DEFAULT is converted to the NULL
memory policy in all policy scopes.  Any existing non-default policy
will simply be removed when MPOL_DEFAULT is specified.  As a result,
MPOL_DEFAULT means &quot;fall back to the next most specific policy scope.&quot;

    For example, a NULL or default task policy will fall back to the
    system default policy.  A NULL or default vma policy will fall
    back to the task policy.

    When specified in one of the memory policy APIs, the Default mode
    does not use the optional set of nodes.

    It is an error for the set of nodes specified for this policy to
    be non-empty.

MPOL_BIND:  This mode specifies that memory must come from the
set of nodes specified by the policy.  Memory will be allocated from
the node in the set with sufficient free memory that is closest to
the node where the allocation takes place.

MPOL_PREFERRED:  This mode specifies that the allocation should be
attempted from the single node specified in the policy.  If that
allocation fails, the kernel will search other nodes, in order of
increasing distance from the preferred node based on information
provided by the platform firmware.
containing the cpu where the allocation takes place.

    Internally, the Preferred policy uses a single node--the
    preferred_node member of struct mempolicy.  When the internal
    mode flag MPOL_F_LOCAL is set, the preferred_node is ignored and
    the policy is interpreted as local allocation.  &quot;Local&quot; allocation
    policy can be viewed as a Preferred policy that starts at the node
    containing the cpu where the allocation takes place.

    It is possible for the user to specify that local allocation is
    always preferred by passing an empty nodemask with this mode.
    If an empty nodemask is passed, the policy cannot use the
    MPOL_F_STATIC_NODES or MPOL_F_RELATIVE_NODES flags described
    below.

MPOL_INTERLEAVED:  This mode specifies that page allocations be
interleaved, on a page granularity, across the nodes specified in
the policy.  This mode also behaves slightly differently, based on
the context where it is used:

    For allocation of anonymous pages and shared memory pages,
    Interleave mode indexes the set of nodes specified by the policy
    using the page offset of the faulting address into the segment
    [VMA] containing the address modulo the number of nodes specified
    by the policy.  It then attempts to allocate a page, starting at
    the selected node, as if the node had been specified by a Preferred
    policy or had been selected by a local allocation.  That is,
    allocation will follow the per node zonelist.

    For allocation of page cache pages, Interleave mode indexes the set
    of nodes specified by the policy using a node counter maintained
    per task.  This counter wraps around to the lowest specified node
    after it reaches the highest specified node.  This will tend to
    spread the pages out over the nodes specified by the policy based
    on the order in which they are allocated, rather than based on any
    page offset into an address range or file.  During system boot up,
    the temporary interleaved system default policy works in this
    mode.
</code></pre>
<p>   Linux memory policy supports the following optional mode flags:</p>
<pre><code>MPOL_F_STATIC_NODES:  This flag specifies that the nodemask passed by
the user should not be remapped if the task or VMA&#39;s set of allowed
nodes changes after the memory policy has been defined.

    Without this flag, anytime a mempolicy is rebound because of a
    change in the set of allowed nodes, the node (Preferred) or
    nodemask (Bind, Interleave) is remapped to the new set of
    allowed nodes.  This may result in nodes being used that were
    previously undesired.

    With this flag, if the user-specified nodes overlap with the
    nodes allowed by the task&#39;s cpuset, then the memory policy is
    applied to their intersection.  If the two sets of nodes do not
    overlap, the Default policy is used.

    For example, consider a task that is attached to a cpuset with
    mems 1-3 that sets an Interleave policy over the same set.  If
    the cpuset&#39;s mems change to 3-5, the Interleave will now occur
    over nodes 3, 4, and 5.  With this flag, however, since only node
    3 is allowed from the user&#39;s nodemask, the &quot;interleave&quot; only
    occurs over that node.  If no nodes from the user&#39;s nodemask are
    now allowed, the Default behavior is used.

    MPOL_F_STATIC_NODES cannot be combined with the
    MPOL_F_RELATIVE_NODES flag.  It also cannot be used for
    MPOL_PREFERRED policies that were created with an empty nodemask
    (local allocation).

MPOL_F_RELATIVE_NODES:  This flag specifies that the nodemask passed
by the user will be mapped relative to the set of the task or VMA&#39;s
set of allowed nodes.  The kernel stores the user-passed nodemask,
and if the allowed nodes changes, then that original nodemask will
be remapped relative to the new set of allowed nodes.

    Without this flag (and without MPOL_F_STATIC_NODES), anytime a
    mempolicy is rebound because of a change in the set of allowed
    nodes, the node (Preferred) or nodemask (Bind, Interleave) is
    remapped to the new set of allowed nodes.  That remap may not
    preserve the relative nature of the user&#39;s passed nodemask to its
    set of allowed nodes upon successive rebinds: a nodemask of
    1,3,5 may be remapped to 7-9 and then to 1-3 if the set of
    allowed nodes is restored to its original state.

    With this flag, the remap is done so that the node numbers from
    the user&#39;s passed nodemask are relative to the set of allowed
    nodes.  In other words, if nodes 0, 2, and 4 are set in the user&#39;s
    nodemask, the policy will be effected over the first (and in the
    Bind or Interleave case, the third and fifth) nodes in the set of
    allowed nodes.  The nodemask passed by the user represents nodes
    relative to task or VMA&#39;s set of allowed nodes.

    If the user&#39;s nodemask includes nodes that are outside the range
    of the new set of allowed nodes (for example, node 5 is set in
    the user&#39;s nodemask when the set of allowed nodes is only 0-3),
    then the remap wraps around to the beginning of the nodemask and,
    if not already set, sets the node in the mempolicy nodemask.

    For example, consider a task that is attached to a cpuset with
    mems 2-5 that sets an Interleave policy over the same set with
    MPOL_F_RELATIVE_NODES.  If the cpuset&#39;s mems change to 3-7, the
    interleave now occurs over nodes 3,5-6.  If the cpuset&#39;s mems
    then change to 0,2-3,5, then the interleave occurs over nodes
    0,3,5.

    Thanks to the consistent remapping, applications preparing
    nodemasks to specify memory policies using this flag should
    disregard their current, actual cpuset imposed memory placement
    and prepare the nodemask as if they were always located on
    memory nodes 0 to N-1, where N is the number of memory nodes the
    policy is intended to manage.  Let the kernel then remap to the
    set of memory nodes allowed by the task&#39;s cpuset, as that may
    change over time.

    MPOL_F_RELATIVE_NODES cannot be combined with the
    MPOL_F_STATIC_NODES flag.  It also cannot be used for
    MPOL_PREFERRED policies that were created with an empty nodemask
    (local allocation).
</code></pre>
<p>MEMORY POLICY REFERENCE COUNTING</p>
<p>To resolve use/free races, struct mempolicy contains an atomic reference<br>count field.  Internal interfaces, mpol_get()/mpol_put() increment and<br>decrement this reference count, respectively.  mpol_put() will only free<br>the structure back to the mempolicy kmem cache when the reference count<br>goes to zero.</p>
<p>When a new memory policy is allocated, its reference count is initialized<br>to ‘1’, representing the reference held by the task that is installing the<br>new policy.  When a pointer to a memory policy structure is stored in another<br>structure, another reference is added, as the task’s reference will be dropped<br>on completion of the policy installation.</p>
<p>During run-time “usage” of the policy, we attempt to minimize atomic operations<br>on the reference count, as this can lead to cache lines bouncing between cpus<br>and NUMA nodes.  “Usage” here means one of the following:</p>
<ol>
<li><p>querying of the policy, either by the task itself [using the get_mempolicy()<br>API discussed below] or by another task using the /proc/<pid>/numa_maps<br>interface.</p>
</li>
<li><p>examination of the policy to determine the policy mode and associated node<br>or node lists, if any, for page allocation.  This is considered a “hot<br>path”.  Note that for MPOL_BIND, the “usage” extends across the entire<br>allocation process, which may sleep during page reclaimation, because the<br>BIND policy nodemask is used, by reference, to filter ineligible nodes.</p>
</li>
</ol>
<p>We can avoid taking an extra reference during the usages listed above as<br>follows:</p>
<ol>
<li><p>we never need to get/free the system default policy as this is never<br>changed nor freed, once the system is up and running.</p>
</li>
<li><p>for querying the policy, we do not need to take an extra reference on the<br>target task’s task policy nor vma policies because we always acquire the<br>task’s mm’s mmap_sem for read during the query.  The set_mempolicy() and<br>mbind() APIs [see below] always acquire the mmap_sem for write when<br>installing or replacing task or vma policies.  Thus, there is no possibility<br>of a task or thread freeing a policy while another task or thread is<br>querying it.</p>
</li>
<li><p>Page allocation usage of task or vma policy occurs in the fault path where<br>we hold them mmap_sem for read.  Again, because replacing the task or vma<br>policy requires that the mmap_sem be held for write, the policy can’t be<br>freed out from under us while we’re using it for page allocation.</p>
</li>
<li><p>Shared policies require special consideration.  One task can replace a<br>shared memory policy while another task, with a distinct mmap_sem, is<br>querying or allocating a page based on the policy.  To resolve this<br>potential race, the shared policy infrastructure adds an extra reference<br>to the shared policy during lookup while holding a spin lock on the shared<br>policy management structure.  This requires that we drop this extra<br>reference when we’re finished “using” the policy.  We must drop the<br>extra reference on shared policies in the same query/allocation paths<br>used for non-shared policies.  For this reason, shared policies are marked<br>as such, and the extra reference is dropped “conditionally”–i.e., only<br>for shared policies.</p>
<p>Because of this extra reference counting, and because we must lookup<br>shared policies in a tree structure under spinlock, shared policies are<br>more expensive to use in the page allocation path.  This is especially<br>true for shared policies on shared memory regions shared by tasks running<br>on different NUMA nodes.  This extra overhead can be avoided by always<br>falling back to task or system default policy for shared memory regions,<br>or by prefaulting the entire shared memory region into memory and locking<br>it down.  However, this might not be appropriate for all applications.</p>
</li>
</ol>
<p>MEMORY POLICY APIs</p>
<p>Linux supports 3 system calls for controlling memory policy.  These APIS<br>always affect only the calling task, the calling task’s address space, or<br>some shared object mapped into the calling task’s address space.</p>
<pre><code>Note:  the headers that define these APIs and the parameter data types
for user space applications reside in a package that is not part of
the Linux kernel.  The kernel system call interfaces, with the &#39;sys_&#39;
prefix, are defined in &lt;linux/syscalls.h&gt;; the mode and flag
definitions are defined in &lt;linux/mempolicy.h&gt;.
</code></pre>
<p>Set [Task] Memory Policy:</p>
<pre><code>long set_mempolicy(int mode, const unsigned long *nmask,
                unsigned long maxnode);

Set&#39;s the calling task&#39;s &quot;task/process memory policy&quot; to mode
specified by the &#39;mode&#39; argument and the set of nodes defined
by &#39;nmask&#39;.  &#39;nmask&#39; points to a bit mask of node ids containing
at least &#39;maxnode&#39; ids.  Optional mode flags may be passed by
combining the &#39;mode&#39; argument with the flag (for example:
MPOL_INTERLEAVE | MPOL_F_STATIC_NODES).

See the set_mempolicy(2) man page for more details
</code></pre>
<p>Get [Task] Memory Policy or Related Information</p>
<pre><code>long get_mempolicy(int *mode,
           const unsigned long *nmask, unsigned long maxnode,
           void *addr, int flags);

Queries the &quot;task/process memory policy&quot; of the calling task, or
the policy or location of a specified virtual address, depending
on the &#39;flags&#39; argument.

See the get_mempolicy(2) man page for more details
</code></pre>
<p>Install VMA/Shared Policy for a Range of Task’s Address Space</p>
<pre><code>long mbind(void *start, unsigned long len, int mode,
       const unsigned long *nmask, unsigned long maxnode,
       unsigned flags);

mbind() installs the policy specified by (mode, nmask, maxnodes) as
a VMA policy for the range of the calling task&#39;s address space
specified by the &#39;start&#39; and &#39;len&#39; arguments.  Additional actions
may be requested via the &#39;flags&#39; argument.

See the mbind(2) man page for more details.
</code></pre>
<p>MEMORY POLICY COMMAND LINE INTERFACE</p>
<p>Although not strictly part of the Linux implementation of memory policy,<br>a command line tool, numactl(8), exists that allows one to:</p>
<ul>
<li><p>set the task policy for a specified program via set_mempolicy(2), fork(2) and<br>exec(2)</p>
</li>
<li><p>set the shared policy for a shared memory segment via mbind(2)</p>
</li>
</ul>
<p>The numactl(8) tool is packaged with the run-time version of the library<br>containing the memory policy system call wrappers.  Some distributions<br>package the headers and compile-time libraries in a separate development<br>package.</p>
<p>MEMORY POLICIES AND CPUSETS</p>
<p>Memory policies work within cpusets as described above.  For memory policies<br>that require a node or set of nodes, the nodes are restricted to the set of<br>nodes whose memories are allowed by the cpuset constraints.  If the nodemask<br>specified for the policy contains nodes that are not allowed by the cpuset and<br>MPOL_F_RELATIVE_NODES is not used, the intersection of the set of nodes<br>specified for the policy and the set of nodes with memory is used.  If the<br>result is the empty set, the policy is considered invalid and cannot be<br>installed.  If MPOL_F_RELATIVE_NODES is used, the policy’s nodes are mapped<br>onto and folded into the task’s set of allowed nodes as previously described.</p>
<p>The interaction of memory policies and cpusets can be problematic when tasks<br>in two cpusets share access to a memory region, such as shared memory segments<br>created by shmget() of mmap() with the MAP_ANONYMOUS and MAP_SHARED flags, and<br>any of the tasks install shared policy on the region, only nodes whose<br>memories are allowed in both cpusets may be used in the policies.  Obtaining<br>this information requires “stepping outside” the memory policy APIs to use the<br>cpuset information and requires that one know in what cpusets other task might<br>be attaching to the shared region.  Furthermore, if the cpusets’ allowed<br>memory sets are disjoint, “local” allocation is the only valid policy.</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_numa_memory_policy/" title="Kernel-3.10.0-957.el7_numa_memory_policy" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_numa_memory_policy/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_nvdimm/" title="Kernel-3.10.0-957.el7_nvdi"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_ntfs/" title="Kernel-3.10.0-957.el7_ntfs"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>