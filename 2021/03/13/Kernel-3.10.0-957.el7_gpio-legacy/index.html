<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-3.10.0-957.el7_gpio-legacy | oosTech.com</title>
  <meta name="description" content="GPIO Interfaces This provides an overview of GPIO access conventions on Linux. These calls use the gpio_* naming prefix.  No other calls should use thatprefix, or the related __gpio_* prefix. What is">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-3.10.0-957.el7_gpio-legacy">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_gpio-legacy/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="GPIO Interfaces This provides an overview of GPIO access conventions on Linux. These calls use the gpio_* naming prefix.  No other calls should use thatprefix, or the related __gpio_* prefix. What is">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_gpio-legacy/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#What-is-a-GPIO"><span class="toc-number">1.</span> <span class="toc-text">What is a GPIO?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GPIO-conventions"><span class="toc-number">2.</span> <span class="toc-text">GPIO conventions</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Identifying-GPIOs"><span class="toc-number">2.1.</span> <span class="toc-text">Identifying GPIOs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Using-GPIOs"><span class="toc-number">2.2.</span> <span class="toc-text">Using GPIOs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spinlock-Safe-GPIO-access"><span class="toc-number">2.3.</span> <span class="toc-text">Spinlock-Safe GPIO access</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO-access-that-may-sleep"><span class="toc-number">2.4.</span> <span class="toc-text">GPIO access that may sleep</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpio-request-one"><span class="toc-number">2.5.</span> <span class="toc-text">gpio_request_one()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpio-request-array"><span class="toc-number">2.6.</span> <span class="toc-text">gpio_request_array()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpio-free-array"><span class="toc-number">2.7.</span> <span class="toc-text">gpio_free_array()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Claiming-and-Releasing-GPIOs"><span class="toc-number">2.8.</span> <span class="toc-text">Claiming and Releasing GPIOs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIOs-mapped-to-IRQs"><span class="toc-number">2.9.</span> <span class="toc-text">GPIOs mapped to IRQs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Emulating-Open-Drain-Signals"><span class="toc-number">2.10.</span> <span class="toc-text">Emulating Open Drain Signals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO-controllers-and-the-pinctrl-subsystem"><span class="toc-number">2.11.</span> <span class="toc-text">GPIO controllers and the pinctrl subsystem</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#What-do-these-conventions-omit"><span class="toc-number">3.</span> <span class="toc-text">What do these conventions omit?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GPIO-implementor%E2%80%99s-framework-OPTIONAL"><span class="toc-number">4.</span> <span class="toc-text">GPIO implementor’s framework (OPTIONAL)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Controller-Drivers-gpio-chip"><span class="toc-number">4.1.</span> <span class="toc-text">Controller Drivers: gpio_chip</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Platform-Support"><span class="toc-number">4.2.</span> <span class="toc-text">Platform Support</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Board-Support"><span class="toc-number">4.3.</span> <span class="toc-text">Board Support</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Sysfs-Interface-for-Userspace-OPTIONAL"><span class="toc-number">5.</span> <span class="toc-text">Sysfs Interface for Userspace (OPTIONAL)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Paths-in-Sysfs"><span class="toc-number">5.1.</span> <span class="toc-text">Paths in Sysfs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exporting-from-Kernel-code"><span class="toc-number">5.2.</span> <span class="toc-text">Exporting from Kernel code</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-3.10.0-957.el7_gpio-legacy" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-3.10.0-957.el7_gpio-legacy
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_gpio-legacy/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_gpio-legacy/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-3.10.0-957.el7_gpio-legacy/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>GPIO Interfaces</p>
<p>This provides an overview of GPIO access conventions on Linux.</p>
<p>These calls use the gpio_* naming prefix.  No other calls should use that<br>prefix, or the related __gpio_* prefix.</p>
<h1 id="What-is-a-GPIO"><a href="#What-is-a-GPIO" class="headerlink" title="What is a GPIO?"></a>What is a GPIO?</h1><p>A “General Purpose Input/Output” (GPIO) is a flexible software-controlled<br>digital signal.  They are provided from many kinds of chip, and are familiar<br>to Linux developers working with embedded and custom hardware.  Each GPIO<br>represents a bit connected to a particular pin, or “ball” on Ball Grid Array<br>(BGA) packages.  Board schematics show which external hardware connects to<br>which GPIOs.  Drivers can be written generically, so that board setup code<br>passes such pin configuration data to drivers.</p>
<p>System-on-Chip (SOC) processors heavily rely on GPIOs.  In some cases, every<br>non-dedicated pin can be configured as a GPIO; and most chips have at least<br>several dozen of them.  Programmable logic devices (like FPGAs) can easily<br>provide GPIOs; multifunction chips like power managers, and audio codecs<br>often have a few such pins to help with pin scarcity on SOCs; and there are<br>also “GPIO Expander” chips that connect using the I2C or SPI serial busses.<br>Most PC southbridges have a few dozen GPIO-capable pins (with only the BIOS<br>firmware knowing how they’re used).</p>
<p>The exact capabilities of GPIOs vary between systems.  Common options:</p>
<ul>
<li><p>Output values are writable (high=1, low=0).  Some chips also have<br>options about how that value is driven, so that for example only one<br>value might be driven … supporting “wire-OR” and similar schemes<br>for the other value (notably, “open drain” signaling).</p>
</li>
<li><p>Input values are likewise readable (1, 0).  Some chips support readback<br>of pins configured as “output”, which is very useful in such “wire-OR”<br>cases (to support bidirectional signaling).  GPIO controllers may have<br>input de-glitch/debounce logic, sometimes with software controls.</p>
</li>
<li><p>Inputs can often be used as IRQ signals, often edge triggered but<br>sometimes level triggered.  Such IRQs may be configurable as system<br>wakeup events, to wake the system from a low power state.</p>
</li>
<li><p>Usually a GPIO will be configurable as either input or output, as needed<br>by different product boards; single direction ones exist too.</p>
</li>
<li><p>Most GPIOs can be accessed while holding spinlocks, but those accessed<br>through a serial bus normally can’t.  Some systems support both types.</p>
</li>
</ul>
<p>On a given board each GPIO is used for one specific purpose like monitoring<br>MMC/SD card insertion/removal, detecting card writeprotect status, driving<br>a LED, configuring a transceiver, bitbanging a serial bus, poking a hardware<br>watchdog, sensing a switch, and so on.</p>
<h1 id="GPIO-conventions"><a href="#GPIO-conventions" class="headerlink" title="GPIO conventions"></a>GPIO conventions</h1><p>Note that this is called a “convention” because you don’t need to do it this<br>way, and it’s no crime if you don’t.  There <strong>are</strong> cases where portability<br>is not the main issue; GPIOs are often used for the kind of board-specific<br>glue logic that may even change between board revisions, and can’t ever be<br>used on a board that’s wired differently.  Only least-common-denominator<br>functionality can be very portable.  Other features are platform-specific,<br>and that can be critical for glue logic.</p>
<p>Plus, this doesn’t require any implementation framework, just an interface.<br>One platform might implement it as simple inline functions accessing chip<br>registers; another might implement it by delegating through abstractions<br>used for several very different kinds of GPIO controller.  (There is some<br>optional code supporting such an implementation strategy, described later<br>in this document, but drivers acting as clients to the GPIO interface must<br>not care how it’s implemented.)</p>
<p>That said, if the convention is supported on their platform, drivers should<br>use it when possible.  Platforms must select ARCH_REQUIRE_GPIOLIB or<br>ARCH_WANT_OPTIONAL_GPIOLIB in their Kconfig.  Drivers that can’t work without<br>standard GPIO calls should have Kconfig entries which depend on GPIOLIB.  The<br>GPIO calls are available, either as “real code” or as optimized-away stubs,<br>when drivers use the include file:</p>
<pre><code>#include &lt;linux/gpio.h&gt;
</code></pre>
<p>If you stick to this convention then it’ll be easier for other developers to<br>see what your code is doing, and help maintain it.</p>
<p>Note that these operations include I/O barriers on platforms which need to<br>use them; drivers don’t need to add them explicitly.</p>
<h2 id="Identifying-GPIOs"><a href="#Identifying-GPIOs" class="headerlink" title="Identifying GPIOs"></a>Identifying GPIOs</h2><p>GPIOs are identified by unsigned integers in the range 0..MAX_INT.  That<br>reserves “negative” numbers for other purposes like marking signals as<br>“not available on this board”, or indicating faults.  Code that doesn’t<br>touch the underlying hardware treats these integers as opaque cookies.</p>
<p>Platforms define how they use those integers, and usually #define symbols<br>for the GPIO lines so that board-specific setup code directly corresponds<br>to the relevant schematics.  In contrast, drivers should only use GPIO<br>numbers passed to them from that setup code, using platform_data to hold<br>board-specific pin configuration data (along with other board specific<br>data they need).  That avoids portability problems.</p>
<p>So for example one platform uses numbers 32-159 for GPIOs; while another<br>uses numbers 0..63 with one set of GPIO controllers, 64-79 with another<br>type of GPIO controller, and on one particular board 80-95 with an FPGA.<br>The numbers need not be contiguous; either of those platforms could also<br>use numbers 2000-2063 to identify GPIOs in a bank of I2C GPIO expanders.</p>
<p>If you want to initialize a structure with an invalid GPIO number, use<br>some negative number (perhaps “-EINVAL”); that will never be valid.  To<br>test if such number from such a structure could reference a GPIO, you<br>may use this predicate:</p>
<pre><code>int gpio_is_valid(int number);
</code></pre>
<p>A number that’s not valid will be rejected by calls which may request<br>or free GPIOs (see below).  Other numbers may also be rejected; for<br>example, a number might be valid but temporarily unused on a given board.</p>
<p>Whether a platform supports multiple GPIO controllers is a platform-specific<br>implementation issue, as are whether that support can leave “holes” in the space<br>of GPIO numbers, and whether new controllers can be added at runtime.  Such issues<br>can affect things including whether adjacent GPIO numbers are both valid.</p>
<h2 id="Using-GPIOs"><a href="#Using-GPIOs" class="headerlink" title="Using GPIOs"></a>Using GPIOs</h2><p>The first thing a system should do with a GPIO is allocate it, using<br>the gpio_request() call; see later.</p>
<p>One of the next things to do with a GPIO, often in board setup code when<br>setting up a platform_device using the GPIO, is mark its direction:</p>
<pre><code>/* set as input or output, returning 0 or negative errno */
int gpio_direction_input(unsigned gpio);
int gpio_direction_output(unsigned gpio, int value);
</code></pre>
<p>The return value is zero for success, else a negative errno.  It should<br>be checked, since the get/set calls don’t have error returns and since<br>misconfiguration is possible.  You should normally issue these calls from<br>a task context.  However, for spinlock-safe GPIOs it’s OK to use them<br>before tasking is enabled, as part of early board setup.</p>
<p>For output GPIOs, the value provided becomes the initial output value.<br>This helps avoid signal glitching during system startup.</p>
<p>For compatibility with legacy interfaces to GPIOs, setting the direction<br>of a GPIO implicitly requests that GPIO (see below) if it has not been<br>requested already.  That compatibility is being removed from the optional<br>gpiolib framework.</p>
<p>Setting the direction can fail if the GPIO number is invalid, or when<br>that particular GPIO can’t be used in that mode.  It’s generally a bad<br>idea to rely on boot firmware to have set the direction correctly, since<br>it probably wasn’t validated to do more than boot Linux.  (Similarly,<br>that board setup code probably needs to multiplex that pin as a GPIO,<br>and configure pullups/pulldowns appropriately.)</p>
<h2 id="Spinlock-Safe-GPIO-access"><a href="#Spinlock-Safe-GPIO-access" class="headerlink" title="Spinlock-Safe GPIO access"></a>Spinlock-Safe GPIO access</h2><p>Most GPIO controllers can be accessed with memory read/write instructions.<br>Those don’t need to sleep, and can safely be done from inside hard<br>(nonthreaded) IRQ handlers and similar contexts.</p>
<p>Use the following calls to access such GPIOs,<br>for which gpio_cansleep() will always return false (see below):</p>
<pre><code>/* GPIO INPUT:  return zero or nonzero */
int gpio_get_value(unsigned gpio);

/* GPIO OUTPUT */
void gpio_set_value(unsigned gpio, int value);
</code></pre>
<p>The values are boolean, zero for low, nonzero for high.  When reading the<br>value of an output pin, the value returned should be what’s seen on the<br>pin … that won’t always match the specified output value, because of<br>issues including open-drain signaling and output latencies.</p>
<p>The get/set calls have no error returns because “invalid GPIO” should have<br>been reported earlier from gpio_direction_*().  However, note that not all<br>platforms can read the value of output pins; those that can’t should always<br>return zero.  Also, using these calls for GPIOs that can’t safely be accessed<br>without sleeping (see below) is an error.</p>
<p>Platform-specific implementations are encouraged to optimize the two<br>calls to access the GPIO value in cases where the GPIO number (and for<br>output, value) are constant.  It’s normal for them to need only a couple<br>of instructions in such cases (reading or writing a hardware register),<br>and not to need spinlocks.  Such optimized calls can make bitbanging<br>applications a lot more efficient (in both space and time) than spending<br>dozens of instructions on subroutine calls.</p>
<h2 id="GPIO-access-that-may-sleep"><a href="#GPIO-access-that-may-sleep" class="headerlink" title="GPIO access that may sleep"></a>GPIO access that may sleep</h2><p>Some GPIO controllers must be accessed using message based busses like I2C<br>or SPI.  Commands to read or write those GPIO values require waiting to<br>get to the head of a queue to transmit a command and get its response.<br>This requires sleeping, which can’t be done from inside IRQ handlers.</p>
<p>Platforms that support this type of GPIO distinguish them from other GPIOs<br>by returning nonzero from this call (which requires a valid GPIO number,<br>which should have been previously allocated with gpio_request):</p>
<pre><code>int gpio_cansleep(unsigned gpio);
</code></pre>
<p>To access such GPIOs, a different set of accessors is defined:</p>
<pre><code>/* GPIO INPUT:  return zero or nonzero, might sleep */
int gpio_get_value_cansleep(unsigned gpio);

/* GPIO OUTPUT, might sleep */
void gpio_set_value_cansleep(unsigned gpio, int value);
</code></pre>
<p>Accessing such GPIOs requires a context which may sleep,  for example<br>a threaded IRQ handler, and those accessors must be used instead of<br>spinlock-safe accessors without the cansleep() name suffix.</p>
<p>Other than the fact that these accessors might sleep, and will work<br>on GPIOs that can’t be accessed from hardIRQ handlers, these calls act<br>the same as the spinlock-safe calls.</p>
<p>  ** IN ADDITION ** calls to setup and configure such GPIOs must be made<br>from contexts which may sleep, since they may need to access the GPIO<br>controller chip too:  (These setup calls are usually made from board<br>setup or driver probe/teardown code, so this is an easy constraint.)</p>
<pre><code>gpio_direction_input()
gpio_direction_output()
gpio_request()
</code></pre>
<h2 id="gpio-request-one"><a href="#gpio-request-one" class="headerlink" title="gpio_request_one()"></a>gpio_request_one()</h2><h2 id="gpio-request-array"><a href="#gpio-request-array" class="headerlink" title="gpio_request_array()"></a>gpio_request_array()</h2><h2 id="gpio-free-array"><a href="#gpio-free-array" class="headerlink" title="gpio_free_array()"></a>gpio_free_array()</h2><pre><code>gpio_free()
gpio_set_debounce()
</code></pre>
<h2 id="Claiming-and-Releasing-GPIOs"><a href="#Claiming-and-Releasing-GPIOs" class="headerlink" title="Claiming and Releasing GPIOs"></a>Claiming and Releasing GPIOs</h2><p>To help catch system configuration errors, two calls are defined.</p>
<pre><code>/* request GPIO, returning 0 or negative errno.
 * non-null labels may be useful for diagnostics.
 */
int gpio_request(unsigned gpio, const char *label);

/* release previously-claimed GPIO */
void gpio_free(unsigned gpio);
</code></pre>
<p>Passing invalid GPIO numbers to gpio_request() will fail, as will requesting<br>GPIOs that have already been claimed with that call.  The return value of<br>gpio_request() must be checked.  You should normally issue these calls from<br>a task context.  However, for spinlock-safe GPIOs it’s OK to request GPIOs<br>before tasking is enabled, as part of early board setup.</p>
<p>These calls serve two basic purposes.  One is marking the signals which<br>are actually in use as GPIOs, for better diagnostics; systems may have<br>several hundred potential GPIOs, but often only a dozen are used on any<br>given board.  Another is to catch conflicts, identifying errors when<br>(a) two or more drivers wrongly think they have exclusive use of that<br>signal, or (b) something wrongly believes it’s safe to remove drivers<br>needed to manage a signal that’s in active use.  That is, requesting a<br>GPIO can serve as a kind of lock.</p>
<p>Some platforms may also use knowledge about what GPIOs are active for<br>power management, such as by powering down unused chip sectors and, more<br>easily, gating off unused clocks.</p>
<p>For GPIOs that use pins known to the pinctrl subsystem, that subsystem should<br>be informed of their use; a gpiolib driver’s .request() operation may call<br>pinctrl_request_gpio(), and a gpiolib driver’s .free() operation may call<br>pinctrl_free_gpio(). The pinctrl subsystem allows a pinctrl_request_gpio()<br>to succeed concurrently with a pin or pingroup being “owned” by a device for<br>pin multiplexing.</p>
<p>Any programming of pin multiplexing hardware that is needed to route the<br>GPIO signal to the appropriate pin should occur within a GPIO driver’s<br>.direction_input() or .direction_output() operations, and occur after any<br>setup of an output GPIO’s value. This allows a glitch-free migration from a<br>pin’s special function to GPIO. This is sometimes required when using a GPIO<br>to implement a workaround on signals typically driven by a non-GPIO HW block.</p>
<p>Some platforms allow some or all GPIO signals to be routed to different pins.<br>Similarly, other aspects of the GPIO or pin may need to be configured, such as<br>pullup/pulldown. Platform software should arrange that any such details are<br>configured prior to gpio_request() being called for those GPIOs, e.g. using<br>the pinctrl subsystem’s mapping table, so that GPIO users need not be aware<br>of these details.</p>
<p>Also note that it’s your responsibility to have stopped using a GPIO<br>before you free it.</p>
<p>Considering in most cases GPIOs are actually configured right after they<br>are claimed, three additional calls are defined:</p>
<pre><code>/* request a single GPIO, with initial configuration specified by
 * &#39;flags&#39;, identical to gpio_request() wrt other arguments and
 * return value
 */
int gpio_request_one(unsigned gpio, unsigned long flags, const char *label);

/* request multiple GPIOs in a single call
 */
int gpio_request_array(struct gpio *array, size_t num);

/* release multiple GPIOs in a single call
 */
void gpio_free_array(struct gpio *array, size_t num);
</code></pre>
<p>where ‘flags’ is currently defined to specify the following properties:</p>
<pre><code>* GPIOF_DIR_IN        - to configure direction as input
* GPIOF_DIR_OUT        - to configure direction as output

* GPIOF_INIT_LOW    - as output, set initial level to LOW
* GPIOF_INIT_HIGH    - as output, set initial level to HIGH
* GPIOF_OPEN_DRAIN    - gpio pin is open drain type.
* GPIOF_OPEN_SOURCE    - gpio pin is open source type.

* GPIOF_EXPORT_DIR_FIXED    - export gpio to sysfs, keep direction
* GPIOF_EXPORT_DIR_CHANGEABLE    - also export, allow changing direction
</code></pre>
<p>since GPIOF_INIT_* are only valid when configured as output, so group valid<br>combinations as:</p>
<pre><code>* GPIOF_IN        - configure as input
* GPIOF_OUT_INIT_LOW    - configured as output, initial level LOW
* GPIOF_OUT_INIT_HIGH    - configured as output, initial level HIGH
</code></pre>
<p>When setting the flag as GPIOF_OPEN_DRAIN then it will assume that pins is<br>open drain type. Such pins will not be driven to 1 in output mode. It is<br>require to connect pull-up on such pins. By enabling this flag, gpio lib will<br>make the direction to input when it is asked to set value of 1 in output mode<br>to make the pin HIGH. The pin is make to LOW by driving value 0 in output mode.</p>
<p>When setting the flag as GPIOF_OPEN_SOURCE then it will assume that pins is<br>open source type. Such pins will not be driven to 0 in output mode. It is<br>require to connect pull-down on such pin. By enabling this flag, gpio lib will<br>make the direction to input when it is asked to set value of 0 in output mode<br>to make the pin LOW. The pin is make to HIGH by driving value 1 in output mode.</p>
<p>In the future, these flags can be extended to support more properties.</p>
<p>Further more, to ease the claim/release of multiple GPIOs, ‘struct gpio’ is<br>introduced to encapsulate all three fields as:</p>
<pre><code>struct gpio &#123;
    unsigned    gpio;
    unsigned long    flags;
    const char    *label;
&#125;;
</code></pre>
<p>A typical example of usage:</p>
<pre><code>static struct gpio leds_gpios[] = &#123;
    &#123; 32, GPIOF_OUT_INIT_HIGH, &quot;Power LED&quot; &#125;, /* default to ON */
    &#123; 33, GPIOF_OUT_INIT_LOW,  &quot;Green LED&quot; &#125;, /* default to OFF */
    &#123; 34, GPIOF_OUT_INIT_LOW,  &quot;Red LED&quot;   &#125;, /* default to OFF */
    &#123; 35, GPIOF_OUT_INIT_LOW,  &quot;Blue LED&quot;  &#125;, /* default to OFF */
    &#123; ... &#125;,
&#125;;

err = gpio_request_one(31, GPIOF_IN, &quot;Reset Button&quot;);
if (err)
    ...

err = gpio_request_array(leds_gpios, ARRAY_SIZE(leds_gpios));
if (err)
    ...

gpio_free_array(leds_gpios, ARRAY_SIZE(leds_gpios));
</code></pre>
<h2 id="GPIOs-mapped-to-IRQs"><a href="#GPIOs-mapped-to-IRQs" class="headerlink" title="GPIOs mapped to IRQs"></a>GPIOs mapped to IRQs</h2><p>GPIO numbers are unsigned integers; so are IRQ numbers.  These make up<br>two logically distinct namespaces (GPIO 0 need not use IRQ 0).  You can<br>map between them using calls like:</p>
<pre><code>/* map GPIO numbers to IRQ numbers */
int gpio_to_irq(unsigned gpio);

/* map IRQ numbers to GPIO numbers (avoid using this) */
int irq_to_gpio(unsigned irq);
</code></pre>
<p>Those return either the corresponding number in the other namespace, or<br>else a negative errno code if the mapping can’t be done.  (For example,<br>some GPIOs can’t be used as IRQs.)  It is an unchecked error to use a GPIO<br>number that wasn’t set up as an input using gpio_direction_input(), or<br>to use an IRQ number that didn’t originally come from gpio_to_irq().</p>
<p>These two mapping calls are expected to cost on the order of a single<br>addition or subtraction.  They’re not allowed to sleep.</p>
<p>Non-error values returned from gpio_to_irq() can be passed to request_irq()<br>or free_irq().  They will often be stored into IRQ resources for platform<br>devices, by the board-specific initialization code.  Note that IRQ trigger<br>options are part of the IRQ interface, e.g. IRQF_TRIGGER_FALLING, as are<br>system wakeup capabilities.</p>
<p>Non-error values returned from irq_to_gpio() would most commonly be used<br>with gpio_get_value(), for example to initialize or update driver state<br>when the IRQ is edge-triggered.  Note that some platforms don’t support<br>this reverse mapping, so you should avoid using it.</p>
<h2 id="Emulating-Open-Drain-Signals"><a href="#Emulating-Open-Drain-Signals" class="headerlink" title="Emulating Open Drain Signals"></a>Emulating Open Drain Signals</h2><p>Sometimes shared signals need to use “open drain” signaling, where only the<br>low signal level is actually driven.  (That term applies to CMOS transistors;<br>“open collector” is used for TTL.)  A pullup resistor causes the high signal<br>level.  This is sometimes called a “wire-AND”; or more practically, from the<br>negative logic (low=true) perspective this is a “wire-OR”.</p>
<p>One common example of an open drain signal is a shared active-low IRQ line.<br>Also, bidirectional data bus signals sometimes use open drain signals.</p>
<p>Some GPIO controllers directly support open drain outputs; many don’t.  When<br>you need open drain signaling but your hardware doesn’t directly support it,<br>there’s a common idiom you can use to emulate it with any GPIO pin that can<br>be used as either an input or an output:</p>
<p> LOW:    gpio_direction_output(gpio, 0) … this drives the signal<br>    and overrides the pullup.</p>
<p> HIGH:    gpio_direction_input(gpio) … this turns off the output,<br>    so the pullup (or some other device) controls the signal.</p>
<p>If you are “driving” the signal high but gpio_get_value(gpio) reports a low<br>value (after the appropriate rise time passes), you know some other component<br>is driving the shared signal low.  That’s not necessarily an error.  As one<br>common example, that’s how I2C clocks are stretched:  a slave that needs a<br>slower clock delays the rising edge of SCK, and the I2C master adjusts its<br>signaling rate accordingly.</p>
<h2 id="GPIO-controllers-and-the-pinctrl-subsystem"><a href="#GPIO-controllers-and-the-pinctrl-subsystem" class="headerlink" title="GPIO controllers and the pinctrl subsystem"></a>GPIO controllers and the pinctrl subsystem</h2><p>A GPIO controller on a SOC might be tightly coupled with the pinctrl<br>subsystem, in the sense that the pins can be used by other functions<br>together with an optional gpio feature. We have already covered the<br>case where e.g. a GPIO controller need to reserve a pin or set the<br>direction of a pin by calling any of:</p>
<p>pinctrl_request_gpio()<br>pinctrl_free_gpio()<br>pinctrl_gpio_direction_input()<br>pinctrl_gpio_direction_output()</p>
<p>But how does the pin control subsystem cross-correlate the GPIO<br>numbers (which are a global business) to a certain pin on a certain<br>pin controller?</p>
<p>This is done by registering “ranges” of pins, which are essentially<br>cross-reference tables. These are described in<br>Documentation/pinctrl.txt</p>
<p>While the pin allocation is totally managed by the pinctrl subsystem,<br>gpio (under gpiolib) is still maintained by gpio drivers. It may happen<br>that different pin ranges in a SoC is managed by different gpio drivers.</p>
<p>This makes it logical to let gpio drivers announce their pin ranges to<br>the pin ctrl subsystem before it will call ‘pinctrl_request_gpio’ in order<br>to request the corresponding pin to be prepared by the pinctrl subsystem<br>before any gpio usage.</p>
<p>For this, the gpio controller can register its pin range with pinctrl<br>subsystem. There are two ways of doing it currently: with or without DT.</p>
<p>For with DT support refer to Documentation/devicetree/bindings/gpio/gpio.txt.</p>
<p>For non-DT support, user can call gpiochip_add_pin_range() with appropriate<br>parameters to register a range of gpio pins with a pinctrl driver. For this<br>exact name string of pinctrl device has to be passed as one of the<br>argument to this routine.</p>
<h1 id="What-do-these-conventions-omit"><a href="#What-do-these-conventions-omit" class="headerlink" title="What do these conventions omit?"></a>What do these conventions omit?</h1><p>One of the biggest things these conventions omit is pin multiplexing, since<br>this is highly chip-specific and nonportable.  One platform might not need<br>explicit multiplexing; another might have just two options for use of any<br>given pin; another might have eight options per pin; another might be able<br>to route a given GPIO to any one of several pins.  (Yes, those examples all<br>come from systems that run Linux today.)</p>
<p>Related to multiplexing is configuration and enabling of the pullups or<br>pulldowns integrated on some platforms.  Not all platforms support them,<br>or support them in the same way; and any given board might use external<br>pullups (or pulldowns) so that the on-chip ones should not be used.<br>(When a circuit needs 5 kOhm, on-chip 100 kOhm resistors won’t do.)<br>Likewise drive strength (2 mA vs 20 mA) and voltage (1.8V vs 3.3V) is a<br>platform-specific issue, as are models like (not) having a one-to-one<br>correspondence between configurable pins and GPIOs.</p>
<p>There are other system-specific mechanisms that are not specified here,<br>like the aforementioned options for input de-glitching and wire-OR output.<br>Hardware may support reading or writing GPIOs in gangs, but that’s usually<br>configuration dependent:  for GPIOs sharing the same bank.  (GPIOs are<br>commonly grouped in banks of 16 or 32, with a given SOC having several such<br>banks.)  Some systems can trigger IRQs from output GPIOs, or read values<br>from pins not managed as GPIOs.  Code relying on such mechanisms will<br>necessarily be nonportable.</p>
<p>Dynamic definition of GPIOs is not currently standard; for example, as<br>a side effect of configuring an add-on board with some GPIO expanders.</p>
<h1 id="GPIO-implementor’s-framework-OPTIONAL"><a href="#GPIO-implementor’s-framework-OPTIONAL" class="headerlink" title="GPIO implementor’s framework (OPTIONAL)"></a>GPIO implementor’s framework (OPTIONAL)</h1><p>As noted earlier, there is an optional implementation framework making it<br>easier for platforms to support different kinds of GPIO controller using<br>the same programming interface.  This framework is called “gpiolib”.</p>
<p>As a debugging aid, if debugfs is available a /sys/kernel/debug/gpio file<br>will be found there.  That will list all the controllers registered through<br>this framework, and the state of the GPIOs currently in use.</p>
<h2 id="Controller-Drivers-gpio-chip"><a href="#Controller-Drivers-gpio-chip" class="headerlink" title="Controller Drivers: gpio_chip"></a>Controller Drivers: gpio_chip</h2><p>In this framework each GPIO controller is packaged as a “struct gpio_chip”<br>with information common to each controller of that type:</p>
<ul>
<li>methods to establish GPIO direction</li>
<li>methods used to access GPIO values</li>
<li>flag saying whether calls to its methods may sleep</li>
<li>optional debugfs dump method (showing extra state like pullup config)</li>
<li>label for diagnostics</li>
</ul>
<p>There is also per-instance data, which may come from device.platform_data:<br>the number of its first GPIO, and how many GPIOs it exposes.</p>
<p>The code implementing a gpio_chip should support multiple instances of the<br>controller, possibly using the driver model.  That code will configure each<br>gpio_chip and issue gpiochip_add().  Removing a GPIO controller should be<br>rare; use gpiochip_remove() when it is unavoidable.</p>
<p>Most often a gpio_chip is part of an instance-specific structure with state<br>not exposed by the GPIO interfaces, such as addressing, power management,<br>and more.  Chips such as codecs will have complex non-GPIO state.</p>
<p>Any debugfs dump method should normally ignore signals which haven’t been<br>requested as GPIOs.  They can use gpiochip_is_requested(), which returns<br>either NULL or the label associated with that GPIO when it was requested.</p>
<h2 id="Platform-Support"><a href="#Platform-Support" class="headerlink" title="Platform Support"></a>Platform Support</h2><p>To support this framework, a platform’s Kconfig will “select” either<br>ARCH_REQUIRE_GPIOLIB or ARCH_WANT_OPTIONAL_GPIOLIB<br>and arrange that its &lt;asm/gpio.h&gt; includes &lt;asm-generic/gpio.h&gt; and defines<br>three functions: gpio_get_value(), gpio_set_value(), and gpio_cansleep().</p>
<p>It may also provide a custom value for ARCH_NR_GPIOS, so that it better<br>reflects the number of GPIOs in actual use on that platform, without<br>wasting static table space.  (It should count both built-in/SoC GPIOs and<br>also ones on GPIO expanders.</p>
<p>ARCH_REQUIRE_GPIOLIB means that the gpiolib code will always get compiled<br>into the kernel on that architecture.</p>
<p>ARCH_WANT_OPTIONAL_GPIOLIB means the gpiolib code defaults to off and the user<br>can enable it and build it into the kernel optionally.</p>
<p>If neither of these options are selected, the platform does not support<br>GPIOs through GPIO-lib and the code cannot be enabled by the user.</p>
<p>Trivial implementations of those functions can directly use framework<br>code, which always dispatches through the gpio_chip:</p>
<p>  #define gpio_get_value    __gpio_get_value<br>  #define gpio_set_value    __gpio_set_value<br>  #define gpio_cansleep        __gpio_cansleep</p>
<p>Fancier implementations could instead define those as inline functions with<br>logic optimizing access to specific SOC-based GPIOs.  For example, if the<br>referenced GPIO is the constant “12”, getting or setting its value could<br>cost as little as two or three instructions, never sleeping.  When such an<br>optimization is not possible those calls must delegate to the framework<br>code, costing at least a few dozen instructions.  For bitbanged I/O, such<br>instruction savings can be significant.</p>
<p>For SOCs, platform-specific code defines and registers gpio_chip instances<br>for each bank of on-chip GPIOs.  Those GPIOs should be numbered/labeled to<br>match chip vendor documentation, and directly match board schematics.  They<br>may well start at zero and go up to a platform-specific limit.  Such GPIOs<br>are normally integrated into platform initialization to make them always be<br>available, from arch_initcall() or earlier; they can often serve as IRQs.</p>
<h2 id="Board-Support"><a href="#Board-Support" class="headerlink" title="Board Support"></a>Board Support</h2><p>For external GPIO controllers – such as I2C or SPI expanders, ASICs, multi<br>function devices, FPGAs or CPLDs – most often board-specific code handles<br>registering controller devices and ensures that their drivers know what GPIO<br>numbers to use with gpiochip_add().  Their numbers often start right after<br>platform-specific GPIOs.</p>
<p>For example, board setup code could create structures identifying the range<br>of GPIOs that chip will expose, and passes them to each GPIO expander chip<br>using platform_data.  Then the chip driver’s probe() routine could pass that<br>data to gpiochip_add().</p>
<p>Initialization order can be important.  For example, when a device relies on<br>an I2C-based GPIO, its probe() routine should only be called after that GPIO<br>becomes available.  That may mean the device should not be registered until<br>calls for that GPIO can work.  One way to address such dependencies is for<br>such gpio_chip controllers to provide setup() and teardown() callbacks to<br>board specific code; those board specific callbacks would register devices<br>once all the necessary resources are available, and remove them later when<br>the GPIO controller device becomes unavailable.</p>
<h1 id="Sysfs-Interface-for-Userspace-OPTIONAL"><a href="#Sysfs-Interface-for-Userspace-OPTIONAL" class="headerlink" title="Sysfs Interface for Userspace (OPTIONAL)"></a>Sysfs Interface for Userspace (OPTIONAL)</h1><p>Platforms which use the “gpiolib” implementors framework may choose to<br>configure a sysfs user interface to GPIOs.  This is different from the<br>debugfs interface, since it provides control over GPIO direction and<br>value instead of just showing a gpio state summary.  Plus, it could be<br>present on production systems without debugging support.</p>
<p>Given appropriate hardware documentation for the system, userspace could<br>know for example that GPIO #23 controls the write protect line used to<br>protect boot loader segments in flash memory.  System upgrade procedures<br>may need to temporarily remove that protection, first importing a GPIO,<br>then changing its output state, then updating the code before re-enabling<br>the write protection.  In normal use, GPIO #23 would never be touched,<br>and the kernel would have no need to know about it.</p>
<p>Again depending on appropriate hardware documentation, on some systems<br>userspace GPIO can be used to determine system configuration data that<br>standard kernels won’t know about.  And for some tasks, simple userspace<br>GPIO drivers could be all that the system really needs.</p>
<p>Note that standard kernel drivers exist for common “LEDs and Buttons”<br>GPIO tasks:  “leds-gpio” and “gpio_keys”, respectively.  Use those<br>instead of talking directly to the GPIOs; they integrate with kernel<br>frameworks better than your userspace code could.</p>
<h2 id="Paths-in-Sysfs"><a href="#Paths-in-Sysfs" class="headerlink" title="Paths in Sysfs"></a>Paths in Sysfs</h2><p>There are three kinds of entry in /sys/class/gpio:</p>
<ul>
<li><p>   Control interfaces used to get userspace control over GPIOs;</p>
</li>
<li><p>   GPIOs themselves; and</p>
</li>
<li><p>   GPIO controllers (“gpio_chip” instances).</p>
</li>
</ul>
<p>That’s in addition to standard files including the “device” symlink.</p>
<p>The control interfaces are write-only:</p>
<pre><code>/sys/class/gpio/

    &quot;export&quot; ... Userspace may ask the kernel to export control of
    a GPIO to userspace by writing its number to this file.

    Example:  &quot;echo 19 &gt; export&quot; will create a &quot;gpio19&quot; node
    for GPIO #19, if that&#39;s not requested by kernel code.

    &quot;unexport&quot; ... Reverses the effect of exporting to userspace.

    Example:  &quot;echo 19 &gt; unexport&quot; will remove a &quot;gpio19&quot;
    node exported using the &quot;export&quot; file.
</code></pre>
<p>GPIO signals have paths like /sys/class/gpio/gpio42/ (for GPIO #42)<br>and have the following read/write attributes:</p>
<pre><code>/sys/class/gpio/gpioN/

&quot;direction&quot; ... reads as either &quot;in&quot; or &quot;out&quot;.  This value may
    normally be written.  Writing as &quot;out&quot; defaults to
    initializing the value as low.  To ensure glitch free
    operation, values &quot;low&quot; and &quot;high&quot; may be written to
    configure the GPIO as an output with that initial value.

    Note that this attribute *will not exist* if the kernel
    doesn&#39;t support changing the direction of a GPIO, or
    it was exported by kernel code that didn&#39;t explicitly
    allow userspace to reconfigure this GPIO&#39;s direction.

&quot;value&quot; ... reads as either 0 (low) or 1 (high).  If the GPIO
    is configured as an output, this value may be written;
    any nonzero value is treated as high.

    If the pin can be configured as interrupt-generating interrupt
    and if it has been configured to generate interrupts (see the
    description of &quot;edge&quot;), you can poll(2) on that file and
    poll(2) will return whenever the interrupt was triggered. If
    you use poll(2), set the events POLLPRI and POLLERR. If you
    use select(2), set the file descriptor in exceptfds. After
    poll(2) returns, either lseek(2) to the beginning of the sysfs
    file and read the new value or close the file and re-open it
    to read the value.

&quot;edge&quot; ... reads as either &quot;none&quot;, &quot;rising&quot;, &quot;falling&quot;, or
    &quot;both&quot;. Write these strings to select the signal edge(s)
    that will make poll(2) on the &quot;value&quot; file return.

    This file exists only if the pin can be configured as an
    interrupt generating input pin.

&quot;active_low&quot; ... reads as either 0 (false) or 1 (true).  Write
    any nonzero value to invert the value attribute both
    for reading and writing.  Existing and subsequent
    poll(2) support configuration via the edge attribute
    for &quot;rising&quot; and &quot;falling&quot; edges will follow this
    setting.
</code></pre>
<p>GPIO controllers have paths like /sys/class/gpio/gpiochip42/ (for the<br>controller implementing GPIOs starting at #42) and have the following<br>read-only attributes:</p>
<pre><code>/sys/class/gpio/gpiochipN/

    &quot;base&quot; ... same as N, the first GPIO managed by this chip

    &quot;label&quot; ... provided for diagnostics (not always unique)

    &quot;ngpio&quot; ... how many GPIOs this manges (N to N + ngpio - 1)
</code></pre>
<p>Board documentation should in most cases cover what GPIOs are used for<br>what purposes.  However, those numbers are not always stable; GPIOs on<br>a daughtercard might be different depending on the base board being used,<br>or other cards in the stack.  In such cases, you may need to use the<br>gpiochip nodes (possibly in conjunction with schematics) to determine<br>the correct GPIO number to use for a given signal.</p>
<h2 id="Exporting-from-Kernel-code"><a href="#Exporting-from-Kernel-code" class="headerlink" title="Exporting from Kernel code"></a>Exporting from Kernel code</h2><p>Kernel code can explicitly manage exports of GPIOs which have already been<br>requested using gpio_request():</p>
<pre><code>/* export the GPIO to userspace */
int gpio_export(unsigned gpio, bool direction_may_change);

/* reverse gpio_export() */
void gpio_unexport();

/* create a sysfs link to an exported GPIO node */
int gpio_export_link(struct device *dev, const char *name,
    unsigned gpio)

/* change the polarity of a GPIO node in sysfs */
int gpio_sysfs_set_active_low(unsigned gpio, int value);
</code></pre>
<p>After a kernel driver requests a GPIO, it may only be made available in<br>the sysfs interface by gpio_export().  The driver can control whether the<br>signal direction may change.  This helps drivers prevent userspace code<br>from accidentally clobbering important system state.</p>
<p>This explicit exporting can help with debugging (by making some kinds<br>of experiments easier), or can provide an always-there interface that’s<br>suitable for documenting as part of a board support package.</p>
<p>After the GPIO has been exported, gpio_export_link() allows creating<br>symlinks from elsewhere in sysfs to the GPIO sysfs node.  Drivers can<br>use this to provide the interface under their own device in sysfs with<br>a descriptive name.</p>
<p>Drivers can use gpio_sysfs_set_active_low() to hide GPIO line polarity<br>differences between boards from user space.  This only affects the<br>sysfs interface.  Polarity change can be done both before and after<br>gpio_export(), and previously enabled poll(2) support for either<br>rising or falling edge will be reconfigured to follow this setting.</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_gpio-legacy/" title="Kernel-3.10.0-957.el7_gpio-legacy" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_gpio-legacy/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_kernel-docs/" title="Kernel-3.10.0-957.el7_kernel-docs"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_fsl,mxs-pinctrl/" title="Kernel-3.10.0-957.el7_fsl,mxs-pinctrl"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>