<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-3.10.0-957.el7_coda | oosTech.com</title>
  <meta name="description" content="NOTE:This is one of the technical documents describing a component ofCoda – this document describes the client kernel-Venus interface. For more information:  http:&#x2F;&#x2F;www.coda.cs.cmu.eduFor user level s">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-3.10.0-957.el7_coda">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_coda/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="NOTE:This is one of the technical documents describing a component ofCoda – this document describes the client kernel-Venus interface. For more information:  http:&#x2F;&#x2F;www.coda.cs.cmu.eduFor user level s">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_coda/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-3.10.0-957.el7_coda" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-3.10.0-957.el7_coda
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_coda/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_coda/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-3.10.0-957.el7_coda/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>NOTE:<br>This is one of the technical documents describing a component of<br>Coda – this document describes the client kernel-Venus interface.</p>
<p>For more information:<br>  <a target="_blank" rel="noopener" href="http://www.coda.cs.cmu.edu/">http://www.coda.cs.cmu.edu</a><br>For user level software needed to run Coda:<br>  <a href="ftp://ftp.coda.cs.cmu.edu/">ftp://ftp.coda.cs.cmu.edu</a></p>
<p>To run Coda you need to get a user level cache manager for the client,<br>named Venus, as well as tools to manipulate ACLs, to log in, etc.  The<br>client needs to have the Coda filesystem selected in the kernel<br>configuration.</p>
<p>The server needs a user level server and at present does not depend on<br>kernel support.</p>
<p>  The Venus kernel interface<br>  Peter J. Braam<br>  v1.0, Nov 9, 1997</p>
<p>  This document describes the communication between Venus and kernel<br>  level filesystem code needed for the operation of the Coda file sys-<br>  tem.  This document version is meant to describe the current interface<br>  (version 1.0) as well as improvements we envisage.</p>
<hr>
<p>  Table of Contents</p>
<ol>
<li><p>Introduction</p>
</li>
<li><p>Servicing Coda filesystem calls</p>
</li>
<li><p>The message layer</p>
<p>3.1 Implementation details</p>
</li>
<li><p>The interface at the call level</p>
<p>4.1 Data structures shared by the kernel and Venus<br>4.2 The pioctl interface<br>4.3 root<br>4.4 lookup<br>4.5 getattr<br>4.6 setattr<br>4.7 access<br>4.8 create<br>4.9 mkdir<br>4.10 link<br>4.11 symlink<br>4.12 remove<br>4.13 rmdir<br>4.14 readlink<br>4.15 open<br>4.16 close<br>4.17 ioctl<br>4.18 rename<br>4.19 readdir<br>4.20 vget<br>4.21 fsync<br>4.22 inactive<br>4.23 rdwr<br>4.24 odymount<br>4.25 ody_lookup<br>4.26 ody_expand<br>4.27 prefetch<br>4.28 signal</p>
</li>
<li><p>The minicache and downcalls</p>
<p>5.1 INVALIDATE<br>5.2 FLUSH<br>5.3 PURGEUSER<br>5.4 ZAPFILE<br>5.5 ZAPDIR<br>5.6 ZAPVNODE<br>5.7 PURGEFID<br>5.8 REPLACE</p>
</li>
<li><p>Initialization and cleanup</p>
<p>6.1 Requirements</p>
</li>
</ol>
<hr>
<p>  0wpage</p>
<p>  11..  IInnttrroodduuccttiioonn</p>
<p>  A key component in the Coda Distributed File System is the cache<br>  manager, _V_e_n_u_s.</p>
<p>  When processes on a Coda enabled system access files in the Coda<br>  filesystem, requests are directed at the filesystem layer in the<br>  operating system. The operating system will communicate with Venus to<br>  service the request for the process.  Venus manages a persistent<br>  client cache and makes remote procedure calls to Coda file servers and<br>  related servers (such as authentication servers) to service these<br>  requests it receives from the operating system.  When Venus has<br>  serviced a request it replies to the operating system with appropriate<br>  return codes, and other data related to the request.  Optionally the<br>  kernel support for Coda may maintain a minicache of recently processed<br>  requests to limit the number of interactions with Venus.  Venus<br>  possesses the facility to inform the kernel when elements from its<br>  minicache are no longer valid.</p>
<p>  This document describes precisely this communication between the<br>  kernel and Venus.  The definitions of so called upcalls and downcalls<br>  will be given with the format of the data they handle. We shall also<br>  describe the semantic invariants resulting from the calls.</p>
<p>  Historically Coda was implemented in a BSD file system in Mach 2.6.<br>  The interface between the kernel and Venus is very similar to the BSD<br>  VFS interface.  Similar functionality is provided, and the format of<br>  the parameters and returned data is very similar to the BSD VFS.  This<br>  leads to an almost natural environment for implementing a kernel-level<br>  filesystem driver for Coda in a BSD system.  However, other operating<br>  systems such as Linux and Windows 95 and NT have virtual filesystem<br>  with different interfaces.</p>
<p>  To implement Coda on these systems some reverse engineering of the<br>  Venus/Kernel protocol is necessary.  Also it came to light that other<br>  systems could profit significantly from certain small optimizations<br>  and modifications to the protocol. To facilitate this work as well as<br>  to make future ports easier, communication between Venus and the<br>  kernel should be documented in great detail.  This is the aim of this<br>  document.</p>
<p>  0wpage</p>
<p>  22..  SSeerrvviicciinngg CCooddaa ffiilleessyysstteemm ccaallllss</p>
<p>  The service of a request for a Coda file system service originates in<br>  a process PP which accessing a Coda file. It makes a system call which<br>  traps to the OS kernel. Examples of such calls trapping to the kernel<br>  are _r_e_a_d_, _w_r_i_t_e_, _o_p_e_n_, _c_l_o_s_e_, _c_r_e_a_t_e_, _m_k_d_i_r_, _r_m_d_i_r_, _c_h_m_o_d in a Unix<br>  context.  Similar calls exist in the Win32 environment, and are named<br>  _C_r_e_a_t_e_F_i_l_e_, .</p>
<p>  Generally the operating system handles the request in a virtual<br>  filesystem (VFS) layer, which is named I/O Manager in NT and IFS<br>  manager in Windows 95.  The VFS is responsible for partial processing<br>  of the request and for locating the specific filesystem(s) which will<br>  service parts of the request.  Usually the information in the path<br>  assists in locating the correct FS drivers.  Sometimes after extensive<br>  pre-processing, the VFS starts invoking exported routines in the FS<br>  driver.  This is the point where the FS specific processing of the<br>  request starts, and here the Coda specific kernel code comes into<br>  play.</p>
<p>  The FS layer for Coda must expose and implement several interfaces.<br>  First and foremost the VFS must be able to make all necessary calls to<br>  the Coda FS layer, so the Coda FS driver must expose the VFS interface<br>  as applicable in the operating system. These differ very significantly<br>  among operating systems, but share features such as facilities to<br>  read/write and create and remove objects.  The Coda FS layer services<br>  such VFS requests by invoking one or more well defined services<br>  offered by the cache manager Venus.  When the replies from Venus have<br>  come back to the FS driver, servicing of the VFS call continues and<br>  finishes with a reply to the kernel’s VFS. Finally the VFS layer<br>  returns to the process.</p>
<p>  As a result of this design a basic interface exposed by the FS driver<br>  must allow Venus to manage message traffic.  In particular Venus must<br>  be able to retrieve and place messages and to be notified of the<br>  arrival of a new message. The notification must be through a mechanism<br>  which does not block Venus since Venus must attend to other tasks even<br>  when no messages are waiting or being processed.</p>
<pre><code>                 Interfaces of the Coda FS Driver
</code></pre>
<p>  Furthermore the FS layer provides for a special path of communication<br>  between a user process and Venus, called the pioctl interface. The<br>  pioctl interface is used for Coda specific services, such as<br>  requesting detailed information about the persistent cache managed by<br>  Venus. Here the involvement of the kernel is minimal.  It identifies<br>  the calling process and passes the information on to Venus.  When<br>  Venus replies the response is passed back to the caller in unmodified<br>  form.</p>
<p>  Finally Venus allows the kernel FS driver to cache the results from<br>  certain services.  This is done to avoid excessive context switches<br>  and results in an efficient system.  However, Venus may acquire<br>  information, for example from the network which implies that cached<br>  information must be flushed or replaced. Venus then makes a downcall<br>  to the Coda FS layer to request flushes or updates in the cache.  The<br>  kernel FS driver handles such requests synchronously.</p>
<p>  Among these interfaces the VFS interface and the facility to place,<br>  receive and be notified of messages are platform specific.  We will<br>  not go into the calls exported to the VFS layer but we will state the<br>  requirements of the message exchange mechanism.</p>
<p>  0wpage</p>
<p>  33..  TThhee mmeessssaaggee llaayyeerr</p>
<p>  At the lowest level the communication between Venus and the FS driver<br>  proceeds through messages.  The synchronization between processes<br>  requesting Coda file service and Venus relies on blocking and waking<br>  up processes.  The Coda FS driver processes VFS- and pioctl-requests<br>  on behalf of a process P, creates messages for Venus, awaits replies<br>  and finally returns to the caller.  The implementation of the exchange<br>  of messages is platform specific, but the semantics have (so far)<br>  appeared to be generally applicable.  Data buffers are created by the<br>  FS Driver in kernel memory on behalf of P and copied to user memory in<br>  Venus.</p>
<p>  The FS Driver while servicing P makes upcalls to Venus.  Such an<br>  upcall is dispatched to Venus by creating a message structure.  The<br>  structure contains the identification of P, the message sequence<br>  number, the size of the request and a pointer to the data in kernel<br>  memory for the request.  Since the data buffer is re-used to hold the<br>  reply from Venus, there is a field for the size of the reply.  A flags<br>  field is used in the message to precisely record the status of the<br>  message.  Additional platform dependent structures involve pointers to<br>  determine the position of the message on queues and pointers to<br>  synchronization objects.  In the upcall routine the message structure<br>  is filled in, flags are set to 0, and it is placed on the _p_e_n_d_i_n_g<br>  queue.  The routine calling upcall is responsible for allocating the<br>  data buffer; its structure will be described in the next section.</p>
<p>  A facility must exist to notify Venus that the message has been<br>  created, and implemented using available synchronization objects in<br>  the OS. This notification is done in the upcall context of the process<br>  P. When the message is on the pending queue, process P cannot proceed<br>  in upcall.  The (kernel mode) processing of P in the filesystem<br>  request routine must be suspended until Venus has replied.  Therefore<br>  the calling thread in P is blocked in upcall.  A pointer in the<br>  message structure will locate the synchronization object on which P is<br>  sleeping.</p>
<p>  Venus detects the notification that a message has arrived, and the FS<br>  driver allow Venus to retrieve the message with a getmsg_from_kernel<br>  call. This action finishes in the kernel by putting the message on the<br>  queue of processing messages and setting flags to READ.  Venus is<br>  passed the contents of the data buffer. The getmsg_from_kernel call<br>  now returns and Venus processes the request.</p>
<p>  At some later point the FS driver receives a message from Venus,<br>  namely when Venus calls sendmsg_to_kernel.  At this moment the Coda FS<br>  driver looks at the contents of the message and decides if:</p>
<p>  +o  the message is a reply for a suspended thread P.  If so it removes<br>     the message from the processing queue and marks the message as<br>     WRITTEN.  Finally, the FS driver unblocks P (still in the kernel<br>     mode context of Venus) and the sendmsg_to_kernel call returns to<br>     Venus.  The process P will be scheduled at some point and continues<br>     processing its upcall with the data buffer replaced with the reply<br>     from Venus.</p>
<p>  +o  The message is a _d_o_w_n_c_a_l_l.  A downcall is a request from Venus to<br>     the FS Driver. The FS driver processes the request immediately<br>     (usually a cache eviction or replacement) and when it finishes<br>     sendmsg_to_kernel returns.</p>
<p>  Now P awakes and continues processing upcall.  There are some<br>  subtleties to take account of. First P will determine if it was woken<br>  up in upcall by a signal from some other source (for example an<br>  attempt to terminate P) or as is normally the case by Venus in its<br>  sendmsg_to_kernel call.  In the normal case, the upcall routine will<br>  deallocate the message structure and return.  The FS routine can proceed<br>  with its processing.</p>
<pre><code>                  Sleeping and IPC arrangements
</code></pre>
<p>  In case P is woken up by a signal and not by Venus, it will first look<br>  at the flags field.  If the message is not yet READ, the process P can<br>  handle its signal without notifying Venus.  If Venus has READ, and<br>  the request should not be processed, P can send Venus a signal message<br>  to indicate that it should disregard the previous message.  Such<br>  signals are put in the queue at the head, and read first by Venus.  If<br>  the message is already marked as WRITTEN it is too late to stop the<br>  processing.  The VFS routine will now continue.  (– If a VFS request<br>  involves more than one upcall, this can lead to complicated state, an<br>  extra field “handle_signals” could be added in the message structure<br>  to indicate points of no return have been passed.–)</p>
<p>  33..11..  IImmpplleemmeennttaattiioonn ddeettaaiillss</p>
<p>  The Unix implementation of this mechanism has been through the<br>  implementation of a character device associated with Coda.  Venus<br>  retrieves messages by doing a read on the device, replies are sent<br>  with a write and notification is through the select system call on the<br>  file descriptor for the device.  The process P is kept waiting on an<br>  interruptible wait queue object.</p>
<p>  In Windows NT and the DPMI Windows 95 implementation a DeviceIoControl<br>  call is used.  The DeviceIoControl call is designed to copy buffers<br>  from user memory to kernel memory with OPCODES. The sendmsg_to_kernel<br>  is issued as a synchronous call, while the getmsg_from_kernel call is<br>  asynchronous.  Windows EventObjects are used for notification of<br>  message arrival.  The process P is kept waiting on a KernelEvent<br>  object in NT and a semaphore in Windows 95.</p>
<p>  0wpage</p>
<p>  44..  TThhee iinntteerrffaaccee aatt tthhee ccaallll lleevveell</p>
<p>  This section describes the upcalls a Coda FS driver can make to Venus.<br>  Each of these upcalls make use of two structures: inputArgs and<br>  outputArgs.   In pseudo BNF form the structures take the following<br>  form:</p>
<p>  struct inputArgs {<br>      u_long opcode;<br>      u_long unique;     /* Keep multiple outstanding msgs distinct <em>/<br>      u_short pid;                 /</em> Common to all <em>/<br>      u_short pgid;                /</em> Common to all <em>/<br>      struct CodaCred cred;        /</em> Common to all */</p>
<pre><code>  &lt;union &quot;in&quot; of call dependent parts of inputArgs&gt;
</code></pre>
<p>  };</p>
<p>  struct outputArgs {<br>      u_long opcode;<br>      u_long unique;       /* Keep multiple outstanding msgs distinct */<br>      u_long result;</p>
<pre><code>  &lt;union &quot;out&quot; of call dependent parts of inputArgs&gt;
</code></pre>
<p>  };</p>
<p>  Before going on let us elucidate the role of the various fields. The<br>  inputArgs start with the opcode which defines the type of service<br>  requested from Venus. There are approximately 30 upcalls at present<br>  which we will discuss.   The unique field labels the inputArg with a<br>  unique number which will identify the message uniquely.  A process and<br>  process group id are passed.  Finally the credentials of the caller<br>  are included.</p>
<p>  Before delving into the specific calls we need to discuss a variety of<br>  data structures shared by the kernel and Venus.</p>
<p>  44..11..  DDaattaa ssttrruuccttuurreess sshhaarreedd bbyy tthhee kkeerrnneell aanndd VVeennuuss</p>
<p>  The CodaCred structure defines a variety of user and group ids as<br>  they are set for the calling process. The vuid_t and guid_t are 32 bit<br>  unsigned integers.  It also defines group membership in an array.  On<br>  Unix the CodaCred has proven sufficient to implement good security<br>  semantics for Coda but the structure may have to undergo modification<br>  for the Windows environment when these mature.</p>
<p>  struct CodaCred {<br>      vuid_t cr_uid, cr_euid, cr_suid, cr_fsuid; /* Real, effective, set, fs uid*/<br>      vgid_t cr_gid, cr_egid, cr_sgid, cr_fsgid; /* same for groups <em>/<br>      vgid_t cr_groups[NGROUPS];        /</em> Group membership for caller */<br>  };</p>
<p>  NNOOTTEE It is questionable if we need CodaCreds in Venus. Finally Venus<br>  doesn’t know about groups, although it does create files with the<br>  default uid/gid.  Perhaps the list of group membership is superfluous.</p>
<p>  The next item is the fundamental identifier used to identify Coda<br>  files, the ViceFid.  A fid of a file uniquely defines a file or<br>  directory in the Coda filesystem within a _c_e_l_l.   (– A _c_e_l_l is a<br>  group of Coda servers acting under the aegis of a single system<br>  control machine or SCM. See the Coda Administration manual for a<br>  detailed description of the role of the SCM.–)</p>
<p>  typedef struct ViceFid {<br>      VolumeId Volume;<br>      VnodeId Vnode;<br>      Unique_t Unique;<br>  } ViceFid;</p>
<p>  Each of the constituent fields: VolumeId, VnodeId and Unique_t are<br>  unsigned 32 bit integers.  We envisage that a further field will need<br>  to be prefixed to identify the Coda cell; this will probably take the<br>  form of a Ipv6 size IP address naming the Coda cell through DNS.</p>
<p>  The next important structure shared between Venus and the kernel is<br>  the attributes of the file.  The following structure is used to<br>  exchange information.  It has room for future extensions such as<br>  support for device files (currently not present in Coda).</p>
<p>  struct coda_vattr {<br>          enum coda_vtype va_type;        /* vnode type (for create) <em>/<br>          u_short         va_mode;        /</em> files access mode and type <em>/<br>          short           va_nlink;       /</em> number of references to file <em>/<br>          vuid_t          va_uid;         /</em> owner user id <em>/<br>          vgid_t          va_gid;         /</em> owner group id <em>/<br>          long            va_fsid;        /</em> file system id (dev for now) <em>/<br>          long            va_fileid;      /</em> file id <em>/<br>          u_quad_t        va_size;        /</em> file size in bytes <em>/<br>          long            va_blocksize;   /</em> blocksize preferred for i/o <em>/<br>          struct timespec va_atime;       /</em> time of last access <em>/<br>          struct timespec va_mtime;       /</em> time of last modification <em>/<br>          struct timespec va_ctime;       /</em> time file changed <em>/<br>          u_long          va_gen;         /</em> generation number of file <em>/<br>          u_long          va_flags;       /</em> flags defined for file <em>/<br>          dev_t           va_rdev;        /</em> device special file represents <em>/<br>          u_quad_t        va_bytes;       /</em> bytes of disk space held by file <em>/<br>          u_quad_t        va_filerev;     /</em> file modification number <em>/<br>          u_int           va_vaflags;     /</em> operations flags, see below <em>/<br>          long            va_spare;       /</em> remain quad aligned */<br>  };</p>
<p>  44..22..  TThhee ppiiooccttll iinntteerrffaaccee</p>
<p>  Coda specific requests can be made by application through the pioctl<br>  interface. The pioctl is implemented as an ordinary ioctl on a<br>  fictitious file /coda/.CONTROL.  The pioctl call opens this file, gets<br>  a file handle and makes the ioctl call. Finally it closes the file.</p>
<p>  The kernel involvement in this is limited to providing the facility to<br>  open and close and pass the ioctl message _a_n_d to verify that a path in<br>  the pioctl data buffers is a file in a Coda filesystem.</p>
<p>  The kernel is handed a data packet of the form:</p>
<pre><code>  struct &#123;
      const char *path;
      struct ViceIoctl vidata;
      int follow;
  &#125; data;
</code></pre>
<p>  where</p>
<p>  struct ViceIoctl {<br>          caddr_t in, out;        /* Data to be transferred in, or out <em>/<br>          short in_size;          /</em> Size of input buffer &lt;= 2K <em>/<br>          short out_size;         /</em> Maximum size of output buffer, &lt;= 2K */<br>  };</p>
<p>  The path must be a Coda file, otherwise the ioctl upcall will not be<br>  made.</p>
<p>  NNOOTTEE  The data structures and code are a mess.  We need to clean this<br>  up.</p>
<p>  We now proceed to document the individual calls:</p>
<p>  0wpage</p>
<p>  44..33..  rroooott</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn empty

 oouutt

            struct cfs_root_out &#123;
                ViceFid VFid;
            &#125; cfs_root;
</code></pre>
<p>  DDeessccrriippttiioonn This call is made to Venus during the initialization of<br>  the Coda filesystem. If the result is zero, the cfs_root structure<br>  contains the ViceFid of the root of the Coda filesystem. If a non-zero<br>  result is generated, its value is a platform dependent error code<br>  indicating the difficulty Venus encountered in locating the root of<br>  the Coda filesystem.</p>
<p>  0wpage</p>
<p>  44..44..  llooookkuupp</p>
<p>  SSuummmmaarryy Find the ViceFid and type of an object in a directory if it<br>  exists.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct  cfs_lookup_in &#123;
                ViceFid     VFid;
                char        *name;          /* Place holder for data. */
            &#125; cfs_lookup;



 oouutt

            struct cfs_lookup_out &#123;
                ViceFid VFid;
                int vtype;
            &#125; cfs_lookup;
</code></pre>
<p>  DDeessccrriippttiioonn This call is made to determine the ViceFid and filetype of<br>  a directory entry.  The directory entry requested carries name name<br>  and Venus will search the directory identified by cfs_lookup_in.VFid.<br>  The result may indicate that the name does not exist, or that<br>  difficulty was encountered in finding it (e.g. due to disconnection).<br>  If the result is zero, the field cfs_lookup_out.VFid contains the<br>  targets ViceFid and cfs_lookup_out.vtype the coda_vtype giving the<br>  type of object the name designates.</p>
<p>  The name of the object is an 8 bit character string of maximum length<br>  CFS_MAXNAMLEN, currently set to 256 (including a 0 terminator.)</p>
<p>  It is extremely important to realize that Venus bitwise ors the field<br>  cfs_lookup.vtype with CFS_NOCACHE to indicate that the object should<br>  not be put in the kernel name cache.</p>
<p>  NNOOTTEE The type of the vtype is currently wrong.  It should be<br>  coda_vtype. Linux does not take note of CFS_NOCACHE.  It should.</p>
<p>  0wpage</p>
<p>  44..55..  ggeettaattttrr</p>
<p>  SSuummmmaarryy Get the attributes of a file.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_getattr_in &#123;
                ViceFid VFid;
                struct coda_vattr attr; /* XXXXX */
            &#125; cfs_getattr;



 oouutt

            struct cfs_getattr_out &#123;
                struct coda_vattr attr;
            &#125; cfs_getattr;
</code></pre>
<p>  DDeessccrriippttiioonn This call returns the attributes of the file identified by<br>  fid.</p>
<p>  EErrrroorrss Errors can occur if the object with fid does not exist, is<br>  unaccessible or if the caller does not have permission to fetch<br>  attributes.</p>
<p>  NNoottee Many kernel FS drivers (Linux, NT and Windows 95) need to acquire<br>  the attributes as well as the Fid for the instantiation of an internal<br>  “inode” or “FileHandle”.  A significant improvement in performance on<br>  such systems could be made by combining the _l_o_o_k_u_p and _g_e_t_a_t_t_r calls<br>  both at the Venus/kernel interaction level and at the RPC level.</p>
<p>  The vattr structure included in the input arguments is superfluous and<br>  should be removed.</p>
<p>  0wpage</p>
<p>  44..66..  sseettaattttrr</p>
<p>  SSuummmmaarryy Set the attributes of a file.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_setattr_in &#123;
                ViceFid VFid;
                struct coda_vattr attr;
            &#125; cfs_setattr;




 oouutt
    empty
</code></pre>
<p>  DDeessccrriippttiioonn The structure attr is filled with attributes to be changed<br>  in BSD style.  Attributes not to be changed are set to -1, apart from<br>  vtype which is set to VNON. Other are set to the value to be assigned.<br>  The only attributes which the FS driver may request to change are the<br>  mode, owner, groupid, atime, mtime and ctime.  The return value<br>  indicates success or failure.</p>
<p>  EErrrroorrss A variety of errors can occur.  The object may not exist, may<br>  be inaccessible, or permission may not be granted by Venus.</p>
<p>  0wpage</p>
<p>  44..77..  aacccceessss</p>
<p>  SSuummmmaarryy</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_access_in &#123;
                ViceFid     VFid;
                int flags;
            &#125; cfs_access;



 oouutt
    empty
</code></pre>
<p>  DDeessccrriippttiioonn Verify if access to the object identified by VFid for<br>  operations described by flags is permitted.  The result indicates if<br>  access will be granted.  It is important to remember that Coda uses<br>  ACLs to enforce protection and that ultimately the servers, not the<br>  clients enforce the security of the system.  The result of this call<br>  will depend on whether a _t_o_k_e_n is held by the user.</p>
<p>  EErrrroorrss The object may not exist, or the ACL describing the protection<br>  may not be accessible.</p>
<p>  0wpage</p>
<p>  44..88..  ccrreeaattee</p>
<p>  SSuummmmaarryy Invoked to create a file</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_create_in &#123;
                ViceFid VFid;
                struct coda_vattr attr;
                int excl;
                int mode;
                char        *name;          /* Place holder for data. */
            &#125; cfs_create;




 oouutt

            struct cfs_create_out &#123;
                ViceFid VFid;
                struct coda_vattr attr;
            &#125; cfs_create;
</code></pre>
<p>  DDeessccrriippttiioonn  This upcall is invoked to request creation of a file.<br>  The file will be created in the directory identified by VFid, its name<br>  will be name, and the mode will be mode.  If excl is set an error will<br>  be returned if the file already exists.  If the size field in attr is<br>  set to zero the file will be truncated.  The uid and gid of the file<br>  are set by converting the CodaCred to a uid using a macro CRTOUID<br>  (this macro is platform dependent).  Upon success the VFid and<br>  attributes of the file are returned.  The Coda FS Driver will normally<br>  instantiate a vnode, inode or file handle at kernel level for the new<br>  object.</p>
<p>  EErrrroorrss A variety of errors can occur. Permissions may be insufficient.<br>  If the object exists and is not a file the error EISDIR is returned<br>  under Unix.</p>
<p>  NNOOTTEE The packing of parameters is very inefficient and appears to<br>  indicate confusion between the system call creat and the VFS operation<br>  create. The VFS operation create is only called to create new objects.<br>  This create call differs from the Unix one in that it is not invoked<br>  to return a file descriptor. The truncate and exclusive options,<br>  together with the mode, could simply be part of the mode as it is<br>  under Unix.  There should be no flags argument; this is used in open<br>  (2) to return a file descriptor for READ or WRITE mode.</p>
<p>  The attributes of the directory should be returned too, since the size<br>  and mtime changed.</p>
<p>  0wpage</p>
<p>  44..99..  mmkkddiirr</p>
<p>  SSuummmmaarryy Create a new directory.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_mkdir_in &#123;
                ViceFid     VFid;
                struct coda_vattr attr;
                char        *name;          /* Place holder for data. */
            &#125; cfs_mkdir;



 oouutt

            struct cfs_mkdir_out &#123;
                ViceFid VFid;
                struct coda_vattr attr;
            &#125; cfs_mkdir;
</code></pre>
<p>  DDeessccrriippttiioonn This call is similar to create but creates a directory.<br>  Only the mode field in the input parameters is used for creation.<br>  Upon successful creation, the attr returned contains the attributes of<br>  the new directory.</p>
<p>  EErrrroorrss As for create.</p>
<p>  NNOOTTEE The input parameter should be changed to mode instead of<br>  attributes.</p>
<p>  The attributes of the parent should be returned since the size and<br>  mtime changes.</p>
<p>  0wpage</p>
<p>  44..1100..  lliinnkk</p>
<p>  SSuummmmaarryy Create a link to an existing file.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_link_in &#123;
                ViceFid sourceFid;          /* cnode to link *to* */
                ViceFid destFid;            /* Directory in which to place link */
                char        *tname;         /* Place holder for data. */
            &#125; cfs_link;



 oouutt
    empty
</code></pre>
<p>  DDeessccrriippttiioonn This call creates a link to the sourceFid in the directory<br>  identified by destFid with name tname.  The source must reside in the<br>  target’s parent, i.e. the source must be have parent destFid, i.e. Coda<br>  does not support cross directory hard links.  Only the return value is<br>  relevant.  It indicates success or the type of failure.</p>
<p>  EErrrroorrss The usual errors can occur.0wpage</p>
<p>  44..1111..  ssyymmlliinnkk</p>
<p>  SSuummmmaarryy create a symbolic link</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_symlink_in &#123;
                ViceFid     VFid;          /* Directory to put symlink in */
                char        *srcname;
                struct coda_vattr attr;
                char        *tname;
            &#125; cfs_symlink;



 oouutt
    none
</code></pre>
<p>  DDeessccrriippttiioonn Create a symbolic link. The link is to be placed in the<br>  directory identified by VFid and named tname.  It should point to the<br>  pathname srcname.  The attributes of the newly created object are to<br>  be set to attr.</p>
<p>  EErrrroorrss</p>
<p>  NNOOTTEE The attributes of the target directory should be returned since<br>  its size changed.</p>
<p>  0wpage</p>
<p>  44..1122..  rreemmoovvee</p>
<p>  SSuummmmaarryy Remove a file</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_remove_in &#123;
                ViceFid     VFid;
                char        *name;          /* Place holder for data. */
            &#125; cfs_remove;



 oouutt
    none
</code></pre>
<p>  DDeessccrriippttiioonn  Remove file named cfs_remove_in.name in directory<br>  identified by   VFid.</p>
<p>  EErrrroorrss</p>
<p>  NNOOTTEE The attributes of the directory should be returned since its<br>  mtime and size may change.</p>
<p>  0wpage</p>
<p>  44..1133..  rrmmddiirr</p>
<p>  SSuummmmaarryy Remove a directory</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_rmdir_in &#123;
                ViceFid     VFid;
                char        *name;          /* Place holder for data. */
            &#125; cfs_rmdir;



 oouutt
    none
</code></pre>
<p>  DDeessccrriippttiioonn Remove the directory with name name from the directory<br>  identified by VFid.</p>
<p>  EErrrroorrss</p>
<p>  NNOOTTEE The attributes of the parent directory should be returned since<br>  its mtime and size may change.</p>
<p>  0wpage</p>
<p>  44..1144..  rreeaaddlliinnkk</p>
<p>  SSuummmmaarryy Read the value of a symbolic link.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_readlink_in &#123;
                ViceFid VFid;
            &#125; cfs_readlink;



 oouutt

            struct cfs_readlink_out &#123;
                int count;
                caddr_t     data;           /* Place holder for data. */
            &#125; cfs_readlink;
</code></pre>
<p>  DDeessccrriippttiioonn This routine reads the contents of symbolic link<br>  identified by VFid into the buffer data.  The buffer data must be able<br>  to hold any name up to CFS_MAXNAMLEN (PATH or NAM??).</p>
<p>  EErrrroorrss No unusual errors.</p>
<p>  0wpage</p>
<p>  44..1155..  ooppeenn</p>
<p>  SSuummmmaarryy Open a file.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_open_in &#123;
                ViceFid     VFid;
                int flags;
            &#125; cfs_open;



 oouutt

            struct cfs_open_out &#123;
                dev_t       dev;
                ino_t       inode;
            &#125; cfs_open;
</code></pre>
<p>  DDeessccrriippttiioonn  This request asks Venus to place the file identified by<br>  VFid in its cache and to note that the calling process wishes to open<br>  it with flags as in open(2).  The return value to the kernel differs<br>  for Unix and Windows systems.  For Unix systems the Coda FS Driver is<br>  informed of the device and inode number of the container file in the<br>  fields dev and inode.  For Windows the path of the container file is<br>  returned to the kernel.<br>  EErrrroorrss</p>
<p>  NNOOTTEE Currently the cfs_open_out structure is not properly adapted to<br>  deal with the Windows case.  It might be best to implement two<br>  upcalls, one to open aiming at a container file name, the other at a<br>  container file inode.</p>
<p>  0wpage</p>
<p>  44..1166..  cclloossee</p>
<p>  SSuummmmaarryy Close a file, update it on the servers.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_close_in &#123;
                ViceFid     VFid;
                int flags;
            &#125; cfs_close;



 oouutt
    none
</code></pre>
<p>  DDeessccrriippttiioonn Close the file identified by VFid.</p>
<p>  EErrrroorrss</p>
<p>  NNOOTTEE The flags argument is bogus and not used.  However, Venus’ code<br>  has room to deal with an execp input field, probably this field should<br>  be used to inform Venus that the file was closed but is still memory<br>  mapped for execution.  There are comments about fetching versus not<br>  fetching the data in Venus vproc_vfscalls.  This seems silly.  If a<br>  file is being closed, the data in the container file is to be the new<br>  data.  Here again the execp flag might be in play to create confusion:<br>  currently Venus might think a file can be flushed from the cache when<br>  it is still memory mapped.  This needs to be understood.</p>
<p>  0wpage</p>
<p>  44..1177..  iiooccttll</p>
<p>  SSuummmmaarryy Do an ioctl on a file. This includes the pioctl interface.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_ioctl_in &#123;
                ViceFid VFid;
                int cmd;
                int len;
                int rwflag;
                char *data;                 /* Place holder for data. */
            &#125; cfs_ioctl;



 oouutt


            struct cfs_ioctl_out &#123;
                int len;
                caddr_t     data;           /* Place holder for data. */
            &#125; cfs_ioctl;
</code></pre>
<p>  DDeessccrriippttiioonn Do an ioctl operation on a file.  The command, len and<br>  data arguments are filled as usual.  flags is not used by Venus.</p>
<p>  EErrrroorrss</p>
<p>  NNOOTTEE Another bogus parameter.  flags is not used.  What is the<br>  business about PREFETCHING in the Venus code?</p>
<p>  0wpage</p>
<p>  44..1188..  rreennaammee</p>
<p>  SSuummmmaarryy Rename a fid.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_rename_in &#123;
                ViceFid     sourceFid;
                char        *srcname;
                ViceFid destFid;
                char        *destname;
            &#125; cfs_rename;



 oouutt
    none
</code></pre>
<p>  DDeessccrriippttiioonn  Rename the object with name srcname in directory<br>  sourceFid to destname in destFid.   It is important that the names<br>  srcname and destname are 0 terminated strings.  Strings in Unix<br>  kernels are not always null terminated.</p>
<p>  EErrrroorrss</p>
<p>  0wpage</p>
<p>  44..1199..  rreeaaddddiirr</p>
<p>  SSuummmmaarryy Read directory entries.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_readdir_in &#123;
                ViceFid     VFid;
                int count;
                int offset;
            &#125; cfs_readdir;




 oouutt

            struct cfs_readdir_out &#123;
                int size;
                caddr_t     data;           /* Place holder for data. */
            &#125; cfs_readdir;
</code></pre>
<p>  DDeessccrriippttiioonn Read directory entries from VFid starting at offset and<br>  read at most count bytes.  Returns the data in data and returns<br>  the size in size.</p>
<p>  EErrrroorrss</p>
<p>  NNOOTTEE This call is not used.  Readdir operations exploit container<br>  files.  We will re-evaluate this during the directory revamp which is<br>  about to take place.</p>
<p>  0wpage</p>
<p>  44..2200..  vvggeett</p>
<p>  SSuummmmaarryy instructs Venus to do an FSDB-&gt;Get.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_vget_in &#123;
                ViceFid VFid;
            &#125; cfs_vget;



 oouutt

            struct cfs_vget_out &#123;
                ViceFid VFid;
                int vtype;
            &#125; cfs_vget;
</code></pre>
<p>  DDeessccrriippttiioonn This upcall asks Venus to do a get operation on an fsobj<br>  labelled by VFid.</p>
<p>  EErrrroorrss</p>
<p>  NNOOTTEE This operation is not used.  However, it is extremely useful<br>  since it can be used to deal with read/write memory mapped files.<br>  These can be “pinned” in the Venus cache using vget and released with<br>  inactive.</p>
<p>  0wpage</p>
<p>  44..2211..  ffssyynncc</p>
<p>  SSuummmmaarryy Tell Venus to update the RVM attributes of a file.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_fsync_in &#123;
                ViceFid VFid;
            &#125; cfs_fsync;



 oouutt
    none
</code></pre>
<p>  DDeessccrriippttiioonn Ask Venus to update RVM attributes of object VFid. This<br>  should be called as part of kernel level fsync type calls.  The<br>  result indicates if the syncing was successful.</p>
<p>  EErrrroorrss</p>
<p>  NNOOTTEE Linux does not implement this call. It should.</p>
<p>  0wpage</p>
<p>  44..2222..  iinnaaccttiivvee</p>
<p>  SSuummmmaarryy Tell Venus a vnode is no longer in use.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_inactive_in &#123;
                ViceFid VFid;
            &#125; cfs_inactive;



 oouutt
    none
</code></pre>
<p>  DDeessccrriippttiioonn This operation returns EOPNOTSUPP.</p>
<p>  EErrrroorrss</p>
<p>  NNOOTTEE This should perhaps be removed.</p>
<p>  0wpage</p>
<p>  44..2233..  rrddwwrr</p>
<p>  SSuummmmaarryy Read or write from a file</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct cfs_rdwr_in &#123;
                ViceFid     VFid;
                int rwflag;
                int count;
                int offset;
                int ioflag;
                caddr_t     data;           /* Place holder for data. */
            &#125; cfs_rdwr;




 oouutt

            struct cfs_rdwr_out &#123;
                int rwflag;
                int count;
                caddr_t     data;   /* Place holder for data. */
            &#125; cfs_rdwr;
</code></pre>
<p>  DDeessccrriippttiioonn This upcall asks Venus to read or write from a file.</p>
<p>  EErrrroorrss</p>
<p>  NNOOTTEE It should be removed since it is against the Coda philosophy that<br>  read/write operations never reach Venus.  I have been told the<br>  operation does not work.  It is not currently used.</p>
<p>  0wpage</p>
<p>  44..2244..  ooddyymmoouunntt</p>
<p>  SSuummmmaarryy Allows mounting multiple Coda “filesystems” on one Unix mount<br>  point.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn

            struct ody_mount_in &#123;
                char        *name;          /* Place holder for data. */
            &#125; ody_mount;



 oouutt

            struct ody_mount_out &#123;
                ViceFid VFid;
            &#125; ody_mount;
</code></pre>
<p>  DDeessccrriippttiioonn  Asks Venus to return the rootfid of a Coda system named<br>  name.  The fid is returned in VFid.</p>
<p>  EErrrroorrss</p>
<p>  NNOOTTEE This call was used by David for dynamic sets.  It should be<br>  removed since it causes a jungle of pointers in the VFS mounting area.<br>  It is not used by Coda proper.  Call is not implemented by Venus.</p>
<p>  0wpage</p>
<p>  44..2255..  ooddyy__llooookkuupp</p>
<p>  SSuummmmaarryy Looks up something.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn irrelevant


 oouutt
    irrelevant
</code></pre>
<p>  DDeessccrriippttiioonn</p>
<p>  EErrrroorrss</p>
<p>  NNOOTTEE Gut it. Call is not implemented by Venus.</p>
<p>  0wpage</p>
<p>  44..2266..  ooddyy__eexxppaanndd</p>
<p>  SSuummmmaarryy expands something in a dynamic set.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn irrelevant

 oouutt
    irrelevant
</code></pre>
<p>  DDeessccrriippttiioonn</p>
<p>  EErrrroorrss</p>
<p>  NNOOTTEE Gut it.  Call is not implemented by Venus.</p>
<p>  0wpage</p>
<p>  44..2277..  pprreeffeettcchh</p>
<p>  SSuummmmaarryy Prefetch a dynamic set.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn Not documented.

 oouutt
    Not documented.
</code></pre>
<p>  DDeessccrriippttiioonn  Venus worker.cc has support for this call, although it is<br>  noted that it doesn’t work.  Not surprising, since the kernel does not<br>  have support for it. (ODY_PREFETCH is not a defined operation).</p>
<p>  EErrrroorrss</p>
<p>  NNOOTTEE Gut it. It isn’t working and isn’t used by Coda.</p>
<p>  0wpage</p>
<p>  44..2288..  ssiiggnnaall</p>
<p>  SSuummmmaarryy Send Venus a signal about an upcall.</p>
<p>  AArrgguummeennttss</p>
<pre><code> iinn none

 oouutt
    not applicable.
</code></pre>
<p>  DDeessccrriippttiioonn  This is an out-of-band upcall to Venus to inform Venus<br>  that the calling process received a signal after Venus read the<br>  message from the input queue.  Venus is supposed to clean up the<br>  operation.</p>
<p>  EErrrroorrss No reply is given.</p>
<p>  NNOOTTEE We need to better understand what Venus needs to clean up and if<br>  it is doing this correctly.  Also we need to handle multiple upcall<br>  per system call situations correctly.  It would be important to know<br>  what state changes in Venus take place after an upcall for which the<br>  kernel is responsible for notifying Venus to clean up (e.g. open<br>  definitely is such a state change, but many others are maybe not).</p>
<p>  0wpage</p>
<p>  55..  TThhee mmiinniiccaacchhee aanndd ddoowwnnccaallllss</p>
<p>  The Coda FS Driver can cache results of lookup and access upcalls, to<br>  limit the frequency of upcalls.  Upcalls carry a price since a process<br>  context switch needs to take place.  The counterpart of caching the<br>  information is that Venus will notify the FS Driver that cached<br>  entries must be flushed or renamed.</p>
<p>  The kernel code generally has to maintain a structure which links the<br>  internal file handles (called vnodes in BSD, inodes in Linux and<br>  FileHandles in Windows) with the ViceFid’s which Venus maintains.  The<br>  reason is that frequent translations back and forth are needed in<br>  order to make upcalls and use the results of upcalls.  Such linking<br>  objects are called ccnnooddeess.</p>
<p>  The current minicache implementations have cache entries which record<br>  the following:</p>
<ol>
<li><p>the name of the file</p>
</li>
<li><p>the cnode of the directory containing the object</p>
</li>
<li><p>a list of CodaCred’s for which the lookup is permitted.</p>
</li>
<li><p>the cnode of the object</p>
<p>The lookup call in the Coda FS Driver may request the cnode of the<br>desired object from the cache, by passing its name, directory and the<br>CodaCred’s of the caller.  The cache will return the cnode or indicate<br>that it cannot be found.  The Coda FS Driver must be careful to<br>invalidate cache entries when it modifies or removes objects.</p>
<p>When Venus obtains information that indicates that cache entries are<br>no longer valid, it will make a downcall to the kernel.  Downcalls are<br>intercepted by the Coda FS Driver and lead to cache invalidations of<br>the kind described below.  The Coda FS Driver does not return an error<br>unless the downcall data could not be read into kernel memory.</p>
</li>
</ol>
<p>  55..11..  IINNVVAALLIIDDAATTEE</p>
<p>  No information is available on this call.</p>
<p>  55..22..  FFLLUUSSHH</p>
<p>  AArrgguummeennttss None</p>
<p>  SSuummmmaarryy Flush the name cache entirely.</p>
<p>  DDeessccrriippttiioonn Venus issues this call upon startup and when it dies. This<br>  is to prevent stale cache information being held.  Some operating<br>  systems allow the kernel name cache to be switched off dynamically.<br>  When this is done, this downcall is made.</p>
<p>  55..33..  PPUURRGGEEUUSSEERR</p>
<p>  AArrgguummeennttss</p>
<pre><code>      struct cfs_purgeuser_out &#123;/* CFS_PURGEUSER is a venus-&gt;kernel call */
          struct CodaCred cred;
      &#125; cfs_purgeuser;
</code></pre>
<p>  DDeessccrriippttiioonn Remove all entries in the cache carrying the Cred.  This<br>  call is issued when tokens for a user expire or are flushed.</p>
<p>  55..44..  ZZAAPPFFIILLEE</p>
<p>  AArrgguummeennttss</p>
<pre><code>      struct cfs_zapfile_out &#123;  /* CFS_ZAPFILE is a venus-&gt;kernel call */
          ViceFid CodaFid;
      &#125; cfs_zapfile;
</code></pre>
<p>  DDeessccrriippttiioonn Remove all entries which have the (dir vnode, name) pair.<br>  This is issued as a result of an invalidation of cached attributes of<br>  a vnode.</p>
<p>  NNOOTTEE Call is not named correctly in NetBSD and Mach.  The minicache<br>  zapfile routine takes different arguments. Linux does not implement<br>  the invalidation of attributes correctly.</p>
<p>  55..55..  ZZAAPPDDIIRR</p>
<p>  AArrgguummeennttss</p>
<pre><code>      struct cfs_zapdir_out &#123;   /* CFS_ZAPDIR is a venus-&gt;kernel call */
          ViceFid CodaFid;
      &#125; cfs_zapdir;
</code></pre>
<p>  DDeessccrriippttiioonn Remove all entries in the cache lying in a directory<br>  CodaFid, and all children of this directory. This call is issued when<br>  Venus receives a callback on the directory.</p>
<p>  55..66..  ZZAAPPVVNNOODDEE</p>
<p>  AArrgguummeennttss</p>
<pre><code>      struct cfs_zapvnode_out &#123; /* CFS_ZAPVNODE is a venus-&gt;kernel call */
          struct CodaCred cred;
          ViceFid VFid;
      &#125; cfs_zapvnode;
</code></pre>
<p>  DDeessccrriippttiioonn Remove all entries in the cache carrying the cred and VFid<br>  as in the arguments. This downcall is probably never issued.</p>
<p>  55..77..  PPUURRGGEEFFIIDD</p>
<p>  SSuummmmaarryy</p>
<p>  AArrgguummeennttss</p>
<pre><code>      struct cfs_purgefid_out &#123; /* CFS_PURGEFID is a venus-&gt;kernel call */
          ViceFid CodaFid;
      &#125; cfs_purgefid;
</code></pre>
<p>  DDeessccrriippttiioonn Flush the attribute for the file. If it is a dir (odd<br>  vnode), purge its children from the namecache and remove the file from the<br>  namecache.</p>
<p>  55..88..  RREEPPLLAACCEE</p>
<p>  SSuummmmaarryy Replace the Fid’s for a collection of names.</p>
<p>  AArrgguummeennttss</p>
<pre><code>      struct cfs_replace_out &#123; /* cfs_replace is a venus-&gt;kernel call */
          ViceFid NewFid;
          ViceFid OldFid;
      &#125; cfs_replace;
</code></pre>
<p>  DDeessccrriippttiioonn This routine replaces a ViceFid in the name cache with<br>  another.  It is added to allow Venus during reintegration to replace<br>  locally allocated temp fids while disconnected with global fids even<br>  when the reference counts on those fids are not zero.</p>
<p>  0wpage</p>
<p>  66..  IInniittiiaalliizzaattiioonn aanndd cclleeaannuupp</p>
<p>  This section gives brief hints as to desirable features for the Coda<br>  FS Driver at startup and upon shutdown or Venus failures.  Before<br>  entering the discussion it is useful to repeat that the Coda FS Driver<br>  maintains the following data:</p>
<ol>
<li><p>message queues</p>
</li>
<li><p>cnodes</p>
</li>
<li><p>name cache entries</p>
<p>The name cache entries are entirely private to the driver, so they<br>can easily be manipulated.   The message queues will generally have<br>clear points of initialization and destruction.  The cnodes are<br>much more delicate.  User processes hold reference counts in Coda<br>filesystems and it can be difficult to clean up the cnodes.</p>
<p>It can expect requests through:</p>
</li>
<li><p>the message subsystem</p>
</li>
<li><p>the VFS layer</p>
</li>
<li><p>pioctl interface</p>
<p>Currently the _p_i_o_c_t_l passes through the VFS for Coda so we can<br>treat these similarly.</p>
</li>
</ol>
<p>  66..11..  RReeqquuiirreemmeennttss</p>
<p>  The following requirements should be accommodated:</p>
<ol>
<li>The message queues should have open and close routines.  On Unix<br>the opening of the character devices are such routines.</li>
</ol>
<p>  +o  Before opening, no messages can be placed.</p>
<p>  +o  Opening will remove any old messages still pending.</p>
<p>  +o  Close will notify any sleeping processes that their upcall cannot<br>     be completed.</p>
<p>  +o  Close will free all memory allocated by the message queues.</p>
<ol start="2">
<li><p>At open the namecache shall be initialized to empty state.</p>
</li>
<li><p>Before the message queues are open, all VFS operations will fail.<br>Fortunately this can be achieved by making sure than mounting the<br>Coda filesystem cannot succeed before opening.</p>
</li>
<li><p>After closing of the queues, no VFS operations can succeed.  Here<br>one needs to be careful, since a few operations (lookup,<br>read/write, readdir) can proceed without upcalls.  These must be<br>explicitly blocked.</p>
</li>
<li><p>Upon closing the namecache shall be flushed and disabled.</p>
</li>
<li><p>All memory held by cnodes can be freed without relying on upcalls.</p>
</li>
<li><p>Unmounting the file system can be done without relying on upcalls.</p>
</li>
<li><p>Mounting the Coda filesystem should fail gracefully if Venus cannot<br>get the rootfid or the attributes of the rootfid.  The latter is<br>best implemented by Venus fetching these objects before attempting<br>to mount.</p>
<p>NNOOTTEE  NetBSD in particular but also Linux have not implemented the<br>above requirements fully.  For smooth operation this needs to be<br>corrected.</p>
</li>
</ol>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_coda/" title="Kernel-3.10.0-957.el7_coda" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_coda/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_gpio/" title="Kernel-3.10.0-957.el7_gpio"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_booting-without-of/" title="Kernel-3.10.0-957.el7_booting-without-of"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>