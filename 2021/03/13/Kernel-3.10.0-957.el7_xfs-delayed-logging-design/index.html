<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-3.10.0-957.el7_xfs-delayed-logging-design | oosTech.com</title>
  <meta name="description" content="XFS Delayed Logging DesignIntroduction to Re-logging in XFSXFS logging is a combination of logical and physical logging. Some objects,such as inodes and dquots, are logged in logical format where the">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-3.10.0-957.el7_xfs-delayed-logging-design">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_xfs-delayed-logging-design/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="XFS Delayed Logging DesignIntroduction to Re-logging in XFSXFS logging is a combination of logical and physical logging. Some objects,such as inodes and dquots, are logged in logical format where the">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_xfs-delayed-logging-design/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#XFS-Delayed-Logging-Design"><span class="toc-number">1.</span> <span class="toc-text">XFS Delayed Logging Design</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction-to-Re-logging-in-XFS"><span class="toc-number">2.</span> <span class="toc-text">Introduction to Re-logging in XFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Delayed-Logging-Concepts"><span class="toc-number">3.</span> <span class="toc-text">Delayed Logging: Concepts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Delayed-Logging-Design"><span class="toc-number">4.</span> <span class="toc-text">Delayed Logging: Design</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-3.10.0-957.el7_xfs-delayed-logging-design" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-3.10.0-957.el7_xfs-delayed-logging-design
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_xfs-delayed-logging-design/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_xfs-delayed-logging-design/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-3.10.0-957.el7_xfs-delayed-logging-design/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h2 id="XFS-Delayed-Logging-Design"><a href="#XFS-Delayed-Logging-Design" class="headerlink" title="XFS Delayed Logging Design"></a>XFS Delayed Logging Design</h2><h2 id="Introduction-to-Re-logging-in-XFS"><a href="#Introduction-to-Re-logging-in-XFS" class="headerlink" title="Introduction to Re-logging in XFS"></a>Introduction to Re-logging in XFS</h2><p>XFS logging is a combination of logical and physical logging. Some objects,<br>such as inodes and dquots, are logged in logical format where the details<br>logged are made up of the changes to in-core structures rather than on-disk<br>structures. Other objects - typically buffers - have their physical changes<br>logged. The reason for these differences is to reduce the amount of log space<br>required for objects that are frequently logged. Some parts of inodes are more<br>frequently logged than others, and inodes are typically more frequently logged<br>than any other object (except maybe the superblock buffer) so keeping the<br>amount of metadata logged low is of prime importance.</p>
<p>The reason that this is such a concern is that XFS allows multiple separate<br>modifications to a single object to be carried in the log at any given time.<br>This allows the log to avoid needing to flush each change to disk before<br>recording a new change to the object. XFS does this via a method called<br>“re-logging”. Conceptually, this is quite simple - all it requires is that any<br>new change to the object is recorded with a <em>new copy</em> of all the existing<br>changes in the new transaction that is written to the log.</p>
<p>That is, if we have a sequence of changes A through to F, and the object was<br>written to disk after change D, we would see in the log the following series<br>of transactions, their contents and the log sequence number (LSN) of the<br>transaction:</p>
<pre><code>Transaction        Contents    LSN
   A               A           X
   B              A+B          X+n
   C             A+B+C         X+n+m
   D            A+B+C+D        X+n+m+o
    &lt;object written to disk&gt;
   E               E           Y (&gt; X+n+m+o)
   F              E+F          YÙ+p
</code></pre>
<p>In other words, each time an object is relogged, the new transaction contains<br>the aggregation of all the previous changes currently held only in the log.</p>
<p>This relogging technique also allows objects to be moved forward in the log so<br>that an object being relogged does not prevent the tail of the log from ever<br>moving forward.  This can be seen in the table above by the changing<br>(increasing) LSN of each subsequent transaction - the LSN is effectively a<br>direct encoding of the location in the log of the transaction.</p>
<p>This relogging is also used to implement long-running, multiple-commit<br>transactions.  These transaction are known as rolling transactions, and require<br>a special log reservation known as a permanent transaction reservation. A<br>typical example of a rolling transaction is the removal of extents from an<br>inode which can only be done at a rate of two extents per transaction because<br>of reservation size limitations. Hence a rolling extent removal transaction<br>keeps relogging the inode and btree buffers as they get modified in each<br>removal operation. This keeps them moving forward in the log as the operation<br>progresses, ensuring that current operation never gets blocked by itself if the<br>log wraps around.</p>
<p>Hence it can be seen that the relogging operation is fundamental to the correct<br>working of the XFS journalling subsystem. From the above description, most<br>people should be able to see why the XFS metadata operations writes so much to<br>the log - repeated operations to the same objects write the same changes to<br>the log over and over again. Worse is the fact that objects tend to get<br>dirtier as they get relogged, so each subsequent transaction is writing more<br>metadata into the log.</p>
<p>Another feature of the XFS transaction subsystem is that most transactions are<br>asynchronous. That is, they don’t commit to disk until either a log buffer is<br>filled (a log buffer can hold multiple transactions) or a synchronous operation<br>forces the log buffers holding the transactions to disk. This means that XFS is<br>doing aggregation of transactions in memory - batching them, if you like - to<br>minimise the impact of the log IO on transaction throughput.</p>
<p>The limitation on asynchronous transaction throughput is the number and size of<br>log buffers made available by the log manager. By default there are 8 log<br>buffers available and the size of each is 32kB - the size can be increased up<br>to 256kB by use of a mount option.</p>
<p>Effectively, this gives us the maximum bound of outstanding metadata changes<br>that can be made to the filesystem at any point in time - if all the log<br>buffers are full and under IO, then no more transactions can be committed until<br>the current batch completes. It is now common for a single current CPU core to<br>be to able to issue enough transactions to keep the log buffers full and under<br>IO permanently. Hence the XFS journalling subsystem can be considered to be IO<br>bound.</p>
<h2 id="Delayed-Logging-Concepts"><a href="#Delayed-Logging-Concepts" class="headerlink" title="Delayed Logging: Concepts"></a>Delayed Logging: Concepts</h2><p>The key thing to note about the asynchronous logging combined with the<br>relogging technique XFS uses is that we can be relogging changed objects<br>multiple times before they are committed to disk in the log buffers. If we<br>return to the previous relogging example, it is entirely possible that<br>transactions A through D are committed to disk in the same log buffer.</p>
<p>That is, a single log buffer may contain multiple copies of the same object,<br>but only one of those copies needs to be there - the last one “D”, as it<br>contains all the changes from the previous changes. In other words, we have one<br>necessary copy in the log buffer, and three stale copies that are simply<br>wasting space. When we are doing repeated operations on the same set of<br>objects, these “stale objects” can be over 90% of the space used in the log<br>buffers. It is clear that reducing the number of stale objects written to the<br>log would greatly reduce the amount of metadata we write to the log, and this<br>is the fundamental goal of delayed logging.</p>
<p>From a conceptual point of view, XFS is already doing relogging in memory (where<br>memory == log buffer), only it is doing it extremely inefficiently. It is using<br>logical to physical formatting to do the relogging because there is no<br>infrastructure to keep track of logical changes in memory prior to physically<br>formatting the changes in a transaction to the log buffer. Hence we cannot avoid<br>accumulating stale objects in the log buffers.</p>
<p>Delayed logging is the name we’ve given to keeping and tracking transactional<br>changes to objects in memory outside the log buffer infrastructure. Because of<br>the relogging concept fundamental to the XFS journalling subsystem, this is<br>actually relatively easy to do - all the changes to logged items are already<br>tracked in the current infrastructure. The big problem is how to accumulate<br>them and get them to the log in a consistent, recoverable manner.<br>Describing the problems and how they have been solved is the focus of this<br>document.</p>
<p>One of the key changes that delayed logging makes to the operation of the<br>journalling subsystem is that it disassociates the amount of outstanding<br>metadata changes from the size and number of log buffers available. In other<br>words, instead of there only being a maximum of 2MB of transaction changes not<br>written to the log at any point in time, there may be a much greater amount<br>being accumulated in memory. Hence the potential for loss of metadata on a<br>crash is much greater than for the existing logging mechanism.</p>
<p>It should be noted that this does not change the guarantee that log recovery<br>will result in a consistent filesystem. What it does mean is that as far as the<br>recovered filesystem is concerned, there may be many thousands of transactions<br>that simply did not occur as a result of the crash. This makes it even more<br>important that applications that care about their data use fsync() where they<br>need to ensure application level data integrity is maintained.</p>
<p>It should be noted that delayed logging is not an innovative new concept that<br>warrants rigorous proofs to determine whether it is correct or not. The method<br>of accumulating changes in memory for some period before writing them to the<br>log is used effectively in many filesystems including ext3 and ext4. Hence<br>no time is spent in this document trying to convince the reader that the<br>concept is sound. Instead it is simply considered a “solved problem” and as<br>such implementing it in XFS is purely an exercise in software engineering.</p>
<p>The fundamental requirements for delayed logging in XFS are simple:</p>
<pre><code>1. Reduce the amount of metadata written to the log by at least
   an order of magnitude.
2. Supply sufficient statistics to validate Requirement #1.
3. Supply sufficient new tracing infrastructure to be able to debug
   problems with the new code.
4. No on-disk format change (metadata or log format).
5. Enable and disable with a mount option.
6. No performance regressions for synchronous transaction workloads.
</code></pre>
<h2 id="Delayed-Logging-Design"><a href="#Delayed-Logging-Design" class="headerlink" title="Delayed Logging: Design"></a>Delayed Logging: Design</h2><p>Storing Changes</p>
<p>The problem with accumulating changes at a logical level (i.e. just using the<br>existing log item dirty region tracking) is that when it comes to writing the<br>changes to the log buffers, we need to ensure that the object we are formatting<br>is not changing while we do this. This requires locking the object to prevent<br>concurrent modification. Hence flushing the logical changes to the log would<br>require us to lock every object, format them, and then unlock them again.</p>
<p>This introduces lots of scope for deadlocks with transactions that are already<br>running. For example, a transaction has object A locked and modified, but needs<br>the delayed logging tracking lock to commit the transaction. However, the<br>flushing thread has the delayed logging tracking lock already held, and is<br>trying to get the lock on object A to flush it to the log buffer. This appears<br>to be an unsolvable deadlock condition, and it was solving this problem that<br>was the barrier to implementing delayed logging for so long.</p>
<p>The solution is relatively simple - it just took a long time to recognise it.<br>Put simply, the current logging code formats the changes to each item into an<br>vector array that points to the changed regions in the item. The log write code<br>simply copies the memory these vectors point to into the log buffer during<br>transaction commit while the item is locked in the transaction. Instead of<br>using the log buffer as the destination of the formatting code, we can use an<br>allocated memory buffer big enough to fit the formatted vector.</p>
<p>If we then copy the vector into the memory buffer and rewrite the vector to<br>point to the memory buffer rather than the object itself, we now have a copy of<br>the changes in a format that is compatible with the log buffer writing code.<br>that does not require us to lock the item to access. This formatting and<br>rewriting can all be done while the object is locked during transaction commit,<br>resulting in a vector that is transactionally consistent and can be accessed<br>without needing to lock the owning item.</p>
<p>Hence we avoid the need to lock items when we need to flush outstanding<br>asynchronous transactions to the log. The differences between the existing<br>formatting method and the delayed logging formatting can be seen in the<br>diagram below.</p>
<p>Current format log vector:</p>
<p>Object    +———————————————+<br>Vector 1      +—-+<br>Vector 2                    +—-+<br>Vector 3                                   +———-+</p>
<p>After formatting:</p>
<p>Log Buffer    +-V1-+-V2-+—-V3—-+</p>
<p>Delayed logging vector:</p>
<p>Object    +———————————————+<br>Vector 1      +—-+<br>Vector 2                    +—-+<br>Vector 3                                   +———-+</p>
<p>After formatting:</p>
<p>Memory Buffer +-V1-+-V2-+—-V3—-+<br>Vector 1      +—-+<br>Vector 2           +—-+<br>Vector 3                +———-+</p>
<p>The memory buffer and associated vector need to be passed as a single object,<br>but still need to be associated with the parent object so if the object is<br>relogged we can replace the current memory buffer with a new memory buffer that<br>contains the latest changes.</p>
<p>The reason for keeping the vector around after we’ve formatted the memory<br>buffer is to support splitting vectors across log buffer boundaries correctly.<br>If we don’t keep the vector around, we do not know where the region boundaries<br>are in the item, so we’d need a new encapsulation method for regions in the log<br>buffer writing (i.e. double encapsulation). This would be an on-disk format<br>change and as such is not desirable.  It also means we’d have to write the log<br>region headers in the formatting stage, which is problematic as there is per<br>region state that needs to be placed into the headers during the log write.</p>
<p>Hence we need to keep the vector, but by attaching the memory buffer to it and<br>rewriting the vector addresses to point at the memory buffer we end up with a<br>self-describing object that can be passed to the log buffer write code to be<br>handled in exactly the same manner as the existing log vectors are handled.<br>Hence we avoid needing a new on-disk format to handle items that have been<br>relogged in memory.</p>
<p>Tracking Changes</p>
<p>Now that we can record transactional changes in memory in a form that allows<br>them to be used without limitations, we need to be able to track and accumulate<br>them so that they can be written to the log at some later point in time.  The<br>log item is the natural place to store this vector and buffer, and also makes sense<br>to be the object that is used to track committed objects as it will always<br>exist once the object has been included in a transaction.</p>
<p>The log item is already used to track the log items that have been written to<br>the log but not yet written to disk. Such log items are considered “active”<br>and as such are stored in the Active Item List (AIL) which is a LSN-ordered<br>double linked list. Items are inserted into this list during log buffer IO<br>completion, after which they are unpinned and can be written to disk. An object<br>that is in the AIL can be relogged, which causes the object to be pinned again<br>and then moved forward in the AIL when the log buffer IO completes for that<br>transaction.</p>
<p>Essentially, this shows that an item that is in the AIL can still be modified<br>and relogged, so any tracking must be separate to the AIL infrastructure. As<br>such, we cannot reuse the AIL list pointers for tracking committed items, nor<br>can we store state in any field that is protected by the AIL lock. Hence the<br>committed item tracking needs it’s own locks, lists and state fields in the log<br>item.</p>
<p>Similar to the AIL, tracking of committed items is done through a new list<br>called the Committed Item List (CIL).  The list tracks log items that have been<br>committed and have formatted memory buffers attached to them. It tracks objects<br>in transaction commit order, so when an object is relogged it is removed from<br>it’s place in the list and re-inserted at the tail. This is entirely arbitrary<br>and done to make it easy for debugging - the last items in the list are the<br>ones that are most recently modified. Ordering of the CIL is not necessary for<br>transactional integrity (as discussed in the next section) so the ordering is<br>done for convenience/sanity of the developers.</p>
<p>Delayed Logging: Checkpoints</p>
<p>When we have a log synchronisation event, commonly known as a “log force”,<br>all the items in the CIL must be written into the log via the log buffers.<br>We need to write these items in the order that they exist in the CIL, and they<br>need to be written as an atomic transaction. The need for all the objects to be<br>written as an atomic transaction comes from the requirements of relogging and<br>log replay - all the changes in all the objects in a given transaction must<br>either be completely replayed during log recovery, or not replayed at all. If<br>a transaction is not replayed because it is not complete in the log, then<br>no later transactions should be replayed, either.</p>
<p>To fulfill this requirement, we need to write the entire CIL in a single log<br>transaction. Fortunately, the XFS log code has no fixed limit on the size of a<br>transaction, nor does the log replay code. The only fundamental limit is that<br>the transaction cannot be larger than just under half the size of the log.  The<br>reason for this limit is that to find the head and tail of the log, there must<br>be at least one complete transaction in the log at any given time. If a<br>transaction is larger than half the log, then there is the possibility that a<br>crash during the write of a such a transaction could partially overwrite the<br>only complete previous transaction in the log. This will result in a recovery<br>failure and an inconsistent filesystem and hence we must enforce the maximum<br>size of a checkpoint to be slightly less than a half the log.</p>
<p>Apart from this size requirement, a checkpoint transaction looks no different<br>to any other transaction - it contains a transaction header, a series of<br>formatted log items and a commit record at the tail. From a recovery<br>perspective, the checkpoint transaction is also no different - just a lot<br>bigger with a lot more items in it. The worst case effect of this is that we<br>might need to tune the recovery transaction object hash size.</p>
<p>Because the checkpoint is just another transaction and all the changes to log<br>items are stored as log vectors, we can use the existing log buffer writing<br>code to write the changes into the log. To do this efficiently, we need to<br>minimise the time we hold the CIL locked while writing the checkpoint<br>transaction. The current log write code enables us to do this easily with the<br>way it separates the writing of the transaction contents (the log vectors) from<br>the transaction commit record, but tracking this requires us to have a<br>per-checkpoint context that travels through the log write process through to<br>checkpoint completion.</p>
<p>Hence a checkpoint has a context that tracks the state of the current<br>checkpoint from initiation to checkpoint completion. A new context is initiated<br>at the same time a checkpoint transaction is started. That is, when we remove<br>all the current items from the CIL during a checkpoint operation, we move all<br>those changes into the current checkpoint context. We then initialise a new<br>context and attach that to the CIL for aggregation of new transactions.</p>
<p>This allows us to unlock the CIL immediately after transfer of all the<br>committed items and effectively allow new transactions to be issued while we<br>are formatting the checkpoint into the log. It also allows concurrent<br>checkpoints to be written into the log buffers in the case of log force heavy<br>workloads, just like the existing transaction commit code does. This, however,<br>requires that we strictly order the commit records in the log so that<br>checkpoint sequence order is maintained during log replay.</p>
<p>To ensure that we can be writing an item into a checkpoint transaction at<br>the same time another transaction modifies the item and inserts the log item<br>into the new CIL, then checkpoint transaction commit code cannot use log items<br>to store the list of log vectors that need to be written into the transaction.<br>Hence log vectors need to be able to be chained together to allow them to be<br>detached from the log items. That is, when the CIL is flushed the memory<br>buffer and log vector attached to each log item needs to be attached to the<br>checkpoint context so that the log item can be released. In diagrammatic form,<br>the CIL would look like this before the flush:</p>
<pre><code>CIL Head
   |
   V
Log Item &lt;-&gt; log vector 1    -&gt; memory buffer
   |                -&gt; vector array
   V
Log Item &lt;-&gt; log vector 2    -&gt; memory buffer
   |                -&gt; vector array
   V
......
   |
   V
Log Item &lt;-&gt; log vector N-1    -&gt; memory buffer
   |                -&gt; vector array
   V
Log Item &lt;-&gt; log vector N    -&gt; memory buffer
                -&gt; vector array
</code></pre>
<p>And after the flush the CIL head is empty, and the checkpoint context log<br>vector list would look like:</p>
<pre><code>Checkpoint Context
   |
   V
log vector 1    -&gt; memory buffer
   |        -&gt; vector array
   |        -&gt; Log Item
   V
log vector 2    -&gt; memory buffer
   |        -&gt; vector array
   |        -&gt; Log Item
   V
......
   |
   V
log vector N-1    -&gt; memory buffer
   |        -&gt; vector array
   |        -&gt; Log Item
   V
log vector N    -&gt; memory buffer
        -&gt; vector array
        -&gt; Log Item
</code></pre>
<p>Once this transfer is done, the CIL can be unlocked and new transactions can<br>start, while the checkpoint flush code works over the log vector chain to<br>commit the checkpoint.</p>
<p>Once the checkpoint is written into the log buffers, the checkpoint context is<br>attached to the log buffer that the commit record was written to along with a<br>completion callback. Log IO completion will call that callback, which can then<br>run transaction committed processing for the log items (i.e. insert into AIL<br>and unpin) in the log vector chain and then free the log vector chain and<br>checkpoint context.</p>
<p>Discussion Point: I am uncertain as to whether the log item is the most<br>efficient way to track vectors, even though it seems like the natural way to do<br>it. The fact that we walk the log items (in the CIL) just to chain the log<br>vectors and break the link between the log item and the log vector means that<br>we take a cache line hit for the log item list modification, then another for<br>the log vector chaining. If we track by the log vectors, then we only need to<br>break the link between the log item and the log vector, which means we should<br>dirty only the log item cachelines. Normally I wouldn’t be concerned about one<br>vs two dirty cachelines except for the fact I’ve seen upwards of 80,000 log<br>vectors in one checkpoint transaction. I’d guess this is a “measure and<br>compare” situation that can be done after a working and reviewed implementation<br>is in the dev tree….</p>
<p>Delayed Logging: Checkpoint Sequencing</p>
<p>One of the key aspects of the XFS transaction subsystem is that it tags<br>committed transactions with the log sequence number of the transaction commit.<br>This allows transactions to be issued asynchronously even though there may be<br>future operations that cannot be completed until that transaction is fully<br>committed to the log. In the rare case that a dependent operation occurs (e.g.<br>re-using a freed metadata extent for a data extent), a special, optimised log<br>force can be issued to force the dependent transaction to disk immediately.</p>
<p>To do this, transactions need to record the LSN of the commit record of the<br>transaction. This LSN comes directly from the log buffer the transaction is<br>written into. While this works just fine for the existing transaction<br>mechanism, it does not work for delayed logging because transactions are not<br>written directly into the log buffers. Hence some other method of sequencing<br>transactions is required.</p>
<p>As discussed in the checkpoint section, delayed logging uses per-checkpoint<br>contexts, and as such it is simple to assign a sequence number to each<br>checkpoint. Because the switching of checkpoint contexts must be done<br>atomically, it is simple to ensure that each new context has a monotonically<br>increasing sequence number assigned to it without the need for an external<br>atomic counter - we can just take the current context sequence number and add<br>one to it for the new context.</p>
<p>Then, instead of assigning a log buffer LSN to the transaction commit LSN<br>during the commit, we can assign the current checkpoint sequence. This allows<br>operations that track transactions that have not yet completed know what<br>checkpoint sequence needs to be committed before they can continue. As a<br>result, the code that forces the log to a specific LSN now needs to ensure that<br>the log forces to a specific checkpoint.</p>
<p>To ensure that we can do this, we need to track all the checkpoint contexts<br>that are currently committing to the log. When we flush a checkpoint, the<br>context gets added to a “committing” list which can be searched. When a<br>checkpoint commit completes, it is removed from the committing list. Because<br>the checkpoint context records the LSN of the commit record for the checkpoint,<br>we can also wait on the log buffer that contains the commit record, thereby<br>using the existing log force mechanisms to execute synchronous forces.</p>
<p>It should be noted that the synchronous forces may need to be extended with<br>mitigation algorithms similar to the current log buffer code to allow<br>aggregation of multiple synchronous transactions if there are already<br>synchronous transactions being flushed. Investigation of the performance of the<br>current design is needed before making any decisions here.</p>
<p>The main concern with log forces is to ensure that all the previous checkpoints<br>are also committed to disk before the one we need to wait for. Therefore we<br>need to check that all the prior contexts in the committing list are also<br>complete before waiting on the one we need to complete. We do this<br>synchronisation in the log force code so that we don’t need to wait anywhere<br>else for such serialisation - it only matters when we do a log force.</p>
<p>The only remaining complexity is that a log force now also has to handle the<br>case where the forcing sequence number is the same as the current context. That<br>is, we need to flush the CIL and potentially wait for it to complete. This is a<br>simple addition to the existing log forcing code to check the sequence numbers<br>and push if required. Indeed, placing the current sequence checkpoint flush in<br>the log force code enables the current mechanism for issuing synchronous<br>transactions to remain untouched (i.e. commit an asynchronous transaction, then<br>force the log at the LSN of that transaction) and so the higher level code<br>behaves the same regardless of whether delayed logging is being used or not.</p>
<p>Delayed Logging: Checkpoint Log Space Accounting</p>
<p>The big issue for a checkpoint transaction is the log space reservation for the<br>transaction. We don’t know how big a checkpoint transaction is going to be<br>ahead of time, nor how many log buffers it will take to write out, nor the<br>number of split log vector regions are going to be used. We can track the<br>amount of log space required as we add items to the commit item list, but we<br>still need to reserve the space in the log for the checkpoint.</p>
<p>A typical transaction reserves enough space in the log for the worst case space<br>usage of the transaction. The reservation accounts for log record headers,<br>transaction and region headers, headers for split regions, buffer tail padding,<br>etc. as well as the actual space for all the changed metadata in the<br>transaction. While some of this is fixed overhead, much of it is dependent on<br>the size of the transaction and the number of regions being logged (the number<br>of log vectors in the transaction).</p>
<p>An example of the differences would be logging directory changes versus logging<br>inode changes. If you modify lots of inode cores (e.g. chmod -R g+w *), then<br>there are lots of transactions that only contain an inode core and an inode log<br>format structure. That is, two vectors totaling roughly 150 bytes. If we modify<br>10,000 inodes, we have about 1.5MB of metadata to write in 20,000 vectors. Each<br>vector is 12 bytes, so the total to be logged is approximately 1.75MB. In<br>comparison, if we are logging full directory buffers, they are typically 4KB<br>each, so we in 1.5MB of directory buffers we’d have roughly 400 buffers and a<br>buffer format structure for each buffer - roughly 800 vectors or 1.51MB total<br>space.  From this, it should be obvious that a static log space reservation is<br>not particularly flexible and is difficult to select the “optimal value” for<br>all workloads.</p>
<p>Further, if we are going to use a static reservation, which bit of the entire<br>reservation does it cover? We account for space used by the transaction<br>reservation by tracking the space currently used by the object in the CIL and<br>then calculating the increase or decrease in space used as the object is<br>relogged. This allows for a checkpoint reservation to only have to account for<br>log buffer metadata used such as log header records.</p>
<p>However, even using a static reservation for just the log metadata is<br>problematic. Typically log record headers use at least 16KB of log space per<br>1MB of log space consumed (512 bytes per 32k) and the reservation needs to be<br>large enough to handle arbitrary sized checkpoint transactions. This<br>reservation needs to be made before the checkpoint is started, and we need to<br>be able to reserve the space without sleeping.  For a 8MB checkpoint, we need a<br>reservation of around 150KB, which is a non-trivial amount of space.</p>
<p>A static reservation needs to manipulate the log grant counters - we can take a<br>permanent reservation on the space, but we still need to make sure we refresh<br>the write reservation (the actual space available to the transaction) after<br>every checkpoint transaction completion. Unfortunately, if this space is not<br>available when required, then the regrant code will sleep waiting for it.</p>
<p>The problem with this is that it can lead to deadlocks as we may need to commit<br>checkpoints to be able to free up log space (refer back to the description of<br>rolling transactions for an example of this).  Hence we <em>must</em> always have<br>space available in the log if we are to use static reservations, and that is<br>very difficult and complex to arrange. It is possible to do, but there is a<br>simpler way.</p>
<p>The simpler way of doing this is tracking the entire log space used by the<br>items in the CIL and using this to dynamically calculate the amount of log<br>space required by the log metadata. If this log metadata space changes as a<br>result of a transaction commit inserting a new memory buffer into the CIL, then<br>the difference in space required is removed from the transaction that causes<br>the change. Transactions at this level will <em>always</em> have enough space<br>available in their reservation for this as they have already reserved the<br>maximal amount of log metadata space they require, and such a delta reservation<br>will always be less than or equal to the maximal amount in the reservation.</p>
<p>Hence we can grow the checkpoint transaction reservation dynamically as items<br>are added to the CIL and avoid the need for reserving and regranting log space<br>up front. This avoids deadlocks and removes a blocking point from the<br>checkpoint flush code.</p>
<p>As mentioned early, transactions can’t grow to more than half the size of the<br>log. Hence as part of the reservation growing, we need to also check the size<br>of the reservation against the maximum allowed transaction size. If we reach<br>the maximum threshold, we need to push the CIL to the log. This is effectively<br>a “background flush” and is done on demand. This is identical to<br>a CIL push triggered by a log force, only that there is no waiting for the<br>checkpoint commit to complete. This background push is checked and executed by<br>transaction commit code.</p>
<p>If the transaction subsystem goes idle while we still have items in the CIL,<br>they will be flushed by the periodic log force issued by the xfssyncd. This log<br>force will push the CIL to disk, and if the transaction subsystem stays idle,<br>allow the idle log to be covered (effectively marked clean) in exactly the same<br>manner that is done for the existing logging method. A discussion point is<br>whether this log force needs to be done more frequently than the current rate<br>which is once every 30s.</p>
<p>Delayed Logging: Log Item Pinning</p>
<p>Currently log items are pinned during transaction commit while the items are<br>still locked. This happens just after the items are formatted, though it could<br>be done any time before the items are unlocked. The result of this mechanism is<br>that items get pinned once for every transaction that is committed to the log<br>buffers. Hence items that are relogged in the log buffers will have a pin count<br>for every outstanding transaction they were dirtied in. When each of these<br>transactions is completed, they will unpin the item once. As a result, the item<br>only becomes unpinned when all the transactions complete and there are no<br>pending transactions. Thus the pinning and unpinning of a log item is symmetric<br>as there is a 1:1 relationship with transaction commit and log item completion.</p>
<p>For delayed logging, however, we have an asymmetric transaction commit to<br>completion relationship. Every time an object is relogged in the CIL it goes<br>through the commit process without a corresponding completion being registered.<br>That is, we now have a many-to-one relationship between transaction commit and<br>log item completion. The result of this is that pinning and unpinning of the<br>log items becomes unbalanced if we retain the “pin on transaction commit, unpin<br>on transaction completion” model.</p>
<p>To keep pin/unpin symmetry, the algorithm needs to change to a “pin on<br>insertion into the CIL, unpin on checkpoint completion”. In other words, the<br>pinning and unpinning becomes symmetric around a checkpoint context. We have to<br>pin the object the first time it is inserted into the CIL - if it is already in<br>the CIL during a transaction commit, then we do not pin it again. Because there<br>can be multiple outstanding checkpoint contexts, we can still see elevated pin<br>counts, but as each checkpoint completes the pin count will retain the correct<br>value according to it’s context.</p>
<p>Just to make matters more slightly more complex, this checkpoint level context<br>for the pin count means that the pinning of an item must take place under the<br>CIL commit/flush lock. If we pin the object outside this lock, we cannot<br>guarantee which context the pin count is associated with. This is because of<br>the fact pinning the item is dependent on whether the item is present in the<br>current CIL or not. If we don’t pin the CIL first before we check and pin the<br>object, we have a race with CIL being flushed between the check and the pin<br>(or not pinning, as the case may be). Hence we must hold the CIL flush/commit<br>lock to guarantee that we pin the items correctly.</p>
<p>Delayed Logging: Concurrent Scalability</p>
<p>A fundamental requirement for the CIL is that accesses through transaction<br>commits must scale to many concurrent commits. The current transaction commit<br>code does not break down even when there are transactions coming from 2048<br>processors at once. The current transaction code does not go any faster than if<br>there was only one CPU using it, but it does not slow down either.</p>
<p>As a result, the delayed logging transaction commit code needs to be designed<br>for concurrency from the ground up. It is obvious that there are serialisation<br>points in the design - the three important ones are:</p>
<pre><code>1. Locking out new transaction commits while flushing the CIL
2. Adding items to the CIL and updating item space accounting
3. Checkpoint commit ordering
</code></pre>
<p>Looking at the transaction commit and CIL flushing interactions, it is clear<br>that we have a many-to-one interaction here. That is, the only restriction on<br>the number of concurrent transactions that can be trying to commit at once is<br>the amount of space available in the log for their reservations. The practical<br>limit here is in the order of several hundred concurrent transactions for a<br>128MB log, which means that it is generally one per CPU in a machine.</p>
<p>The amount of time a transaction commit needs to hold out a flush is a<br>relatively long period of time - the pinning of log items needs to be done<br>while we are holding out a CIL flush, so at the moment that means it is held<br>across the formatting of the objects into memory buffers (i.e. while memcpy()s<br>are in progress). Ultimately a two pass algorithm where the formatting is done<br>separately to the pinning of objects could be used to reduce the hold time of<br>the transaction commit side.</p>
<p>Because of the number of potential transaction commit side holders, the lock<br>really needs to be a sleeping lock - if the CIL flush takes the lock, we do not<br>want every other CPU in the machine spinning on the CIL lock. Given that<br>flushing the CIL could involve walking a list of tens of thousands of log<br>items, it will get held for a significant time and so spin contention is a<br>significant concern. Preventing lots of CPUs spinning doing nothing is the<br>main reason for choosing a sleeping lock even though nothing in either the<br>transaction commit or CIL flush side sleeps with the lock held.</p>
<p>It should also be noted that CIL flushing is also a relatively rare operation<br>compared to transaction commit for asynchronous transaction workloads - only<br>time will tell if using a read-write semaphore for exclusion will limit<br>transaction commit concurrency due to cache line bouncing of the lock on the<br>read side.</p>
<p>The second serialisation point is on the transaction commit side where items<br>are inserted into the CIL. Because transactions can enter this code<br>concurrently, the CIL needs to be protected separately from the above<br>commit/flush exclusion. It also needs to be an exclusive lock but it is only<br>held for a very short time and so a spin lock is appropriate here. It is<br>possible that this lock will become a contention point, but given the short<br>hold time once per transaction I think that contention is unlikely.</p>
<p>The final serialisation point is the checkpoint commit record ordering code<br>that is run as part of the checkpoint commit and log force sequencing. The code<br>path that triggers a CIL flush (i.e. whatever triggers the log force) will enter<br>an ordering loop after writing all the log vectors into the log buffers but<br>before writing the commit record. This loop walks the list of committing<br>checkpoints and needs to block waiting for checkpoints to complete their commit<br>record write. As a result it needs a lock and a wait variable. Log force<br>sequencing also requires the same lock, list walk, and blocking mechanism to<br>ensure completion of checkpoints.</p>
<p>These two sequencing operations can use the mechanism even though the<br>events they are waiting for are different. The checkpoint commit record<br>sequencing needs to wait until checkpoint contexts contain a commit LSN<br>(obtained through completion of a commit record write) while log force<br>sequencing needs to wait until previous checkpoint contexts are removed from<br>the committing list (i.e. they’ve completed). A simple wait variable and<br>broadcast wakeups (thundering herds) has been used to implement these two<br>serialisation queues. They use the same lock as the CIL, too. If we see too<br>much contention on the CIL lock, or too many context switches as a result of<br>the broadcast wakeups these operations can be put under a new spinlock and<br>given separate wait lists to reduce lock contention and the number of processes<br>woken by the wrong event.</p>
<p>Lifecycle Changes</p>
<p>The existing log item life cycle is as follows:</p>
<pre><code>1. Transaction allocate
2. Transaction reserve
3. Lock item
4. Join item to transaction
    If not already attached,
        Allocate log item
        Attach log item to owner item
    Attach log item to transaction
5. Modify item
    Record modifications in log item
6. Transaction commit
    Pin item in memory
    Format item into log buffer
    Write commit LSN into transaction
    Unlock item
    Attach transaction to log buffer

&lt;log buffer IO dispatched&gt;
&lt;log buffer IO completes&gt;

7. Transaction completion
    Mark log item committed
    Insert log item into AIL
        Write commit LSN into log item
    Unpin log item
8. AIL traversal
    Lock item
    Mark log item clean
    Flush item to disk

&lt;item IO completion&gt;

9. Log item removed from AIL
    Moves log tail
    Item unlocked
</code></pre>
<p>Essentially, steps 1-6 operate independently from step 7, which is also<br>independent of steps 8-9. An item can be locked in steps 1-6 or steps 8-9<br>at the same time step 7 is occurring, but only steps 1-6 or 8-9 can occur<br>at the same time. If the log item is in the AIL or between steps 6 and 7<br>and steps 1-6 are re-entered, then the item is relogged. Only when steps 8-9<br>are entered and completed is the object considered clean.</p>
<p>With delayed logging, there are new steps inserted into the life cycle:</p>
<pre><code>1. Transaction allocate
2. Transaction reserve
3. Lock item
4. Join item to transaction
    If not already attached,
        Allocate log item
        Attach log item to owner item
    Attach log item to transaction
5. Modify item
    Record modifications in log item
6. Transaction commit
    Pin item in memory if not pinned in CIL
    Format item into log vector + buffer
    Attach log vector and buffer to log item
    Insert log item into CIL
    Write CIL context sequence into transaction
    Unlock item

&lt;next log force&gt;

7. CIL push
    lock CIL flush
    Chain log vectors and buffers together
    Remove items from CIL
    unlock CIL flush
    write log vectors into log
    sequence commit records
    attach checkpoint context to log buffer

&lt;log buffer IO dispatched&gt;
&lt;log buffer IO completes&gt;

8. Checkpoint completion
    Mark log item committed
    Insert item into AIL
        Write commit LSN into log item
    Unpin log item
9. AIL traversal
    Lock item
    Mark log item clean
    Flush item to disk
&lt;item IO completion&gt;
10. Log item removed from AIL
    Moves log tail
    Item unlocked
</code></pre>
<p>From this, it can be seen that the only life cycle differences between the two<br>logging methods are in the middle of the life cycle - they still have the same<br>beginning and end and execution constraints. The only differences are in the<br>committing of the log items to the log itself and the completion processing.<br>Hence delayed logging should not introduce any constraints on log item<br>behaviour, allocation or freeing that don’t already exist.</p>
<p>As a result of this zero-impact “insertion” of delayed logging infrastructure<br>and the design of the internal structures to avoid on disk format changes, we<br>can basically switch between delayed logging and the existing mechanism with a<br>mount option. Fundamentally, there is no reason why the log manager would not<br>be able to swap methods automatically and transparently depending on load<br>characteristics, but this should not be necessary if delayed logging works as<br>designed.</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_xfs-delayed-logging-design/" title="Kernel-3.10.0-957.el7_xfs-delayed-logging-design" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_xfs-delayed-logging-design/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_biodoc/" title="Kernel-3.10.0-957.el7_biodoc"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_whatisRCU/" title="Kernel-3.10.0-957.el7_whatisRCU"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>