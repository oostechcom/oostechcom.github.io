<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-2.6.32-573.12.1.el6_rt-mutex-design | oosTech.com</title>
  <meta name="description" content="Copyright (c) 2006 Steven RostedtLicensed under the GNU Free Documentation License, Version 1.2RT-mutex implementation designThis document tries to describe the design of the rtmutex.c implementation.">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-2.6.32-573.12.1.el6_rt-mutex-design">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_rt-mutex-design/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="Copyright (c) 2006 Steven RostedtLicensed under the GNU Free Documentation License, Version 1.2RT-mutex implementation designThis document tries to describe the design of the rtmutex.c implementation.">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_rt-mutex-design/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Copyright-c-2006-Steven-Rostedt"><span class="toc-number">2.</span> <span class="toc-text">Copyright (c) 2006 Steven Rostedt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Licensed-under-the-GNU-Free-Documentation-License-Version-1-2"><span class="toc-number">3.</span> <span class="toc-text">Licensed under the GNU Free Documentation License, Version 1.2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#-1"><span class="toc-number">4.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RT-mutex-implementation-design"><span class="toc-number">4.1.</span> <span class="toc-text">RT-mutex implementation design</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unbounded-Priority-Inversion"><span class="toc-number">4.2.</span> <span class="toc-text">Unbounded Priority Inversion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Priority-Inheritance-PI"><span class="toc-number">4.3.</span> <span class="toc-text">Priority Inheritance (PI)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Terminology"><span class="toc-number">4.4.</span> <span class="toc-text">Terminology</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PI-chain"><span class="toc-number">4.5.</span> <span class="toc-text">PI chain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Plist"><span class="toc-number">4.6.</span> <span class="toc-text">Plist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mutex-Waiter-List"><span class="toc-number">4.7.</span> <span class="toc-text">Mutex Waiter List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Task-PI-List"><span class="toc-number">4.8.</span> <span class="toc-text">Task PI List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Depth-of-the-PI-Chain"><span class="toc-number">4.9.</span> <span class="toc-text">Depth of the PI Chain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mutex-owner-and-flags"><span class="toc-number">4.10.</span> <span class="toc-text">Mutex owner and flags</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cmpxchg-Tricks"><span class="toc-number">4.11.</span> <span class="toc-text">cmpxchg Tricks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Priority-adjustments"><span class="toc-number">4.12.</span> <span class="toc-text">Priority adjustments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#High-level-overview-of-the-PI-chain-walk"><span class="toc-number">4.13.</span> <span class="toc-text">High level overview of the PI chain walk</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pending-Owners-and-Lock-stealing"><span class="toc-number">4.14.</span> <span class="toc-text">Pending Owners and Lock stealing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Taking-of-a-mutex-The-walk-through"><span class="toc-number">4.15.</span> <span class="toc-text">Taking of a mutex (The walk through)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Task-blocks-on-mutex"><span class="toc-number">4.16.</span> <span class="toc-text">Task blocks on mutex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Waking-up-in-the-loop"><span class="toc-number">4.17.</span> <span class="toc-text">Waking up in the loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Failed-to-get-mutex-on-Timeout-or-Signal"><span class="toc-number">4.18.</span> <span class="toc-text">Failed to get mutex on Timeout or Signal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unlocking-the-Mutex"><span class="toc-number">4.19.</span> <span class="toc-text">Unlocking the Mutex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Contact"><span class="toc-number">4.20.</span> <span class="toc-text">Contact</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Credits"><span class="toc-number">4.21.</span> <span class="toc-text">Credits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Updates"><span class="toc-number">4.22.</span> <span class="toc-text">Updates</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-2.6.32-573.12.1.el6_rt-mutex-design" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-2.6.32-573.12.1.el6_rt-mutex-design
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_rt-mutex-design/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_rt-mutex-design/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_rt-mutex-design/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="Copyright-c-2006-Steven-Rostedt"><a href="#Copyright-c-2006-Steven-Rostedt" class="headerlink" title="Copyright (c) 2006 Steven Rostedt"></a>Copyright (c) 2006 Steven Rostedt</h1><h1 id="Licensed-under-the-GNU-Free-Documentation-License-Version-1-2"><a href="#Licensed-under-the-GNU-Free-Documentation-License-Version-1-2" class="headerlink" title="Licensed under the GNU Free Documentation License, Version 1.2"></a>Licensed under the GNU Free Documentation License, Version 1.2</h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h2 id="RT-mutex-implementation-design"><a href="#RT-mutex-implementation-design" class="headerlink" title="RT-mutex implementation design"></a>RT-mutex implementation design</h2><p>This document tries to describe the design of the rtmutex.c implementation.<br>It doesn’t describe the reasons why rtmutex.c exists. For that please see<br>Documentation/rt-mutex.txt.  Although this document does explain problems<br>that happen without this code, but that is in the concept to understand<br>what the code actually is doing.</p>
<p>The goal of this document is to help others understand the priority<br>inheritance (PI) algorithm that is used, as well as reasons for the<br>decisions that were made to implement PI in the manner that was done.</p>
<h2 id="Unbounded-Priority-Inversion"><a href="#Unbounded-Priority-Inversion" class="headerlink" title="Unbounded Priority Inversion"></a>Unbounded Priority Inversion</h2><p>Priority inversion is when a lower priority process executes while a higher<br>priority process wants to run.  This happens for several reasons, and<br>most of the time it can’t be helped.  Anytime a high priority process wants<br>to use a resource that a lower priority process has (a mutex for example),<br>the high priority process must wait until the lower priority process is done<br>with the resource.  This is a priority inversion.  What we want to prevent<br>is something called unbounded priority inversion.  That is when the high<br>priority process is prevented from running by a lower priority process for<br>an undetermined amount of time.</p>
<p>The classic example of unbounded priority inversion is were you have three<br>processes, let’s call them processes A, B, and C, where A is the highest<br>priority process, C is the lowest, and B is in between. A tries to grab a lock<br>that C owns and must wait and lets C run to release the lock. But in the<br>meantime, B executes, and since B is of a higher priority than C, it preempts C,<br>but by doing so, it is in fact preempting A which is a higher priority process.<br>Now there’s no way of knowing how long A will be sleeping waiting for C<br>to release the lock, because for all we know, B is a CPU hog and will<br>never give C a chance to release the lock.  This is called unbounded priority<br>inversion.</p>
<p>Here’s a little ASCII art to show the problem.</p>
<p>   grab lock L1 (owned by C)<br>     |<br>A —+<br>        C preempted by B<br>          |<br>C    +—-+</p>
<p>B         +——–&gt;<br>                B now keeps A from running.</p>
<h2 id="Priority-Inheritance-PI"><a href="#Priority-Inheritance-PI" class="headerlink" title="Priority Inheritance (PI)"></a>Priority Inheritance (PI)</h2><p>There are several ways to solve this issue, but other ways are out of scope<br>for this document.  Here we only discuss PI.</p>
<p>PI is where a process inherits the priority of another process if the other<br>process blocks on a lock owned by the current process.  To make this easier<br>to understand, let’s use the previous example, with processes A, B, and C again.</p>
<p>This time, when A blocks on the lock owned by C, C would inherit the priority<br>of A.  So now if B becomes runnable, it would not preempt C, since C now has<br>the high priority of A.  As soon as C releases the lock, it loses its<br>inherited priority, and A then can continue with the resource that C had.</p>
<h2 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h2><p>Here I explain some terminology that is used in this document to help describe<br>the design that is used to implement PI.</p>
<p>PI chain - The PI chain is an ordered series of locks and processes that cause<br>           processes to inherit priorities from a previous process that is<br>           blocked on one of its locks.  This is described in more detail<br>           later in this document.</p>
<p>mutex    - In this document, to differentiate from locks that implement<br>           PI and spin locks that are used in the PI code, from now on<br>           the PI locks will be called a mutex.</p>
<p>lock     - In this document from now on, I will use the term lock when<br>           referring to spin locks that are used to protect parts of the PI<br>           algorithm.  These locks disable preemption for UP (when<br>           CONFIG_PREEMPT is enabled) and on SMP prevents multiple CPUs from<br>           entering critical sections simultaneously.</p>
<p>spin lock - Same as lock above.</p>
<p>waiter   - A waiter is a struct that is stored on the stack of a blocked<br>           process.  Since the scope of the waiter is within the code for<br>           a process being blocked on the mutex, it is fine to allocate<br>           the waiter on the process’s stack (local variable).  This<br>           structure holds a pointer to the task, as well as the mutex that<br>           the task is blocked on.  It also has the plist node structures to<br>           place the task in the waiter_list of a mutex as well as the<br>           pi_list of a mutex owner task (described below).</p>
<pre><code>       waiter is sometimes used in reference to the task that is waiting
       on a mutex. This is the same as waiter-&gt;task.
</code></pre>
<p>waiters  - A list of processes that are blocked on a mutex.</p>
<p>top waiter - The highest priority process waiting on a specific mutex.</p>
<p>top pi waiter - The highest priority process waiting on one of the mutexes<br>                that a specific process owns.</p>
<p>Note:  task and process are used interchangeably in this document, mostly to<br>       differentiate between two processes that are being described together.</p>
<h2 id="PI-chain"><a href="#PI-chain" class="headerlink" title="PI chain"></a>PI chain</h2><p>The PI chain is a list of processes and mutexes that may cause priority<br>inheritance to take place.  Multiple chains may converge, but a chain<br>would never diverge, since a process can’t be blocked on more than one<br>mutex at a time.</p>
<p>Example:</p>
<p>   Process:  A, B, C, D, E<br>   Mutexes:  L1, L2, L3, L4</p>
<p>   A owns: L1<br>           B blocked on L1<br>           B owns L2<br>                  C blocked on L2<br>                  C owns L3<br>                         D blocked on L3<br>                         D owns L4<br>                                E blocked on L4</p>
<p>The chain would be:</p>
<p>   E-&gt;L4-&gt;D-&gt;L3-&gt;C-&gt;L2-&gt;B-&gt;L1-&gt;A</p>
<p>To show where two chains merge, we could add another process F and<br>another mutex L5 where B owns L5 and F is blocked on mutex L5.</p>
<p>The chain for F would be:</p>
<p>   F-&gt;L5-&gt;B-&gt;L1-&gt;A</p>
<p>Since a process may own more than one mutex, but never be blocked on more than<br>one, the chains merge.</p>
<p>Here we show both chains:</p>
<p>   E-&gt;L4-&gt;D-&gt;L3-&gt;C-&gt;L2-+<br>                       |<br>                       +-&gt;B-&gt;L1-&gt;A<br>                       |<br>                 F-&gt;L5-+</p>
<p>For PI to work, the processes at the right end of these chains (or we may<br>also call it the Top of the chain) must be equal to or higher in priority<br>than the processes to the left or below in the chain.</p>
<p>Also since a mutex may have more than one process blocked on it, we can<br>have multiple chains merge at mutexes.  If we add another process G that is<br>blocked on mutex L2:</p>
<p>  G-&gt;L2-&gt;B-&gt;L1-&gt;A</p>
<p>And once again, to show how this can grow I will show the merging chains<br>again.</p>
<p>   E-&gt;L4-&gt;D-&gt;L3-&gt;C-+<br>                   +-&gt;L2-+<br>                   |     |<br>                 G-+     +-&gt;B-&gt;L1-&gt;A<br>                         |<br>                   F-&gt;L5-+</p>
<h2 id="Plist"><a href="#Plist" class="headerlink" title="Plist"></a>Plist</h2><p>Before I go further and talk about how the PI chain is stored through lists<br>on both mutexes and processes, I’ll explain the plist.  This is similar to<br>the struct list_head functionality that is already in the kernel.<br>The implementation of plist is out of scope for this document, but it is<br>very important to understand what it does.</p>
<p>There are a few differences between plist and list, the most important one<br>being that plist is a priority sorted linked list.  This means that the<br>priorities of the plist are sorted, such that it takes O(1) to retrieve the<br>highest priority item in the list.  Obviously this is useful to store processes<br>based on their priorities.</p>
<p>Another difference, which is important for implementation, is that, unlike<br>list, the head of the list is a different element than the nodes of a list.<br>So the head of the list is declared as struct plist_head and nodes that will<br>be added to the list are declared as struct plist_node.</p>
<h2 id="Mutex-Waiter-List"><a href="#Mutex-Waiter-List" class="headerlink" title="Mutex Waiter List"></a>Mutex Waiter List</h2><p>Every mutex keeps track of all the waiters that are blocked on itself. The mutex<br>has a plist to store these waiters by priority.  This list is protected by<br>a spin lock that is located in the struct of the mutex. This lock is called<br>wait_lock.  Since the modification of the waiter list is never done in<br>interrupt context, the wait_lock can be taken without disabling interrupts.</p>
<h2 id="Task-PI-List"><a href="#Task-PI-List" class="headerlink" title="Task PI List"></a>Task PI List</h2><p>To keep track of the PI chains, each process has its own PI list.  This is<br>a list of all top waiters of the mutexes that are owned by the process.<br>Note that this list only holds the top waiters and not all waiters that are<br>blocked on mutexes owned by the process.</p>
<p>The top of the task’s PI list is always the highest priority task that<br>is waiting on a mutex that is owned by the task.  So if the task has<br>inherited a priority, it will always be the priority of the task that is<br>at the top of this list.</p>
<p>This list is stored in the task structure of a process as a plist called<br>pi_list.  This list is protected by a spin lock also in the task structure,<br>called pi_lock.  This lock may also be taken in interrupt context, so when<br>locking the pi_lock, interrupts must be disabled.</p>
<h2 id="Depth-of-the-PI-Chain"><a href="#Depth-of-the-PI-Chain" class="headerlink" title="Depth of the PI Chain"></a>Depth of the PI Chain</h2><p>The maximum depth of the PI chain is not dynamic, and could actually be<br>defined.  But is very complex to figure it out, since it depends on all<br>the nesting of mutexes.  Let’s look at the example where we have 3 mutexes,<br>L1, L2, and L3, and four separate functions func1, func2, func3 and func4.<br>The following shows a locking order of L1-&gt;L2-&gt;L3, but may not actually<br>be directly nested that way.</p>
<p>void func1(void)<br>{<br>    mutex_lock(L1);</p>
<pre><code>/* do anything */

mutex_unlock(L1);
</code></pre>
<p>}</p>
<p>void func2(void)<br>{<br>    mutex_lock(L1);<br>    mutex_lock(L2);</p>
<pre><code>/* do something */

mutex_unlock(L2);
mutex_unlock(L1);
</code></pre>
<p>}</p>
<p>void func3(void)<br>{<br>    mutex_lock(L2);<br>    mutex_lock(L3);</p>
<pre><code>/* do something else */

mutex_unlock(L3);
mutex_unlock(L2);
</code></pre>
<p>}</p>
<p>void func4(void)<br>{<br>    mutex_lock(L3);</p>
<pre><code>/* do something again */

mutex_unlock(L3);
</code></pre>
<p>}</p>
<p>Now we add 4 processes that run each of these functions separately.<br>Processes A, B, C, and D which run functions func1, func2, func3 and func4<br>respectively, and such that D runs first and A last.  With D being preempted<br>in func4 in the “do something again” area, we have a locking that follows:</p>
<p>D owns L3<br>       C blocked on L3<br>       C owns L2<br>              B blocked on L2<br>              B owns L1<br>                     A blocked on L1</p>
<p>And thus we have the chain A-&gt;L1-&gt;B-&gt;L2-&gt;C-&gt;L3-&gt;D.</p>
<p>This gives us a PI depth of 4 (four processes), but looking at any of the<br>functions individually, it seems as though they only have at most a locking<br>depth of two.  So, although the locking depth is defined at compile time,<br>it still is very difficult to find the possibilities of that depth.</p>
<p>Now since mutexes can be defined by user-land applications, we don’t want a DOS<br>type of application that nests large amounts of mutexes to create a large<br>PI chain, and have the code holding spin locks while looking at a large<br>amount of data.  So to prevent this, the implementation not only implements<br>a maximum lock depth, but also only holds at most two different locks at a<br>time, as it walks the PI chain.  More about this below.</p>
<h2 id="Mutex-owner-and-flags"><a href="#Mutex-owner-and-flags" class="headerlink" title="Mutex owner and flags"></a>Mutex owner and flags</h2><p>The mutex structure contains a pointer to the owner of the mutex.  If the<br>mutex is not owned, this owner is set to NULL.  Since all architectures<br>have the task structure on at least a four byte alignment (and if this is<br>not true, the rtmutex.c code will be broken!), this allows for the two<br>least significant bits to be used as flags.  This part is also described<br>in Documentation/rt-mutex.txt, but will also be briefly described here.</p>
<p>Bit 0 is used as the “Pending Owner” flag.  This is described later.<br>Bit 1 is used as the “Has Waiters” flags.  This is also described later<br>  in more detail, but is set whenever there are waiters on a mutex.</p>
<h2 id="cmpxchg-Tricks"><a href="#cmpxchg-Tricks" class="headerlink" title="cmpxchg Tricks"></a>cmpxchg Tricks</h2><p>Some architectures implement an atomic cmpxchg (Compare and Exchange).  This<br>is used (when applicable) to keep the fast path of grabbing and releasing<br>mutexes short.</p>
<p>cmpxchg is basically the following function performed atomically:</p>
<p>unsigned long _cmpxchg(unsigned long *A, unsigned long *B, unsigned long *C)<br>{<br>    unsigned long T = *A;<br>    if (*A == *B) {<br>        *A = *C;<br>    }<br>    return T;<br>}<br>#define cmpxchg(a,b,c) _cmpxchg(&amp;a,&amp;b,&amp;c)</p>
<p>This is really nice to have, since it allows you to only update a variable<br>if the variable is what you expect it to be.  You know if it succeeded if<br>the return value (the old value of A) is equal to B.</p>
<p>The macro rt_mutex_cmpxchg is used to try to lock and unlock mutexes. If<br>the architecture does not support CMPXCHG, then this macro is simply set<br>to fail every time.  But if CMPXCHG is supported, then this will<br>help out extremely to keep the fast path short.</p>
<p>The use of rt_mutex_cmpxchg with the flags in the owner field help optimize<br>the system for architectures that support it.  This will also be explained<br>later in this document.</p>
<h2 id="Priority-adjustments"><a href="#Priority-adjustments" class="headerlink" title="Priority adjustments"></a>Priority adjustments</h2><p>The implementation of the PI code in rtmutex.c has several places that a<br>process must adjust its priority.  With the help of the pi_list of a<br>process this is rather easy to know what needs to be adjusted.</p>
<p>The functions implementing the task adjustments are rt_mutex_adjust_prio,<br>__rt_mutex_adjust_prio (same as the former, but expects the task pi_lock<br>to already be taken), rt_mutex_get_prio, and rt_mutex_setprio.</p>
<p>rt_mutex_getprio and rt_mutex_setprio are only used in __rt_mutex_adjust_prio.</p>
<p>rt_mutex_getprio returns the priority that the task should have.  Either the<br>task’s own normal priority, or if a process of a higher priority is waiting on<br>a mutex owned by the task, then that higher priority should be returned.<br>Since the pi_list of a task holds an order by priority list of all the top<br>waiters of all the mutexes that the task owns, rt_mutex_getprio simply needs<br>to compare the top pi waiter to its own normal priority, and return the higher<br>priority back.</p>
<p>(Note:  if looking at the code, you will notice that the lower number of<br>        prio is returned.  This is because the prio field in the task structure<br>        is an inverse order of the actual priority.  So a “prio” of 5 is<br>        of higher priority than a “prio” of 10.)</p>
<p>__rt_mutex_adjust_prio examines the result of rt_mutex_getprio, and if the<br>result does not equal the task’s current priority, then rt_mutex_setprio<br>is called to adjust the priority of the task to the new priority.<br>Note that rt_mutex_setprio is defined in kernel/sched.c to implement the<br>actual change in priority.</p>
<p>It is interesting to note that __rt_mutex_adjust_prio can either increase<br>or decrease the priority of the task.  In the case that a higher priority<br>process has just blocked on a mutex owned by the task, __rt_mutex_adjust_prio<br>would increase/boost the task’s priority.  But if a higher priority task<br>were for some reason to leave the mutex (timeout or signal), this same function<br>would decrease/unboost the priority of the task.  That is because the pi_list<br>always contains the highest priority task that is waiting on a mutex owned<br>by the task, so we only need to compare the priority of that top pi waiter<br>to the normal priority of the given task.</p>
<h2 id="High-level-overview-of-the-PI-chain-walk"><a href="#High-level-overview-of-the-PI-chain-walk" class="headerlink" title="High level overview of the PI chain walk"></a>High level overview of the PI chain walk</h2><p>The PI chain walk is implemented by the function rt_mutex_adjust_prio_chain.</p>
<p>The implementation has gone through several iterations, and has ended up<br>with what we believe is the best.  It walks the PI chain by only grabbing<br>at most two locks at a time, and is very efficient.</p>
<p>The rt_mutex_adjust_prio_chain can be used either to boost or lower process<br>priorities.</p>
<p>rt_mutex_adjust_prio_chain is called with a task to be checked for PI<br>(de)boosting (the owner of a mutex that a process is blocking on), a flag to<br>check for deadlocking, the mutex that the task owns, and a pointer to a waiter<br>that is the process’s waiter struct that is blocked on the mutex (although this<br>parameter may be NULL for deboosting).</p>
<p>For this explanation, I will not mention deadlock detection. This explanation<br>will try to stay at a high level.</p>
<p>When this function is called, there are no locks held.  That also means<br>that the state of the owner and lock can change when entered into this function.</p>
<p>Before this function is called, the task has already had rt_mutex_adjust_prio<br>performed on it.  This means that the task is set to the priority that it<br>should be at, but the plist nodes of the task’s waiter have not been updated<br>with the new priorities, and that this task may not be in the proper locations<br>in the pi_lists and wait_lists that the task is blocked on.  This function<br>solves all that.</p>
<p>A loop is entered, where task is the owner to be checked for PI changes that<br>was passed by parameter (for the first iteration).  The pi_lock of this task is<br>taken to prevent any more changes to the pi_list of the task.  This also<br>prevents new tasks from completing the blocking on a mutex that is owned by this<br>task.</p>
<p>If the task is not blocked on a mutex then the loop is exited.  We are at<br>the top of the PI chain.</p>
<p>A check is now done to see if the original waiter (the process that is blocked<br>on the current mutex) is the top pi waiter of the task.  That is, is this<br>waiter on the top of the task’s pi_list.  If it is not, it either means that<br>there is another process higher in priority that is blocked on one of the<br>mutexes that the task owns, or that the waiter has just woken up via a signal<br>or timeout and has left the PI chain.  In either case, the loop is exited, since<br>we don’t need to do any more changes to the priority of the current task, or any<br>task that owns a mutex that this current task is waiting on.  A priority chain<br>walk is only needed when a new top pi waiter is made to a task.</p>
<p>The next check sees if the task’s waiter plist node has the priority equal to<br>the priority the task is set at.  If they are equal, then we are done with<br>the loop.  Remember that the function started with the priority of the<br>task adjusted, but the plist nodes that hold the task in other processes<br>pi_lists have not been adjusted.</p>
<p>Next, we look at the mutex that the task is blocked on. The mutex’s wait_lock<br>is taken.  This is done by a spin_trylock, because the locking order of the<br>pi_lock and wait_lock goes in the opposite direction. If we fail to grab the<br>lock, the pi_lock is released, and we restart the loop.</p>
<p>Now that we have both the pi_lock of the task as well as the wait_lock of<br>the mutex the task is blocked on, we update the task’s waiter’s plist node<br>that is located on the mutex’s wait_list.</p>
<p>Now we release the pi_lock of the task.</p>
<p>Next the owner of the mutex has its pi_lock taken, so we can update the<br>task’s entry in the owner’s pi_list.  If the task is the highest priority<br>process on the mutex’s wait_list, then we remove the previous top waiter<br>from the owner’s pi_list, and replace it with the task.</p>
<p>Note: It is possible that the task was the current top waiter on the mutex,<br>      in which case the task is not yet on the pi_list of the waiter.  This<br>      is OK, since plist_del does nothing if the plist node is not on any<br>      list.</p>
<p>If the task was not the top waiter of the mutex, but it was before we<br>did the priority updates, that means we are deboosting/lowering the<br>task.  In this case, the task is removed from the pi_list of the owner,<br>and the new top waiter is added.</p>
<p>Lastly, we unlock both the pi_lock of the task, as well as the mutex’s<br>wait_lock, and continue the loop again.  On the next iteration of the<br>loop, the previous owner of the mutex will be the task that will be<br>processed.</p>
<p>Note: One might think that the owner of this mutex might have changed<br>      since we just grab the mutex’s wait_lock. And one could be right.<br>      The important thing to remember is that the owner could not have<br>      become the task that is being processed in the PI chain, since<br>      we have taken that task’s pi_lock at the beginning of the loop.<br>      So as long as there is an owner of this mutex that is not the same<br>      process as the tasked being worked on, we are OK.</p>
<pre><code>  Looking closely at the code, one might be confused.  The check for the
  end of the PI chain is when the task isn&#39;t blocked on anything or the
  task&#39;s waiter structure &quot;task&quot; element is NULL.  This check is
  protected only by the task&#39;s pi_lock.  But the code to unlock the mutex
  sets the task&#39;s waiter structure &quot;task&quot; element to NULL with only
  the protection of the mutex&#39;s wait_lock, which was not taken yet.
  Isn&#39;t this a race condition if the task becomes the new owner?

  The answer is No!  The trick is the spin_trylock of the mutex&#39;s
  wait_lock.  If we fail that lock, we release the pi_lock of the
  task and continue the loop, doing the end of PI chain check again.

  In the code to release the lock, the wait_lock of the mutex is held
  the entire time, and it is not let go when we grab the pi_lock of the
  new owner of the mutex.  So if the switch of a new owner were to happen
  after the check for end of the PI chain and the grabbing of the
  wait_lock, the unlocking code would spin on the new owner&#39;s pi_lock
  but never give up the wait_lock.  So the PI chain loop is guaranteed to
  fail the spin_trylock on the wait_lock, release the pi_lock, and
  try again.

  If you don&#39;t quite understand the above, that&#39;s OK. You don&#39;t have to,
  unless you really want to make a proof out of it ;)
</code></pre>
<h2 id="Pending-Owners-and-Lock-stealing"><a href="#Pending-Owners-and-Lock-stealing" class="headerlink" title="Pending Owners and Lock stealing"></a>Pending Owners and Lock stealing</h2><p>One of the flags in the owner field of the mutex structure is “Pending Owner”.<br>What this means is that an owner was chosen by the process releasing the<br>mutex, but that owner has yet to wake up and actually take the mutex.</p>
<p>Why is this important?  Why can’t we just give the mutex to another process<br>and be done with it?</p>
<p>The PI code is to help with real-time processes, and to let the highest<br>priority process run as long as possible with little latencies and delays.<br>If a high priority process owns a mutex that a lower priority process is<br>blocked on, when the mutex is released it would be given to the lower priority<br>process.  What if the higher priority process wants to take that mutex again.<br>The high priority process would fail to take that mutex that it just gave up<br>and it would need to boost the lower priority process to run with full<br>latency of that critical section (since the low priority process just entered<br>it).</p>
<p>There’s no reason a high priority process that gives up a mutex should be<br>penalized if it tries to take that mutex again.  If the new owner of the<br>mutex has not woken up yet, there’s no reason that the higher priority process<br>could not take that mutex away.</p>
<p>To solve this, we introduced Pending Ownership and Lock Stealing.  When a<br>new process is given a mutex that it was blocked on, it is only given<br>pending ownership.  This means that it’s the new owner, unless a higher<br>priority process comes in and tries to grab that mutex.  If a higher priority<br>process does come along and wants that mutex, we let the higher priority<br>process “steal” the mutex from the pending owner (only if it is still pending)<br>and continue with the mutex.</p>
<h2 id="Taking-of-a-mutex-The-walk-through"><a href="#Taking-of-a-mutex-The-walk-through" class="headerlink" title="Taking of a mutex (The walk through)"></a>Taking of a mutex (The walk through)</h2><p>OK, now let’s take a look at the detailed walk through of what happens when<br>taking a mutex.</p>
<p>The first thing that is tried is the fast taking of the mutex.  This is<br>done when we have CMPXCHG enabled (otherwise the fast taking automatically<br>fails).  Only when the owner field of the mutex is NULL can the lock be<br>taken with the CMPXCHG and nothing else needs to be done.</p>
<p>If there is contention on the lock, whether it is owned or pending owner<br>we go about the slow path (rt_mutex_slowlock).</p>
<p>The slow path function is where the task’s waiter structure is created on<br>the stack.  This is because the waiter structure is only needed for the<br>scope of this function.  The waiter structure holds the nodes to store<br>the task on the wait_list of the mutex, and if need be, the pi_list of<br>the owner.</p>
<p>The wait_lock of the mutex is taken since the slow path of unlocking the<br>mutex also takes this lock.</p>
<p>We then call try_to_take_rt_mutex.  This is where the architecture that<br>does not implement CMPXCHG would always grab the lock (if there’s no<br>contention).</p>
<p>try_to_take_rt_mutex is used every time the task tries to grab a mutex in the<br>slow path.  The first thing that is done here is an atomic setting of<br>the “Has Waiters” flag of the mutex’s owner field.  Yes, this could really<br>be false, because if the mutex has no owner, there are no waiters and<br>the current task also won’t have any waiters.  But we don’t have the lock<br>yet, so we assume we are going to be a waiter.  The reason for this is to<br>play nice for those architectures that do have CMPXCHG.  By setting this flag<br>now, the owner of the mutex can’t release the mutex without going into the<br>slow unlock path, and it would then need to grab the wait_lock, which this<br>code currently holds.  So setting the “Has Waiters” flag forces the owner<br>to synchronize with this code.</p>
<p>Now that we know that we can’t have any races with the owner releasing the<br>mutex, we check to see if we can take the ownership.  This is done if the<br>mutex doesn’t have a owner, or if we can steal the mutex from a pending<br>owner.  Let’s look at the situations we have here.</p>
<ol>
<li>Has owner that is pending</li>
</ol>
<hr>
<p>  The mutex has a owner, but it hasn’t woken up and the mutex flag<br>  “Pending Owner” is set.  The first check is to see if the owner isn’t the<br>  current task.  This is because this function is also used for the pending<br>  owner to grab the mutex.  When a pending owner wakes up, it checks to see<br>  if it can take the mutex, and this is done if the owner is already set to<br>  itself.  If so, we succeed and leave the function, clearing the “Pending<br>  Owner” bit.</p>
<p>  If the pending owner is not current, we check to see if the current priority is<br>  higher than the pending owner.  If not, we fail the function and return.</p>
<p>  There’s also something special about a pending owner.  That is a pending owner<br>  is never blocked on a mutex.  So there is no PI chain to worry about.  It also<br>  means that if the mutex doesn’t have any waiters, there’s no accounting needed<br>  to update the pending owner’s pi_list, since we only worry about processes<br>  blocked on the current mutex.</p>
<p>  If there are waiters on this mutex, and we just stole the ownership, we need<br>  to take the top waiter, remove it from the pi_list of the pending owner, and<br>  add it to the current pi_list.  Note that at this moment, the pending owner<br>  is no longer on the list of waiters.  This is fine, since the pending owner<br>  would add itself back when it realizes that it had the ownership stolen<br>  from itself.  When the pending owner tries to grab the mutex, it will fail<br>  in try_to_take_rt_mutex if the owner field points to another process.</p>
<ol start="2">
<li>No owner</li>
</ol>
<hr>
<p>  If there is no owner (or we successfully stole the lock), we set the owner<br>  of the mutex to current, and set the flag of “Has Waiters” if the current<br>  mutex actually has waiters, or we clear the flag if it doesn’t.  See, it was<br>  OK that we set that flag early, since now it is cleared.</p>
<ol start="3">
<li>Failed to grab ownership</li>
</ol>
<hr>
<p>  The most interesting case is when we fail to take ownership. This means that<br>  there exists an owner, or there’s a pending owner with equal or higher<br>  priority than the current task.</p>
<p>We’ll continue on the failed case.</p>
<p>If the mutex has a timeout, we set up a timer to go off to break us out<br>of this mutex if we failed to get it after a specified amount of time.</p>
<p>Now we enter a loop that will continue to try to take ownership of the mutex, or<br>fail from a timeout or signal.</p>
<p>Once again we try to take the mutex.  This will usually fail the first time<br>in the loop, since it had just failed to get the mutex.  But the second time<br>in the loop, this would likely succeed, since the task would likely be<br>the pending owner.</p>
<p>If the mutex is TASK_INTERRUPTIBLE a check for signals and timeout is done<br>here.</p>
<p>The waiter structure has a “task” field that points to the task that is blocked<br>on the mutex.  This field can be NULL the first time it goes through the loop<br>or if the task is a pending owner and had it’s mutex stolen.  If the “task”<br>field is NULL then we need to set up the accounting for it.</p>
<h2 id="Task-blocks-on-mutex"><a href="#Task-blocks-on-mutex" class="headerlink" title="Task blocks on mutex"></a>Task blocks on mutex</h2><p>The accounting of a mutex and process is done with the waiter structure of<br>the process.  The “task” field is set to the process, and the “lock” field<br>to the mutex.  The plist nodes are initialized to the processes current<br>priority.</p>
<p>Since the wait_lock was taken at the entry of the slow lock, we can safely<br>add the waiter to the wait_list.  If the current process is the highest<br>priority process currently waiting on this mutex, then we remove the<br>previous top waiter process (if it exists) from the pi_list of the owner,<br>and add the current process to that list.  Since the pi_list of the owner<br>has changed, we call rt_mutex_adjust_prio on the owner to see if the owner<br>should adjust its priority accordingly.</p>
<p>If the owner is also blocked on a lock, and had its pi_list changed<br>(or deadlock checking is on), we unlock the wait_lock of the mutex and go ahead<br>and run rt_mutex_adjust_prio_chain on the owner, as described earlier.</p>
<p>Now all locks are released, and if the current process is still blocked on a<br>mutex (waiter “task” field is not NULL), then we go to sleep (call schedule).</p>
<h2 id="Waking-up-in-the-loop"><a href="#Waking-up-in-the-loop" class="headerlink" title="Waking up in the loop"></a>Waking up in the loop</h2><p>The schedule can then wake up for a few reasons.</p>
<ol>
<li>we were given pending ownership of the mutex.</li>
<li>we received a signal and was TASK_INTERRUPTIBLE</li>
<li>we had a timeout and was TASK_INTERRUPTIBLE</li>
</ol>
<p>In any of these cases, we continue the loop and once again try to grab the<br>ownership of the mutex.  If we succeed, we exit the loop, otherwise we continue<br>and on signal and timeout, will exit the loop, or if we had the mutex stolen<br>we just simply add ourselves back on the lists and go back to sleep.</p>
<p>Note: For various reasons, because of timeout and signals, the steal mutex<br>      algorithm needs to be careful. This is because the current process is<br>      still on the wait_list. And because of dynamic changing of priorities,<br>      especially on SCHED_OTHER tasks, the current process can be the<br>      highest priority task on the wait_list.</p>
<h2 id="Failed-to-get-mutex-on-Timeout-or-Signal"><a href="#Failed-to-get-mutex-on-Timeout-or-Signal" class="headerlink" title="Failed to get mutex on Timeout or Signal"></a>Failed to get mutex on Timeout or Signal</h2><p>If a timeout or signal occurred, the waiter’s “task” field would not be<br>NULL and the task needs to be taken off the wait_list of the mutex and perhaps<br>pi_list of the owner.  If this process was a high priority process, then<br>the rt_mutex_adjust_prio_chain needs to be executed again on the owner,<br>but this time it will be lowering the priorities.</p>
<h2 id="Unlocking-the-Mutex"><a href="#Unlocking-the-Mutex" class="headerlink" title="Unlocking the Mutex"></a>Unlocking the Mutex</h2><p>The unlocking of a mutex also has a fast path for those architectures with<br>CMPXCHG.  Since the taking of a mutex on contention always sets the<br>“Has Waiters” flag of the mutex’s owner, we use this to know if we need to<br>take the slow path when unlocking the mutex.  If the mutex doesn’t have any<br>waiters, the owner field of the mutex would equal the current process and<br>the mutex can be unlocked by just replacing the owner field with NULL.</p>
<p>If the owner field has the “Has Waiters” bit set (or CMPXCHG is not available),<br>the slow unlock path is taken.</p>
<p>The first thing done in the slow unlock path is to take the wait_lock of the<br>mutex.  This synchronizes the locking and unlocking of the mutex.</p>
<p>A check is made to see if the mutex has waiters or not.  On architectures that<br>do not have CMPXCHG, this is the location that the owner of the mutex will<br>determine if a waiter needs to be awoken or not.  On architectures that<br>do have CMPXCHG, that check is done in the fast path, but it is still needed<br>in the slow path too.  If a waiter of a mutex woke up because of a signal<br>or timeout between the time the owner failed the fast path CMPXCHG check and<br>the grabbing of the wait_lock, the mutex may not have any waiters, thus the<br>owner still needs to make this check. If there are no waiters then the mutex<br>owner field is set to NULL, the wait_lock is released and nothing more is<br>needed.</p>
<p>If there are waiters, then we need to wake one up and give that waiter<br>pending ownership.</p>
<p>On the wake up code, the pi_lock of the current owner is taken.  The top<br>waiter of the lock is found and removed from the wait_list of the mutex<br>as well as the pi_list of the current owner.  The task field of the new<br>pending owner’s waiter structure is set to NULL, and the owner field of the<br>mutex is set to the new owner with the “Pending Owner” bit set, as well<br>as the “Has Waiters” bit if there still are other processes blocked on the<br>mutex.</p>
<p>The pi_lock of the previous owner is released, and the new pending owner’s<br>pi_lock is taken.  Remember that this is the trick to prevent the race<br>condition in rt_mutex_adjust_prio_chain from adding itself as a waiter<br>on the mutex.</p>
<p>We now clear the “pi_blocked_on” field of the new pending owner, and if<br>the mutex still has waiters pending, we add the new top waiter to the pi_list<br>of the pending owner.</p>
<p>Finally we unlock the pi_lock of the pending owner and wake it up.</p>
<h2 id="Contact"><a href="#Contact" class="headerlink" title="Contact"></a>Contact</h2><p>For updates on this document, please email Steven Rostedt <a href="mailto:&#114;&#x6f;&#115;&#116;&#101;&#x64;&#116;&#x40;&#103;&#x6f;&#111;&#x64;&#109;&#x69;&#x73;&#x2e;&#x6f;&#x72;&#103;">&#114;&#x6f;&#115;&#116;&#101;&#x64;&#116;&#x40;&#103;&#x6f;&#111;&#x64;&#109;&#x69;&#x73;&#x2e;&#x6f;&#x72;&#103;</a></p>
<h2 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h2><p>Author:  Steven Rostedt <a href="mailto:&#x72;&#x6f;&#x73;&#116;&#x65;&#x64;&#116;&#64;&#103;&#x6f;&#111;&#x64;&#x6d;&#x69;&#115;&#46;&#111;&#114;&#103;">&#x72;&#x6f;&#x73;&#116;&#x65;&#x64;&#116;&#64;&#103;&#x6f;&#111;&#x64;&#x6d;&#x69;&#115;&#46;&#111;&#114;&#103;</a></p>
<p>Reviewers:  Ingo Molnar, Thomas Gleixner, Thomas Duetsch, and Randy Dunlap</p>
<h2 id="Updates"><a href="#Updates" class="headerlink" title="Updates"></a>Updates</h2><p>This document was originally written for 2.6.17-rc3-mm1</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_rt-mutex-design/" title="Kernel-2.6.32-573.12.1.el6_rt-mutex-design" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_rt-mutex-design/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_rxrpc/" title="Kernel-2.6.32-573.12.1.el6_rxrpc"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_parport-lowlevel/" title="Kernel-2.6.32-573.12.1.el6_parport-lowlevel"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>