<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-3.10.0-957.el7_IPMI | oosTech.com</title>
  <meta name="description" content="The Linux IPMI Driver           ---------------------               Corey Minyard           &lt;minyard@mvista.com&gt;             &lt;minyard@acm.org&gt;  The Intelligent Platfo">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-3.10.0-957.el7_IPMI">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_IPMI/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="The Linux IPMI Driver           ---------------------               Corey Minyard           &lt;minyard@mvista.com&gt;             &lt;minyard@acm.org&gt;  The Intelligent Platfo">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_IPMI/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_mpc5200/" class="title">Kernel-3.10.0-957.el7_mpc5200</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_6pack/" class="title">Kernel-3.10.0-957.el7_6pack</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Configuration"><span class="toc-number">1.</span> <span class="toc-text">Configuration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-Design"><span class="toc-number">2.</span> <span class="toc-text">Basic Design</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Addressing"><span class="toc-number">3.</span> <span class="toc-text">Addressing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Messages"><span class="toc-number">4.</span> <span class="toc-text">Messages</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Upper-Layer-Interface-Message-Handler"><span class="toc-number">5.</span> <span class="toc-text">The Upper Layer Interface (Message Handler)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Lower-Layer-SMI-Interface"><span class="toc-number">6.</span> <span class="toc-text">The Lower Layer (SMI) Interface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-SI-Driver"><span class="toc-number">7.</span> <span class="toc-text">The SI Driver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-SMBus-Driver-SSIF"><span class="toc-number">8.</span> <span class="toc-text">The SMBus Driver (SSIF)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Other-Pieces"><span class="toc-number">9.</span> <span class="toc-text">Other Pieces</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Get-the-detailed-info-related-with-the-IPMI-device"><span class="toc-number">10.</span> <span class="toc-text">Get the detailed info related with the IPMI device</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Watchdog"><span class="toc-number">11.</span> <span class="toc-text">Watchdog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Panic-Timeouts"><span class="toc-number">12.</span> <span class="toc-text">Panic Timeouts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Poweroff"><span class="toc-number">13.</span> <span class="toc-text">Poweroff</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-3.10.0-957.el7_IPMI" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-3.10.0-957.el7_IPMI
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_IPMI/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_IPMI/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-3.10.0-957.el7_IPMI/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <pre><code>                      The Linux IPMI Driver
          ---------------------
              Corey Minyard
          &lt;minyard@mvista.com&gt;
            &lt;minyard@acm.org&gt;
</code></pre>
<p>The Intelligent Platform Management Interface, or IPMI, is a<br>standard for controlling intelligent devices that monitor a system.<br>It provides for dynamic discovery of sensors in the system and the<br>ability to monitor the sensors and be informed when the sensor’s<br>values change or go outside certain boundaries.  It also has a<br>standardized database for field-replaceable units (FRUs) and a watchdog<br>timer.</p>
<p>To use this, you need an interface to an IPMI controller in your<br>system (called a Baseboard Management Controller, or BMC) and<br>management software that can use the IPMI system.</p>
<p>This document describes how to use the IPMI driver for Linux.  If you<br>are not familiar with IPMI itself, see the web site at<br><a target="_blank" rel="noopener" href="http://www.intel.com/design/servers/ipmi/index.htm">http://www.intel.com/design/servers/ipmi/index.htm</a>.  IPMI is a big<br>subject and I can’t cover it all here!</p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>The Linux IPMI driver is modular, which means you have to pick several<br>things to have it work right depending on your hardware.  Most of<br>these are available in the ‘Character Devices’ menu then the IPMI<br>menu.</p>
<p>No matter what, you must pick ‘IPMI top-level message handler’ to use<br>IPMI.  What you do beyond that depends on your needs and hardware.</p>
<p>The message handler does not provide any user-level interfaces.<br>Kernel code (like the watchdog) can still use it.  If you need access<br>from userland, you need to select ‘Device interface for IPMI’ if you<br>want access through a device driver.</p>
<p>The driver interface depends on your hardware.  If your system<br>properly provides the SMBIOS info for IPMI, the driver will detect it<br>and just work.  If you have a board with a standard interface (These<br>will generally be either “KCS”, “SMIC”, or “BT”, consult your hardware<br>manual), choose the ‘IPMI SI handler’ option.  A driver also exists<br>for direct I2C access to the IPMI management controller.  Some boards<br>support this, but it is unknown if it will work on every board.  For<br>this, choose ‘IPMI SMBus handler’, but be ready to try to do some<br>figuring to see if it will work on your system if the SMBIOS/APCI<br>information is wrong or not present.  It is fairly safe to have both<br>these enabled and let the drivers auto-detect what is present.</p>
<p>You should generally enable ACPI on your system, as systems with IPMI<br>can have ACPI tables describing them.</p>
<p>If you have a standard interface and the board manufacturer has done<br>their job correctly, the IPMI controller should be automatically<br>detected (via ACPI or SMBIOS tables) and should just work.  Sadly,<br>many boards do not have this information.  The driver attempts<br>standard defaults, but they may not work.  If you fall into this<br>situation, you need to read the section below named ‘The SI Driver’ or<br>“The SMBus Driver” on how to hand-configure your system.</p>
<p>IPMI defines a standard watchdog timer.  You can enable this with the<br>‘IPMI Watchdog Timer’ config option.  If you compile the driver into<br>the kernel, then via a kernel command-line option you can have the<br>watchdog timer start as soon as it initializes.  It also have a lot<br>of other options, see the ‘Watchdog’ section below for more details.<br>Note that you can also have the watchdog continue to run if it is<br>closed (by default it is disabled on close).  Go into the ‘Watchdog<br>Cards’ menu, enable ‘Watchdog Timer Support’, and enable the option<br>‘Disable watchdog shutdown on close’.</p>
<p>IPMI systems can often be powered off using IPMI commands.  Select<br>‘IPMI Poweroff’ to do this.  The driver will auto-detect if the system<br>can be powered off by IPMI.  It is safe to enable this even if your<br>system doesn’t support this option.  This works on ATCA systems, the<br>Radisys CPI1 card, and any IPMI system that supports standard chassis<br>management commands.</p>
<p>If you want the driver to put an event into the event log on a panic,<br>enable the ‘Generate a panic event to all BMCs on a panic’ option.  If<br>you want the whole panic string put into the event log using OEM<br>events, enable the ‘Generate OEM events containing the panic string’<br>option.  You can also enable these dynamically by setting the module<br>parameter named “panic_op” in the ipmi_msghandler module to “event”<br>or “string”.  Setting that parameter to “none” disables this function.</p>
<h2 id="Basic-Design"><a href="#Basic-Design" class="headerlink" title="Basic Design"></a>Basic Design</h2><p>The Linux IPMI driver is designed to be very modular and flexible, you<br>only need to take the pieces you need and you can use it in many<br>different ways.  Because of that, it’s broken into many chunks of<br>code.  These chunks (by module name) are:</p>
<p>ipmi_msghandler - This is the central piece of software for the IPMI<br>system.  It handles all messages, message timing, and responses.  The<br>IPMI users tie into this, and the IPMI physical interfaces (called<br>System Management Interfaces, or SMIs) also tie in here.  This<br>provides the kernelland interface for IPMI, but does not provide an<br>interface for use by application processes.</p>
<p>ipmi_devintf - This provides a userland IOCTL interface for the IPMI<br>driver, each open file for this device ties in to the message handler<br>as an IPMI user.</p>
<p>ipmi_si - A driver for various system interfaces.  This supports KCS,<br>SMIC, and BT interfaces.  Unless you have an SMBus interface or your<br>own custom interface, you probably need to use this.</p>
<p>ipmi_ssif - A driver for accessing BMCs on the SMBus. It uses the<br>I2C kernel driver’s SMBus interfaces to send and receive IPMI messages<br>over the SMBus.</p>
<p>ipmi_watchdog - IPMI requires systems to have a very capable watchdog<br>timer.  This driver implements the standard Linux watchdog timer<br>interface on top of the IPMI message handler.</p>
<p>ipmi_poweroff - Some systems support the ability to be turned off via<br>IPMI commands.</p>
<p>These are all individually selectable via configuration options.</p>
<p>Note that the KCS-only interface has been removed.  The af_ipmi driver<br>is no longer supported and has been removed because it was impossible<br>to do 32 bit emulation on 64-bit kernels with it.</p>
<p>Much documentation for the interface is in the include files.  The<br>IPMI include files are:</p>
<p>net/af_ipmi.h - Contains the socket interface.</p>
<p>linux/ipmi.h - Contains the user interface and IOCTL interface for IPMI.</p>
<p>linux/ipmi_smi.h - Contains the interface for system management interfaces<br>(things that interface to IPMI controllers) to use.</p>
<p>linux/ipmi_msgdefs.h - General definitions for base IPMI messaging.</p>
<h2 id="Addressing"><a href="#Addressing" class="headerlink" title="Addressing"></a>Addressing</h2><p>The IPMI addressing works much like IP addresses, you have an overlay<br>to handle the different address types.  The overlay is:</p>
<p>  struct ipmi_addr<br>  {<br>    int   addr_type;<br>    short channel;<br>    char  data[IPMI_MAX_ADDR_SIZE];<br>  };</p>
<p>The addr_type determines what the address really is.  The driver<br>currently understands two different types of addresses.</p>
<p>“System Interface” addresses are defined as:</p>
<p>  struct ipmi_system_interface_addr<br>  {<br>    int   addr_type;<br>    short channel;<br>  };</p>
<p>and the type is IPMI_SYSTEM_INTERFACE_ADDR_TYPE.  This is used for talking<br>straight to the BMC on the current card.  The channel must be<br>IPMI_BMC_CHANNEL.</p>
<p>Messages that are destined to go out on the IPMB bus use the<br>IPMI_IPMB_ADDR_TYPE address type.  The format is</p>
<p>  struct ipmi_ipmb_addr<br>  {<br>    int           addr_type;<br>    short         channel;<br>    unsigned char slave_addr;<br>    unsigned char lun;<br>  };</p>
<p>The “channel” here is generally zero, but some devices support more<br>than one channel, it corresponds to the channel as defined in the IPMI<br>spec.</p>
<h2 id="Messages"><a href="#Messages" class="headerlink" title="Messages"></a>Messages</h2><p>Messages are defined as:</p>
<p>struct ipmi_msg<br>{<br>    unsigned char netfn;<br>    unsigned char lun;<br>    unsigned char cmd;<br>    unsigned char *data;<br>    int           data_len;<br>};</p>
<p>The driver takes care of adding/stripping the header information.  The<br>data portion is just the data to be send (do NOT put addressing info<br>here) or the response.  Note that the completion code of a response is<br>the first item in “data”, it is not stripped out because that is how<br>all the messages are defined in the spec (and thus makes counting the<br>offsets a little easier :-).</p>
<p>When using the IOCTL interface from userland, you must provide a block<br>of data for “data”, fill it, and set data_len to the length of the<br>block of data, even when receiving messages.  Otherwise the driver<br>will have no place to put the message.</p>
<p>Messages coming up from the message handler in kernelland will come in<br>as:</p>
<p>  struct ipmi_recv_msg<br>  {<br>    struct list_head link;</p>
<pre><code>/* The type of message as defined in the &quot;Receive Types&quot;
       defines above. */
int         recv_type;

ipmi_user_t      *user;
struct ipmi_addr addr;
long             msgid;
struct ipmi_msg  msg;

/* Call this when done with the message.  It will presumably free
   the message and do any other necessary cleanup. */
void (*done)(struct ipmi_recv_msg *msg);

/* Place-holder for the data, don&#39;t make any assumptions about
   the size or existence of this, since it may change. */
unsigned char   msg_data[IPMI_MAX_MSG_LENGTH];
</code></pre>
<p>  };</p>
<p>You should look at the receive type and handle the message<br>appropriately.</p>
<h2 id="The-Upper-Layer-Interface-Message-Handler"><a href="#The-Upper-Layer-Interface-Message-Handler" class="headerlink" title="The Upper Layer Interface (Message Handler)"></a>The Upper Layer Interface (Message Handler)</h2><p>The upper layer of the interface provides the users with a consistent<br>view of the IPMI interfaces.  It allows multiple SMI interfaces to be<br>addressed (because some boards actually have multiple BMCs on them)<br>and the user should not have to care what type of SMI is below them.</p>
<p>Creating the User</p>
<p>To user the message handler, you must first create a user using<br>ipmi_create_user.  The interface number specifies which SMI you want<br>to connect to, and you must supply callback functions to be called<br>when data comes in.  The callback function can run at interrupt level,<br>so be careful using the callbacks.  This also allows to you pass in a<br>piece of data, the handler_data, that will be passed back to you on<br>all calls.</p>
<p>Once you are done, call ipmi_destroy_user() to get rid of the user.</p>
<p>From userland, opening the device automatically creates a user, and<br>closing the device automatically destroys the user.</p>
<p>Messaging</p>
<p>To send a message from kernel-land, the ipmi_request() call does<br>pretty much all message handling.  Most of the parameter are<br>self-explanatory.  However, it takes a “msgid” parameter.  This is NOT<br>the sequence number of messages.  It is simply a long value that is<br>passed back when the response for the message is returned.  You may<br>use it for anything you like.</p>
<p>Responses come back in the function pointed to by the ipmi_recv_hndl<br>field of the “handler” that you passed in to ipmi_create_user().<br>Remember again, these may be running at interrupt level.  Remember to<br>look at the receive type, too.</p>
<p>From userland, you fill out an ipmi_req_t structure and use the<br>IPMICTL_SEND_COMMAND ioctl.  For incoming stuff, you can use select()<br>or poll() to wait for messages to come in.  However, you cannot use<br>read() to get them, you must call the IPMICTL_RECEIVE_MSG with the<br>ipmi_recv_t structure to actually get the message.  Remember that you<br>must supply a pointer to a block of data in the msg.data field, and<br>you must fill in the msg.data_len field with the size of the data.<br>This gives the receiver a place to actually put the message.</p>
<p>If the message cannot fit into the data you provide, you will get an<br>EMSGSIZE error and the driver will leave the data in the receive<br>queue.  If you want to get it and have it truncate the message, us<br>the IPMICTL_RECEIVE_MSG_TRUNC ioctl.</p>
<p>When you send a command (which is defined by the lowest-order bit of<br>the netfn per the IPMI spec) on the IPMB bus, the driver will<br>automatically assign the sequence number to the command and save the<br>command.  If the response is not receive in the IPMI-specified 5<br>seconds, it will generate a response automatically saying the command<br>timed out.  If an unsolicited response comes in (if it was after 5<br>seconds, for instance), that response will be ignored.</p>
<p>In kernelland, after you receive a message and are done with it, you<br>MUST call ipmi_free_recv_msg() on it, or you will leak messages.  Note<br>that you should NEVER mess with the “done” field of a message, that is<br>required to properly clean up the message.</p>
<p>Note that when sending, there is an ipmi_request_supply_msgs() call<br>that lets you supply the smi and receive message.  This is useful for<br>pieces of code that need to work even if the system is out of buffers<br>(the watchdog timer uses this, for instance).  You supply your own<br>buffer and own free routines.  This is not recommended for normal use,<br>though, since it is tricky to manage your own buffers.</p>
<p>Events and Incoming Commands</p>
<p>The driver takes care of polling for IPMI events and receiving<br>commands (commands are messages that are not responses, they are<br>commands that other things on the IPMB bus have sent you).  To receive<br>these, you must register for them, they will not automatically be sent<br>to you.</p>
<p>To receive events, you must call ipmi_set_gets_events() and set the<br>“val” to non-zero.  Any events that have been received by the driver<br>since startup will immediately be delivered to the first user that<br>registers for events.  After that, if multiple users are registered<br>for events, they will all receive all events that come in.</p>
<p>For receiving commands, you have to individually register commands you<br>want to receive.  Call ipmi_register_for_cmd() and supply the netfn<br>and command name for each command you want to receive.  You also<br>specify a bitmask of the channels you want to receive the command from<br>(or use IPMI_CHAN_ALL for all channels if you don’t care).  Only one<br>user may be registered for each netfn/cmd/channel, but different users<br>may register for different commands, or the same command if the<br>channel bitmasks do not overlap.</p>
<p>From userland, equivalent IOCTLs are provided to do these functions.</p>
<h2 id="The-Lower-Layer-SMI-Interface"><a href="#The-Lower-Layer-SMI-Interface" class="headerlink" title="The Lower Layer (SMI) Interface"></a>The Lower Layer (SMI) Interface</h2><p>As mentioned before, multiple SMI interfaces may be registered to the<br>message handler, each of these is assigned an interface number when<br>they register with the message handler.  They are generally assigned<br>in the order they register, although if an SMI unregisters and then<br>another one registers, all bets are off.</p>
<p>The ipmi_smi.h defines the interface for management interfaces, see<br>that for more details.</p>
<h2 id="The-SI-Driver"><a href="#The-SI-Driver" class="headerlink" title="The SI Driver"></a>The SI Driver</h2><p>The SI driver allows up to 4 KCS or SMIC interfaces to be configured<br>in the system.  By default, scan the ACPI tables for interfaces, and<br>if it doesn’t find any the driver will attempt to register one KCS<br>interface at the spec-specified I/O port 0xca2 without interrupts.<br>You can change this at module load time (for a module) with:</p>
<p>  modprobe ipmi_si.o type=<type1>,<type2>….<br>       ports=<port1>,<port2>… addrs=<addr1>,<addr2>…<br>       irqs=<irq1>,<irq2>…<br>       regspacings=<sp1>,<sp2>,… regsizes=<size1>,<size2>,…<br>       regshifts=<shift1>,<shift2>,…<br>       slave_addrs=<addr1>,<addr2>,…<br>       force_kipmid=<enable1>,<enable2>,…<br>       kipmid_max_busy_us=<ustime1>,<ustime2>,…<br>       unload_when_empty=[0|1]<br>       trydefaults=[0|1] trydmi=[0|1] tryacpi=[0|1]<br>       tryplatform=[0|1] trypci=[0|1]</p>
<p>Each of these except try… items is a list, the first item for the<br>first interface, second item for the second interface, etc.</p>
<p>The si_type may be either “kcs”, “smic”, or “bt”.  If you leave it blank, it<br>defaults to “kcs”.</p>
<p>If you specify addrs as non-zero for an interface, the driver will<br>use the memory address given as the address of the device.  This<br>overrides si_ports.</p>
<p>If you specify ports as non-zero for an interface, the driver will<br>use the I/O port given as the device address.</p>
<p>If you specify irqs as non-zero for an interface, the driver will<br>attempt to use the given interrupt for the device.</p>
<p>trydefaults sets whether the standard IPMI interface at 0xca2 and<br>any interfaces specified by ACPE are tried.  By default, the driver<br>tries it, set this value to zero to turn this off.</p>
<p>The other try… items disable discovery by their corresponding<br>names.  These are all enabled by default, set them to zero to disable<br>them.  The tryplatform disables openfirmware.</p>
<p>The next three parameters have to do with register layout.  The<br>registers used by the interfaces may not appear at successive<br>locations and they may not be in 8-bit registers.  These parameters<br>allow the layout of the data in the registers to be more precisely<br>specified.</p>
<p>The regspacings parameter give the number of bytes between successive<br>register start addresses.  For instance, if the regspacing is set to 4<br>and the start address is 0xca2, then the address for the second<br>register would be 0xca6.  This defaults to 1.</p>
<p>The regsizes parameter gives the size of a register, in bytes.  The<br>data used by IPMI is 8-bits wide, but it may be inside a larger<br>register.  This parameter allows the read and write type to specified.<br>It may be 1, 2, 4, or 8.  The default is 1.</p>
<p>Since the register size may be larger than 32 bits, the IPMI data may not<br>be in the lower 8 bits.  The regshifts parameter give the amount to shift<br>the data to get to the actual IPMI data.</p>
<p>The slave_addrs specifies the IPMI address of the local BMC.  This is<br>usually 0x20 and the driver defaults to that, but in case it’s not, it<br>can be specified when the driver starts up.</p>
<p>The force_ipmid parameter forcefully enables (if set to 1) or disables<br>(if set to 0) the kernel IPMI daemon.  Normally this is auto-detected<br>by the driver, but systems with broken interrupts might need an enable,<br>or users that don’t want the daemon (don’t need the performance, don’t<br>want the CPU hit) can disable it.</p>
<p>If unload_when_empty is set to 1, the driver will be unloaded if it<br>doesn’t find any interfaces or all the interfaces fail to work.  The<br>default is one.  Setting to 0 is useful with the hotmod, but is<br>obviously only useful for modules.</p>
<p>When compiled into the kernel, the parameters can be specified on the<br>kernel command line as:</p>
<p>  ipmi_si.type=<type1>,<type2>…<br>       ipmi_si.ports=<port1>,<port2>… ipmi_si.addrs=<addr1>,<addr2>…<br>       ipmi_si.irqs=<irq1>,<irq2>… ipmi_si.trydefaults=[0|1]<br>       ipmi_si.regspacings=<sp1>,<sp2>,…<br>       ipmi_si.regsizes=<size1>,<size2>,…<br>       ipmi_si.regshifts=<shift1>,<shift2>,…<br>       ipmi_si.slave_addrs=<addr1>,<addr2>,…<br>       ipmi_si.force_kipmid=<enable1>,<enable2>,…<br>       ipmi_si.kipmid_max_busy_us=<ustime1>,<ustime2>,…</p>
<p>It works the same as the module parameters of the same names.</p>
<p>By default, the driver will attempt to detect any device specified by<br>ACPI, and if none of those then a KCS device at the spec-specified<br>0xca2.  If you want to turn this off, set the “trydefaults” option to<br>false.</p>
<p>If your IPMI interface does not support interrupts and is a KCS or<br>SMIC interface, the IPMI driver will start a kernel thread for the<br>interface to help speed things up.  This is a low-priority kernel<br>thread that constantly polls the IPMI driver while an IPMI operation<br>is in progress.  The force_kipmid module parameter will all the user to<br>force this thread on or off.  If you force it off and don’t have<br>interrupts, the driver will run VERY slowly.  Don’t blame me,<br>these interfaces suck.</p>
<p>Unfortunately, this thread can use a lot of CPU depending on the<br>interface’s performance.  This can waste a lot of CPU and cause<br>various issues with detecting idle CPU and using extra power.  To<br>avoid this, the kipmid_max_busy_us sets the maximum amount of time, in<br>microseconds, that kipmid will spin before sleeping for a tick.  This<br>value sets a balance between performance and CPU waste and needs to be<br>tuned to your needs.  Maybe, someday, auto-tuning will be added, but<br>that’s not a simple thing and even the auto-tuning would need to be<br>tuned to the user’s desired performance.</p>
<p>The driver supports a hot add and remove of interfaces.  This way,<br>interfaces can be added or removed after the kernel is up and running.<br>This is done using /sys/modules/ipmi_si/parameters/hotmod, which is a<br>write-only parameter.  You write a string to this interface.  The string<br>has the format:<br>   <op1>[:op2[:op3…]]<br>The “op”s are:<br>   add|remove,kcs|bt|smic,mem|i/o,<address>[,<opt1>[,<opt2>[,…]]]<br>You can specify more than one interface on the line.  The “opt”s are:<br>   rsp=<regspacing><br>   rsi=<regsize><br>   rsh=<regshift><br>   irq=<irq><br>   ipmb=<ipmb slave addr><br>and these have the same meanings as discussed above.  Note that you<br>can also use this on the kernel command line for a more compact format<br>for specifying an interface.  Note that when removing an interface,<br>only the first three parameters (si type, address type, and address)<br>are used for the comparison.  Any options are ignored for removing.</p>
<h2 id="The-SMBus-Driver-SSIF"><a href="#The-SMBus-Driver-SSIF" class="headerlink" title="The SMBus Driver (SSIF)"></a>The SMBus Driver (SSIF)</h2><p>The SMBus driver allows up to 4 SMBus devices to be configured in the<br>system.  By default, the driver will only register with something it<br>finds in DMI or ACPI tables.  You can change this<br>at module load time (for a module) with:</p>
<p>  modprobe ipmi_ssif.o<br>    addr=<i2caddr1>[,<i2caddr2>[,…]]<br>    adapter=<adapter1>[,<adapter2>[…]]<br>    dbg=<flags1>,<flags2>…<br>        slave_addrs=<addr1>,<addr2>,…<br>    [dbg_probe=1]</p>
<p>The addresses are normal I2C addresses.  The adapter is the string<br>name of the adapter, as shown in /sys/class/i2c-adapter/i2c-<n>/name.<br>It is <em>NOT</em> i2c-<n> itself.  Also, the comparison is done ignoring<br>spaces, so if the name is “This is an I2C chip” you can say<br>adapter_name=ThisisanI2cchip.  This is because it’s hard to pass in<br>spaces in kernel parameters.</p>
<p>The debug flags are bit flags for each BMC found, they are:<br>IPMI messages: 1, driver state: 2, timing: 4, I2C probe: 8</p>
<p>Setting dbg_probe to 1 will enable debugging of the probing and<br>detection process for BMCs on the SMBusses.</p>
<p>The slave_addrs specifies the IPMI address of the local BMC.  This is<br>usually 0x20 and the driver defaults to that, but in case it’s not, it<br>can be specified when the driver starts up.</p>
<p>Discovering the IPMI compliant BMC on the SMBus can cause devices on<br>the I2C bus to fail. The SMBus driver writes a “Get Device ID” IPMI<br>message as a block write to the I2C bus and waits for a response.<br>This action can be detrimental to some I2C devices. It is highly<br>recommended that the known I2C address be given to the SMBus driver in<br>the smb_addr parameter unless you have DMI or ACPI data to tell the<br>driver what to use.</p>
<p>When compiled into the kernel, the addresses can be specified on the<br>kernel command line as:</p>
<p>  ipmb_ssif.addr=<i2caddr1>[,<i2caddr2>[…]]<br>    ipmi_ssif.adapter=<adapter1>[,<adapter2>[…]]<br>    ipmi_ssif.dbg=<flags1>[,<flags2>[…]]<br>    ipmi_ssif.dbg_probe=1<br>        ipmi_ssif.slave_addrs=<addr1>[,<addr2>[…]]</p>
<p>These are the same options as on the module command line.</p>
<p>The I2C driver does not support non-blocking access or polling, so<br>this driver cannod to IPMI panic events, extend the watchdog at panic<br>time, or other panic-related IPMI functions without special kernel<br>patches and driver modifications.  You can get those at the openipmi<br>web page.</p>
<p>The driver supports a hot add and remove of interfaces through the I2C<br>sysfs interface.</p>
<h2 id="Other-Pieces"><a href="#Other-Pieces" class="headerlink" title="Other Pieces"></a>Other Pieces</h2><h2 id="Get-the-detailed-info-related-with-the-IPMI-device"><a href="#Get-the-detailed-info-related-with-the-IPMI-device" class="headerlink" title="Get the detailed info related with the IPMI device"></a>Get the detailed info related with the IPMI device</h2><p>Some users need more detailed information about a device, like where<br>the address came from or the raw base device for the IPMI interface.<br>You can use the IPMI smi_watcher to catch the IPMI interfaces as they<br>come or go, and to grab the information, you can use the function<br>ipmi_get_smi_info(), which returns the following structure:</p>
<p>struct ipmi_smi_info {<br>    enum ipmi_addr_src addr_src;<br>    struct device *dev;<br>    union {<br>        struct {<br>            void *acpi_handle;<br>        } acpi_info;<br>    } addr_info;<br>};</p>
<p>Currently special info for only for SI_ACPI address sources is<br>returned.  Others may be added as necessary.</p>
<p>Note that the dev pointer is included in the above structure, and<br>assuming ipmi_smi_get_info returns success, you must call put_device<br>on the dev pointer.</p>
<h2 id="Watchdog"><a href="#Watchdog" class="headerlink" title="Watchdog"></a>Watchdog</h2><p>A watchdog timer is provided that implements the Linux-standard<br>watchdog timer interface.  It has three module parameters that can be<br>used to control it:</p>
<p>  modprobe ipmi_watchdog timeout=<t> pretimeout=<t> action=<action type><br>      preaction=<preaction type> preop=<preop type> start_now=x<br>      nowayout=x ifnum_to_use=n panic_wdt_timeout=<t></p>
<p>ifnum_to_use specifies which interface the watchdog timer should use.<br>The default is -1, which means to pick the first one registered.</p>
<p>The timeout is the number of seconds to the action, and the pretimeout<br>is the amount of seconds before the reset that the pre-timeout panic will<br>occur (if pretimeout is zero, then pretimeout will not be enabled).  Note<br>that the pretimeout is the time before the final timeout.  So if the<br>timeout is 50 seconds and the pretimeout is 10 seconds, then the pretimeout<br>will occur in 40 second (10 seconds before the timeout). The panic_wdt_timeout<br>is the value of timeout which is set on kernel panic, in order to let actions<br>such as kdump to occur during panic.</p>
<p>The action may be “reset”, “power_cycle”, or “power_off”, and<br>specifies what to do when the timer times out, and defaults to<br>“reset”.</p>
<p>The preaction may be “pre_smi” for an indication through the SMI<br>interface, “pre_int” for an indication through the SMI with an<br>interrupts, and “pre_nmi” for a NMI on a preaction.  This is how<br>the driver is informed of the pretimeout.</p>
<p>The preop may be set to “preop_none” for no operation on a pretimeout,<br>“preop_panic” to set the preoperation to panic, or “preop_give_data”<br>to provide data to read from the watchdog device when the pretimeout<br>occurs.  A “pre_nmi” setting CANNOT be used with “preop_give_data”<br>because you can’t do data operations from an NMI.</p>
<p>When preop is set to “preop_give_data”, one byte comes ready to read<br>on the device when the pretimeout occurs.  Select and fasync work on<br>the device, as well.</p>
<p>If start_now is set to 1, the watchdog timer will start running as<br>soon as the driver is loaded.</p>
<p>If nowayout is set to 1, the watchdog timer will not stop when the<br>watchdog device is closed.  The default value of nowayout is true<br>if the CONFIG_WATCHDOG_NOWAYOUT option is enabled, or false if not.</p>
<p>When compiled into the kernel, the kernel command line is available<br>for configuring the watchdog:</p>
<p>  ipmi_watchdog.timeout=<t> ipmi_watchdog.pretimeout=<t><br>    ipmi_watchdog.action=<action type><br>    ipmi_watchdog.preaction=<preaction type><br>    ipmi_watchdog.preop=<preop type><br>    ipmi_watchdog.start_now=x<br>    ipmi_watchdog.nowayout=x<br>    ipmi_watchdog.panic_wdt_timeout=<t></p>
<p>The options are the same as the module parameter options.</p>
<p>The watchdog will panic and start a 120 second reset timeout if it<br>gets a pre-action.  During a panic or a reboot, the watchdog will<br>start a 120 timer if it is running to make sure the reboot occurs.</p>
<p>Note that if you use the NMI preaction for the watchdog, you MUST NOT<br>use the nmi watchdog.  There is no reasonable way to tell if an NMI<br>comes from the IPMI controller, so it must assume that if it gets an<br>otherwise unhandled NMI, it must be from IPMI and it will panic<br>immediately.</p>
<p>Once you open the watchdog timer, you must write a ‘V’ character to the<br>device to close it, or the timer will not stop.  This is a new semantic<br>for the driver, but makes it consistent with the rest of the watchdog<br>drivers in Linux.</p>
<h2 id="Panic-Timeouts"><a href="#Panic-Timeouts" class="headerlink" title="Panic Timeouts"></a>Panic Timeouts</h2><p>The OpenIPMI driver supports the ability to put semi-custom and custom<br>events in the system event log if a panic occurs.  if you enable the<br>‘Generate a panic event to all BMCs on a panic’ option, you will get<br>one event on a panic in a standard IPMI event format.  If you enable<br>the ‘Generate OEM events containing the panic string’ option, you will<br>also get a bunch of OEM events holding the panic string.</p>
<p>The field settings of the events are:</p>
<ul>
<li>Generator ID: 0x21 (kernel)</li>
<li>EvM Rev: 0x03 (this event is formatting in IPMI 1.0 format)</li>
<li>Sensor Type: 0x20 (OS critical stop sensor)</li>
<li>Sensor #: The first byte of the panic string (0 if no panic string)</li>
<li>Event Dir | Event Type: 0x6f (Assertion, sensor-specific event info)</li>
<li>Event Data 1: 0xa1 (Runtime stop in OEM bytes 2 and 3)</li>
<li>Event data 2: second byte of panic string</li>
<li>Event data 3: third byte of panic string<br>See the IPMI spec for the details of the event layout.  This event is<br>always sent to the local management controller.  It will handle routing<br>the message to the right place</li>
</ul>
<p>Other OEM events have the following format:<br>Record ID (bytes 0-1): Set by the SEL.<br>Record type (byte 2): 0xf0 (OEM non-timestamped)<br>byte 3: The slave address of the card saving the panic<br>byte 4: A sequence number (starting at zero)<br>The rest of the bytes (11 bytes) are the panic string.  If the panic string<br>is longer than 11 bytes, multiple messages will be sent with increasing<br>sequence numbers.</p>
<p>Because you cannot send OEM events using the standard interface, this<br>function will attempt to find an SEL and add the events there.  It<br>will first query the capabilities of the local management controller.<br>If it has an SEL, then they will be stored in the SEL of the local<br>management controller.  If not, and the local management controller is<br>an event generator, the event receiver from the local management<br>controller will be queried and the events sent to the SEL on that<br>device.  Otherwise, the events go nowhere since there is nowhere to<br>send them.</p>
<h2 id="Poweroff"><a href="#Poweroff" class="headerlink" title="Poweroff"></a>Poweroff</h2><p>If the poweroff capability is selected, the IPMI driver will install<br>a shutdown function into the standard poweroff function pointer.  This<br>is in the ipmi_poweroff module.  When the system requests a powerdown,<br>it will send the proper IPMI commands to do this.  This is supported on<br>several platforms.</p>
<p>There is a module parameter named “poweroff_powercycle” that may<br>either be zero (do a power down) or non-zero (do a power cycle, power<br>the system off, then power it on in a few seconds).  Setting<br>ipmi_poweroff.poweroff_control=x will do the same thing on the kernel<br>command line.  The parameter is also available via the proc filesystem<br>in /proc/sys/dev/ipmi/poweroff_powercycle.  Note that if the system<br>does not support power cycling, it will always do the power off.</p>
<p>The “ifnum_to_use” parameter specifies which interface the poweroff<br>code should use.  The default is -1, which means to pick the first one<br>registered.</p>
<p>Note that if you have ACPI enabled, the system will prefer using ACPI to<br>power off.</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_IPMI/" title="Kernel-3.10.0-957.el7_IPMI" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_IPMI/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_DMA-API/" title="Kernel-3.10.0-957.el7_DMA-API"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_Smack/" title="Kernel-3.10.0-957.el7_Smack"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>