<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-2.6.32-573.12.1.el6_DMA-mapping | oosTech.com</title>
  <meta name="description" content="Dynamic DMA mapping         &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;       David S. Miller &lt;davem@redhat.com&gt;      Richard Henderson &lt;rth@cygnus.com&gt;       Jakub Jelinek &lt;jakub@redhat.com&gt;  This">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-2.6.32-573.12.1.el6_DMA-mapping">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_DMA-mapping/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="Dynamic DMA mapping         &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;       David S. Miller &lt;davem@redhat.com&gt;      Richard Henderson &lt;rth@cygnus.com&gt;       Jakub Jelinek &lt;jakub@redhat.com&gt;  This">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_DMA-mapping/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-2.6.32-573.12.1.el6_DMA-mapping" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-2.6.32-573.12.1.el6_DMA-mapping
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_DMA-mapping/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_DMA-mapping/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_DMA-mapping/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <pre><code>        Dynamic DMA mapping
        ===================

     David S. Miller &lt;davem@redhat.com&gt;
     Richard Henderson &lt;rth@cygnus.com&gt;
      Jakub Jelinek &lt;jakub@redhat.com&gt;
</code></pre>
<p>This document describes the DMA mapping system in terms of the pci_<br>API.  For a similar API that works for generic devices, see<br>DMA-API.txt.</p>
<p>Most of the 64bit platforms have special hardware that translates bus<br>addresses (DMA addresses) into physical addresses.  This is similar to<br>how page tables and/or a TLB translates virtual addresses to physical<br>addresses on a CPU.  This is needed so that e.g. PCI devices can<br>access with a Single Address Cycle (32bit DMA address) any page in the<br>64bit physical address space.  Previously in Linux those 64bit<br>platforms had to set artificial limits on the maximum RAM size in the<br>system, so that the virt_to_bus() static scheme works (the DMA address<br>translation tables were simply filled on bootup to map each bus<br>address to the physical page __pa(bus_to_virt())).</p>
<p>So that Linux can use the dynamic DMA mapping, it needs some help from the<br>drivers, namely it has to take into account that DMA addresses should be<br>mapped only for the time they are actually used and unmapped after the DMA<br>transfer.</p>
<p>The following API will work of course even on platforms where no such<br>hardware exists, see e.g. arch/x86/include/asm/pci.h for how it is implemented on<br>top of the virt_to_bus interface.</p>
<p>First of all, you should make sure</p>
<p>#include &lt;linux/pci.h&gt;</p>
<p>is in your driver. This file will obtain for you the definition of the<br>dma_addr_t (which can hold any valid DMA address for the platform)<br>type which should be used everywhere you hold a DMA (bus) address<br>returned from the DMA mapping functions.</p>
<pre><code>         What memory is DMA&#39;able?
</code></pre>
<p>The first piece of information you must know is what kernel memory can<br>be used with the DMA mapping facilities.  There has been an unwritten<br>set of rules regarding this, and this text is an attempt to finally<br>write them down.</p>
<p>If you acquired your memory via the page allocator<br>(i.e. __get_free_page*()) or the generic memory allocators<br>(i.e. kmalloc() or kmem_cache_alloc()) then you may DMA to/from<br>that memory using the addresses returned from those routines.</p>
<p>This means specifically that you may <em>not</em> use the memory/addresses<br>returned from vmalloc() for DMA.  It is possible to DMA to the<br><em>underlying</em> memory mapped into a vmalloc() area, but this requires<br>walking page tables to get the physical addresses, and then<br>translating each of those pages back to a kernel address using<br>something like __va().  [ EDIT: Update this when we integrate<br>Gerd Knorr’s generic code which does this. ]</p>
<p>This rule also means that you may use neither kernel image addresses<br>(items in data/text/bss segments), nor module image addresses, nor<br>stack addresses for DMA.  These could all be mapped somewhere entirely<br>different than the rest of physical memory.  Even if those classes of<br>memory could physically work with DMA, you’d need to ensure the I/O<br>buffers were cacheline-aligned.  Without that, you’d see cacheline<br>sharing problems (data corruption) on CPUs with DMA-incoherent caches.<br>(The CPU could write to one word, DMA would write to a different one<br>in the same cache line, and one of them could be overwritten.)</p>
<p>Also, this means that you cannot take the return of a kmap()<br>call and DMA to/from that.  This is similar to vmalloc().</p>
<p>What about block I/O and networking buffers?  The block I/O and<br>networking subsystems make sure that the buffers they use are valid<br>for you to DMA from/to.</p>
<pre><code>        DMA addressing limitations
</code></pre>
<p>Does your device have any DMA addressing limitations?  For example, is<br>your device only capable of driving the low order 24-bits of address<br>on the PCI bus for SAC DMA transfers?  If so, you need to inform the<br>PCI layer of this fact.</p>
<p>By default, the kernel assumes that your device can address the full<br>32-bits in a SAC cycle.  For a 64-bit DAC capable device, this needs<br>to be increased.  And for a device with limitations, as discussed in<br>the previous paragraph, it needs to be decreased.</p>
<p>pci_alloc_consistent() by default will return 32-bit DMA addresses.<br>PCI-X specification requires PCI-X devices to support 64-bit<br>addressing (DAC) for all transactions. And at least one platform (SGI<br>SN2) requires 64-bit consistent allocations to operate correctly when<br>the IO bus is in PCI-X mode. Therefore, like with pci_set_dma_mask(),<br>it’s good practice to call pci_set_consistent_dma_mask() to set the<br>appropriate mask even if your device only supports 32-bit DMA<br>(default) and especially if it’s a PCI-X device.</p>
<p>For correct operation, you must interrogate the PCI layer in your<br>device probe routine to see if the PCI controller on the machine can<br>properly support the DMA addressing limitation your device has.  It is<br>good style to do this even if your device holds the default setting,<br>because this shows that you did think about these issues wrt. your<br>device.</p>
<p>The query is performed via a call to pci_set_dma_mask():</p>
<pre><code>int pci_set_dma_mask(struct pci_dev *pdev, u64 device_mask);
</code></pre>
<p>The query for consistent allocations is performed via a call to<br>pci_set_consistent_dma_mask():</p>
<pre><code>int pci_set_consistent_dma_mask(struct pci_dev *pdev, u64 device_mask);
</code></pre>
<p>Here, pdev is a pointer to the PCI device struct of your device, and<br>device_mask is a bit mask describing which bits of a PCI address your<br>device supports.  It returns zero if your card can perform DMA<br>properly on the machine given the address mask you provided.</p>
<p>If it returns non-zero, your device cannot perform DMA properly on<br>this platform, and attempting to do so will result in undefined<br>behavior.  You must either use a different mask, or not use DMA.</p>
<p>This means that in the failure case, you have three options:</p>
<ol>
<li>Use another DMA mask, if possible (see below).</li>
<li>Use some non-DMA mode for data transfer, if possible.</li>
<li>Ignore this device and do not initialize it.</li>
</ol>
<p>It is recommended that your driver print a kernel KERN_WARNING message<br>when you end up performing either #2 or #3.  In this manner, if a user<br>of your driver reports that performance is bad or that the device is not<br>even detected, you can ask them for the kernel messages to find out<br>exactly why.</p>
<p>The standard 32-bit addressing PCI device would do something like<br>this:</p>
<pre><code>if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) &#123;
    printk(KERN_WARNING
           &quot;mydev: No suitable DMA available.\n&quot;);
    goto ignore_this_device;
&#125;
</code></pre>
<p>Another common scenario is a 64-bit capable device.  The approach<br>here is to try for 64-bit DAC addressing, but back down to a<br>32-bit mask should that fail.  The PCI platform code may fail the<br>64-bit mask not because the platform is not capable of 64-bit<br>addressing.  Rather, it may fail in this case simply because<br>32-bit SAC addressing is done more efficiently than DAC addressing.<br>Sparc64 is one platform which behaves in this way.</p>
<p>Here is how you would handle a 64-bit capable device which can drive<br>all 64-bits when accessing streaming DMA:</p>
<pre><code>int using_dac;

if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(64))) &#123;
    using_dac = 1;
&#125; else if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) &#123;
    using_dac = 0;
&#125; else &#123;
    printk(KERN_WARNING
           &quot;mydev: No suitable DMA available.\n&quot;);
    goto ignore_this_device;
&#125;
</code></pre>
<p>If a card is capable of using 64-bit consistent allocations as well,<br>the case would look like this:</p>
<pre><code>int using_dac, consistent_using_dac;

if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(64))) &#123;
    using_dac = 1;
       consistent_using_dac = 1;
    pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));
&#125; else if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) &#123;
    using_dac = 0;
    consistent_using_dac = 0;
    pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));
&#125; else &#123;
    printk(KERN_WARNING
           &quot;mydev: No suitable DMA available.\n&quot;);
    goto ignore_this_device;
&#125;
</code></pre>
<p>pci_set_consistent_dma_mask() will always be able to set the same or a<br>smaller mask as pci_set_dma_mask(). However for the rare case that a<br>device driver only uses consistent allocations, one would have to<br>check the return value from pci_set_consistent_dma_mask().</p>
<p>Finally, if your device can only drive the low 24-bits of<br>address during PCI bus mastering you might do something like:</p>
<pre><code>if (pci_set_dma_mask(pdev, DMA_BIT_MASK(24))) &#123;
    printk(KERN_WARNING
           &quot;mydev: 24-bit DMA addressing not available.\n&quot;);
    goto ignore_this_device;
&#125;
</code></pre>
<p>When pci_set_dma_mask() is successful, and returns zero, the PCI layer<br>saves away this mask you have provided.  The PCI layer will use this<br>information later when you make DMA mappings.</p>
<p>There is a case which we are aware of at this time, which is worth<br>mentioning in this documentation.  If your device supports multiple<br>functions (for example a sound card provides playback and record<br>functions) and the various different functions have <em>different</em><br>DMA addressing limitations, you may wish to probe each mask and<br>only provide the functionality which the machine can handle.  It<br>is important that the last call to pci_set_dma_mask() be for the<br>most specific mask.</p>
<p>Here is pseudo-code showing how this might be done:</p>
<pre><code>#define PLAYBACK_ADDRESS_BITS    DMA_BIT_MASK(32)
#define RECORD_ADDRESS_BITS    0x00ffffff

struct my_sound_card *card;
struct pci_dev *pdev;

...
if (!pci_set_dma_mask(pdev, PLAYBACK_ADDRESS_BITS)) &#123;
    card-&gt;playback_enabled = 1;
&#125; else &#123;
    card-&gt;playback_enabled = 0;
    printk(KERN_WARN &quot;%s: Playback disabled due to DMA limitations.\n&quot;,
           card-&gt;name);
&#125;
if (!pci_set_dma_mask(pdev, RECORD_ADDRESS_BITS)) &#123;
    card-&gt;record_enabled = 1;
&#125; else &#123;
    card-&gt;record_enabled = 0;
    printk(KERN_WARN &quot;%s: Record disabled due to DMA limitations.\n&quot;,
           card-&gt;name);
&#125;
</code></pre>
<p>A sound card was used as an example here because this genre of PCI<br>devices seems to be littered with ISA chips given a PCI front end,<br>and thus retaining the 16MB DMA addressing limitations of ISA.</p>
<pre><code>        Types of DMA mappings
</code></pre>
<p>There are two types of DMA mappings:</p>
<ul>
<li><p>Consistent DMA mappings which are usually mapped at driver<br>initialization, unmapped at the end and for which the hardware should<br>guarantee that the device and the CPU can access the data<br>in parallel and will see updates made by each other without any<br>explicit software flushing.</p>
<p>Think of “consistent” as “synchronous” or “coherent”.</p>
<p>The current default is to return consistent memory in the low 32<br>bits of the PCI bus space.  However, for future compatibility you<br>should set the consistent mask even if this default is fine for your<br>driver.</p>
<p>Good examples of what to use consistent mappings for are:</p>
<ul>
<li>Network card DMA ring descriptors.</li>
<li>SCSI adapter mailbox command data structures.</li>
<li>Device firmware microcode executed out of<br>main memory.</li>
</ul>
<p>The invariant these examples all require is that any CPU store<br>to memory is immediately visible to the device, and vice<br>versa.  Consistent mappings guarantee this.</p>
<p>IMPORTANT: Consistent DMA memory does not preclude the usage of</p>
<pre><code>       proper memory barriers.  The CPU may reorder stores to
   consistent memory just as it may normal memory.  Example:
   if it is important for the device to see the first word
   of a descriptor updated before the second, you must do
   something like:

  desc-&gt;word0 = address;
  wmb();
  desc-&gt;word1 = DESC_VALID;

       in order to get correct behavior on all platforms.

   Also, on some platforms your driver may need to flush CPU write
   buffers in much the same way as it needs to flush write buffers
   found in PCI bridges (such as by reading a register&#39;s value
   after writing it).
</code></pre>
</li>
<li><p>Streaming DMA mappings which are usually mapped for one DMA transfer,<br>unmapped right after it (unless you use pci_dma_sync_* below) and for which<br>hardware can optimize for sequential accesses.</p>
<p>This of “streaming” as “asynchronous” or “outside the coherency<br>domain”.</p>
<p>Good examples of what to use streaming mappings for are:</p>
<ul>
<li>Networking buffers transmitted/received by a device.</li>
<li>Filesystem buffers written/read by a SCSI device.</li>
</ul>
<p>The interfaces for using this type of mapping were designed in<br>such a way that an implementation can make whatever performance<br>optimizations the hardware allows.  To this end, when using<br>such mappings you must be explicit about what you want to happen.</p>
</li>
</ul>
<p>Neither type of DMA mapping has alignment restrictions that come<br>from PCI, although some devices may have such restrictions.<br>Also, systems with caches that aren’t DMA-coherent will work better<br>when the underlying buffers don’t share cache lines with other data.</p>
<pre><code>     Using Consistent DMA mappings.
</code></pre>
<p>To allocate and map large (PAGE_SIZE or so) consistent DMA regions,<br>you should do:</p>
<pre><code>dma_addr_t dma_handle;

cpu_addr = pci_alloc_consistent(pdev, size, &amp;dma_handle);
</code></pre>
<p>where pdev is a struct pci_dev *. This may be called in interrupt context.<br>You should use dma_alloc_coherent (see DMA-API.txt) for buses<br>where devices don’t have struct pci_dev (like ISA, EISA).</p>
<p>This argument is needed because the DMA translations may be bus<br>specific (and often is private to the bus which the device is attached<br>to).</p>
<p>Size is the length of the region you want to allocate, in bytes.</p>
<p>This routine will allocate RAM for that region, so it acts similarly to<br>__get_free_pages (but takes size instead of a page order).  If your<br>driver needs regions sized smaller than a page, you may prefer using<br>the pci_pool interface, described below.</p>
<p>The consistent DMA mapping interfaces, for non-NULL pdev, will by<br>default return a DMA address which is SAC (Single Address Cycle)<br>addressable.  Even if the device indicates (via PCI dma mask) that it<br>may address the upper 32-bits and thus perform DAC cycles, consistent<br>allocation will only return &gt; 32-bit PCI addresses for DMA if the<br>consistent dma mask has been explicitly changed via<br>pci_set_consistent_dma_mask().  This is true of the pci_pool interface<br>as well.</p>
<p>pci_alloc_consistent returns two values: the virtual address which you<br>can use to access it from the CPU and dma_handle which you pass to the<br>card.</p>
<p>The cpu return address and the DMA bus master address are both<br>guaranteed to be aligned to the smallest PAGE_SIZE order which<br>is greater than or equal to the requested size.  This invariant<br>exists (for example) to guarantee that if you allocate a chunk<br>which is smaller than or equal to 64 kilobytes, the extent of the<br>buffer you receive will not cross a 64K boundary.</p>
<p>To unmap and free such a DMA region, you call:</p>
<pre><code>pci_free_consistent(pdev, size, cpu_addr, dma_handle);
</code></pre>
<p>where pdev, size are the same as in the above call and cpu_addr and<br>dma_handle are the values pci_alloc_consistent returned to you.<br>This function may not be called in interrupt context.</p>
<p>If your driver needs lots of smaller memory regions, you can write<br>custom code to subdivide pages returned by pci_alloc_consistent,<br>or you can use the pci_pool API to do that.  A pci_pool is like<br>a kmem_cache, but it uses pci_alloc_consistent not __get_free_pages.<br>Also, it understands common hardware constraints for alignment,<br>like queue heads needing to be aligned on N byte boundaries.</p>
<p>Create a pci_pool like this:</p>
<pre><code>struct pci_pool *pool;

pool = pci_pool_create(name, pdev, size, align, alloc);
</code></pre>
<p>The “name” is for diagnostics (like a kmem_cache name); pdev and size<br>are as above.  The device’s hardware alignment requirement for this<br>type of data is “align” (which is expressed in bytes, and must be a<br>power of two).  If your device has no boundary crossing restrictions,<br>pass 0 for alloc; passing 4096 says memory allocated from this pool<br>must not cross 4KByte boundaries (but at that time it may be better to<br>go for pci_alloc_consistent directly instead).</p>
<p>Allocate memory from a pci pool like this:</p>
<pre><code>cpu_addr = pci_pool_alloc(pool, flags, &amp;dma_handle);
</code></pre>
<p>flags are SLAB_KERNEL if blocking is permitted (not in_interrupt nor<br>holding SMP locks), SLAB_ATOMIC otherwise.  Like pci_alloc_consistent,<br>this returns two values, cpu_addr and dma_handle.</p>
<p>Free memory that was allocated from a pci_pool like this:</p>
<pre><code>pci_pool_free(pool, cpu_addr, dma_handle);
</code></pre>
<p>where pool is what you passed to pci_pool_alloc, and cpu_addr and<br>dma_handle are the values pci_pool_alloc returned. This function<br>may be called in interrupt context.</p>
<p>Destroy a pci_pool by calling:</p>
<pre><code>pci_pool_destroy(pool);
</code></pre>
<p>Make sure you’ve called pci_pool_free for all memory allocated<br>from a pool before you destroy the pool. This function may not<br>be called in interrupt context.</p>
<pre><code>        DMA Direction
</code></pre>
<p>The interfaces described in subsequent portions of this document<br>take a DMA direction argument, which is an integer and takes on<br>one of the following values:</p>
<p> PCI_DMA_BIDIRECTIONAL<br> PCI_DMA_TODEVICE<br> PCI_DMA_FROMDEVICE<br> PCI_DMA_NONE</p>
<p>One should provide the exact DMA direction if you know it.</p>
<p>PCI_DMA_TODEVICE means “from main memory to the PCI device”<br>PCI_DMA_FROMDEVICE means “from the PCI device to main memory”<br>It is the direction in which the data moves during the DMA<br>transfer.</p>
<p>You are <em>strongly</em> encouraged to specify this as precisely<br>as you possibly can.</p>
<p>If you absolutely cannot know the direction of the DMA transfer,<br>specify PCI_DMA_BIDIRECTIONAL.  It means that the DMA can go in<br>either direction.  The platform guarantees that you may legally<br>specify this, and that it will work, but this may be at the<br>cost of performance for example.</p>
<p>The value PCI_DMA_NONE is to be used for debugging.  One can<br>hold this in a data structure before you come to know the<br>precise direction, and this will help catch cases where your<br>direction tracking logic has failed to set things up properly.</p>
<p>Another advantage of specifying this value precisely (outside of<br>potential platform-specific optimizations of such) is for debugging.<br>Some platforms actually have a write permission boolean which DMA<br>mappings can be marked with, much like page protections in the user<br>program address space.  Such platforms can and do report errors in the<br>kernel logs when the PCI controller hardware detects violation of the<br>permission setting.</p>
<p>Only streaming mappings specify a direction, consistent mappings<br>implicitly have a direction attribute setting of<br>PCI_DMA_BIDIRECTIONAL.</p>
<p>The SCSI subsystem tells you the direction to use in the<br>‘sc_data_direction’ member of the SCSI command your driver is<br>working on.</p>
<p>For Networking drivers, it’s a rather simple affair.  For transmit<br>packets, map/unmap them with the PCI_DMA_TODEVICE direction<br>specifier.  For receive packets, just the opposite, map/unmap them<br>with the PCI_DMA_FROMDEVICE direction specifier.</p>
<pre><code>      Using Streaming DMA mappings
</code></pre>
<p>The streaming DMA mapping routines can be called from interrupt<br>context.  There are two versions of each map/unmap, one which will<br>map/unmap a single memory region, and one which will map/unmap a<br>scatterlist.</p>
<p>To map a single region, you do:</p>
<pre><code>struct pci_dev *pdev = mydev-&gt;pdev;
dma_addr_t dma_handle;
void *addr = buffer-&gt;ptr;
size_t size = buffer-&gt;len;

dma_handle = pci_map_single(pdev, addr, size, direction);
</code></pre>
<p>and to unmap it:</p>
<pre><code>pci_unmap_single(pdev, dma_handle, size, direction);
</code></pre>
<p>You should call pci_unmap_single when the DMA activity is finished, e.g.<br>from the interrupt which told you that the DMA transfer is done.</p>
<p>Using cpu pointers like this for single mappings has a disadvantage,<br>you cannot reference HIGHMEM memory in this way.  Thus, there is a<br>map/unmap interface pair akin to pci_{map,unmap}_single.  These<br>interfaces deal with page/offset pairs instead of cpu pointers.<br>Specifically:</p>
<pre><code>struct pci_dev *pdev = mydev-&gt;pdev;
dma_addr_t dma_handle;
struct page *page = buffer-&gt;page;
unsigned long offset = buffer-&gt;offset;
size_t size = buffer-&gt;len;

dma_handle = pci_map_page(pdev, page, offset, size, direction);

...

pci_unmap_page(pdev, dma_handle, size, direction);
</code></pre>
<p>Here, “offset” means byte offset within the given page.</p>
<p>With scatterlists, you map a region gathered from several regions by:</p>
<pre><code>int i, count = pci_map_sg(pdev, sglist, nents, direction);
struct scatterlist *sg;

for_each_sg(sglist, sg, count, i) &#123;
    hw_address[i] = sg_dma_address(sg);
    hw_len[i] = sg_dma_len(sg);
&#125;
</code></pre>
<p>where nents is the number of entries in the sglist.</p>
<p>The implementation is free to merge several consecutive sglist entries<br>into one (e.g. if DMA mapping is done with PAGE_SIZE granularity, any<br>consecutive sglist entries can be merged into one provided the first one<br>ends and the second one starts on a page boundary - in fact this is a huge<br>advantage for cards which either cannot do scatter-gather or have very<br>limited number of scatter-gather entries) and returns the actual number<br>of sg entries it mapped them to. On failure 0 is returned.</p>
<p>Then you should loop count times (note: this can be less than nents times)<br>and use sg_dma_address() and sg_dma_len() macros where you previously<br>accessed sg-&gt;address and sg-&gt;length as shown above.</p>
<p>To unmap a scatterlist, just call:</p>
<pre><code>pci_unmap_sg(pdev, sglist, nents, direction);
</code></pre>
<p>Again, make sure DMA activity has already finished.</p>
<p>PLEASE NOTE:  The ‘nents’ argument to the pci_unmap_sg call must be<br>              the <em>same</em> one you passed into the pci_map_sg call,<br>          it should <em>NOT</em> be the ‘count’ value <em>returned</em> from the<br>              pci_map_sg call.</p>
<p>Every pci_map_{single,sg} call should have its pci_unmap_{single,sg}<br>counterpart, because the bus address space is a shared resource (although<br>in some ports the mapping is per each BUS so less devices contend for the<br>same bus address space) and you could render the machine unusable by eating<br>all bus addresses.</p>
<p>If you need to use the same streaming DMA region multiple times and touch<br>the data in between the DMA transfers, the buffer needs to be synced<br>properly in order for the cpu and device to see the most uptodate and<br>correct copy of the DMA buffer.</p>
<p>So, firstly, just map it with pci_map_{single,sg}, and after each DMA<br>transfer call either:</p>
<pre><code>pci_dma_sync_single_for_cpu(pdev, dma_handle, size, direction);
</code></pre>
<p>or:</p>
<pre><code>pci_dma_sync_sg_for_cpu(pdev, sglist, nents, direction);
</code></pre>
<p>as appropriate.</p>
<p>Then, if you wish to let the device get at the DMA area again,<br>finish accessing the data with the cpu, and then before actually<br>giving the buffer to the hardware call either:</p>
<pre><code>pci_dma_sync_single_for_device(pdev, dma_handle, size, direction);
</code></pre>
<p>or:</p>
<pre><code>pci_dma_sync_sg_for_device(dev, sglist, nents, direction);
</code></pre>
<p>as appropriate.</p>
<p>After the last DMA transfer call one of the DMA unmap routines<br>pci_unmap_{single,sg}. If you don’t touch the data from the first pci_map_*<br>call till pci_unmap_*, then you don’t have to call the pci_dma_sync_*<br>routines at all.</p>
<p>Here is pseudo code which shows a situation in which you would need<br>to use the pci_dma_sync_*() interfaces.</p>
<pre><code>my_card_setup_receive_buffer(struct my_card *cp, char *buffer, int len)
&#123;
    dma_addr_t mapping;

    mapping = pci_map_single(cp-&gt;pdev, buffer, len, PCI_DMA_FROMDEVICE);

    cp-&gt;rx_buf = buffer;
    cp-&gt;rx_len = len;
    cp-&gt;rx_dma = mapping;

    give_rx_buf_to_card(cp);
&#125;

...

my_card_interrupt_handler(int irq, void *devid, struct pt_regs *regs)
&#123;
    struct my_card *cp = devid;

    ...
    if (read_card_status(cp) == RX_BUF_TRANSFERRED) &#123;
        struct my_card_header *hp;

        /* Examine the header to see if we wish
         * to accept the data.  But synchronize
         * the DMA transfer with the CPU first
         * so that we see updated contents.
         */
        pci_dma_sync_single_for_cpu(cp-&gt;pdev, cp-&gt;rx_dma,
                        cp-&gt;rx_len,
                        PCI_DMA_FROMDEVICE);

        /* Now it is safe to examine the buffer. */
        hp = (struct my_card_header *) cp-&gt;rx_buf;
        if (header_is_ok(hp)) &#123;
            pci_unmap_single(cp-&gt;pdev, cp-&gt;rx_dma, cp-&gt;rx_len,
                     PCI_DMA_FROMDEVICE);
            pass_to_upper_layers(cp-&gt;rx_buf);
            make_and_setup_new_rx_buf(cp);
        &#125; else &#123;
            /* Just sync the buffer and give it back
             * to the card.
             */
            pci_dma_sync_single_for_device(cp-&gt;pdev,
                               cp-&gt;rx_dma,
                               cp-&gt;rx_len,
                               PCI_DMA_FROMDEVICE);
            give_rx_buf_to_card(cp);
        &#125;
    &#125;
&#125;
</code></pre>
<p>Drivers converted fully to this interface should not use virt_to_bus any<br>longer, nor should they use bus_to_virt. Some drivers have to be changed a<br>little bit, because there is no longer an equivalent to bus_to_virt in the<br>dynamic DMA mapping scheme - you have to always store the DMA addresses<br>returned by the pci_alloc_consistent, pci_pool_alloc, and pci_map_single<br>calls (pci_map_sg stores them in the scatterlist itself if the platform<br>supports dynamic DMA mapping in hardware) in your driver structures and/or<br>in the card registers.</p>
<p>All PCI drivers should be using these interfaces with no exceptions.<br>It is planned to completely remove virt_to_bus() and bus_to_virt() as<br>they are entirely deprecated.  Some ports already do not provide these<br>as it is impossible to correctly support them.</p>
<pre><code>    Optimizing Unmap State Space Consumption
</code></pre>
<p>On many platforms, pci_unmap_{single,page}() is simply a nop.<br>Therefore, keeping track of the mapping address and length is a waste<br>of space.  Instead of filling your drivers up with ifdefs and the like<br>to “work around” this (which would defeat the whole purpose of a<br>portable API) the following facilities are provided.</p>
<p>Actually, instead of describing the macros one by one, we’ll<br>transform some example code.</p>
<ol>
<li><p>Use DECLARE_PCI_UNMAP_{ADDR,LEN} in state saving structures.<br>Example, before:</p>
<p> struct ring_state {</p>
<pre><code> struct sk_buff *skb;
 dma_addr_t mapping;
 __u32 len;
</code></pre>
<p> };</p>
<p>after:</p>
<p> struct ring_state {</p>
<pre><code> struct sk_buff *skb;
 DECLARE_PCI_UNMAP_ADDR(mapping)
 DECLARE_PCI_UNMAP_LEN(len)
</code></pre>
<p> };</p>
<p>NOTE: DO NOT put a semicolon at the end of the DECLARE_*()</p>
<pre><code>  macro.
</code></pre>
</li>
<li><p>Use pci_unmap_{addr,len}_set to set these values.<br>Example, before:</p>
<p> ringp-&gt;mapping = FOO;<br> ringp-&gt;len = BAR;</p>
<p>after:</p>
<p> pci_unmap_addr_set(ringp, mapping, FOO);<br> pci_unmap_len_set(ringp, len, BAR);</p>
</li>
<li><p>Use pci_unmap_{addr,len} to access these values.<br>Example, before:</p>
<p> pci_unmap_single(pdev, ringp-&gt;mapping, ringp-&gt;len,</p>
<pre><code>      PCI_DMA_FROMDEVICE);
</code></pre>
<p>after:</p>
<p> pci_unmap_single(pdev,</p>
<pre><code>      pci_unmap_addr(ringp, mapping),
      pci_unmap_len(ringp, len),
      PCI_DMA_FROMDEVICE);
</code></pre>
</li>
</ol>
<p>It really should be self-explanatory.  We treat the ADDR and LEN<br>separately, because it is possible for an implementation to only<br>need the address in order to perform the unmap operation.</p>
<pre><code>        Platform Issues
</code></pre>
<p>If you are just writing drivers for Linux and do not maintain<br>an architecture port for the kernel, you can safely skip down<br>to “Closing”.</p>
<ol>
<li><p>Struct scatterlist requirements.</p>
<p>Struct scatterlist must contain, at a minimum, the following<br>members:</p>
<p> struct page *page;<br> unsigned int offset;<br> unsigned int length;</p>
<p>The base address is specified by a “page+offset” pair.</p>
<p>Previous versions of struct scatterlist contained a “void *address”<br>field that was sometimes used instead of page+offset.  As of Linux<br>2.5., page+offset is always used, and the “address” field has been<br>deleted.</p>
</li>
<li><p>More to come…</p>
<pre><code>     Handling Errors
</code></pre>
</li>
</ol>
<p>DMA address space is limited on some architectures and an allocation<br>failure can be determined by:</p>
<ul>
<li><p>checking if pci_alloc_consistent returns NULL or pci_map_sg returns 0</p>
</li>
<li><p>checking the returned dma_addr_t of pci_map_single and pci_map_page<br>by using pci_dma_mapping_error():</p>
<p>  dma_addr_t dma_handle;</p>
<p>  dma_handle = pci_map_single(pdev, addr, size, direction);<br>  if (pci_dma_mapping_error(pdev, dma_handle)) {</p>
<pre><code>  /*
   * reduce current DMA mapping usage,
   * delay and try again later or
   * reset driver.
   */
</code></pre>
<p>  }</p>
<pre><code>         Closing
</code></pre>
</li>
</ul>
<p>This document, and the API itself, would not be in it’s current<br>form without the feedback and suggestions from numerous individuals.<br>We would like to specifically mention, in no particular order, the<br>following people:</p>
<pre><code>Russell King &lt;rmk@arm.linux.org.uk&gt;
Leo Dagum &lt;dagum@barrel.engr.sgi.com&gt;
Ralf Baechle &lt;ralf@oss.sgi.com&gt;
Grant Grundler &lt;grundler@cup.hp.com&gt;
Jay Estabrook &lt;Jay.Estabrook@compaq.com&gt;
Thomas Sailer &lt;sailer@ife.ee.ethz.ch&gt;
Andrea Arcangeli &lt;andrea@suse.de&gt;
Jens Axboe &lt;jens.axboe@oracle.com&gt;
David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;
</code></pre>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_DMA-mapping/" title="Kernel-2.6.32-573.12.1.el6_DMA-mapping" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_DMA-mapping/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_IPMI/" title="Kernel-2.6.32-573.12.1.el6_IPMI"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_DMA-API/" title="Kernel-2.6.32-573.12.1.el6_DMA-API"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>