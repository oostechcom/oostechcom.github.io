<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-2.6.32-573.12.1.el6_booting-without-of | oosTech.com</title>
  <meta name="description" content="Booting the Linux&#x2F;ppc kernel without Open Firmware        --------------------------------------------------  (c) 2005 Benjamin Herrenschmidt ,    IBM Corp.(c) 2005 Becky Bruce &lt;becky.bruce">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-2.6.32-573.12.1.el6_booting-without-of">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_booting-without-of/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="Booting the Linux&#x2F;ppc kernel without Open Firmware        --------------------------------------------------  (c) 2005 Benjamin Herrenschmidt ,    IBM Corp.(c) 2005 Becky Bruce &lt;becky.bruce">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_booting-without-of/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Table-of-Contents"><span class="toc-number">1.</span> <span class="toc-text">Table of Contents</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Revision-Information"><span class="toc-number">2.</span> <span class="toc-text">Revision Information</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#I-Introduction"><span class="toc-number">3.</span> <span class="toc-text">I - Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#II-The-DT-block-format"><span class="toc-number">4.</span> <span class="toc-text">II - The DT block format</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#III-Required-content-of-the-device-tree"><span class="toc-number">5.</span> <span class="toc-text">III - Required content of the device tree</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IV-%E2%80%9Cdtc%E2%80%9D-the-device-tree-compiler"><span class="toc-number">6.</span> <span class="toc-text">IV - “dtc”, the device tree compiler</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Input-formats"><span class="toc-number">6.1.</span> <span class="toc-text">  Input formats:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Output-formats"><span class="toc-number">6.2.</span> <span class="toc-text"> Output formats:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#V-Recommendations-for-a-bootloader"><span class="toc-number">7.</span> <span class="toc-text">V - Recommendations for a bootloader</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VI-System-on-a-chip-devices-and-nodes"><span class="toc-number">8.</span> <span class="toc-text">VI - System-on-a-chip devices and nodes</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VII-Specifying-interrupt-information-for-devices"><span class="toc-number">9.</span> <span class="toc-text">VII - Specifying interrupt information for devices</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VIII-Specifying-Device-Power-Management-Information-sleep-property"><span class="toc-number">10.</span> <span class="toc-text">VIII - Specifying Device Power Management Information (sleep property)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Appendix-A-Sample-SOC-node-for-MPC8540"><span class="toc-number">11.</span> <span class="toc-text">Appendix A - Sample SOC node for MPC8540</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-2.6.32-573.12.1.el6_booting-without-of" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-2.6.32-573.12.1.el6_booting-without-of
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_booting-without-of/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_booting-without-of/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_booting-without-of/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <pre><code>       Booting the Linux/ppc kernel without Open Firmware
       --------------------------------------------------
</code></pre>
<p>(c) 2005 Benjamin Herrenschmidt <benh at kernel.crashing.org>,<br>    IBM Corp.<br>(c) 2005 Becky Bruce &lt;becky.bruce at freescale.com&gt;,<br>    Freescale Semiconductor, FSL SOC and 32-bit additions<br>(c) 2006 MontaVista Software, Inc.<br>    Flash chip node definition</p>
<h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><p>  I - Introduction<br>    1) Entry point for arch/powerpc<br>    2) Board support</p>
<p>  II - The DT block format<br>    1) Header<br>    2) Device tree generalities<br>    3) Device tree “structure” block<br>    4) Device tree “strings” block</p>
<p>  III - Required content of the device tree<br>    1) Note about cells and address representation<br>    2) Note about “compatible” properties<br>    3) Note about “name” properties<br>    4) Note about node and property names and character set<br>    5) Required nodes and properties<br>      a) The root node<br>      b) The /cpus node<br>      c) The /cpus/* nodes<br>      d) the /memory node(s)<br>      e) The /chosen node<br>      f) the /soc<SOCname> node</p>
<p>  IV - “dtc”, the device tree compiler</p>
<p>  V - Recommendations for a bootloader</p>
<p>  VI - System-on-a-chip devices and nodes<br>    1) Defining child nodes of an SOC<br>    2) Representing devices without a current OF specification<br>      a) PHY nodes<br>      b) Interrupt controllers<br>      c) 4xx/Axon EMAC ethernet nodes<br>      d) Xilinx IP cores<br>      e) USB EHCI controllers<br>      f) MDIO on GPIOs<br>      g) SPI busses</p>
<p>  VII - Marvell Discovery mv64[345]6x System Controller chips<br>    1) The /system-controller node<br>    2) Child nodes of /system-controller<br>      a) Marvell Discovery MDIO bus<br>      b) Marvell Discovery ethernet controller<br>      c) Marvell Discovery PHY nodes<br>      d) Marvell Discovery SDMA nodes<br>      e) Marvell Discovery BRG nodes<br>      f) Marvell Discovery CUNIT nodes<br>      g) Marvell Discovery MPSCROUTING nodes<br>      h) Marvell Discovery MPSCINTR nodes<br>      i) Marvell Discovery MPSC nodes<br>      j) Marvell Discovery Watch Dog Timer nodes<br>      k) Marvell Discovery I2C nodes<br>      l) Marvell Discovery PIC (Programmable Interrupt Controller) nodes<br>      m) Marvell Discovery MPP (Multipurpose Pins) multiplexing nodes<br>      n) Marvell Discovery GPP (General Purpose Pins) nodes<br>      o) Marvell Discovery PCI host bridge node<br>      p) Marvell Discovery CPU Error nodes<br>      q) Marvell Discovery SRAM Controller nodes<br>      r) Marvell Discovery PCI Error Handler nodes<br>      s) Marvell Discovery Memory Controller nodes</p>
<p>  VIII - Specifying interrupt information for devices<br>    1) interrupts property<br>    2) interrupt-parent property<br>    3) OpenPIC Interrupt Controllers<br>    4) ISA Interrupt Controllers</p>
<p>  IX - Specifying GPIO information for devices<br>    1) gpios property<br>    2) gpio-controller nodes</p>
<p>  X - Specifying device power management information (sleep property)</p>
<p>  Appendix A - Sample SOC node for MPC8540</p>
<h1 id="Revision-Information"><a href="#Revision-Information" class="headerlink" title="Revision Information"></a>Revision Information</h1><p>   May 18, 2005: Rev 0.1 - Initial draft, no chapter III yet.</p>
<p>   May 19, 2005: Rev 0.2 - Add chapter III and bits &amp; pieces here or<br>                           clarifies the fact that a lot of things are<br>                           optional, the kernel only requires a very<br>                           small device tree, though it is encouraged<br>                           to provide an as complete one as possible.</p>
<p>   May 24, 2005: Rev 0.3 - Precise that DT block has to be in RAM<br>             - Misc fixes<br>             - Define version 3 and new format version 16<br>               for the DT block (version 16 needs kernel<br>               patches, will be fwd separately).<br>               String block now has a size, and full path<br>               is replaced by unit name for more<br>               compactness.<br>               linux,phandle is made optional, only nodes<br>               that are referenced by other nodes need it.<br>               “name” property is now automatically<br>               deduced from the unit name</p>
<p>   June 1, 2005: Rev 0.4 - Correct confusion between OF_DT_END and<br>                           OF_DT_END_NODE in structure definition.<br>                         - Change version 16 format to always align<br>                           property data to 4 bytes. Since tokens are<br>                           already aligned, that means no specific<br>                           required alignment between property size<br>                           and property data. The old style variable<br>                           alignment would make it impossible to do<br>                           “simple” insertion of properties using<br>                           memmove (thanks Milton for<br>                           noticing). Updated kernel patch as well<br>             - Correct a few more alignment constraints<br>             - Add a chapter about the device-tree<br>                           compiler and the textural representation of<br>                           the tree that can be “compiled” by dtc.</p>
<p>   November 21, 2005: Rev 0.5<br>             - Additions/generalizations for 32-bit<br>             - Changed to reflect the new arch/powerpc<br>               structure<br>             - Added chapter VI</p>
<p> ToDo:<br>    - Add some definitions of interrupt tree (simple/complex)<br>    - Add some definitions for PCI host bridges<br>    - Add some common address format examples<br>    - Add definitions for standard properties and “compatible”<br>      names for cells that are not already defined by the existing<br>      OF spec.<br>    - Compare FSL SOC use of PCI to standard and make sure no new<br>      node definition required.<br>    - Add more information about node definitions for SOC devices<br>        that currently have no standard, like the FSL CPM.</p>
<h1 id="I-Introduction"><a href="#I-Introduction" class="headerlink" title="I - Introduction"></a>I - Introduction</h1><p>During the recent development of the Linux/ppc64 kernel, and more<br>specifically, the addition of new platform types outside of the old<br>IBM pSeries/iSeries pair, it was decided to enforce some strict rules<br>regarding the kernel entry and bootloader &lt;-&gt; kernel interfaces, in<br>order to avoid the degeneration that had become the ppc32 kernel entry<br>point and the way a new platform should be added to the kernel. The<br>legacy iSeries platform breaks those rules as it predates this scheme,<br>but no new board support will be accepted in the main tree that<br>doesn’t follows them properly.  In addition, since the advent of the<br>arch/powerpc merged architecture for ppc32 and ppc64, new 32-bit<br>platforms and 32-bit platforms which move into arch/powerpc will be<br>required to use these rules as well.</p>
<p>The main requirement that will be defined in more detail below is<br>the presence of a device-tree whose format is defined after Open<br>Firmware specification. However, in order to make life easier<br>to embedded board vendors, the kernel doesn’t require the device-tree<br>to represent every device in the system and only requires some nodes<br>and properties to be present. This will be described in detail in<br>section III, but, for example, the kernel does not require you to<br>create a node for every PCI device in the system. It is a requirement<br>to have a node for PCI host bridges in order to provide interrupt<br>routing informations and memory/IO ranges, among others. It is also<br>recommended to define nodes for on chip devices and other busses that<br>don’t specifically fit in an existing OF specification. This creates a<br>great flexibility in the way the kernel can then probe those and match<br>drivers to device, without having to hard code all sorts of tables. It<br>also makes it more flexible for board vendors to do minor hardware<br>upgrades without significantly impacting the kernel code or cluttering<br>it with special cases.</p>
<ol>
<li>Entry point for arch/powerpc</li>
</ol>
<hr>
<p>   There is one and one single entry point to the kernel, at the start<br>   of the kernel image. That entry point supports two calling<br>   conventions:</p>
<pre><code>    a) Boot from Open Firmware. If your firmware is compatible
    with Open Firmware (IEEE 1275) or provides an OF compatible
    client interface API (support for &quot;interpret&quot; callback of
    forth words isn&#39;t required), you can enter the kernel with:

          r5 : OF callback pointer as defined by IEEE 1275
          bindings to powerpc. Only the 32-bit client interface
          is currently supported

          r3, r4 : address &amp; length of an initrd if any or 0

          The MMU is either on or off; the kernel will run the
          trampoline located in arch/powerpc/kernel/prom_init.c to
          extract the device-tree and other information from open
          firmware and build a flattened device-tree as described
          in b). prom_init() will then re-enter the kernel using
          the second method. This trampoline code runs in the
          context of the firmware, which is supposed to handle all
          exceptions during that time.

    b) Direct entry with a flattened device-tree block. This entry
    point is called by a) after the OF trampoline and can also be
    called directly by a bootloader that does not support the Open
    Firmware client interface. It is also used by &quot;kexec&quot; to
    implement &quot;hot&quot; booting of a new kernel from a previous
    running one. This method is what I will describe in more
    details in this document, as method a) is simply standard Open
    Firmware, and thus should be implemented according to the
    various standard documents defining it and its binding to the
    PowerPC platform. The entry point definition then becomes:

            r3 : physical pointer to the device-tree block
            (defined in chapter II) in RAM

            r4 : physical pointer to the kernel itself. This is
            used by the assembly code to properly disable the MMU
            in case you are entering the kernel with MMU enabled
            and a non-1:1 mapping.

            r5 : NULL (as to differentiate with method a)

    Note about SMP entry: Either your firmware puts your other
    CPUs in some sleep loop or spin loop in ROM where you can get
    them out via a soft reset or some other means, in which case
    you don&#39;t need to care, or you&#39;ll have to enter the kernel
    with all CPUs. The way to do that with method b) will be
    described in a later revision of this document.
</code></pre>
<ol start="2">
<li>Board support</li>
</ol>
<hr>
<p>64-bit kernels:</p>
<p>   Board supports (platforms) are not exclusive config options. An<br>   arbitrary set of board supports can be built in a single kernel<br>   image. The kernel will “know” what set of functions to use for a<br>   given platform based on the content of the device-tree. Thus, you<br>   should:</p>
<pre><code>    a) add your platform support as a _boolean_ option in
    arch/powerpc/Kconfig, following the example of PPC_PSERIES,
    PPC_PMAC and PPC_MAPLE. The later is probably a good
    example of a board support to start from.

    b) create your main platform file as
    &quot;arch/powerpc/platforms/myplatform/myboard_setup.c&quot; and add it
    to the Makefile under the condition of your CONFIG_
    option. This file will define a structure of type &quot;ppc_md&quot;
    containing the various callbacks that the generic code will
    use to get to your platform specific code

    c) Add a reference to your &quot;ppc_md&quot; structure in the
    &quot;machines&quot; table in arch/powerpc/kernel/setup_64.c if you are
    a 64-bit platform.

    d) request and get assigned a platform number (see PLATFORM_*
    constants in arch/powerpc/include/asm/processor.h
</code></pre>
<p>32-bit embedded kernels:</p>
<p>  Currently, board support is essentially an exclusive config option.<br>  The kernel is configured for a single platform.  Part of the reason<br>  for this is to keep kernels on embedded systems small and efficient;<br>  part of this is due to the fact the code is already that way. In the<br>  future, a kernel may support multiple platforms, but only if the<br>  platforms feature the same core architecture.  A single kernel build<br>  cannot support both configurations with Book E and configurations<br>  with classic Powerpc architectures.</p>
<p>  32-bit embedded platforms that are moved into arch/powerpc using a<br>  flattened device tree should adopt the merged tree practice of<br>  setting ppc_md up dynamically, even though the kernel is currently<br>  built with support for only a single platform at a time.  This allows<br>  unification of the setup code, and will make it easier to go to a<br>  multiple-platform-support model in the future.</p>
<p>NOTE: I believe the above will be true once Ben’s done with the merge<br>of the boot sequences…. someone speak up if this is wrong!</p>
<p>  To add a 32-bit embedded platform support, follow the instructions<br>  for 64-bit platforms above, with the exception that the Kconfig<br>  option should be set up such that the kernel builds exclusively for<br>  the platform selected.  The processor type for the platform should<br>  enable another config option to select the specific board<br>  supported.</p>
<p>NOTE: If Ben doesn’t merge the setup files, may need to change this to<br>point to setup_32.c</p>
<p>   I will describe later the boot process and various callbacks that<br>   your platform should implement.</p>
<h1 id="II-The-DT-block-format"><a href="#II-The-DT-block-format" class="headerlink" title="II - The DT block format"></a>II - The DT block format</h1><p>This chapter defines the actual format of the flattened device-tree<br>passed to the kernel. The actual content of it and kernel requirements<br>are described later. You can find example of code manipulating that<br>format in various places, including arch/powerpc/kernel/prom_init.c<br>which will generate a flattened device-tree from the Open Firmware<br>representation, or the fs2dt utility which is part of the kexec tools<br>which will generate one from a filesystem representation. It is<br>expected that a bootloader like uboot provides a bit more support,<br>that will be discussed later as well.</p>
<p>Note: The block has to be in main memory. It has to be accessible in<br>both real mode and virtual mode with no mapping other than main<br>memory. If you are writing a simple flash bootloader, it should copy<br>the block to RAM before passing it to the kernel.</p>
<ol>
<li>Header</li>
</ol>
<hr>
<p>   The kernel is entered with r3 pointing to an area of memory that is<br>   roughly described in arch/powerpc/include/asm/prom.h by the structure<br>   boot_param_header:</p>
<p>struct boot_param_header {<br>        u32     magic;                  /* magic word OF_DT_HEADER <em>/<br>        u32     totalsize;              /</em> total size of DT block <em>/<br>        u32     off_dt_struct;          /</em> offset to structure <em>/<br>        u32     off_dt_strings;         /</em> offset to strings <em>/<br>        u32     off_mem_rsvmap;         /</em> offset to memory reserve map<br>                                           <em>/<br>        u32     version;                /</em> format version <em>/<br>        u32     last_comp_version;      /</em> last compatible version */</p>
<pre><code>    /* version 2 fields below */
    u32     boot_cpuid_phys;        /* Which physical CPU id we&#39;re
                                       booting on */
    /* version 3 fields below */
    u32     size_dt_strings;        /* size of the strings block */

    /* version 17 fields below */
    u32    size_dt_struct;        /* size of the DT structure block */
</code></pre>
<p>};</p>
<p>   Along with the constants:</p>
<p>/* Definitions used by the flattened device tree <em>/<br>#define OF_DT_HEADER            0xd00dfeed      /</em> 4: version,<br>                           4: total size <em>/<br>#define OF_DT_BEGIN_NODE        0x1             /</em> Start node: full name<br>                           <em>/<br>#define OF_DT_END_NODE          0x2             /</em> End node <em>/<br>#define OF_DT_PROP              0x3             /</em> Property: name off,<br>                                                   size, content */<br>#define OF_DT_END               0x9</p>
<p>   All values in this header are in big endian format, the various<br>   fields in this header are defined more precisely below. All<br>   “offset” values are in bytes from the start of the header; that is<br>   from the value of r3.</p>
<ul>
<li><p>magic</p>
<p>This is a magic value that “marks” the beginning of the<br>device-tree block header. It contains the value 0xd00dfeed and is<br>defined by the constant OF_DT_HEADER</p>
</li>
<li><p>totalsize</p>
<p>This is the total size of the DT block including the header. The<br>“DT” block should enclose all data structures defined in this<br>chapter (who are pointed to by offsets in this header). That is,<br>the device-tree structure, strings, and the memory reserve map.</p>
</li>
<li><p>off_dt_struct</p>
<p>This is an offset from the beginning of the header to the start<br>of the “structure” part the device tree. (see 2) device tree)</p>
</li>
<li><p>off_dt_strings</p>
<p>This is an offset from the beginning of the header to the start<br>of the “strings” part of the device-tree</p>
</li>
<li><p>off_mem_rsvmap</p>
<p>This is an offset from the beginning of the header to the start<br>of the reserved memory map. This map is a list of pairs of 64-<br>bit integers. Each pair is a physical address and a size. The<br>list is terminated by an entry of size 0. This map provides the<br>kernel with a list of physical memory areas that are “reserved”<br>and thus not to be used for memory allocations, especially during<br>early initialization. The kernel needs to allocate memory during<br>boot for things like un-flattening the device-tree, allocating an<br>MMU hash table, etc… Those allocations must be done in such a<br>way to avoid overriding critical things like, on Open Firmware<br>capable machines, the RTAS instance, or on some pSeries, the TCE<br>tables used for the iommu. Typically, the reserve map should<br>contain <em>at least</em> this DT block itself (header,total_size). If<br>you are passing an initrd to the kernel, you should reserve it as<br>well. You do not need to reserve the kernel image itself. The map<br>should be 64-bit aligned.</p>
</li>
<li><p>version</p>
<p>This is the version of this structure. Version 1 stops<br>here. Version 2 adds an additional field boot_cpuid_phys.<br>Version 3 adds the size of the strings block, allowing the kernel<br>to reallocate it easily at boot and free up the unused flattened<br>structure after expansion. Version 16 introduces a new more<br>“compact” format for the tree itself that is however not backward<br>compatible. Version 17 adds an additional field, size_dt_struct,<br>allowing it to be reallocated or moved more easily (this is<br>particularly useful for bootloaders which need to make<br>adjustments to a device tree based on probed information). You<br>should always generate a structure of the highest version defined<br>at the time of your implementation. Currently that is version 17,<br>unless you explicitly aim at being backward compatible.</p>
</li>
<li><p>last_comp_version</p>
<p>Last compatible version. This indicates down to what version of<br>the DT block you are backward compatible. For example, version 2<br>is backward compatible with version 1 (that is, a kernel build<br>for version 1 will be able to boot with a version 2 format). You<br>should put a 1 in this field if you generate a device tree of<br>version 1 to 3, or 16 if you generate a tree of version 16 or 17<br>using the new unit name format.</p>
</li>
<li><p>boot_cpuid_phys</p>
<p>This field only exist on version 2 headers. It indicate which<br>physical CPU ID is calling the kernel entry point. This is used,<br>among others, by kexec. If you are on an SMP system, this value<br>should match the content of the “reg” property of the CPU node in<br>the device-tree corresponding to the CPU calling the kernel entry<br>point (see further chapters for more informations on the required<br>device-tree contents)</p>
</li>
<li><p>size_dt_strings</p>
<p>This field only exists on version 3 and later headers.  It<br>gives the size of the “strings” section of the device tree (which<br>starts at the offset given by off_dt_strings).</p>
</li>
<li><p>size_dt_struct</p>
<p>This field only exists on version 17 and later headers.  It gives<br>the size of the “structure” section of the device tree (which<br>starts at the offset given by off_dt_struct).</p>
<p>So the typical layout of a DT block (though the various parts don’t<br>need to be in that order) looks like this (addresses go from top to<br>bottom):</p>
</li>
</ul>
<pre><code>         ------------------------------
   r3 -&gt; |  struct boot_param_header  |
         ------------------------------
         |      (alignment gap) (*)   |
         ------------------------------
         |      memory reserve map    |
         ------------------------------
         |      (alignment gap)       |
         ------------------------------
         |                            |
         |    device-tree structure   |
         |                            |
         ------------------------------
         |      (alignment gap)       |
         ------------------------------
         |                            |
         |     device-tree strings    |
         |                            |
  -----&gt; ------------------------------
  |
  |
  --- (r3 + totalsize)
</code></pre>
<p>  (*) The alignment gaps are not necessarily present; their presence<br>      and size are dependent on the various alignment requirements of<br>      the individual data blocks.</p>
<ol start="2">
<li>Device tree generalities</li>
</ol>
<hr>
<p>This device-tree itself is separated in two different blocks, a<br>structure block and a strings block. Both need to be aligned to a 4<br>byte boundary.</p>
<p>First, let’s quickly describe the device-tree concept before detailing<br>the storage format. This chapter does <em>not</em> describe the detail of the<br>required types of nodes &amp; properties for the kernel, this is done<br>later in chapter III.</p>
<p>The device-tree layout is strongly inherited from the definition of<br>the Open Firmware IEEE 1275 device-tree. It’s basically a tree of<br>nodes, each node having two or more named properties. A property can<br>have a value or not.</p>
<p>It is a tree, so each node has one and only one parent except for the<br>root node who has no parent.</p>
<p>A node has 2 names. The actual node name is generally contained in a<br>property of type “name” in the node property list whose value is a<br>zero terminated string and is mandatory for version 1 to 3 of the<br>format definition (as it is in Open Firmware). Version 16 makes it<br>optional as it can generate it from the unit name defined below.</p>
<p>There is also a “unit name” that is used to differentiate nodes with<br>the same name at the same level, it is usually made of the node<br>names, the “@” sign, and a “unit address”, which definition is<br>specific to the bus type the node sits on.</p>
<p>The unit name doesn’t exist as a property per-se but is included in<br>the device-tree structure. It is typically used to represent “path” in<br>the device-tree. More details about the actual format of these will be<br>below.</p>
<p>The kernel powerpc generic code does not make any formal use of the<br>unit address (though some board support code may do) so the only real<br>requirement here for the unit address is to ensure uniqueness of<br>the node unit name at a given level of the tree. Nodes with no notion<br>of address and no possible sibling of the same name (like /memory or<br>/cpus) may omit the unit address in the context of this specification,<br>or use the “@0” default unit address. The unit name is used to define<br>a node “full path”, which is the concatenation of all parent node<br>unit names separated with “/“.</p>
<p>The root node doesn’t have a defined name, and isn’t required to have<br>a name property either if you are using version 3 or earlier of the<br>format. It also has no unit address (no @ symbol followed by a unit<br>address). The root node unit name is thus an empty string. The full<br>path to the root node is “/“.</p>
<p>Every node which actually represents an actual device (that is, a node<br>which isn’t only a virtual “container” for more nodes, like “/cpus”<br>is) is also required to have a “device_type” property indicating the<br>type of node .</p>
<p>Finally, every node that can be referenced from a property in another<br>node is required to have a “linux,phandle” property. Real open<br>firmware implementations provide a unique “phandle” value for every<br>node that the “prom_init()” trampoline code turns into<br>“linux,phandle” properties. However, this is made optional if the<br>flattened device tree is used directly. An example of a node<br>referencing another node via “phandle” is when laying out the<br>interrupt tree which will be described in a further version of this<br>document.</p>
<p>This “linux, phandle” property is a 32-bit value that uniquely<br>identifies a node. You are free to use whatever values or system of<br>values, internal pointers, or whatever to generate these, the only<br>requirement is that every node for which you provide that property has<br>a unique value for it.</p>
<p>Here is an example of a simple device-tree. In this example, an “o”<br>designates a node followed by the node unit name. Properties are<br>presented with their name followed by their content. “content”<br>represents an ASCII string (zero terminated) value, while <content><br>represents a 32-bit hexadecimal value. The various nodes in this<br>example will be discussed in a later chapter. At this point, it is<br>only meant to give you a idea of what a device-tree looks like. I have<br>purposefully kept the “name” and “linux,phandle” properties which<br>aren’t necessary in order to give you a better idea of what the tree<br>looks like in practice.</p>
<p>  / o device-tree<br>      |- name = “device-tree”<br>      |- model = “MyBoardName”<br>      |- compatible = “MyBoardFamilyName”<br>      |- #address-cells = &lt;2&gt;<br>      |- #size-cells = &lt;2&gt;<br>      |- linux,phandle = &lt;0&gt;<br>      |<br>      o cpus<br>      | | - name = “cpus”<br>      | | - linux,phandle = &lt;1&gt;<br>      | | - #address-cells = &lt;1&gt;<br>      | | - #size-cells = &lt;0&gt;<br>      | |<br>      | o PowerPC,970@0<br>      |   |- name = “PowerPC,970”<br>      |   |- device_type = “cpu”<br>      |   |- reg = &lt;0&gt;<br>      |   |- clock-frequency = &lt;5f5e1000&gt;<br>      |   |- 64-bit<br>      |   |- linux,phandle = &lt;2&gt;<br>      |<br>      o memory@0<br>      | |- name = “memory”<br>      | |- device_type = “memory”<br>      | |- reg = &lt;00000000 00000000 00000000 20000000&gt;<br>      | |- linux,phandle = &lt;3&gt;<br>      |<br>      o chosen<br>        |- name = “chosen”<br>        |- bootargs = “root=/dev/sda2”<br>        |- linux,phandle = &lt;4&gt;</p>
<p>This tree is almost a minimal tree. It pretty much contains the<br>minimal set of required nodes and properties to boot a linux kernel;<br>that is, some basic model informations at the root, the CPUs, and the<br>physical memory layout.  It also includes misc information passed<br>through /chosen, like in this example, the platform type (mandatory)<br>and the kernel command line arguments (optional).</p>
<p>The /cpus/PowerPC,970@0/64-bit property is an example of a<br>property without a value. All other properties have a value. The<br>significance of the #address-cells and #size-cells properties will be<br>explained in chapter IV which defines precisely the required nodes and<br>properties and their content.</p>
<ol start="3">
<li>Device tree “structure” block</li>
</ol>
<p>The structure of the device tree is a linearized tree structure. The<br>“OF_DT_BEGIN_NODE” token starts a new node, and the “OF_DT_END_NODE”<br>ends that node definition. Child nodes are simply defined before<br>“OF_DT_END_NODE” (that is nodes within the node). A ‘token’ is a 32<br>bit value. The tree has to be “finished” with a OF_DT_END token</p>
<p>Here’s the basic structure of a single node:</p>
<pre><code> * token OF_DT_BEGIN_NODE (that is 0x00000001)
 * for version 1 to 3, this is the node full path as a zero
   terminated string, starting with &quot;/&quot;. For version 16 and later,
   this is the node unit name only (or an empty string for the
   root node)
 * [align gap to next 4 bytes boundary]
 * for each property:
    * token OF_DT_PROP (that is 0x00000003)
    * 32-bit value of property value size in bytes (or 0 if no
      value)
    * 32-bit value of offset in string block of property name
    * property value data if any
    * [align gap to next 4 bytes boundary]
 * [child nodes if any]
 * token OF_DT_END_NODE (that is 0x00000002)
</code></pre>
<p>So the node content can be summarized as a start token, a full path,<br>a list of properties, a list of child nodes, and an end token. Every<br>child node is a full node structure itself as defined above.</p>
<p>NOTE: The above definition requires that all property definitions for<br>a particular node MUST precede any subnode definitions for that node.<br>Although the structure would not be ambiguous if properties and<br>subnodes were intermingled, the kernel parser requires that the<br>properties come first (up until at least 2.6.22).  Any tools<br>manipulating a flattened tree must take care to preserve this<br>constraint.</p>
<ol start="4">
<li>Device tree “strings” block</li>
</ol>
<p>In order to save space, property names, which are generally redundant,<br>are stored separately in the “strings” block. This block is simply the<br>whole bunch of zero terminated strings for all property names<br>concatenated together. The device-tree property definitions in the<br>structure block will contain offset values from the beginning of the<br>strings block.</p>
<h1 id="III-Required-content-of-the-device-tree"><a href="#III-Required-content-of-the-device-tree" class="headerlink" title="III - Required content of the device tree"></a>III - Required content of the device tree</h1><p>WARNING: All “linux,*” properties defined in this document apply only<br>to a flattened device-tree. If your platform uses a real<br>implementation of Open Firmware or an implementation compatible with<br>the Open Firmware client interface, those properties will be created<br>by the trampoline code in the kernel’s prom_init() file. For example,<br>that’s where you’ll have to add code to detect your board model and<br>set the platform number. However, when using the flattened device-tree<br>entry point, there is no prom_init() pass, and thus you have to<br>provide those properties yourself.</p>
<ol>
<li>Note about cells and address representation</li>
</ol>
<hr>
<p>The general rule is documented in the various Open Firmware<br>documentations. If you choose to describe a bus with the device-tree<br>and there exist an OF bus binding, then you should follow the<br>specification. However, the kernel does not require every single<br>device or bus to be described by the device tree.</p>
<p>In general, the format of an address for a device is defined by the<br>parent bus type, based on the #address-cells and #size-cells<br>properties.  Note that the parent’s parent definitions of #address-cells<br>and #size-cells are not inherited so every node with children must specify<br>them.  The kernel requires the root node to have those properties defining<br>addresses format for devices directly mapped on the processor bus.</p>
<p>Those 2 properties define ‘cells’ for representing an address and a<br>size. A “cell” is a 32-bit number. For example, if both contain 2<br>like the example tree given above, then an address and a size are both<br>composed of 2 cells, and each is a 64-bit number (cells are<br>concatenated and expected to be in big endian format). Another example<br>is the way Apple firmware defines them, with 2 cells for an address<br>and one cell for a size.  Most 32-bit implementations should define<br>#address-cells and #size-cells to 1, which represents a 32-bit value.<br>Some 32-bit processors allow for physical addresses greater than 32<br>bits; these processors should define #address-cells as 2.</p>
<p>“reg” properties are always a tuple of the type “address size” where<br>the number of cells of address and size is specified by the bus<br>#address-cells and #size-cells. When a bus supports various address<br>spaces and other flags relative to a given address allocation (like<br>prefetchable, etc…) those flags are usually added to the top level<br>bits of the physical address. For example, a PCI physical address is<br>made of 3 cells, the bottom two containing the actual address itself<br>while the top cell contains address space indication, flags, and pci<br>bus &amp; device numbers.</p>
<p>For busses that support dynamic allocation, it’s the accepted practice<br>to then not provide the address in “reg” (keep it 0) though while<br>providing a flag indicating the address is dynamically allocated, and<br>then, to provide a separate “assigned-addresses” property that<br>contains the fully allocated addresses. See the PCI OF bindings for<br>details.</p>
<p>In general, a simple bus with no address space bits and no dynamic<br>allocation is preferred if it reflects your hardware, as the existing<br>kernel address parsing functions will work out of the box. If you<br>define a bus type with a more complex address format, including things<br>like address space bits, you’ll have to add a bus translator to the<br>prom_parse.c file of the recent kernels for your bus type.</p>
<p>The “reg” property only defines addresses and sizes (if #size-cells is<br>non-0) within a given bus. In order to translate addresses upward<br>(that is into parent bus addresses, and possibly into CPU physical<br>addresses), all busses must contain a “ranges” property. If the<br>“ranges” property is missing at a given level, it’s assumed that<br>translation isn’t possible, i.e., the registers are not visible on the<br>parent bus.  The format of the “ranges” property for a bus is a list<br>of:</p>
<pre><code>bus address, parent bus address, size
</code></pre>
<p>“bus address” is in the format of the bus this bus node is defining,<br>that is, for a PCI bridge, it would be a PCI address. Thus, (bus<br>address, size) defines a range of addresses for child devices. “parent<br>bus address” is in the format of the parent bus of this bus. For<br>example, for a PCI host controller, that would be a CPU address. For a<br>PCI&lt;-&gt;ISA bridge, that would be a PCI address. It defines the base<br>address in the parent bus where the beginning of that range is mapped.</p>
<p>For a new 64-bit powerpc board, I recommend either the 2/2 format or<br>Apple’s 2/1 format which is slightly more compact since sizes usually<br>fit in a single 32-bit word.   New 32-bit powerpc boards should use a<br>1/1 format, unless the processor supports physical addresses greater<br>than 32-bits, in which case a 2/1 format is recommended.</p>
<p>Alternatively, the “ranges” property may be empty, indicating that the<br>registers are visible on the parent bus using an identity mapping<br>translation.  In other words, the parent bus address space is the same<br>as the child bus address space.</p>
<ol start="2">
<li>Note about “compatible” properties</li>
</ol>
<hr>
<p>These properties are optional, but recommended in devices and the root<br>node. The format of a “compatible” property is a list of concatenated<br>zero terminated strings. They allow a device to express its<br>compatibility with a family of similar devices, in some cases,<br>allowing a single driver to match against several devices regardless<br>of their actual names.</p>
<ol start="3">
<li>Note about “name” properties</li>
</ol>
<hr>
<p>While earlier users of Open Firmware like OldWorld macintoshes tended<br>to use the actual device name for the “name” property, it’s nowadays<br>considered a good practice to use a name that is closer to the device<br>class (often equal to device_type). For example, nowadays, ethernet<br>controllers are named “ethernet”, an additional “model” property<br>defining precisely the chip type/model, and “compatible” property<br>defining the family in case a single driver can driver more than one<br>of these chips. However, the kernel doesn’t generally put any<br>restriction on the “name” property; it is simply considered good<br>practice to follow the standard and its evolutions as closely as<br>possible.</p>
<p>Note also that the new format version 16 makes the “name” property<br>optional. If it’s absent for a node, then the node’s unit name is then<br>used to reconstruct the name. That is, the part of the unit name<br>before the “@” sign is used (or the entire unit name if no “@” sign<br>is present).</p>
<ol start="4">
<li>Note about node and property names and character set</li>
</ol>
<hr>
<p>While open firmware provides more flexible usage of 8859-1, this<br>specification enforces more strict rules. Nodes and properties should<br>be comprised only of ASCII characters ‘a’ to ‘z’, ‘0’ to<br>‘9’, ‘,’, ‘.’, ‘_’, ‘+’, ‘#’, ‘?’, and ‘-‘. Node names additionally<br>allow uppercase characters ‘A’ to ‘Z’ (property names should be<br>lowercase. The fact that vendors like Apple don’t respect this rule is<br>irrelevant here). Additionally, node and property names should always<br>begin with a character in the range ‘a’ to ‘z’ (or ‘A’ to ‘Z’ for node<br>names).</p>
<p>The maximum number of characters for both nodes and property names<br>is 31. In the case of node names, this is only the leftmost part of<br>a unit name (the pure “name” property), it doesn’t include the unit<br>address which can extend beyond that limit.</p>
<ol start="5">
<li>Required nodes and properties</li>
</ol>
<hr>
<p>  These are all that are currently required. However, it is strongly<br>  recommended that you expose PCI host bridges as documented in the<br>  PCI binding to open firmware, and your interrupt tree as documented<br>  in OF interrupt tree specification.</p>
<p>  a) The root node</p>
<p>  The root node requires some properties to be present:</p>
<pre><code>- model : this is your board name/model
- #address-cells : address representation for &quot;root&quot; devices
- #size-cells: the size representation for &quot;root&quot; devices
- device_type : This property shouldn&#39;t be necessary. However, if
  you decide to create a device_type for your root node, make sure it
  is _not_ &quot;chrp&quot; unless your platform is a pSeries or PAPR compliant
  one for 64-bit, or a CHRP-type machine for 32-bit as this will
  matched by the kernel this way.
</code></pre>
<p>  Additionally, some recommended properties are:</p>
<pre><code>- compatible : the board &quot;family&quot; generally finds its way here,
  for example, if you have 2 board models with a similar layout,
  that typically get driven by the same platform code in the
  kernel, you would use a different &quot;model&quot; property but put a
  value in &quot;compatible&quot;. The kernel doesn&#39;t directly use that
  value but it is generally useful.
</code></pre>
<p>  The root node is also generally where you add additional properties<br>  specific to your board like the serial number if any, that sort of<br>  thing. It is recommended that if you add any “custom” property whose<br>  name may clash with standard defined ones, you prefix them with your<br>  vendor name and a comma.</p>
<p>  b) The /cpus node</p>
<p>  This node is the parent of all individual CPU nodes. It doesn’t<br>  have any specific requirements, though it’s generally good practice<br>  to have at least:</p>
<pre><code>           #address-cells = &lt;00000001&gt;
           #size-cells    = &lt;00000000&gt;
</code></pre>
<p>  This defines that the “address” for a CPU is a single cell, and has<br>  no meaningful size. This is not necessary but the kernel will assume<br>  that format when reading the “reg” properties of a CPU node, see<br>  below</p>
<p>  c) The /cpus/* nodes</p>
<p>  So under /cpus, you are supposed to create a node for every CPU on<br>  the machine. There is no specific restriction on the name of the<br>  CPU, though It’s common practice to call it PowerPC,<name>. For<br>  example, Apple uses PowerPC,G5 while IBM uses PowerPC,970FX.</p>
<p>  Required properties:</p>
<pre><code>- device_type : has to be &quot;cpu&quot;
- reg : This is the physical CPU number, it&#39;s a single 32-bit cell
  and is also used as-is as the unit number for constructing the
  unit name in the full path. For example, with 2 CPUs, you would
  have the full path:
    /cpus/PowerPC,970FX@0
    /cpus/PowerPC,970FX@1
  (unit addresses do not require leading zeroes)
- d-cache-block-size : one cell, L1 data cache block size in bytes (*)
- i-cache-block-size : one cell, L1 instruction cache block size in
  bytes
- d-cache-size : one cell, size of L1 data cache in bytes
- i-cache-size : one cell, size of L1 instruction cache in bytes
</code></pre>
<p>(*) The cache “block” size is the size on which the cache management<br>instructions operate. Historically, this document used the cache<br>“line” size here which is incorrect. The kernel will prefer the cache<br>block size and will fallback to cache line size for backward<br>compatibility.</p>
<p>  Recommended properties:</p>
<pre><code>- timebase-frequency : a cell indicating the frequency of the
  timebase in Hz. This is not directly used by the generic code,
  but you are welcome to copy/paste the pSeries code for setting
  the kernel timebase/decrementer calibration based on this
  value.
- clock-frequency : a cell indicating the CPU core clock frequency
  in Hz. A new property will be defined for 64-bit values, but if
  your frequency is &lt; 4Ghz, one cell is enough. Here as well as
  for the above, the common code doesn&#39;t use that property, but
  you are welcome to re-use the pSeries or Maple one. A future
  kernel version might provide a common function for this.
- d-cache-line-size : one cell, L1 data cache line size in bytes
  if different from the block size
- i-cache-line-size : one cell, L1 instruction cache line size in
  bytes if different from the block size
</code></pre>
<p>  You are welcome to add any property you find relevant to your board,<br>  like some information about the mechanism used to soft-reset the<br>  CPUs. For example, Apple puts the GPIO number for CPU soft reset<br>  lines in there as a “soft-reset” property since they start secondary<br>  CPUs by soft-resetting them.</p>
<p>  d) the /memory node(s)</p>
<p>  To define the physical memory layout of your board, you should<br>  create one or more memory node(s). You can either create a single<br>  node with all memory ranges in its reg property, or you can create<br>  several nodes, as you wish. The unit address (@ part) used for the<br>  full path is the address of the first range of memory defined by a<br>  given node. If you use a single memory node, this will typically be<br>  @0.</p>
<p>  Required properties:</p>
<pre><code>- device_type : has to be &quot;memory&quot;
- reg : This property contains all the physical memory ranges of
  your board. It&#39;s a list of addresses/sizes concatenated
  together, with the number of cells of each defined by the
  #address-cells and #size-cells of the root node. For example,
  with both of these properties being 2 like in the example given
  earlier, a 970 based machine with 6Gb of RAM could typically
  have a &quot;reg&quot; property here that looks like:

  00000000 00000000 00000000 80000000
  00000001 00000000 00000001 00000000

  That is a range starting at 0 of 0x80000000 bytes and a range
  starting at 0x100000000 and of 0x100000000 bytes. You can see
  that there is no memory covering the IO hole between 2Gb and
  4Gb. Some vendors prefer splitting those ranges into smaller
  segments, but the kernel doesn&#39;t care.
</code></pre>
<p>  e) The /chosen node</p>
<p>  This node is a bit “special”. Normally, that’s where open firmware<br>  puts some variable environment information, like the arguments, or<br>  the default input/output devices.</p>
<p>  This specification makes a few of these mandatory, but also defines<br>  some linux-specific properties that would be normally constructed by<br>  the prom_init() trampoline when booting with an OF client interface,<br>  but that you have to provide yourself when using the flattened format.</p>
<p>  Recommended properties:</p>
<pre><code>- bootargs : This zero-terminated string is passed as the kernel
  command line
- linux,stdout-path : This is the full path to your standard
  console device if any. Typically, if you have serial devices on
  your board, you may want to put the full path to the one set as
  the default console in the firmware here, for the kernel to pick
  it up as its own default console. If you look at the function
  set_preferred_console() in arch/ppc64/kernel/setup.c, you&#39;ll see
  that the kernel tries to find out the default console and has
  knowledge of various types like 8250 serial ports. You may want
  to extend this function to add your own.
</code></pre>
<p>  Note that u-boot creates and fills in the chosen node for platforms<br>  that use it.</p>
<p>  (Note: a practice that is now obsolete was to include a property<br>  under /chosen called interrupt-controller which had a phandle value<br>  that pointed to the main interrupt controller)</p>
<p>  f) the /soc<SOCname> node</p>
<p>  This node is used to represent a system-on-a-chip (SOC) and must be<br>  present if the processor is a SOC. The top-level soc node contains<br>  information that is global to all devices on the SOC. The node name<br>  should contain a unit address for the SOC, which is the base address<br>  of the memory-mapped register set for the SOC. The name of an soc<br>  node should start with “soc”, and the remainder of the name should<br>  represent the part number for the soc.  For example, the MPC8540’s<br>  soc node would be called “soc8540”.</p>
<p>  Required properties:</p>
<pre><code>- device_type : Should be &quot;soc&quot;
- ranges : Should be defined as specified in 1) to describe the
  translation of SOC addresses for memory mapped SOC registers.
- bus-frequency: Contains the bus frequency for the SOC node.
  Typically, the value of this field is filled in by the boot
  loader.
</code></pre>
<p>  Recommended properties:</p>
<pre><code>- reg : This property defines the address and size of the
  memory-mapped registers that are used for the SOC node itself.
  It does not include the child device registers - these will be
  defined inside each child node.  The address specified in the
  &quot;reg&quot; property should match the unit address of the SOC node.
- #address-cells : Address representation for &quot;soc&quot; devices.  The
  format of this field may vary depending on whether or not the
  device registers are memory mapped.  For memory mapped
  registers, this field represents the number of cells needed to
  represent the address of the registers.  For SOCs that do not
  use MMIO, a special address format should be defined that
  contains enough cells to represent the required information.
  See 1) above for more details on defining #address-cells.
- #size-cells : Size representation for &quot;soc&quot; devices
- #interrupt-cells : Defines the width of cells used to represent
   interrupts.  Typically this value is &lt;2&gt;, which includes a
   32-bit number that represents the interrupt number, and a
   32-bit number that represents the interrupt sense and level.
   This field is only needed if the SOC contains an interrupt
   controller.
</code></pre>
<p>  The SOC node may contain child nodes for each SOC device that the<br>  platform uses.  Nodes should not be created for devices which exist<br>  on the SOC but are not used by a particular platform. See chapter VI<br>  for more information on how to specify devices that are part of a SOC.</p>
<p>  Example SOC node for the MPC8540:</p>
<pre><code>soc8540@e0000000 &#123;
    #address-cells = &lt;1&gt;;
    #size-cells = &lt;1&gt;;
    #interrupt-cells = &lt;2&gt;;
    device_type = &quot;soc&quot;;
    ranges = &lt;00000000 e0000000 00100000&gt;
    reg = &lt;e0000000 00003000&gt;;
    bus-frequency = &lt;0&gt;;
&#125;
</code></pre>
<h1 id="IV-“dtc”-the-device-tree-compiler"><a href="#IV-“dtc”-the-device-tree-compiler" class="headerlink" title="IV - “dtc”, the device tree compiler"></a>IV - “dtc”, the device tree compiler</h1><p>dtc source code can be found at<br><a target="_blank" rel="noopener" href="http://ozlabs.org/~dgibson/dtc/dtc.tar.gz">http://ozlabs.org/~dgibson/dtc/dtc.tar.gz</a></p>
<p>WARNING: This version is still in early development stage; the<br>resulting device-tree “blobs” have not yet been validated with the<br>kernel. The current generated bloc lacks a useful reserve map (it will<br>be fixed to generate an empty one, it’s up to the bootloader to fill<br>it up) among others. The error handling needs work, bugs are lurking,<br>etc…</p>
<p>dtc basically takes a device-tree in a given format and outputs a<br>device-tree in another format. The currently supported formats are:</p>
<h2 id="Input-formats"><a href="#Input-formats" class="headerlink" title="  Input formats:"></a>  Input formats:</h2><pre><code> - &quot;dtb&quot;: &quot;blob&quot; format, that is a flattened device-tree block
   with
    header all in a binary blob.
 - &quot;dts&quot;: &quot;source&quot; format. This is a text file containing a
   &quot;source&quot; for a device-tree. The format is defined later in this
    chapter.
 - &quot;fs&quot; format. This is a representation equivalent to the
    output of /proc/device-tree, that is nodes are directories and
properties are files
</code></pre>
<h2 id="Output-formats"><a href="#Output-formats" class="headerlink" title=" Output formats:"></a> Output formats:</h2><pre><code> - &quot;dtb&quot;: &quot;blob&quot; format
 - &quot;dts&quot;: &quot;source&quot; format
 - &quot;asm&quot;: assembly language file. This is a file that can be
   sourced by gas to generate a device-tree &quot;blob&quot;. That file can
   then simply be added to your Makefile. Additionally, the
   assembly file exports some symbols that can be used.
</code></pre>
<p>The syntax of the dtc tool is</p>
<pre><code>dtc [-I &lt;input-format&gt;] [-O &lt;output-format&gt;]
    [-o output-filename] [-V output_version] input_filename
</code></pre>
<p>The “output_version” defines what version of the “blob” format will be<br>generated. Supported versions are 1,2,3 and 16. The default is<br>currently version 3 but that may change in the future to version 16.</p>
<p>Additionally, dtc performs various sanity checks on the tree, like the<br>uniqueness of linux, phandle properties, validity of strings, etc…</p>
<p>The format of the .dts “source” file is “C” like, supports C and C++<br>style comments.</p>
<p>/ {<br>}</p>
<p>The above is the “device-tree” definition. It’s the only statement<br>supported currently at the toplevel.</p>
<p>/ {<br>  property1 = “string_value”;    /* define a property containing a 0<br>                                 * terminated string<br>                 */</p>
<p>  property2 = &lt;1234abcd&gt;;    /* define a property containing a<br>                                 * numerical 32-bit value (hexadecimal)<br>                 */</p>
<p>  property3 = &lt;12345678 12345678 deadbeef&gt;;<br>                                /* define a property containing 3<br>                                 * numerical 32-bit values (cells) in<br>                                 * hexadecimal<br>                 <em>/<br>  property4 = [0a 0b 0c 0d de ea ad be ef];<br>                                /</em> define a property whose content is<br>                                 * an arbitrary array of bytes<br>                                 */</p>
<p>  childnode@addresss {    /* define a child node named “childnode”<br>                                 * whose unit name is “childnode at<br>                 * address”<br>                                 */</p>
<pre><code>childprop = &quot;hello\n&quot;;      /* define a property &quot;childprop&quot; of
                             * childnode (in this case, a string)
                             */
</code></pre>
<p>  };<br>};</p>
<p>Nodes can contain other nodes etc… thus defining the hierarchical<br>structure of the tree.</p>
<p>Strings support common escape sequences from C: “\n”, “\t”, “\r”,<br>“(octal value)”, “\x(hex value)”.</p>
<p>It is also suggested that you pipe your source file through cpp (gcc<br>preprocessor) so you can use #include’s, #define for constants, etc…</p>
<p>Finally, various options are planned but not yet implemented, like<br>automatic generation of phandles, labels (exported to the asm file so<br>you can point to a property content and change it easily from whatever<br>you link the device-tree with), label or path instead of numeric value<br>in some cells to “point” to a node (replaced by a phandle at compile<br>time), export of reserve map address to the asm file, ability to<br>specify reserve map content at compile time, etc…</p>
<p>We may provide a .h include file with common definitions of that<br>proves useful for some properties (like building PCI properties or<br>interrupt maps) though it may be better to add a notion of struct<br>definitions to the compiler…</p>
<h1 id="V-Recommendations-for-a-bootloader"><a href="#V-Recommendations-for-a-bootloader" class="headerlink" title="V - Recommendations for a bootloader"></a>V - Recommendations for a bootloader</h1><p>Here are some various ideas/recommendations that have been proposed<br>while all this has been defined and implemented.</p>
<ul>
<li><p>The bootloader may want to be able to use the device-tree itself<br>and may want to manipulate it (to add/edit some properties,<br>like physical memory size or kernel arguments). At this point, 2<br>choices can be made. Either the bootloader works directly on the<br>flattened format, or the bootloader has its own internal tree<br>representation with pointers (similar to the kernel one) and<br>re-flattens the tree when booting the kernel. The former is a bit<br>more difficult to edit/modify, the later requires probably a bit<br>more code to handle the tree structure. Note that the structure<br>format has been designed so it’s relatively easy to “insert”<br>properties or nodes or delete them by just memmoving things<br>around. It contains no internal offsets or pointers for this<br>purpose.</p>
</li>
<li><p>An example of code for iterating nodes &amp; retrieving properties<br>directly from the flattened tree format can be found in the kernel<br>file arch/ppc64/kernel/prom.c, look at scan_flat_dt() function,<br>its usage in early_init_devtree(), and the corresponding various<br>early_init_dt_scan_*() callbacks. That code can be re-used in a<br>GPL bootloader, and as the author of that code, I would be happy<br>to discuss possible free licensing to any vendor who wishes to<br>integrate all or part of this code into a non-GPL bootloader.</p>
</li>
</ul>
<h1 id="VI-System-on-a-chip-devices-and-nodes"><a href="#VI-System-on-a-chip-devices-and-nodes" class="headerlink" title="VI - System-on-a-chip devices and nodes"></a>VI - System-on-a-chip devices and nodes</h1><p>Many companies are now starting to develop system-on-a-chip<br>processors, where the processor core (CPU) and many peripheral devices<br>exist on a single piece of silicon.  For these SOCs, an SOC node<br>should be used that defines child nodes for the devices that make<br>up the SOC. While platforms are not required to use this model in<br>order to boot the kernel, it is highly encouraged that all SOC<br>implementations define as complete a flat-device-tree as possible to<br>describe the devices on the SOC.  This will allow for the<br>genericization of much of the kernel code.</p>
<ol>
<li>Defining child nodes of an SOC</li>
</ol>
<hr>
<p>Each device that is part of an SOC may have its own node entry inside<br>the SOC node.  For each device that is included in the SOC, the unit<br>address property represents the address offset for this device’s<br>memory-mapped registers in the parent’s address space.  The parent’s<br>address space is defined by the “ranges” property in the top-level soc<br>node. The “reg” property for each node that exists directly under the<br>SOC node should contain the address mapping from the child address space<br>to the parent SOC address space and the size of the device’s<br>memory-mapped register file.</p>
<p>For many devices that may exist inside an SOC, there are predefined<br>specifications for the format of the device tree node.  All SOC child<br>nodes should follow these specifications, except where noted in this<br>document.</p>
<p>See appendix A for an example partial SOC node definition for the<br>MPC8540.</p>
<ol start="2">
<li>Representing devices without a current OF specification</li>
</ol>
<hr>
<p>Currently, there are many devices on SOCs that do not have a standard<br>representation pre-defined as part of the open firmware<br>specifications, mainly because the boards that contain these SOCs are<br>not currently booted using open firmware.   This section contains<br>descriptions for the SOC devices for which new nodes have been<br>defined; this list will expand as more and more SOC-containing<br>platforms are moved over to use the flattened-device-tree model.</p>
<h1 id="VII-Specifying-interrupt-information-for-devices"><a href="#VII-Specifying-interrupt-information-for-devices" class="headerlink" title="VII - Specifying interrupt information for devices"></a>VII - Specifying interrupt information for devices</h1><p>The device tree represents the busses and devices of a hardware<br>system in a form similar to the physical bus topology of the<br>hardware.</p>
<p>In addition, a logical ‘interrupt tree’ exists which represents the<br>hierarchy and routing of interrupts in the hardware.</p>
<p>The interrupt tree model is fully described in the<br>document “Open Firmware Recommended Practice: Interrupt<br>Mapping Version 0.9”.  The document is available at:<br><a target="_blank" rel="noopener" href="http://playground.sun.com/1275/practice">http://playground.sun.com/1275/practice</a>.</p>
<ol>
<li>interrupts property</li>
</ol>
<hr>
<p>Devices that generate interrupts to a single interrupt controller<br>should use the conventional OF representation described in the<br>OF interrupt mapping documentation.</p>
<p>Each device which generates interrupts must have an ‘interrupt’<br>property.  The interrupt property value is an arbitrary number of<br>of ‘interrupt specifier’ values which describe the interrupt or<br>interrupts for the device.</p>
<p>The encoding of an interrupt specifier is determined by the<br>interrupt domain in which the device is located in the<br>interrupt tree.  The root of an interrupt domain specifies in<br>its #interrupt-cells property the number of 32-bit cells<br>required to encode an interrupt specifier.  See the OF interrupt<br>mapping documentation for a detailed description of domains.</p>
<p>For example, the binding for the OpenPIC interrupt controller<br>specifies  an #interrupt-cells value of 2 to encode the interrupt<br>number and level/sense information. All interrupt children in an<br>OpenPIC interrupt domain use 2 cells per interrupt in their interrupts<br>property.</p>
<p>The PCI bus binding specifies a #interrupt-cell value of 1 to encode<br>which interrupt pin (INTA,INTB,INTC,INTD) is used.</p>
<ol start="2">
<li>interrupt-parent property</li>
</ol>
<hr>
<p>The interrupt-parent property is specified to define an explicit<br>link between a device node and its interrupt parent in<br>the interrupt tree.  The value of interrupt-parent is the<br>phandle of the parent node.</p>
<p>If the interrupt-parent property is not defined for a node, it’s<br>interrupt parent is assumed to be an ancestor in the node’s<br><em>device tree</em> hierarchy.</p>
<ol start="3">
<li>OpenPIC Interrupt Controllers</li>
</ol>
<hr>
<p>OpenPIC interrupt controllers require 2 cells to encode<br>interrupt information.  The first cell defines the interrupt<br>number.  The second cell defines the sense and level<br>information.</p>
<p>Sense and level information should be encoded as follows:</p>
<pre><code>0 = low to high edge sensitive type enabled
1 = active low level sensitive type enabled
2 = active high level sensitive type enabled
3 = high to low edge sensitive type enabled
</code></pre>
<ol start="4">
<li>ISA Interrupt Controllers</li>
</ol>
<hr>
<p>ISA PIC interrupt controllers require 2 cells to encode<br>interrupt information.  The first cell defines the interrupt<br>number.  The second cell defines the sense and level<br>information.</p>
<p>ISA PIC interrupt controllers should adhere to the ISA PIC<br>encodings listed below:</p>
<pre><code>0 =  active low level sensitive type enabled
1 =  active high level sensitive type enabled
2 =  high to low edge sensitive type enabled
3 =  low to high edge sensitive type enabled
</code></pre>
<h1 id="VIII-Specifying-Device-Power-Management-Information-sleep-property"><a href="#VIII-Specifying-Device-Power-Management-Information-sleep-property" class="headerlink" title="VIII - Specifying Device Power Management Information (sleep property)"></a>VIII - Specifying Device Power Management Information (sleep property)</h1><p>Devices on SOCs often have mechanisms for placing devices into low-power<br>states that are decoupled from the devices’ own register blocks.  Sometimes,<br>this information is more complicated than a cell-index property can<br>reasonably describe.  Thus, each device controlled in such a manner<br>may contain a “sleep” property which describes these connections.</p>
<p>The sleep property consists of one or more sleep resources, each of<br>which consists of a phandle to a sleep controller, followed by a<br>controller-specific sleep specifier of zero or more cells.</p>
<p>The semantics of what type of low power modes are possible are defined<br>by the sleep controller.  Some examples of the types of low power modes<br>that may be supported are:</p>
<ul>
<li>Dynamic: The device may be disabled or enabled at any time.</li>
<li>System Suspend: The device may request to be disabled or remain<br>awake during system suspend, but will not be disabled until then.</li>
<li>Permanent: The device is disabled permanently (until the next hard<br>reset).</li>
</ul>
<p>Some devices may share a clock domain with each other, such that they should<br>only be suspended when none of the devices are in use.  Where reasonable,<br>such nodes should be placed on a virtual bus, where the bus has the sleep<br>property.  If the clock domain is shared among devices that cannot be<br>reasonably grouped in this manner, then create a virtual sleep controller<br>(similar to an interrupt nexus, except that defining a standardized<br>sleep-map should wait until its necessity is demonstrated).</p>
<h1 id="Appendix-A-Sample-SOC-node-for-MPC8540"><a href="#Appendix-A-Sample-SOC-node-for-MPC8540" class="headerlink" title="Appendix A - Sample SOC node for MPC8540"></a>Appendix A - Sample SOC node for MPC8540</h1><pre><code>soc@e0000000 &#123;
    #address-cells = &lt;1&gt;;
    #size-cells = &lt;1&gt;;
    compatible = &quot;fsl,mpc8540-ccsr&quot;, &quot;simple-bus&quot;;
    device_type = &quot;soc&quot;;
    ranges = &lt;0x00000000 0xe0000000 0x00100000&gt;
    bus-frequency = &lt;0&gt;;
    interrupt-parent = &lt;&amp;pic&gt;;

    ethernet@24000 &#123;
        #address-cells = &lt;1&gt;;
        #size-cells = &lt;1&gt;;
        device_type = &quot;network&quot;;
        model = &quot;TSEC&quot;;
        compatible = &quot;gianfar&quot;, &quot;simple-bus&quot;;
        reg = &lt;0x24000 0x1000&gt;;
        local-mac-address = [ 00 E0 0C 00 73 00 ];
        interrupts = &lt;29 2 30 2 34 2&gt;;
        phy-handle = &lt;&amp;phy0&gt;;
        sleep = &lt;&amp;pmc 00000080&gt;;
        ranges;

        mdio@24520 &#123;
            reg = &lt;0x24520 0x20&gt;;
            compatible = &quot;fsl,gianfar-mdio&quot;;

            phy0: ethernet-phy@0 &#123;
                interrupts = &lt;5 1&gt;;
                reg = &lt;0&gt;;
                device_type = &quot;ethernet-phy&quot;;
            &#125;;

            phy1: ethernet-phy@1 &#123;
                interrupts = &lt;5 1&gt;;
                reg = &lt;1&gt;;
                device_type = &quot;ethernet-phy&quot;;
            &#125;;

            phy3: ethernet-phy@3 &#123;
                interrupts = &lt;7 1&gt;;
                reg = &lt;3&gt;;
                device_type = &quot;ethernet-phy&quot;;
            &#125;;
        &#125;;
    &#125;;

    ethernet@25000 &#123;
        device_type = &quot;network&quot;;
        model = &quot;TSEC&quot;;
        compatible = &quot;gianfar&quot;;
        reg = &lt;0x25000 0x1000&gt;;
        local-mac-address = [ 00 E0 0C 00 73 01 ];
        interrupts = &lt;13 2 14 2 18 2&gt;;
        phy-handle = &lt;&amp;phy1&gt;;
        sleep = &lt;&amp;pmc 00000040&gt;;
    &#125;;

    ethernet@26000 &#123;
        device_type = &quot;network&quot;;
        model = &quot;FEC&quot;;
        compatible = &quot;gianfar&quot;;
        reg = &lt;0x26000 0x1000&gt;;
        local-mac-address = [ 00 E0 0C 00 73 02 ];
        interrupts = &lt;41 2&gt;;
        phy-handle = &lt;&amp;phy3&gt;;
        sleep = &lt;&amp;pmc 00000020&gt;;
    &#125;;

    serial@4500 &#123;
        #address-cells = &lt;1&gt;;
        #size-cells = &lt;1&gt;;
        compatible = &quot;fsl,mpc8540-duart&quot;, &quot;simple-bus&quot;;
        sleep = &lt;&amp;pmc 00000002&gt;;
        ranges;

        serial@4500 &#123;
            device_type = &quot;serial&quot;;
            compatible = &quot;ns16550&quot;;
            reg = &lt;0x4500 0x100&gt;;
            clock-frequency = &lt;0&gt;;
            interrupts = &lt;42 2&gt;;
        &#125;;

        serial@4600 &#123;
            device_type = &quot;serial&quot;;
            compatible = &quot;ns16550&quot;;
            reg = &lt;0x4600 0x100&gt;;
            clock-frequency = &lt;0&gt;;
            interrupts = &lt;42 2&gt;;
        &#125;;
    &#125;;

    pic: pic@40000 &#123;
        interrupt-controller;
        #address-cells = &lt;0&gt;;
        #interrupt-cells = &lt;2&gt;;
        reg = &lt;0x40000 0x40000&gt;;
        compatible = &quot;chrp,open-pic&quot;;
        device_type = &quot;open-pic&quot;;
    &#125;;

    i2c@3000 &#123;
        interrupts = &lt;43 2&gt;;
        reg = &lt;0x3000 0x100&gt;;
        compatible  = &quot;fsl-i2c&quot;;
        dfsrr;
        sleep = &lt;&amp;pmc 00000004&gt;;
    &#125;;

    pmc: power@e0070 &#123;
        compatible = &quot;fsl,mpc8540-pmc&quot;, &quot;fsl,mpc8548-pmc&quot;;
        reg = &lt;0xe0070 0x20&gt;;
    &#125;;
&#125;;
</code></pre>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_booting-without-of/" title="Kernel-2.6.32-573.12.1.el6_booting-without-of" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_booting-without-of/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_coda/" title="Kernel-2.6.32-573.12.1.el6_coda"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_biodoc/" title="Kernel-2.6.32-573.12.1.el6_biodoc"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>