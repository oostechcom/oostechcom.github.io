<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-3.10.0-957.el7_sched-deadline | oosTech.com</title>
  <meta name="description" content="Deadline Task Scheduling           ------------------------  CONTENTS WARNING Overview Scheduling algorithm 1 Main algorithm 2 Bandwidth reclaiming Scheduling Real-Time Tasks 1 Definitions 2">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-3.10.0-957.el7_sched-deadline">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_sched-deadline/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="Deadline Task Scheduling           ------------------------  CONTENTS WARNING Overview Scheduling algorithm 1 Main algorithm 2 Bandwidth reclaiming Scheduling Real-Time Tasks 1 Definitions 2">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_sched-deadline/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CONTENTS"><span class="toc-number">1.</span> <span class="toc-text">CONTENTS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#WARNING"><span class="toc-number">2.</span> <span class="toc-text">WARNING</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Overview"><span class="toc-number">3.</span> <span class="toc-text">Overview</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Scheduling-algorithm"><span class="toc-number">4.</span> <span class="toc-text">Scheduling algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Main-algorithm"><span class="toc-number">4.1.</span> <span class="toc-text">2.1 Main algorithm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Bandwidth-reclaiming"><span class="toc-number">4.2.</span> <span class="toc-text">2.2 Bandwidth reclaiming</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Scheduling-Real-Time-Tasks"><span class="toc-number">5.</span> <span class="toc-text">Scheduling Real-Time Tasks</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Definitions"><span class="toc-number">5.1.</span> <span class="toc-text">3.1 Definitions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Schedulability-Analysis-for-Uniprocessor-Systems"><span class="toc-number">5.2.</span> <span class="toc-text">3.2 Schedulability Analysis for Uniprocessor Systems</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Schedulability-Analysis-for-Multiprocessor-Systems"><span class="toc-number">5.3.</span> <span class="toc-text">3.3 Schedulability Analysis for Multiprocessor Systems</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Relationship-with-SCHED-DEADLINE-Parameters"><span class="toc-number">5.4.</span> <span class="toc-text">3.4 Relationship with SCHED_DEADLINE Parameters</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bandwidth-management"><span class="toc-number">6.</span> <span class="toc-text">Bandwidth management</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-System-wide-settings"><span class="toc-number">6.1.</span> <span class="toc-text">4.1 System wide settings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Task-interface"><span class="toc-number">6.2.</span> <span class="toc-text">4.2 Task interface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Default-behavior"><span class="toc-number">6.3.</span> <span class="toc-text">4.3 Default behavior</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tasks-CPU-affinity"><span class="toc-number">7.</span> <span class="toc-text">Tasks CPU affinity</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-SCHED-DEADLINE-and-cpusets-HOWTO"><span class="toc-number">7.1.</span> <span class="toc-text">5.1 SCHED_DEADLINE and cpusets HOWTO</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Future-plans"><span class="toc-number">8.</span> <span class="toc-text">Future plans</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Appendix-A-Test-suite"><span class="toc-number">9.</span> <span class="toc-text">Appendix A. Test suite</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rt-app-t-100000-10000-d-t-150000-20000-f-10-D5"><span class="toc-number">10.</span> <span class="toc-text">rt-app -t 100000:10000:d -t 150000:20000:f:10 -D5</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rt-app-my-config-json"><span class="toc-number">11.</span> <span class="toc-text">rt-app my_config.json</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#schedtool-E-t-10000000-100000000-e-my-cpuhog-app"><span class="toc-number">12.</span> <span class="toc-text">schedtool -E -t 10000000:100000000 -e .&#x2F;my_cpuhog_app</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#schedtool-E-t-10000000-100000000-my-app-pid"><span class="toc-number">13.</span> <span class="toc-text">schedtool -E -t 10000000:100000000 my_app_pid</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Appendix-B-Minimal-main"><span class="toc-number">14.</span> <span class="toc-text">Appendix B. Minimal main()</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-3.10.0-957.el7_sched-deadline" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-3.10.0-957.el7_sched-deadline
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_sched-deadline/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_sched-deadline/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-3.10.0-957.el7_sched-deadline/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <pre><code>          Deadline Task Scheduling
          ------------------------
</code></pre>
<h1 id="CONTENTS"><a href="#CONTENTS" class="headerlink" title="CONTENTS"></a>CONTENTS</h1><ol start="0">
<li>WARNING</li>
<li>Overview</li>
<li>Scheduling algorithm</li>
<li>1 Main algorithm</li>
<li>2 Bandwidth reclaiming</li>
<li>Scheduling Real-Time Tasks</li>
<li>1 Definitions</li>
<li>2 Schedulability Analysis for Uniprocessor Systems</li>
<li>3 Schedulability Analysis for Multiprocessor Systems</li>
<li>4 Relationship with SCHED_DEADLINE Parameters</li>
<li>Bandwidth management</li>
<li>1 System-wide settings</li>
<li>2 Task interface</li>
<li>3 Default behavior</li>
<li>Tasks CPU affinity</li>
<li>1 SCHED_DEADLINE and cpusets HOWTO</li>
<li>Future plans<br>A. Test suite<br>B. Minimal main()</li>
</ol>
<ol start="0">
<li><h1 id="WARNING"><a href="#WARNING" class="headerlink" title="WARNING"></a>WARNING</h1><p>Fiddling with these settings can result in an unpredictable or even unstable<br>system behavior. As for -rt (group) scheduling, it is assumed that root users<br>know what they’re doing.</p>
</li>
</ol>
<ol>
<li><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>The SCHED_DEADLINE policy contained inside the sched_dl scheduling class is<br>basically an implementation of the Earliest Deadline First (EDF) scheduling<br>algorithm, augmented with a mechanism (called Constant Bandwidth Server, CBS)<br>that makes it possible to isolate the behavior of tasks between each other.</p>
</li>
</ol>
<ol start="2">
<li><h1 id="Scheduling-algorithm"><a href="#Scheduling-algorithm" class="headerlink" title="Scheduling algorithm"></a>Scheduling algorithm</h1></li>
</ol>
<h2 id="2-1-Main-algorithm"><a href="#2-1-Main-algorithm" class="headerlink" title="2.1 Main algorithm"></a>2.1 Main algorithm</h2><p> SCHED_DEADLINE uses three parameters, named “runtime”, “period”, and<br> “deadline”, to schedule tasks. A SCHED_DEADLINE task should receive<br> “runtime” microseconds of execution time every “period” microseconds, and<br> these “runtime” microseconds are available within “deadline” microseconds<br> from the beginning of the period.  In order to implement this behavior,<br> every time the task wakes up, the scheduler computes a “scheduling deadline”<br> consistent with the guarantee (using the CBS[2,3] algorithm). Tasks are then<br> scheduled using EDF[1] on these scheduling deadlines (the task with the<br> earliest scheduling deadline is selected for execution). Notice that the<br> task actually receives “runtime” time units within “deadline” if a proper<br> “admission control” strategy (see Section “4. Bandwidth management”) is used<br> (clearly, if the system is overloaded this guarantee cannot be respected).</p>
<p> Summing up, the CBS[2,3] algorithm assigns scheduling deadlines to tasks so<br> that each task runs for at most its runtime every period, avoiding any<br> interference between different tasks (bandwidth isolation), while the EDF[1]<br> algorithm selects the task with the earliest scheduling deadline as the one<br> to be executed next. Thanks to this feature, tasks that do not strictly comply<br> with the “traditional” real-time task model (see Section 3) can effectively<br> use the new policy.</p>
<p> In more details, the CBS algorithm assigns scheduling deadlines to<br> tasks in the following way:</p>
<ul>
<li><p>Each SCHED_DEADLINE task is characterized by the “runtime”,<br>“deadline”, and “period” parameters;</p>
</li>
<li><p>The state of the task is described by a “scheduling deadline”, and<br>a “remaining runtime”. These two parameters are initially set to 0;</p>
</li>
<li><p>When a SCHED_DEADLINE task wakes up (becomes ready for execution),<br>the scheduler checks if</p>
<pre><code>         remaining runtime                  runtime
----------------------------------    &gt;    ---------
scheduling deadline - current time           period
</code></pre>
<p>then, if the scheduling deadline is smaller than the current time, or<br>this condition is verified, the scheduling deadline and the<br>remaining runtime are re-initialized as</p>
<pre><code> scheduling deadline = current time + deadline
 remaining runtime = runtime
</code></pre>
<p>otherwise, the scheduling deadline and the remaining runtime are<br>left unchanged;</p>
</li>
<li><p>When a SCHED_DEADLINE task executes for an amount of time t, its<br>remaining runtime is decreased as</p>
<pre><code> remaining runtime = remaining runtime - t
</code></pre>
<p>(technically, the runtime is decreased at every tick, or when the<br>task is descheduled / preempted);</p>
</li>
<li><p>When the remaining runtime becomes less or equal than 0, the task is<br>said to be “throttled” (also known as “depleted” in real-time literature)<br>and cannot be scheduled until its scheduling deadline. The “replenishment<br>time” for this task (see next item) is set to be equal to the current<br>value of the scheduling deadline;</p>
</li>
<li><p>When the current time is equal to the replenishment time of a<br>throttled task, the scheduling deadline and the remaining runtime are<br>updated as</p>
<pre><code> scheduling deadline = scheduling deadline + period
 remaining runtime = remaining runtime + runtime
</code></pre>
</li>
</ul>
<h2 id="2-2-Bandwidth-reclaiming"><a href="#2-2-Bandwidth-reclaiming" class="headerlink" title="2.2 Bandwidth reclaiming"></a>2.2 Bandwidth reclaiming</h2><p> Bandwidth reclaiming for deadline tasks is based on the GRUB (Greedy<br> Reclamation of Unused Bandwidth) algorithm [15, 16, 17] and it is enabled<br> when flag SCHED_FLAG_RECLAIM is set.</p>
<p> The following diagram illustrates the state names for tasks handled by GRUB:</p>
<pre><code>                         ------------
             (d)        |   Active   |
          -------------&gt;|            |
          |             | Contending |
          |              ------------
          |                A      |
      ----------           |      |
     |          |          |      |
     | Inactive |          |(b)   | (a)
     |          |          |      |
      ----------           |      |
          A                |      V
          |              ------------
          |             |   Active   |
          --------------|     Non    |
             (c)        | Contending |
                         ------------
</code></pre>
<p> A task can be in one of the following states:</p>
<ul>
<li><p>ActiveContending: if it is ready for execution (or executing);</p>
</li>
<li><p>ActiveNonContending: if it just blocked and has not yet surpassed the 0-lag<br>time;</p>
</li>
<li><p>Inactive: if it is blocked and has surpassed the 0-lag time.</p>
<p>State transitions:</p>
<p>(a) When a task blocks, it does not become immediately inactive since its<br>  bandwidth cannot be immediately reclaimed without breaking the<br>  real-time guarantees. It therefore enters a transitional state called<br>  ActiveNonContending. The scheduler arms the “inactive timer” to fire at<br>  the 0-lag time, when the task’s bandwidth can be reclaimed without<br>  breaking the real-time guarantees.</p>
<p>  The 0-lag time for a task entering the ActiveNonContending state is<br>  computed as</p>
<pre><code>                (runtime * dl_period)
     deadline - ---------------------
                     dl_runtime
</code></pre>
<p>  where runtime is the remaining runtime, while dl_runtime and dl_period<br>  are the reservation parameters.</p>
<p>(b) If the task wakes up before the inactive timer fires, the task re-enters<br>  the ActiveContending state and the “inactive timer” is canceled.<br>  In addition, if the task wakes up on a different runqueue, then<br>  the task’s utilization must be removed from the previous runqueue’s active<br>  utilization and must be added to the new runqueue’s active utilization.<br>  In order to avoid races between a task waking up on a runqueue while the<br>   “inactive timer” is running on a different CPU, the “dl_non_contending”<br>  flag is used to indicate that a task is not on a runqueue but is active<br>  (so, the flag is set when the task blocks and is cleared when the<br>  “inactive timer” fires or when the task  wakes up).</p>
<p>(c) When the “inactive timer” fires, the task enters the Inactive state and<br>  its utilization is removed from the runqueue’s active utilization.</p>
<p>(d) When an inactive task wakes up, it enters the ActiveContending state and<br>  its utilization is added to the active utilization of the runqueue where<br>  it has been enqueued.</p>
<p>For each runqueue, the algorithm GRUB keeps track of two different bandwidths:</p>
</li>
<li><p>Active bandwidth (running_bw): this is the sum of the bandwidths of all<br>tasks in active state (i.e., ActiveContending or ActiveNonContending);</p>
</li>
<li><p>Total bandwidth (this_bw): this is the sum of all tasks “belonging” to the<br>runqueue, including the tasks in Inactive state.</p>
</li>
</ul>
<p> The algorithm reclaims the bandwidth of the tasks in Inactive state.<br> It does so by decrementing the runtime of the executing task Ti at a pace equal<br> to</p>
<pre><code>       dq = -max&#123; Ui, (1 - Uinact) &#125; dt
</code></pre>
<p> where Uinact is the inactive utilization, computed as (this_bq - running_bw),<br> and Ui is the bandwidth of task Ti.</p>
<p> Let’s now see a trivial example of two deadline tasks with runtime equal<br> to 4 and period equal to 8 (i.e., bandwidth equal to 0.5):</p>
<pre><code> A            Task T1
 |
 |                               |
 |                               |
 |--------                       |----
 |       |                       V
 |---|---|---|---|---|---|---|---|---------&gt;t
 0   1   2   3   4   5   6   7   8


 A            Task T2
 |
 |                               |
 |                               |
 |       ------------------------|
 |       |                       V
 |---|---|---|---|---|---|---|---|---------&gt;t
 0   1   2   3   4   5   6   7   8


 A            running_bw
 |
</code></pre>
<p>   1 —————–               ——<br>     |               |               |<br>  0.5-               —————–<br>     |                               |<br>     |—|—|—|—|—|—|—|—|———&gt;t<br>     0   1   2   3   4   5   6   7   8</p>
<ul>
<li><p>Time t = 0:</p>
<p>Both tasks are ready for execution and therefore in ActiveContending state.<br>Suppose Task T1 is the first task to start execution.<br>Since there are no inactive tasks, its runtime is decreased as dq = -1 dt.</p>
</li>
<li><p>Time t = 2:</p>
<p>Suppose that task T1 blocks<br>Task T1 therefore enters the ActiveNonContending state. Since its remaining<br>runtime is equal to 2, its 0-lag time is equal to t = 4.<br>Task T2 start execution, with runtime still decreased as dq = -1 dt since<br>there are no inactive tasks.</p>
</li>
<li><p>Time t = 4:</p>
<p>This is the 0-lag time for Task T1. Since it didn’t woken up in the<br>meantime, it enters the Inactive state. Its bandwidth is removed from<br>running_bw.<br>Task T2 continues its execution. However, its runtime is now decreased as<br>dq = - 0.5 dt because Uinact = 0.5.<br>Task T2 therefore reclaims the bandwidth unused by Task T1.</p>
</li>
<li><p>Time t = 8:</p>
<p>Task T1 wakes up. It enters the ActiveContending state again, and the<br>running_bw is incremented.</p>
</li>
</ul>
<ol start="3">
<li><h1 id="Scheduling-Real-Time-Tasks"><a href="#Scheduling-Real-Time-Tasks" class="headerlink" title="Scheduling Real-Time Tasks"></a>Scheduling Real-Time Tasks</h1></li>
</ol>
<ul>
<li>BIG FAT WARNING <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></li>
<li></li>
<li>This section contains a (not-thorough) summary on classical deadline</li>
<li>scheduling theory, and how it applies to SCHED_DEADLINE.</li>
<li>The reader can “safely” skip to Section 4 if only interested in seeing</li>
<li>how the scheduling policy can be used. Anyway, we strongly recommend</li>
<li>to come back here and continue reading (once the urge for testing is</li>
<li>satisfied :P) to be sure of fully understanding all technical details.</li>
</ul>
<hr>
<p> There are no limitations on what kind of task can exploit this new<br> scheduling discipline, even if it must be said that it is particularly<br> suited for periodic or sporadic real-time tasks that need guarantees on their<br> timing behavior, e.g., multimedia, streaming, control applications, etc.</p>
<h2 id="3-1-Definitions"><a href="#3-1-Definitions" class="headerlink" title="3.1 Definitions"></a>3.1 Definitions</h2><p> A typical real-time task is composed of a repetition of computation phases<br> (task instances, or jobs) which are activated on a periodic or sporadic<br> fashion.<br> Each job J_j (where J_j is the j^th job of the task) is characterized by an<br> arrival time r_j (the time when the job starts), an amount of computation<br> time c_j needed to finish the job, and a job absolute deadline d_j, which<br> is the time within which the job should be finished. The maximum execution<br> time max{c_j} is called “Worst Case Execution Time” (WCET) for the task.<br> A real-time task can be periodic with period P if r_{j+1} = r_j + P, or<br> sporadic with minimum inter-arrival time P is r_{j+1} &gt;= r_j + P. Finally,<br> d_j = r_j + D, where D is the task’s relative deadline.<br> Summing up, a real-time task can be described as<br>    Task = (WCET, D, P)</p>
<p> The utilization of a real-time task is defined as the ratio between its<br> WCET and its period (or minimum inter-arrival time), and represents<br> the fraction of CPU time needed to execute the task.</p>
<p> If the total utilization U=sum(WCET_i/P_i) is larger than M (with M equal<br> to the number of CPUs), then the scheduler is unable to respect all the<br> deadlines.<br> Note that total utilization is defined as the sum of the utilizations<br> WCET_i/P_i over all the real-time tasks in the system. When considering<br> multiple real-time tasks, the parameters of the i-th task are indicated<br> with the “_i” suffix.<br> Moreover, if the total utilization is larger than M, then we risk starving<br> non- real-time tasks by real-time tasks.<br> If, instead, the total utilization is smaller than M, then non real-time<br> tasks will not be starved and the system might be able to respect all the<br> deadlines.<br> As a matter of fact, in this case it is possible to provide an upper bound<br> for tardiness (defined as the maximum between 0 and the difference<br> between the finishing time of a job and its absolute deadline).<br> More precisely, it can be proven that using a global EDF scheduler the<br> maximum tardiness of each task is smaller or equal than<br>    ((M â 1) Â· WCET_max â WCET_min)/(M â (M â 2) Â· U_max) + WCET_max<br> where WCET_max = max{WCET_i} is the maximum WCET, WCET_min=min{WCET_i}<br> is the minimum WCET, and U_max = max{WCET_i/P_i} is the maximum<br> utilization[12].</p>
<h2 id="3-2-Schedulability-Analysis-for-Uniprocessor-Systems"><a href="#3-2-Schedulability-Analysis-for-Uniprocessor-Systems" class="headerlink" title="3.2 Schedulability Analysis for Uniprocessor Systems"></a>3.2 Schedulability Analysis for Uniprocessor Systems</h2><p> If M=1 (uniprocessor system), or in case of partitioned scheduling (each<br> real-time task is statically assigned to one and only one CPU), it is<br> possible to formally check if all the deadlines are respected.<br> If D_i = P_i for all tasks, then EDF is able to respect all the deadlines<br> of all the tasks executing on a CPU if and only if the total utilization<br> of the tasks running on such a CPU is smaller or equal than 1.<br> If D_i != P_i for some task, then it is possible to define the density of<br> a task as WCET_i/min{D_i,P_i}, and EDF is able to respect all the deadlines<br> of all the tasks running on a CPU if the sum of the densities of the tasks<br> running on such a CPU is smaller or equal than 1:<br>    sum(WCET_i / min{D_i, P_i}) &lt;= 1<br> It is important to notice that this condition is only sufficient, and not<br> necessary: there are task sets that are schedulable, but do not respect the<br> condition. For example, consider the task set {Task_1,Task_2} composed by<br> Task_1=(50ms,50ms,100ms) and Task_2=(10ms,100ms,100ms).<br> EDF is clearly able to schedule the two tasks without missing any deadline<br> (Task_1 is scheduled as soon as it is released, and finishes just in time<br> to respect its deadline; Task_2 is scheduled immediately after Task_1, hence<br> its response time cannot be larger than 50ms + 10ms = 60ms) even if<br>    50 / min{50,100} + 10 / min{100, 100} = 50 / 50 + 10 / 100 = 1.1<br> Of course it is possible to test the exact schedulability of tasks with<br> D_i != P_i (checking a condition that is both sufficient and necessary),<br> but this cannot be done by comparing the total utilization or density with<br> a constant. Instead, the so called “processor demand” approach can be used,<br> computing the total amount of CPU time h(t) needed by all the tasks to<br> respect all of their deadlines in a time interval of size t, and comparing<br> such a time with the interval size t. If h(t) is smaller than t (that is,<br> the amount of time needed by the tasks in a time interval of size t is<br> smaller than the size of the interval) for all the possible values of t, then<br> EDF is able to schedule the tasks respecting all of their deadlines. Since<br> performing this check for all possible values of t is impossible, it has been<br> proven[4,5,6] that it is sufficient to perform the test for values of t<br> between 0 and a maximum value L. The cited papers contain all of the<br> mathematical details and explain how to compute h(t) and L.<br> In any case, this kind of analysis is too complex as well as too<br> time-consuming to be performed on-line. Hence, as explained in Section<br> 4 Linux uses an admission test based on the tasks’ utilizations.</p>
<h2 id="3-3-Schedulability-Analysis-for-Multiprocessor-Systems"><a href="#3-3-Schedulability-Analysis-for-Multiprocessor-Systems" class="headerlink" title="3.3 Schedulability Analysis for Multiprocessor Systems"></a>3.3 Schedulability Analysis for Multiprocessor Systems</h2><p> On multiprocessor systems with global EDF scheduling (non partitioned<br> systems), a sufficient test for schedulability can not be based on the<br> utilizations or densities: it can be shown that even if D_i = P_i task<br> sets with utilizations slightly larger than 1 can miss deadlines regardless<br> of the number of CPUs.</p>
<p> Consider a set {Task_1,…Task_{M+1}} of M+1 tasks on a system with M<br> CPUs, with the first task Task_1=(P,P,P) having period, relative deadline<br> and WCET equal to P. The remaining M tasks Task_i=(e,P-1,P-1) have an<br> arbitrarily small worst case execution time (indicated as “e” here) and a<br> period smaller than the one of the first task. Hence, if all the tasks<br> activate at the same time t, global EDF schedules these M tasks first<br> (because their absolute deadlines are equal to t + P - 1, hence they are<br> smaller than the absolute deadline of Task_1, which is t + P). As a<br> result, Task_1 can be scheduled only at time t + e, and will finish at<br> time t + e + P, after its absolute deadline. The total utilization of the<br> task set is U = M Â· e / (P - 1) + P / P = M Â· e / (P - 1) + 1, and for small<br> values of e this can become very close to 1. This is known as “Dhall’s<br> effect”[7]. Note: the example in the original paper by Dhall has been<br> slightly simplified here (for example, Dhall more correctly computed<br> lim_{e-&gt;0}U).</p>
<p> More complex schedulability tests for global EDF have been developed in<br> real-time literature[8,9], but they are not based on a simple comparison<br> between total utilization (or density) and a fixed constant. If all tasks<br> have D_i = P_i, a sufficient schedulability condition can be expressed in<br> a simple way:<br>    sum(WCET_i / P_i) &lt;= M - (M - 1) Â· U_max<br> where U_max = max{WCET_i / P_i}[10]. Notice that for U_max = 1,<br> M - (M - 1) Â· U_max becomes M - M + 1 = 1 and this schedulability condition<br> just confirms the Dhall’s effect. A more complete survey of the literature<br> about schedulability tests for multi-processor real-time scheduling can be<br> found in [11].</p>
<p> As seen, enforcing that the total utilization is smaller than M does not<br> guarantee that global EDF schedules the tasks without missing any deadline<br> (in other words, global EDF is not an optimal scheduling algorithm). However,<br> a total utilization smaller than M is enough to guarantee that non real-time<br> tasks are not starved and that the tardiness of real-time tasks has an upper<br> bound[12] (as previously noted). Different bounds on the maximum tardiness<br> experienced by real-time tasks have been developed in various papers[13,14],<br> but the theoretical result that is important for SCHED_DEADLINE is that if<br> the total utilization is smaller or equal than M then the response times of<br> the tasks are limited.</p>
<h2 id="3-4-Relationship-with-SCHED-DEADLINE-Parameters"><a href="#3-4-Relationship-with-SCHED-DEADLINE-Parameters" class="headerlink" title="3.4 Relationship with SCHED_DEADLINE Parameters"></a>3.4 Relationship with SCHED_DEADLINE Parameters</h2><p> Finally, it is important to understand the relationship between the<br> SCHED_DEADLINE scheduling parameters described in Section 2 (runtime,<br> deadline and period) and the real-time task parameters (WCET, D, P)<br> described in this section. Note that the tasks’ temporal constraints are<br> represented by its absolute deadlines d_j = r_j + D described above, while<br> SCHED_DEADLINE schedules the tasks according to scheduling deadlines (see<br> Section 2).<br> If an admission test is used to guarantee that the scheduling deadlines<br> are respected, then SCHED_DEADLINE can be used to schedule real-time tasks<br> guaranteeing that all the jobs’ deadlines of a task are respected.<br> In order to do this, a task must be scheduled by setting:</p>
<ul>
<li><p>runtime &gt;= WCET</p>
</li>
<li><p>deadline = D</p>
</li>
<li><p>period &lt;= P</p>
<p>IOW, if runtime &gt;= WCET and if period is &lt;= P, then the scheduling deadlines<br>and the absolute deadlines (d_j) coincide, so a proper admission control<br>allows to respect the jobs’ absolute deadlines for this task (this is what is<br>called “hard schedulability property” and is an extension of Lemma 1 of [2]).<br>Notice that if runtime &gt; deadline the admission control will surely reject<br>this task, as it is not possible to respect its temporal constraints.</p>
<p>References:<br>1 - C. L. Liu and J. W. Layland. Scheduling algorithms for multiprogram-<br>  ming in a hard-real-time environment. Journal of the Association for<br>  Computing Machinery, 20(1), 1973.<br>2 - L. Abeni , G. Buttazzo. Integrating Multimedia Applications in Hard<br>  Real-Time Systems. Proceedings of the 19th IEEE Real-time Systems<br>  Symposium, 1998. <a target="_blank" rel="noopener" href="http://retis.sssup.it/~giorgio/paps/1998/rtss98-cbs.pdf">http://retis.sssup.it/~giorgio/paps/1998/rtss98-cbs.pdf</a><br>3 - L. Abeni. Server Mechanisms for Multimedia Applications. ReTiS Lab<br>  Technical Report. <a target="_blank" rel="noopener" href="http://disi.unitn.it/~abeni/tr-98-01.pdf">http://disi.unitn.it/~abeni/tr-98-01.pdf</a><br>4 - J. Y. Leung and M.L. Merril. A Note on Preemptive Scheduling of<br>  Periodic, Real-Time Tasks. Information Processing Letters, vol. 11,<br>  no. 3, pp. 115-118, 1980.<br>5 - S. K. Baruah, A. K. Mok and L. E. Rosier. Preemptively Scheduling<br>  Hard-Real-Time Sporadic Tasks on One Processor. Proceedings of the<br>  11th IEEE Real-time Systems Symposium, 1990.<br>6 - S. K. Baruah, L. E. Rosier and R. R. Howell. Algorithms and Complexity<br>  Concerning the Preemptive Scheduling of Periodic Real-Time tasks on<br>  One Processor. Real-Time Systems Journal, vol. 4, no. 2, pp 301-324,<br>  1990.<br>7 - S. J. Dhall and C. L. Liu. On a real-time scheduling problem. Operations<br>  research, vol. 26, no. 1, pp 127-140, 1978.<br>8 - T. Baker. Multiprocessor EDF and Deadline Monotonic Schedulability<br>  Analysis. Proceedings of the 24th IEEE Real-Time Systems Symposium, 2003.<br>9 - T. Baker. An Analysis of EDF Schedulability on a Multiprocessor.<br>  IEEE Transactions on Parallel and Distributed Systems, vol. 16, no. 8,<br>  pp 760-768, 2005.<br>10 - J. Goossens, S. Funk and S. Baruah, Priority-Driven Scheduling of<br>   Periodic Task Systems on Multiprocessors. Real-Time Systems Journal,<br>   vol. 25, no. 2â3, pp. 187â205, 2003.<br>11 - R. Davis and A. Burns. A Survey of Hard Real-Time Scheduling for<br>   Multiprocessor Systems. ACM Computing Surveys, vol. 43, no. 4, 2011.<br>   <a target="_blank" rel="noopener" href="http://www-users.cs.york.ac.uk/~robdavis/papers/MPSurveyv5.0.pdf">http://www-users.cs.york.ac.uk/~robdavis/papers/MPSurveyv5.0.pdf</a><br>12 - U. C. Devi and J. H. Anderson. Tardiness Bounds under Global EDF<br>   Scheduling on a Multiprocessor. Real-Time Systems Journal, vol. 32,<br>   no. 2, pp 133-189, 2008.<br>13 - P. Valente and G. Lipari. An Upper Bound to the Lateness of Soft<br>   Real-Time Tasks Scheduled by EDF on Multiprocessors. Proceedings of<br>   the 26th IEEE Real-Time Systems Symposium, 2005.<br>14 - J. Erickson, U. Devi and S. Baruah. Improved tardiness bounds for<br>   Global EDF. Proceedings of the 22nd Euromicro Conference on<br>   Real-Time Systems, 2010.<br>15 - G. Lipari, S. Baruah, Greedy reclamation of unused bandwidth in<br>   constant-bandwidth servers, 12th IEEE Euromicro Conference on Real-Time<br>   Systems, 2000.<br>16 - L. Abeni, J. Lelli, C. Scordino, L. Palopoli, Greedy CPU reclaiming for<br>   SCHED DEADLINE. In Proceedings of the Real-Time Linux Workshop (RTLWS),<br>   Dusseldorf, Germany, 2014.<br>17 - L. Abeni, G. Lipari, A. Parri, Y. Sun, Multicore CPU reclaiming: parallel<br>   or sequential?. In Proceedings of the 31st Annual ACM Symposium on Applied<br>   Computing, 2016.</p>
</li>
</ul>
<ol start="4">
<li><h1 id="Bandwidth-management"><a href="#Bandwidth-management" class="headerlink" title="Bandwidth management"></a>Bandwidth management</h1><p>As previously mentioned, in order for -deadline scheduling to be<br>effective and useful (that is, to be able to provide “runtime” time units<br>within “deadline”), it is important to have some method to keep the allocation<br>of the available fractions of CPU time to the various tasks under control.<br>This is usually called “admission control” and if it is not performed, then<br>no guarantee can be given on the actual scheduling of the -deadline tasks.</p>
<p>As already stated in Section 3, a necessary condition to be respected to<br>correctly schedule a set of real-time tasks is that the total utilization<br>is smaller than M. When talking about -deadline tasks, this requires that<br>the sum of the ratio between runtime and period for all tasks is smaller<br>than M. Notice that the ratio runtime/period is equivalent to the utilization<br>of a “traditional” real-time task, and is also often referred to as<br>“bandwidth”.<br>The interface used to control the CPU bandwidth that can be allocated<br>to -deadline tasks is similar to the one already used for -rt<br>tasks with real-time group scheduling (a.k.a. RT-throttling - see<br>Documentation/scheduler/sched-rt-group.txt), and is based on readable/<br>writable control files located in procfs (for system wide settings).<br>Notice that per-group settings (controlled through cgroupfs) are still not<br>defined for -deadline tasks, because more discussion is needed in order to<br>figure out how we want to manage SCHED_DEADLINE bandwidth at the task group<br>level.</p>
<p>A main difference between deadline bandwidth management and RT-throttling<br>is that -deadline tasks have bandwidth on their own (while -rt ones don’t!),<br>and thus we don’t need a higher level throttling mechanism to enforce the<br>desired bandwidth. In other words, this means that interface parameters are<br>only used at admission control time (i.e., when the user calls<br>sched_setattr()). Scheduling is then performed considering actual tasks’<br>parameters, so that CPU bandwidth is allocated to SCHED_DEADLINE tasks<br>respecting their needs in terms of granularity. Therefore, using this simple<br>interface we can put a cap on total utilization of -deadline tasks (i.e.,<br>\Sum (runtime_i / period_i) &lt; global_dl_utilization_cap).</p>
</li>
</ol>
<h2 id="4-1-System-wide-settings"><a href="#4-1-System-wide-settings" class="headerlink" title="4.1 System wide settings"></a>4.1 System wide settings</h2><p> The system wide settings are configured under the /proc virtual file system.</p>
<p> For now the -rt knobs are used for -deadline admission control and the<br> -deadline runtime is accounted against the -rt runtime. We realize that this<br> isn’t entirely desirable; however, it is better to have a small interface for<br> now, and be able to change it easily later. The ideal situation (see 5.) is to<br> run -rt tasks from a -deadline server; in which case the -rt bandwidth is a<br> direct subset of dl_bw.</p>
<p> This means that, for a root_domain comprising M CPUs, -deadline tasks<br> can be created while the sum of their bandwidths stays below:</p>
<p>   M * (sched_rt_runtime_us / sched_rt_period_us)</p>
<p> It is also possible to disable this bandwidth management logic, and<br> be thus free of oversubscribing the system up to any arbitrary level.<br> This is done by writing -1 in /proc/sys/kernel/sched_rt_runtime_us.</p>
<h2 id="4-2-Task-interface"><a href="#4-2-Task-interface" class="headerlink" title="4.2 Task interface"></a>4.2 Task interface</h2><p> Specifying a periodic/sporadic task that executes for a given amount of<br> runtime at each instance, and that is scheduled according to the urgency of<br> its own timing constraints needs, in general, a way of declaring:</p>
<ul>
<li><p>a (maximum/typical) instance execution time,</p>
</li>
<li><p>a minimum interval between consecutive instances,</p>
</li>
<li><p>a time constraint by which each instance must be completed.</p>
<p>Therefore:</p>
</li>
</ul>
<ul>
<li>a new struct sched_attr, containing all the necessary fields is<br>provided;</li>
<li>the new scheduling related syscalls that manipulate it, i.e.,<br>sched_setattr() and sched_getattr() are implemented.</li>
</ul>
<h2 id="4-3-Default-behavior"><a href="#4-3-Default-behavior" class="headerlink" title="4.3 Default behavior"></a>4.3 Default behavior</h2><p> The default value for SCHED_DEADLINE bandwidth is to have rt_runtime equal to<br> 950000. With rt_period equal to 1000000, by default, it means that -deadline<br> tasks can use at most 95%, multiplied by the number of CPUs that compose the<br> root_domain, for each root_domain.<br> This means that non -deadline tasks will receive at least 5% of the CPU time,<br> and that -deadline tasks will receive their runtime with a guaranteed<br> worst-case delay respect to the “deadline” parameter. If “deadline” = “period”<br> and the cpuset mechanism is used to implement partitioned scheduling (see<br> Section 5), then this simple setting of the bandwidth management is able to<br> deterministically guarantee that -deadline tasks will receive their runtime<br> in a period.</p>
<p> Finally, notice that in order not to jeopardize the admission control a<br> -deadline task cannot fork.</p>
<ol start="5">
<li><h1 id="Tasks-CPU-affinity"><a href="#Tasks-CPU-affinity" class="headerlink" title="Tasks CPU affinity"></a>Tasks CPU affinity</h1></li>
</ol>
<p> -deadline tasks cannot have an affinity mask smaller that the entire<br> root_domain they are created on. However, affinities can be specified<br> through the cpuset facility (Documentation/cgroups/cpusets.txt).</p>
<h2 id="5-1-SCHED-DEADLINE-and-cpusets-HOWTO"><a href="#5-1-SCHED-DEADLINE-and-cpusets-HOWTO" class="headerlink" title="5.1 SCHED_DEADLINE and cpusets HOWTO"></a>5.1 SCHED_DEADLINE and cpusets HOWTO</h2><p> An example of a simple configuration (pin a -deadline task to CPU0)<br> follows (rt-app is used to create a -deadline task).</p>
<p> mkdir /dev/cpuset<br> mount -t cgroup -o cpuset cpuset /dev/cpuset<br> cd /dev/cpuset<br> mkdir cpu0<br> echo 0 &gt; cpu0/cpuset.cpus<br> echo 0 &gt; cpu0/cpuset.mems<br> echo 1 &gt; cpuset.cpu_exclusive<br> echo 0 &gt; cpuset.sched_load_balance<br> echo 1 &gt; cpu0/cpuset.cpu_exclusive<br> echo 1 &gt; cpu0/cpuset.mem_exclusive<br> echo $$ &gt; cpu0/tasks<br> rt-app -t 100000:10000:d:0 -D5 (it is now actually superfluous to specify<br> task affinity)</p>
<ol start="6">
<li><h1 id="Future-plans"><a href="#Future-plans" class="headerlink" title="Future plans"></a>Future plans</h1><p>Still missing:</p>
</li>
</ol>
<ul>
<li><p>refinements to deadline inheritance, especially regarding the possibility<br>of retaining bandwidth isolation among non-interacting tasks. This is<br>being studied from both theoretical and practical points of view, and<br>hopefully we should be able to produce some demonstrative code soon;</p>
</li>
<li><p>(c)group based bandwidth management, and maybe scheduling;</p>
</li>
<li><p>access control for non-root users (and related security concerns to<br>address), which is the best way to allow unprivileged use of the mechanisms<br>and how to prevent non-root users “cheat” the system?</p>
<p>As already discussed, we are planning also to merge this work with the EDF<br>throttling patches [<a target="_blank" rel="noopener" href="https://lkml.org/lkml/2010/2/23/239]">https://lkml.org/lkml/2010/2/23/239]</a> but we still are in<br>the preliminary phases of the merge and we really seek feedback that would<br>help us decide on the direction it should take.</p>
</li>
</ul>
<h1 id="Appendix-A-Test-suite"><a href="#Appendix-A-Test-suite" class="headerlink" title="Appendix A. Test suite"></a>Appendix A. Test suite</h1><p> The SCHED_DEADLINE policy can be easily tested using two applications that<br> are part of a wider Linux Scheduler validation suite. The suite is<br> available as a GitHub repository: <a target="_blank" rel="noopener" href="https://github.com/scheduler-tools">https://github.com/scheduler-tools</a>.</p>
<p> The first testing application is called rt-app and can be used to<br> start multiple threads with specific parameters. rt-app supports<br> SCHED_{OTHER,FIFO,RR,DEADLINE} scheduling policies and their related<br> parameters (e.g., niceness, priority, runtime/deadline/period). rt-app<br> is a valuable tool, as it can be used to synthetically recreate certain<br> workloads (maybe mimicking real use-cases) and evaluate how the scheduler<br> behaves under such workloads. In this way, results are easily reproducible.<br> rt-app is available at: <a target="_blank" rel="noopener" href="https://github.com/scheduler-tools/rt-app">https://github.com/scheduler-tools/rt-app</a>.</p>
<p> Thread parameters can be specified from the command line, with something like<br> this:</p>
<h1 id="rt-app-t-100000-10000-d-t-150000-20000-f-10-D5"><a href="#rt-app-t-100000-10000-d-t-150000-20000-f-10-D5" class="headerlink" title="rt-app -t 100000:10000:d -t 150000:20000:f:10 -D5"></a>rt-app -t 100000:10000:d -t 150000:20000:f:10 -D5</h1><p> The above creates 2 threads. The first one, scheduled by SCHED_DEADLINE,<br> executes for 10ms every 100ms. The second one, scheduled at SCHED_FIFO<br> priority 10, executes for 20ms every 150ms. The test will run for a total<br> of 5 seconds.</p>
<p> More interestingly, configurations can be described with a json file that<br> can be passed as input to rt-app with something like this:</p>
<h1 id="rt-app-my-config-json"><a href="#rt-app-my-config-json" class="headerlink" title="rt-app my_config.json"></a>rt-app my_config.json</h1><p> The parameters that can be specified with the second method are a superset<br> of the command line options. Please refer to rt-app documentation for more<br> details (<rt-app-sources>/doc/*.json).</p>
<p> The second testing application is a modification of schedtool, called<br> schedtool-dl, which can be used to setup SCHED_DEADLINE parameters for a<br> certain pid/application. schedtool-dl is available at:<br> <a target="_blank" rel="noopener" href="https://github.com/scheduler-tools/schedtool-dl.git">https://github.com/scheduler-tools/schedtool-dl.git</a>.</p>
<p> The usage is straightforward:</p>
<h1 id="schedtool-E-t-10000000-100000000-e-my-cpuhog-app"><a href="#schedtool-E-t-10000000-100000000-e-my-cpuhog-app" class="headerlink" title="schedtool -E -t 10000000:100000000 -e ./my_cpuhog_app"></a>schedtool -E -t 10000000:100000000 -e ./my_cpuhog_app</h1><p> With this, my_cpuhog_app is put to run inside a SCHED_DEADLINE reservation<br> of 10ms every 100ms (note that parameters are expressed in microseconds).<br> You can also use schedtool to create a reservation for an already running<br> application, given that you know its pid:</p>
<h1 id="schedtool-E-t-10000000-100000000-my-app-pid"><a href="#schedtool-E-t-10000000-100000000-my-app-pid" class="headerlink" title="schedtool -E -t 10000000:100000000 my_app_pid"></a>schedtool -E -t 10000000:100000000 my_app_pid</h1><h1 id="Appendix-B-Minimal-main"><a href="#Appendix-B-Minimal-main" class="headerlink" title="Appendix B. Minimal main()"></a>Appendix B. Minimal main()</h1><p> We provide in what follows a simple (ugly) self-contained code snippet<br> showing how SCHED_DEADLINE reservations can be created by a real-time<br> application developer.</p>
<p> #define _GNU_SOURCE<br> #include &lt;unistd.h&gt;<br> #include &lt;stdio.h&gt;<br> #include &lt;stdlib.h&gt;<br> #include &lt;string.h&gt;<br> #include &lt;time.h&gt;<br> #include &lt;linux/unistd.h&gt;<br> #include &lt;linux/kernel.h&gt;<br> #include &lt;linux/types.h&gt;<br> #include &lt;sys/syscall.h&gt;<br> #include &lt;pthread.h&gt;</p>
<p> #define gettid() syscall(__NR_gettid)</p>
<p> #define SCHED_DEADLINE    6</p>
<p> /* XXX use the proper syscall numbers */<br> #ifdef __x86_64__<br> #define __NR_sched_setattr        314<br> #define __NR_sched_getattr        315<br> #endif</p>
<p> #ifdef <strong>i386</strong><br> #define __NR_sched_setattr        351<br> #define __NR_sched_getattr        352<br> #endif</p>
<p> #ifdef <strong>arm</strong><br> #define __NR_sched_setattr        380<br> #define __NR_sched_getattr        381<br> #endif</p>
<p> static volatile int done;</p>
<p> struct sched_attr {<br>    __u32 size;</p>
<pre><code>__u32 sched_policy;
__u64 sched_flags;

/* SCHED_NORMAL, SCHED_BATCH */
__s32 sched_nice;

/* SCHED_FIFO, SCHED_RR */
__u32 sched_priority;

/* SCHED_DEADLINE (nsec) */
__u64 sched_runtime;
__u64 sched_deadline;
__u64 sched_period;
</code></pre>
<p> };</p>
<p> int sched_setattr(pid_t pid,<br>          const struct sched_attr *attr,<br>          unsigned int flags)<br> {<br>    return syscall(__NR_sched_setattr, pid, attr, flags);<br> }</p>
<p> int sched_getattr(pid_t pid,<br>          struct sched_attr *attr,<br>          unsigned int size,<br>          unsigned int flags)<br> {<br>    return syscall(__NR_sched_getattr, pid, attr, size, flags);<br> }</p>
<p> void *run_deadline(void *data)<br> {<br>    struct sched_attr attr;<br>    int x = 0;<br>    int ret;<br>    unsigned int flags = 0;</p>
<pre><code>printf(&quot;deadline thread started [%ld]\n&quot;, gettid());

attr.size = sizeof(attr);
attr.sched_flags = 0;
attr.sched_nice = 0;
attr.sched_priority = 0;

/* This creates a 10ms/30ms reservation */
attr.sched_policy = SCHED_DEADLINE;
attr.sched_runtime = 10 * 1000 * 1000;
attr.sched_period = attr.sched_deadline = 30 * 1000 * 1000;

ret = sched_setattr(0, &amp;attr, flags);
if (ret &lt; 0) &#123;
    done = 0;
    perror(&quot;sched_setattr&quot;);
    exit(-1);
&#125;

while (!done) &#123;
    x++;
&#125;

printf(&quot;deadline thread dies [%ld]\n&quot;, gettid());
return NULL;
</code></pre>
<p> }</p>
<p> int main (int argc, char **argv)<br> {<br>    pthread_t thread;</p>
<pre><code>printf(&quot;main thread [%ld]\n&quot;, gettid());

pthread_create(&amp;thread, NULL, run_deadline, NULL);

sleep(10);

done = 1;
pthread_join(thread, NULL);

printf(&quot;main dies [%ld]\n&quot;, gettid());
return 0;
</code></pre>
<p> }</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_sched-deadline/" title="Kernel-3.10.0-957.el7_sched-deadline" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_sched-deadline/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_sentelic/" title="Kernel-3.10.0-957.el7_sentelic"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_runtime_pm/" title="Kernel-3.10.0-957.el7_runtime_p"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>