<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-3.10.0-957.el7_api | oosTech.com</title>
  <meta name="description" content="The Definitive KVM (Kernel-based Virtual Machine) API Documentation General description   The kvm API is a set of ioctls that are issued to control various aspectsof a virtual machine.  The ioctls bel">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-3.10.0-957.el7_api">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_api/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="The Definitive KVM (Kernel-based Virtual Machine) API Documentation General description   The kvm API is a set of ioctls that are issued to control various aspectsof a virtual machine.  The ioctls bel">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_api/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#The-Definitive-KVM-Kernel-based-Virtual-Machine-API-Documentation"><span class="toc-number">1.</span> <span class="toc-text">The Definitive KVM (Kernel-based Virtual Machine) API Documentation</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-3.10.0-957.el7_api" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-3.10.0-957.el7_api
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_api/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_api/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-3.10.0-957.el7_api/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="The-Definitive-KVM-Kernel-based-Virtual-Machine-API-Documentation"><a href="#The-Definitive-KVM-Kernel-based-Virtual-Machine-API-Documentation" class="headerlink" title="The Definitive KVM (Kernel-based Virtual Machine) API Documentation"></a>The Definitive KVM (Kernel-based Virtual Machine) API Documentation</h1><ol>
<li>General description</li>
</ol>
<hr>
<p>The kvm API is a set of ioctls that are issued to control various aspects<br>of a virtual machine.  The ioctls belong to three classes</p>
<ul>
<li><p>System ioctls: These query and set global attributes which affect the<br>whole kvm subsystem.  In addition a system ioctl is used to create<br>virtual machines</p>
</li>
<li><p>VM ioctls: These query and set attributes that affect an entire virtual<br>machine, for example memory layout.  In addition a VM ioctl is used to<br>create virtual cpus (vcpus).</p>
<p>Only run VM ioctls from the same process (address space) that was used<br>to create the VM.</p>
</li>
<li><p>vcpu ioctls: These query and set attributes that control the operation<br>of a single virtual cpu.</p>
<p>Only run vcpu ioctls from the same thread that was used to create the<br>vcpu.</p>
</li>
</ul>
<ol start="2">
<li>File descriptors</li>
</ol>
<hr>
<p>The kvm API is centered around file descriptors.  An initial<br>open(“/dev/kvm”) obtains a handle to the kvm subsystem; this handle<br>can be used to issue system ioctls.  A KVM_CREATE_VM ioctl on this<br>handle will create a VM file descriptor which can be used to issue VM<br>ioctls.  A KVM_CREATE_VCPU ioctl on a VM fd will create a virtual cpu<br>and return a file descriptor pointing to it.  Finally, ioctls on a vcpu<br>fd can be used to control the vcpu, including the important task of<br>actually running guest code.</p>
<p>In general file descriptors can be migrated among processes by means<br>of fork() and the SCM_RIGHTS facility of unix domain socket.  These<br>kinds of tricks are explicitly not supported by kvm.  While they will<br>not cause harm to the host, their actual behavior is not guaranteed by<br>the API.  The only supported use is one virtual machine per process,<br>and one vcpu per thread.</p>
<ol start="3">
<li>Extensions</li>
</ol>
<hr>
<p>As of Linux 2.6.22, the KVM ABI has been stabilized: no backward<br>incompatible change are allowed.  However, there is an extension<br>facility that allows backward-compatible extensions to the API to be<br>queried and used.</p>
<p>The extension mechanism is not based on on the Linux version number.<br>Instead, kvm defines extension identifiers and a facility to query<br>whether a particular extension identifier is available.  If it is, a<br>set of ioctls is available for application use.</p>
<ol start="4">
<li>API description</li>
</ol>
<hr>
<p>This section describes ioctls that can be used to control kvm guests.<br>For each ioctl, the following information is provided along with a<br>description:</p>
<p>  Capability: which KVM extension provides this ioctl.  Can be ‘basic’,<br>      which means that is will be provided by any kernel that supports<br>      API version 12 (see section 4.1), a KVM_CAP_xyz constant, which<br>      means availability needs to be checked with KVM_CHECK_EXTENSION<br>      (see section 4.4), or ‘none’ which means that while not all kernels<br>      support this ioctl, there’s no capability bit to check its<br>      availability: for kernels that don’t support the ioctl,<br>      the ioctl returns -ENOTTY.</p>
<p>  Architectures: which instruction set architectures provide this ioctl.<br>      x86 includes both i386 and x86_64.</p>
<p>  Type: system, vm, or vcpu.</p>
<p>  Parameters: what parameters are accepted by the ioctl.</p>
<p>  Returns: the return value.  General error numbers (EBADF, ENOMEM, EINVAL)<br>      are not detailed, but errors with specific meanings are.</p>
<p>4.1 KVM_GET_API_VERSION</p>
<p>Capability: basic<br>Architectures: all<br>Type: system ioctl<br>Parameters: none<br>Returns: the constant KVM_API_VERSION (=12)</p>
<p>This identifies the API version as the stable kvm API. It is not<br>expected that this number will change.  However, Linux 2.6.20 and<br>2.6.21 report earlier versions; these are not documented and not<br>supported.  Applications should refuse to run if KVM_GET_API_VERSION<br>returns a value other than 12.  If this check passes, all ioctls<br>described as ‘basic’ will be available.</p>
<p>4.2 KVM_CREATE_VM</p>
<p>Capability: basic<br>Architectures: all<br>Type: system ioctl<br>Parameters: machine type identifier (KVM_VM_*)<br>Returns: a VM fd that can be used to control the new virtual machine.</p>
<p>The new VM has no virtual cpus and no memory.  An mmap() of a VM fd<br>will access the virtual machine’s physical address space; offset zero<br>corresponds to guest physical address zero.  Use of mmap() on a VM fd<br>is discouraged if userspace memory allocation (KVM_CAP_USER_MEMORY) is<br>available.<br>You most certainly want to use 0 as machine type.</p>
<p>In order to create user controlled virtual machines on S390, check<br>KVM_CAP_S390_UCONTROL and use the flag KVM_VM_S390_UCONTROL as<br>privileged user (CAP_SYS_ADMIN).</p>
<p>4.3 KVM_GET_MSR_INDEX_LIST</p>
<p>Capability: basic<br>Architectures: x86<br>Type: system<br>Parameters: struct kvm_msr_list (in/out)<br>Returns: 0 on success; -1 on error<br>Errors:<br>  E2BIG:     the msr index list is to be to fit in the array specified by<br>             the user.</p>
<p>struct kvm_msr_list {<br>    __u32 nmsrs; /* number of msrs in entries */<br>    __u32 indices[0];<br>};</p>
<p>This ioctl returns the guest msrs that are supported.  The list varies<br>by kvm version and host processor, but does not change otherwise.  The<br>user fills in the size of the indices array in nmsrs, and in return<br>kvm adjusts nmsrs to reflect the actual number of msrs and fills in<br>the indices array with their numbers.</p>
<p>Note: if kvm indicates supports MCE (KVM_CAP_MCE), then the MCE bank MSRs are<br>not returned in the MSR list, as different vcpus can have a different number<br>of banks, as set via the KVM_X86_SETUP_MCE ioctl.</p>
<p>4.4 KVM_CHECK_EXTENSION</p>
<p>Capability: basic, KVM_CAP_CHECK_EXTENSION_VM for vm ioctl<br>Architectures: all<br>Type: system ioctl, vm ioctl<br>Parameters: extension identifier (KVM_CAP_*)<br>Returns: 0 if unsupported; 1 (or some other positive integer) if supported</p>
<p>The API allows the application to query about extensions to the core<br>kvm API.  Userspace passes an extension identifier (an integer) and<br>receives an integer that describes the extension availability.<br>Generally 0 means no and 1 means yes, but some extensions may report<br>additional information in the integer return value.</p>
<p>Based on their initialization different VMs may have different capabilities.<br>It is thus encouraged to use the vm ioctl to query for capabilities (available<br>with KVM_CAP_CHECK_EXTENSION_VM on the vm fd)</p>
<p>4.5 KVM_GET_VCPU_MMAP_SIZE</p>
<p>Capability: basic<br>Architectures: all<br>Type: system ioctl<br>Parameters: none<br>Returns: size of vcpu mmap area, in bytes</p>
<p>The KVM_RUN ioctl (cf.) communicates with userspace via a shared<br>memory region.  This ioctl returns the size of that region.  See the<br>KVM_RUN documentation for details.</p>
<p>4.6 KVM_SET_MEMORY_REGION</p>
<p>Capability: basic<br>Architectures: all<br>Type: vm ioctl<br>Parameters: struct kvm_memory_region (in)<br>Returns: 0 on success, -1 on error</p>
<p>This ioctl is obsolete and has been removed.</p>
<p>4.7 KVM_CREATE_VCPU</p>
<p>Capability: basic<br>Architectures: all<br>Type: vm ioctl<br>Parameters: vcpu id (apic id on x86)<br>Returns: vcpu fd on success, -1 on error</p>
<p>This API adds a vcpu to a virtual machine. No more than max_vcpus may be added.<br>The vcpu id is an integer in the range [0, max_vcpu_id).</p>
<p>The recommended max_vcpus value can be retrieved using the KVM_CAP_NR_VCPUS of<br>the KVM_CHECK_EXTENSION ioctl() at run-time.<br>The maximum possible value for max_vcpus can be retrieved using the<br>KVM_CAP_MAX_VCPUS of the KVM_CHECK_EXTENSION ioctl() at run-time.</p>
<p>If the KVM_CAP_NR_VCPUS does not exist, you should assume that max_vcpus is 4<br>cpus max.<br>If the KVM_CAP_MAX_VCPUS does not exist, you should assume that max_vcpus is<br>same as the value returned from KVM_CAP_NR_VCPUS.</p>
<p>The maximum possible value for max_vcpu_id can be retrieved using the<br>KVM_CAP_MAX_VCPU_ID of the KVM_CHECK_EXTENSION ioctl() at run-time.</p>
<p>If the KVM_CAP_MAX_VCPU_ID does not exist, you should assume that max_vcpu_id<br>is the same as the value returned from KVM_CAP_MAX_VCPUS.</p>
<p>On powerpc using book3s_hv mode, the vcpus are mapped onto virtual<br>threads in one or more virtual CPU cores.  (This is because the<br>hardware requires all the hardware threads in a CPU core to be in the<br>same partition.)  The KVM_CAP_PPC_SMT capability indicates the number<br>of vcpus per virtual core (vcore).  The vcore id is obtained by<br>dividing the vcpu id by the number of vcpus per vcore.  The vcpus in a<br>given vcore will always be in the same physical core as each other<br>(though that might be a different physical core from time to time).<br>Userspace can control the threading (SMT) mode of the guest by its<br>allocation of vcpu ids.  For example, if userspace wants<br>single-threaded guest vcpus, it should make all vcpu ids be a multiple<br>of the number of vcpus per vcore.</p>
<p>For virtual cpus that have been created with S390 user controlled virtual<br>machines, the resulting vcpu fd can be memory mapped at page offset<br>KVM_S390_SIE_PAGE_OFFSET in order to obtain a memory map of the virtual<br>cpu’s hardware control block.</p>
<p>4.8 KVM_GET_DIRTY_LOG (vm ioctl)</p>
<p>Capability: basic<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_dirty_log (in/out)<br>Returns: 0 on success, -1 on error</p>
<p>/* for KVM_GET_DIRTY_LOG */<br>struct kvm_dirty_log {<br>    __u32 slot;<br>    __u32 padding;<br>    union {<br>        void __user <em>dirty_bitmap; /</em> one bit per page */<br>        __u64 padding;<br>    };<br>};</p>
<p>Given a memory slot, return a bitmap containing any pages dirtied<br>since the last call to this ioctl.  Bit 0 is the first page in the<br>memory slot.  Ensure the entire structure is cleared to avoid padding<br>issues.</p>
<p>If KVM_CAP_MULTI_ADDRESS_SPACE is available, bits 16-31 specifies<br>the address space for which you want to return the dirty bitmap.<br>They must be less than the value that KVM_CHECK_EXTENSION returns for<br>the KVM_CAP_MULTI_ADDRESS_SPACE capability.</p>
<p>4.9 KVM_SET_MEMORY_ALIAS</p>
<p>Capability: basic<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_memory_alias (in)<br>Returns: 0 (success), -1 (error)</p>
<p>This ioctl is obsolete and has been removed.</p>
<p>4.10 KVM_RUN</p>
<p>Capability: basic<br>Architectures: all<br>Type: vcpu ioctl<br>Parameters: none<br>Returns: 0 on success, -1 on error<br>Errors:<br>  EINTR:     an unmasked signal is pending</p>
<p>This ioctl is used to run a guest virtual cpu.  While there are no<br>explicit parameters, there is an implicit parameter block that can be<br>obtained by mmap()ing the vcpu fd at offset 0, with the size given by<br>KVM_GET_VCPU_MMAP_SIZE.  The parameter block is formatted as a ‘struct<br>kvm_run’ (see below).</p>
<p>4.11 KVM_GET_REGS</p>
<p>Capability: basic<br>Architectures: all except ARM<br>Type: vcpu ioctl<br>Parameters: struct kvm_regs (out)<br>Returns: 0 on success, -1 on error</p>
<p>Reads the general purpose registers from the vcpu.</p>
<p>/* x86 <em>/<br>struct kvm_regs {<br>    /</em> out (KVM_GET_REGS) / in (KVM_SET_REGS) */<br>    __u64 rax, rbx, rcx, rdx;<br>    __u64 rsi, rdi, rsp, rbp;<br>    __u64 r8,  r9,  r10, r11;<br>    __u64 r12, r13, r14, r15;<br>    __u64 rip, rflags;<br>};</p>
<p>4.12 KVM_SET_REGS</p>
<p>Capability: basic<br>Architectures: all except ARM<br>Type: vcpu ioctl<br>Parameters: struct kvm_regs (in)<br>Returns: 0 on success, -1 on error</p>
<p>Writes the general purpose registers into the vcpu.</p>
<p>See KVM_GET_REGS for the data structure.</p>
<p>4.13 KVM_GET_SREGS</p>
<p>Capability: basic<br>Architectures: x86, ppc<br>Type: vcpu ioctl<br>Parameters: struct kvm_sregs (out)<br>Returns: 0 on success, -1 on error</p>
<p>Reads special registers from the vcpu.</p>
<p>/* x86 */<br>struct kvm_sregs {<br>    struct kvm_segment cs, ds, es, fs, gs, ss;<br>    struct kvm_segment tr, ldt;<br>    struct kvm_dtable gdt, idt;<br>    __u64 cr0, cr2, cr3, cr4, cr8;<br>    __u64 efer;<br>    __u64 apic_base;<br>    __u64 interrupt_bitmap[(KVM_NR_INTERRUPTS + 63) / 64];<br>};</p>
<p>/* ppc – see arch/powerpc/include/uapi/asm/kvm.h */</p>
<p>interrupt_bitmap is a bitmap of pending external interrupts.  At most<br>one bit may be set.  This interrupt has been acknowledged by the APIC<br>but not yet injected into the cpu core.</p>
<p>4.14 KVM_SET_SREGS</p>
<p>Capability: basic<br>Architectures: x86, ppc<br>Type: vcpu ioctl<br>Parameters: struct kvm_sregs (in)<br>Returns: 0 on success, -1 on error</p>
<p>Writes special registers into the vcpu.  See KVM_GET_SREGS for the<br>data structures.</p>
<p>4.15 KVM_TRANSLATE</p>
<p>Capability: basic<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_translation (in/out)<br>Returns: 0 on success, -1 on error</p>
<p>Translates a virtual address according to the vcpu’s current address<br>translation mode.</p>
<p>struct kvm_translation {<br>    /* in */<br>    __u64 linear_address;</p>
<pre><code>/* out */
__u64 physical_address;
__u8  valid;
__u8  writeable;
__u8  usermode;
__u8  pad[5];
</code></pre>
<p>};</p>
<p>4.16 KVM_INTERRUPT</p>
<p>Capability: basic<br>Architectures: x86, ppc<br>Type: vcpu ioctl<br>Parameters: struct kvm_interrupt (in)<br>Returns: 0 on success, negative on failure.</p>
<p>Queues a hardware interrupt vector to be injected.</p>
<p>/* for KVM_INTERRUPT <em>/<br>struct kvm_interrupt {<br>    /</em> in */<br>    __u32 irq;<br>};</p>
<p>X86:</p>
<p>Returns: 0 on success,<br>     -EEXIST if an interrupt is already enqueued<br>     -EINVAL the the irq number is invalid<br>     -ENXIO if the PIC is in the kernel<br>     -EFAULT if the pointer is invalid</p>
<p>Note ‘irq’ is an interrupt vector, not an interrupt pin or line. This<br>ioctl is useful if the in-kernel PIC is not used.</p>
<p>PPC:</p>
<p>Queues an external interrupt to be injected. This ioctl is overleaded<br>with 3 different irq values:</p>
<p>a) KVM_INTERRUPT_SET</p>
<p>  This injects an edge type external interrupt into the guest once it’s ready<br>  to receive interrupts. When injected, the interrupt is done.</p>
<p>b) KVM_INTERRUPT_UNSET</p>
<p>  This unsets any pending interrupt.</p>
<p>  Only available with KVM_CAP_PPC_UNSET_IRQ.</p>
<p>c) KVM_INTERRUPT_SET_LEVEL</p>
<p>  This injects a level type external interrupt into the guest context. The<br>  interrupt stays pending until a specific ioctl with KVM_INTERRUPT_UNSET<br>  is triggered.</p>
<p>  Only available with KVM_CAP_PPC_IRQ_LEVEL.</p>
<p>Note that any value for ‘irq’ other than the ones stated above is invalid<br>and incurs unexpected behavior.</p>
<p>4.17 KVM_DEBUG_GUEST</p>
<p>Capability: basic<br>Architectures: none<br>Type: vcpu ioctl<br>Parameters: none)<br>Returns: -1 on error</p>
<p>Support for this has been removed.  Use KVM_SET_GUEST_DEBUG instead.</p>
<p>4.18 KVM_GET_MSRS</p>
<p>Capability: basic<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_msrs (in/out)<br>Returns: 0 on success, -1 on error</p>
<p>Reads model-specific registers from the vcpu.  Supported msr indices can<br>be obtained using KVM_GET_MSR_INDEX_LIST.</p>
<p>struct kvm_msrs {<br>    __u32 nmsrs; /* number of msrs in entries */<br>    __u32 pad;</p>
<pre><code>struct kvm_msr_entry entries[0];
</code></pre>
<p>};</p>
<p>struct kvm_msr_entry {<br>    __u32 index;<br>    __u32 reserved;<br>    __u64 data;<br>};</p>
<p>Application code should set the ‘nmsrs’ member (which indicates the<br>size of the entries array) and the ‘index’ member of each array entry.<br>kvm will fill in the ‘data’ member.</p>
<p>4.19 KVM_SET_MSRS</p>
<p>Capability: basic<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_msrs (in)<br>Returns: 0 on success, -1 on error</p>
<p>Writes model-specific registers to the vcpu.  See KVM_GET_MSRS for the<br>data structures.</p>
<p>Application code should set the ‘nmsrs’ member (which indicates the<br>size of the entries array), and the ‘index’ and ‘data’ members of each<br>array entry.</p>
<p>4.20 KVM_SET_CPUID</p>
<p>Capability: basic<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_cpuid (in)<br>Returns: 0 on success, -1 on error</p>
<p>Defines the vcpu responses to the cpuid instruction.  Applications<br>should use the KVM_SET_CPUID2 ioctl if available.</p>
<p>struct kvm_cpuid_entry {<br>    __u32 function;<br>    __u32 eax;<br>    __u32 ebx;<br>    __u32 ecx;<br>    __u32 edx;<br>    __u32 padding;<br>};</p>
<p>/* for KVM_SET_CPUID */<br>struct kvm_cpuid {<br>    __u32 nent;<br>    __u32 padding;<br>    struct kvm_cpuid_entry entries[0];<br>};</p>
<p>4.21 KVM_SET_SIGNAL_MASK</p>
<p>Capability: basic<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_signal_mask (in)<br>Returns: 0 on success, -1 on error</p>
<p>Defines which signals are blocked during execution of KVM_RUN.  This<br>signal mask temporarily overrides the threads signal mask.  Any<br>unblocked signal received (except SIGKILL and SIGSTOP, which retain<br>their traditional behaviour) will cause KVM_RUN to return with -EINTR.</p>
<p>Note the signal will only be delivered if not blocked by the original<br>signal mask.</p>
<p>/* for KVM_SET_SIGNAL_MASK */<br>struct kvm_signal_mask {<br>    __u32 len;<br>    __u8  sigset[0];<br>};</p>
<p>4.22 KVM_GET_FPU</p>
<p>Capability: basic<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_fpu (out)<br>Returns: 0 on success, -1 on error</p>
<p>Reads the floating point state from the vcpu.</p>
<p>/* for KVM_GET_FPU and KVM_SET_FPU <em>/<br>struct kvm_fpu {<br>    __u8  fpr[8][16];<br>    __u16 fcw;<br>    __u16 fsw;<br>    __u8  ftwx;  /</em> in fxsave format */<br>    __u8  pad1;<br>    __u16 last_opcode;<br>    __u64 last_ip;<br>    __u64 last_dp;<br>    __u8  xmm[16][16];<br>    __u32 mxcsr;<br>    __u32 pad2;<br>};</p>
<p>4.23 KVM_SET_FPU</p>
<p>Capability: basic<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_fpu (in)<br>Returns: 0 on success, -1 on error</p>
<p>Writes the floating point state to the vcpu.</p>
<p>/* for KVM_GET_FPU and KVM_SET_FPU <em>/<br>struct kvm_fpu {<br>    __u8  fpr[8][16];<br>    __u16 fcw;<br>    __u16 fsw;<br>    __u8  ftwx;  /</em> in fxsave format */<br>    __u8  pad1;<br>    __u16 last_opcode;<br>    __u64 last_ip;<br>    __u64 last_dp;<br>    __u8  xmm[16][16];<br>    __u32 mxcsr;<br>    __u32 pad2;<br>};</p>
<p>4.24 KVM_CREATE_IRQCHIP</p>
<p>Capability: KVM_CAP_IRQCHIP<br>Architectures: x86, ARM<br>Type: vm ioctl<br>Parameters: none<br>Returns: 0 on success, -1 on error</p>
<p>Creates an interrupt controller model in the kernel.  On x86, creates a virtual<br>ioapic, a virtual PIC (two PICs, nested), and sets up future vcpus to have a<br>local APIC.  IRQ routing for GSIs 0-15 is set to both PIC and IOAPIC; GSI 16-23<br>only go to the IOAPIC.</p>
<p>4.25 KVM_IRQ_LINE</p>
<p>Capability: KVM_CAP_IRQCHIP<br>Architectures: x86, arm<br>Type: vm ioctl<br>Parameters: struct kvm_irq_level<br>Returns: 0 on success, -1 on error</p>
<p>Sets the level of a GSI input to the interrupt controller model in the kernel.<br>On some architectures it is required that an interrupt controller model has<br>been previously created with KVM_CREATE_IRQCHIP.  Note that edge-triggered<br>interrupts require the level to be set to 1 and then back to 0.</p>
<p>On real hardware, interrupt pins can be active-low or active-high.  This<br>does not matter for the level field of struct kvm_irq_level: 1 always<br>means active (asserted), 0 means inactive (deasserted).</p>
<p>x86 allows the operating system to program the interrupt polarity<br>(active-low/active-high) for level-triggered interrupts, and KVM used<br>to consider the polarity.  However, due to bitrot in the handling of<br>active-low interrupts, the above convention is now valid on x86 too.<br>This is signaled by KVM_CAP_X86_IOAPIC_POLARITY_IGNORED.  Userspace<br>should not present interrupts to the guest as active-low unless this<br>capability is present (or unless it is not using the in-kernel irqchip,<br>of course).</p>
<p>ARM can signal an interrupt either at the CPU level, or at the in-kernel irqchip<br>(GIC), and for in-kernel irqchip can tell the GIC to use PPIs designated for<br>specific cpus.  The irq field is interpreted like this:</p>
<p> Â bits:  | 31 … 24 | 23  … 16 | 15    …    0 |<br>  field: | irq_type  | vcpu_index |     irq_id     |</p>
<p>The irq_type field has the following values:</p>
<ul>
<li>irq_type[0]: out-of-kernel GIC: irq_id 0 is IRQ, irq_id 1 is FIQ</li>
<li>irq_type[1]: in-kernel GIC: SPI, irq_id between 32 and 1019 (incl.)<pre><code>         (the vcpu_index field is ignored)
</code></pre>
</li>
<li>irq_type[2]: in-kernel GIC: PPI, irq_id between 16 and 31 (incl.)</li>
</ul>
<p>(The irq_id field thus corresponds nicely to the IRQ ID in the ARM GIC specs)</p>
<p>In both cases, level is used to assert/deassert the line.</p>
<p>struct kvm_irq_level {<br>    union {<br>        __u32 irq;     /* GSI <em>/<br>        __s32 status;  /</em> not used for KVM_IRQ_LEVEL <em>/<br>    };<br>    __u32 level;           /</em> 0 or 1 */<br>};</p>
<p>4.26 KVM_GET_IRQCHIP</p>
<p>Capability: KVM_CAP_IRQCHIP<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_irqchip (in/out)<br>Returns: 0 on success, -1 on error</p>
<p>Reads the state of a kernel interrupt controller created with<br>KVM_CREATE_IRQCHIP into a buffer provided by the caller.</p>
<p>struct kvm_irqchip {<br>    __u32 chip_id;  /* 0 = PIC1, 1 = PIC2, 2 = IOAPIC <em>/<br>    __u32 pad;<br>        union {<br>        char dummy[512];  /</em> reserving space */<br>        struct kvm_pic_state pic;<br>        struct kvm_ioapic_state ioapic;<br>    } chip;<br>};</p>
<p>4.27 KVM_SET_IRQCHIP</p>
<p>Capability: KVM_CAP_IRQCHIP<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_irqchip (in)<br>Returns: 0 on success, -1 on error</p>
<p>Sets the state of a kernel interrupt controller created with<br>KVM_CREATE_IRQCHIP from a buffer provided by the caller.</p>
<p>struct kvm_irqchip {<br>    __u32 chip_id;  /* 0 = PIC1, 1 = PIC2, 2 = IOAPIC <em>/<br>    __u32 pad;<br>        union {<br>        char dummy[512];  /</em> reserving space */<br>        struct kvm_pic_state pic;<br>        struct kvm_ioapic_state ioapic;<br>    } chip;<br>};</p>
<p>4.28 KVM_XEN_HVM_CONFIG</p>
<p>Capability: KVM_CAP_XEN_HVM<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_xen_hvm_config (in)<br>Returns: 0 on success, -1 on error</p>
<p>Sets the MSR that the Xen HVM guest uses to initialize its hypercall<br>page, and provides the starting address and size of the hypercall<br>blobs in userspace.  When the guest writes the MSR, kvm copies one<br>page of a blob (32- or 64-bit, depending on the vcpu mode) to guest<br>memory.</p>
<p>struct kvm_xen_hvm_config {<br>    __u32 flags;<br>    __u32 msr;<br>    __u64 blob_addr_32;<br>    __u64 blob_addr_64;<br>    __u8 blob_size_32;<br>    __u8 blob_size_64;<br>    __u8 pad2[30];<br>};</p>
<p>4.29 KVM_GET_CLOCK</p>
<p>Capability: KVM_CAP_ADJUST_CLOCK<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_clock_data (out)<br>Returns: 0 on success, -1 on error</p>
<p>Gets the current timestamp of kvmclock as seen by the current guest. In<br>conjunction with KVM_SET_CLOCK, it is used to ensure monotonicity on scenarios<br>such as migration.</p>
<p>When KVM_CAP_ADJUST_CLOCK is passed to KVM_CHECK_EXTENSION, it returns the<br>set of bits that KVM can return in struct kvm_clock_data’s flag member.</p>
<p>The only flag defined now is KVM_CLOCK_TSC_STABLE.  If set, the returned<br>value is the exact kvmclock value seen by all VCPUs at the instant<br>when KVM_GET_CLOCK was called.  If clear, the returned value is simply<br>CLOCK_MONOTONIC plus a constant offset; the offset can be modified<br>with KVM_SET_CLOCK.  KVM will try to make all VCPUs follow this clock,<br>but the exact value read by each VCPU could differ, because the host<br>TSC is not stable.</p>
<p>struct kvm_clock_data {<br>    __u64 clock;  /* kvmclock current value */<br>    __u32 flags;<br>    __u32 pad[9];<br>};</p>
<p>4.30 KVM_SET_CLOCK</p>
<p>Capability: KVM_CAP_ADJUST_CLOCK<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_clock_data (in)<br>Returns: 0 on success, -1 on error</p>
<p>Sets the current timestamp of kvmclock to the value specified in its parameter.<br>In conjunction with KVM_GET_CLOCK, it is used to ensure monotonicity on scenarios<br>such as migration.</p>
<p>struct kvm_clock_data {<br>    __u64 clock;  /* kvmclock current value */<br>    __u32 flags;<br>    __u32 pad[9];<br>};</p>
<p>4.31 KVM_GET_VCPU_EVENTS</p>
<p>Capability: KVM_CAP_VCPU_EVENTS<br>Extended by: KVM_CAP_INTR_SHADOW<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_vcpu_event (out)<br>Returns: 0 on success, -1 on error</p>
<p>Gets currently pending exceptions, interrupts, and NMIs as well as related<br>states of the vcpu.</p>
<p>struct kvm_vcpu_events {<br>    struct {<br>        __u8 injected;<br>        __u8 nr;<br>        __u8 has_error_code;<br>        __u8 pad;<br>        __u32 error_code;<br>    } exception;<br>    struct {<br>        __u8 injected;<br>        __u8 nr;<br>        __u8 soft;<br>        __u8 shadow;<br>    } interrupt;<br>    struct {<br>        __u8 injected;<br>        __u8 pending;<br>        __u8 masked;<br>        __u8 pad;<br>    } nmi;<br>    __u32 sipi_vector;<br>    __u32 flags;<br>    struct {<br>        __u8 smm;<br>        __u8 pending;<br>        __u8 smm_inside_nmi;<br>        __u8 latched_init;<br>    } smi;<br>};</p>
<p>Only two fields are defined in the flags field:</p>
<ul>
<li><p>KVM_VCPUEVENT_VALID_SHADOW may be set in the flags field to signal that<br>interrupt.shadow contains a valid state.</p>
</li>
<li><p>KVM_VCPUEVENT_VALID_SMM may be set in the flags field to signal that<br>smi contains a valid state.</p>
</li>
</ul>
<p>4.32 KVM_SET_VCPU_EVENTS</p>
<p>Capability: KVM_CAP_VCPU_EVENTS<br>Extended by: KVM_CAP_INTR_SHADOW<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_vcpu_event (in)<br>Returns: 0 on success, -1 on error</p>
<p>Set pending exceptions, interrupts, and NMIs as well as related states of the<br>vcpu.</p>
<p>See KVM_GET_VCPU_EVENTS for the data structure.</p>
<p>Fields that may be modified asynchronously by running VCPUs can be excluded<br>from the update. These fields are nmi.pending, sipi_vector, smi.smm,<br>smi.pending. Keep the corresponding bits in the flags field cleared to<br>suppress overwriting the current in-kernel state. The bits are:</p>
<p>KVM_VCPUEVENT_VALID_NMI_PENDING - transfer nmi.pending to the kernel<br>KVM_VCPUEVENT_VALID_SIPI_VECTOR - transfer sipi_vector<br>KVM_VCPUEVENT_VALID_SMM         - transfer the smi sub-struct.</p>
<p>If KVM_CAP_INTR_SHADOW is available, KVM_VCPUEVENT_VALID_SHADOW can be set in<br>the flags field to signal that interrupt.shadow contains a valid state and<br>shall be written into the VCPU.</p>
<p>KVM_VCPUEVENT_VALID_SMM can only be set if KVM_CAP_X86_SMM is available.</p>
<p>4.33 KVM_GET_DEBUGREGS</p>
<p>Capability: KVM_CAP_DEBUGREGS<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_debugregs (out)<br>Returns: 0 on success, -1 on error</p>
<p>Reads debug registers from the vcpu.</p>
<p>struct kvm_debugregs {<br>    __u64 db[4];<br>    __u64 dr6;<br>    __u64 dr7;<br>    __u64 flags;<br>    __u64 reserved[9];<br>};</p>
<p>4.34 KVM_SET_DEBUGREGS</p>
<p>Capability: KVM_CAP_DEBUGREGS<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_debugregs (in)<br>Returns: 0 on success, -1 on error</p>
<p>Writes debug registers into the vcpu.</p>
<p>See KVM_GET_DEBUGREGS for the data structure. The flags field is unused<br>yet and must be cleared on entry.</p>
<p>4.35 KVM_SET_USER_MEMORY_REGION</p>
<p>Capability: KVM_CAP_USER_MEM<br>Architectures: all<br>Type: vm ioctl<br>Parameters: struct kvm_userspace_memory_region (in)<br>Returns: 0 on success, -1 on error</p>
<p>struct kvm_userspace_memory_region {<br>    __u32 slot;<br>    __u32 flags;<br>    __u64 guest_phys_addr;<br>    __u64 memory_size; /* bytes <em>/<br>    __u64 userspace_addr; /</em> start of the userspace allocated memory */<br>};</p>
<p>/* for kvm_memory_region::flags */<br>#define KVM_MEM_LOG_DIRTY_PAGES    (1UL &lt;&lt; 0)<br>#define KVM_MEM_READONLY    (1UL &lt;&lt; 1)</p>
<p>This ioctl allows the user to create or modify a guest physical memory<br>slot.  When changing an existing slot, it may be moved in the guest<br>physical memory space, or its flags may be modified.  It may not be<br>resized.  Slots may not overlap in guest physical address space.</p>
<p>If KVM_CAP_MULTI_ADDRESS_SPACE is available, bits 16-31 of “slot”<br>specifies the address space which is being modified.  They must be<br>less than the value that KVM_CHECK_EXTENSION returns for the<br>KVM_CAP_MULTI_ADDRESS_SPACE capability.  Slots in separate address spaces<br>are unrelated; the restriction on overlapping slots only applies within<br>each address space.</p>
<p>Memory for the region is taken starting at the address denoted by the<br>field userspace_addr, which must point at user addressable memory for<br>the entire memory slot size.  Any object may back this memory, including<br>anonymous memory, ordinary files, and hugetlbfs.</p>
<p>It is recommended that the lower 21 bits of guest_phys_addr and userspace_addr<br>be identical.  This allows large pages in the guest to be backed by large<br>pages in the host.</p>
<p>The flags field supports two flags: KVM_MEM_LOG_DIRTY_PAGES and<br>KVM_MEM_READONLY.  The former can be set to instruct KVM to keep track of<br>writes to memory within the slot.  See KVM_GET_DIRTY_LOG ioctl to know how to<br>use it.  The latter can be set, if KVM_CAP_READONLY_MEM capability allows it,<br>to make a new slot read-only.  In this case, writes to this memory will be<br>posted to userspace as KVM_EXIT_MMIO exits.</p>
<p>When the KVM_CAP_SYNC_MMU capability is available, changes in the backing of<br>the memory region are automatically reflected into the guest.  For example, an<br>mmap() that affects the region will be made visible immediately.  Another<br>example is madvise(MADV_DROP).</p>
<p>It is recommended to use this API instead of the KVM_SET_MEMORY_REGION ioctl.<br>The KVM_SET_MEMORY_REGION does not allow fine grained control over memory<br>allocation and is deprecated.</p>
<p>4.36 KVM_SET_TSS_ADDR</p>
<p>Capability: KVM_CAP_SET_TSS_ADDR<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: unsigned long tss_address (in)<br>Returns: 0 on success, -1 on error</p>
<p>This ioctl defines the physical address of a three-page region in the guest<br>physical address space.  The region must be within the first 4GB of the<br>guest physical address space and must not conflict with any memory slot<br>or any mmio address.  The guest may malfunction if it accesses this memory<br>region.</p>
<p>This ioctl is required on Intel-based hosts.  This is needed on Intel hardware<br>because of a quirk in the virtualization implementation (see the internals<br>documentation when it pops into existence).</p>
<p>4.37 KVM_ENABLE_CAP</p>
<p>Capability: KVM_CAP_ENABLE_CAP, KVM_CAP_ENABLE_CAP_VM<br>Architectures: x86 (only KVM_CAP_ENABLE_CAP_VM),<br>           mips (only KVM_CAP_ENABLE_CAP), ppc, s390<br>Type: vcpu ioctl, vm ioctl (with KVM_CAP_ENABLE_CAP_VM)<br>Parameters: struct kvm_enable_cap (in)<br>Returns: 0 on success; -1 on error</p>
<p>+Not all extensions are enabled by default. Using this ioctl the application<br>can enable an extension, making it available to the guest.</p>
<p>On systems that do not support this ioctl, it always fails. On systems that<br>do support it, it only works for extensions that are supported for enablement.</p>
<p>To check if a capability can be enabled, the KVM_CHECK_EXTENSION ioctl should<br>be used.</p>
<p>struct kvm_enable_cap {<br>       /* in */<br>       __u32 cap;</p>
<p>The capability that is supposed to get enabled.</p>
<pre><code>   __u32 flags;
</code></pre>
<p>A bitfield indicating future enhancements. Has to be 0 for now.</p>
<pre><code>   __u64 args[4];
</code></pre>
<p>Arguments for enabling a feature. If a feature needs initial values to<br>function properly, this is the place to put them.</p>
<pre><code>   __u8  pad[64];
</code></pre>
<p>};</p>
<p>The vcpu ioctl should be used for vcpu-specific capabilities, the vm ioctl<br>for vm-wide capabilities.</p>
<p>4.38 KVM_GET_MP_STATE</p>
<p>Capability: KVM_CAP_MP_STATE<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_mp_state (out)<br>Returns: 0 on success; -1 on error</p>
<p>struct kvm_mp_state {<br>    __u32 mp_state;<br>};</p>
<p>Returns the vcpu’s current “multiprocessing state” (though also valid on<br>uniprocessor guests).</p>
<p>Possible values are:</p>
<ul>
<li>KVM_MP_STATE_RUNNABLE:        the vcpu is currently running</li>
<li>KVM_MP_STATE_UNINITIALIZED:   the vcpu is an application processor (AP)<pre><code>                          which has not yet received an INIT signal
</code></pre>
</li>
<li>KVM_MP_STATE_INIT_RECEIVED:   the vcpu has received an INIT signal, and is<pre><code>                          now ready for a SIPI
</code></pre>
</li>
<li>KVM_MP_STATE_HALTED:          the vcpu has executed a HLT instruction and<pre><code>                          is waiting for an interrupt
</code></pre>
</li>
<li>KVM_MP_STATE_SIPI_RECEIVED:   the vcpu has just received a SIPI (vector<pre><code>                          accessible via KVM_GET_VCPU_EVENTS)
</code></pre>
</li>
</ul>
<p>This ioctl is only useful after KVM_CREATE_IRQCHIP.  Without an in-kernel<br>irqchip, the multiprocessing state must be maintained by userspace.</p>
<p>4.39 KVM_SET_MP_STATE</p>
<p>Capability: KVM_CAP_MP_STATE<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_mp_state (in)<br>Returns: 0 on success; -1 on error</p>
<p>Sets the vcpu’s current “multiprocessing state”; see KVM_GET_MP_STATE for<br>arguments.</p>
<p>This ioctl is only useful after KVM_CREATE_IRQCHIP.  Without an in-kernel<br>irqchip, the multiprocessing state must be maintained by userspace.</p>
<p>4.40 KVM_SET_IDENTITY_MAP_ADDR</p>
<p>Capability: KVM_CAP_SET_IDENTITY_MAP_ADDR<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: unsigned long identity (in)<br>Returns: 0 on success, -1 on error</p>
<p>This ioctl defines the physical address of a one-page region in the guest<br>physical address space.  The region must be within the first 4GB of the<br>guest physical address space and must not conflict with any memory slot<br>or any mmio address.  The guest may malfunction if it accesses this memory<br>region.</p>
<p>This ioctl is required on Intel-based hosts.  This is needed on Intel hardware<br>because of a quirk in the virtualization implementation (see the internals<br>documentation when it pops into existence).</p>
<p>4.41 KVM_SET_BOOT_CPU_ID</p>
<p>Capability: KVM_CAP_SET_BOOT_CPU_ID<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: unsigned long vcpu_id<br>Returns: 0 on success, -1 on error</p>
<p>Define which vcpu is the Bootstrap Processor (BSP).  Values are the same<br>as the vcpu id in KVM_CREATE_VCPU.  If this ioctl is not called, the default<br>is vcpu 0.</p>
<p>4.42 KVM_GET_XSAVE</p>
<p>Capability: KVM_CAP_XSAVE<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_xsave (out)<br>Returns: 0 on success, -1 on error</p>
<p>struct kvm_xsave {<br>    __u32 region[1024];<br>};</p>
<p>This ioctl would copy current vcpu’s xsave struct to the userspace.</p>
<p>4.43 KVM_SET_XSAVE</p>
<p>Capability: KVM_CAP_XSAVE<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_xsave (in)<br>Returns: 0 on success, -1 on error</p>
<p>struct kvm_xsave {<br>    __u32 region[1024];<br>};</p>
<p>This ioctl would copy userspace’s xsave struct to the kernel.</p>
<p>4.44 KVM_GET_XCRS</p>
<p>Capability: KVM_CAP_XCRS<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_xcrs (out)<br>Returns: 0 on success, -1 on error</p>
<p>struct kvm_xcr {<br>    __u32 xcr;<br>    __u32 reserved;<br>    __u64 value;<br>};</p>
<p>struct kvm_xcrs {<br>    __u32 nr_xcrs;<br>    __u32 flags;<br>    struct kvm_xcr xcrs[KVM_MAX_XCRS];<br>    __u64 padding[16];<br>};</p>
<p>This ioctl would copy current vcpu’s xcrs to the userspace.</p>
<p>4.45 KVM_SET_XCRS</p>
<p>Capability: KVM_CAP_XCRS<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_xcrs (in)<br>Returns: 0 on success, -1 on error</p>
<p>struct kvm_xcr {<br>    __u32 xcr;<br>    __u32 reserved;<br>    __u64 value;<br>};</p>
<p>struct kvm_xcrs {<br>    __u32 nr_xcrs;<br>    __u32 flags;<br>    struct kvm_xcr xcrs[KVM_MAX_XCRS];<br>    __u64 padding[16];<br>};</p>
<p>This ioctl would set vcpu’s xcr to the value userspace specified.</p>
<p>4.46 KVM_GET_SUPPORTED_CPUID</p>
<p>Capability: KVM_CAP_EXT_CPUID<br>Architectures: x86<br>Type: system ioctl<br>Parameters: struct kvm_cpuid2 (in/out)<br>Returns: 0 on success, -1 on error</p>
<p>struct kvm_cpuid2 {<br>    __u32 nent;<br>    __u32 padding;<br>    struct kvm_cpuid_entry2 entries[0];<br>};</p>
<p>#define KVM_CPUID_FLAG_SIGNIFCANT_INDEX        BIT(0)<br>#define KVM_CPUID_FLAG_STATEFUL_FUNC        BIT(1)<br>#define KVM_CPUID_FLAG_STATE_READ_NEXT        BIT(2)</p>
<p>struct kvm_cpuid_entry2 {<br>    __u32 function;<br>    __u32 index;<br>    __u32 flags;<br>    __u32 eax;<br>    __u32 ebx;<br>    __u32 ecx;<br>    __u32 edx;<br>    __u32 padding[3];<br>};</p>
<p>This ioctl returns x86 cpuid features which are supported by both the hardware<br>and kvm.  Userspace can use the information returned by this ioctl to<br>construct cpuid information (for KVM_SET_CPUID2) that is consistent with<br>hardware, kernel, and userspace capabilities, and with user requirements (for<br>example, the user may wish to constrain cpuid to emulate older hardware,<br>or for feature consistency across a cluster).</p>
<p>Userspace invokes KVM_GET_SUPPORTED_CPUID by passing a kvm_cpuid2 structure<br>with the ‘nent’ field indicating the number of entries in the variable-size<br>array ‘entries’.  If the number of entries is too low to describe the cpu<br>capabilities, an error (E2BIG) is returned.  If the number is too high,<br>the ‘nent’ field is adjusted and an error (ENOMEM) is returned.  If the<br>number is just right, the ‘nent’ field is adjusted to the number of valid<br>entries in the ‘entries’ array, which is then filled.</p>
<p>The entries returned are the host cpuid as returned by the cpuid instruction,<br>with unknown or unsupported features masked out.  Some features (for example,<br>x2apic), may not be present in the host cpu, but are exposed by kvm if it can<br>emulate them efficiently. The fields in each entry are defined as follows:</p>
<p>  function: the eax value used to obtain the entry<br>  index: the ecx value used to obtain the entry (for entries that are<br>         affected by ecx)<br>  flags: an OR of zero or more of the following:<br>        KVM_CPUID_FLAG_SIGNIFCANT_INDEX:<br>           if the index field is valid<br>        KVM_CPUID_FLAG_STATEFUL_FUNC:<br>           if cpuid for this function returns different values for successive<br>           invocations; there will be several entries with the same function,<br>           all with this flag set<br>        KVM_CPUID_FLAG_STATE_READ_NEXT:<br>           for KVM_CPUID_FLAG_STATEFUL_FUNC entries, set if this entry is<br>           the first entry to be read by a cpu<br>   eax, ebx, ecx, edx: the values returned by the cpuid instruction for<br>         this function/index combination</p>
<p>The TSC deadline timer feature (CPUID leaf 1, ecx[24]) is always returned<br>as false, since the feature depends on KVM_CREATE_IRQCHIP for local APIC<br>support.  Instead it is reported via</p>
<p>  ioctl(KVM_CHECK_EXTENSION, KVM_CAP_TSC_DEADLINE_TIMER)</p>
<p>if that returns true and you use KVM_CREATE_IRQCHIP, or if you emulate the<br>feature in userspace, then you can enable the feature for KVM_SET_CPUID2.</p>
<p>4.47 KVM_PPC_GET_PVINFO</p>
<p>Capability: KVM_CAP_PPC_GET_PVINFO<br>Architectures: ppc<br>Type: vm ioctl<br>Parameters: struct kvm_ppc_pvinfo (out)<br>Returns: 0 on success, !0 on error</p>
<p>struct kvm_ppc_pvinfo {<br>    __u32 flags;<br>    __u32 hcall[4];<br>    __u8  pad[108];<br>};</p>
<p>This ioctl fetches PV specific information that need to be passed to the guest<br>using the device tree or other means from vm context.</p>
<p>The hcall array defines 4 instructions that make up a hypercall.</p>
<p>If any additional field gets added to this structure later on, a bit for that<br>additional piece of information will be set in the flags bitmap.</p>
<p>The flags bitmap is defined as:</p>
<p>   /* the host supports the ePAPR idle hcall<br>   #define KVM_PPC_PVINFO_FLAGS_EV_IDLE   (1&lt;&lt;0)</p>
<p>4.48 KVM_ASSIGN_PCI_DEVICE</p>
<p>Capability: none<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_assigned_pci_dev (in)<br>Returns: 0 on success, -1 on error</p>
<p>Assigns a host PCI device to the VM.</p>
<p>struct kvm_assigned_pci_dev {<br>    __u32 assigned_dev_id;<br>    __u32 busnr;<br>    __u32 devfn;<br>    __u32 flags;<br>    __u32 segnr;<br>    union {<br>        __u32 reserved[11];<br>    };<br>};</p>
<p>The PCI device is specified by the triple segnr, busnr, and devfn.<br>Identification in succeeding service requests is done via assigned_dev_id. The<br>following flags are specified:</p>
<p>/* Depends on KVM_CAP_IOMMU <em>/<br>#define KVM_DEV_ASSIGN_ENABLE_IOMMU    (1 &lt;&lt; 0)<br>/</em> The following two depend on KVM_CAP_PCI_2_3 */<br>#define KVM_DEV_ASSIGN_PCI_2_3        (1 &lt;&lt; 1)<br>#define KVM_DEV_ASSIGN_MASK_INTX    (1 &lt;&lt; 2)</p>
<p>If KVM_DEV_ASSIGN_PCI_2_3 is set, the kernel will manage legacy INTx interrupts<br>via the PCI-2.3-compliant device-level mask, thus enable IRQ sharing with other<br>assigned devices or host devices. KVM_DEV_ASSIGN_MASK_INTX specifies the<br>guest’s view on the INTx mask, see KVM_ASSIGN_SET_INTX_MASK for details.</p>
<p>The KVM_DEV_ASSIGN_ENABLE_IOMMU flag is a mandatory option to ensure<br>isolation of the device.  Usages not specifying this flag are deprecated.</p>
<p>Only PCI header type 0 devices with PCI BAR resources are supported by<br>device assignment.  The user requesting this ioctl must have read/write<br>access to the PCI sysfs resource files associated with the device.</p>
<p>Errors:<br>  ENOTTY: kernel does not support this ioctl</p>
<p>  Other error conditions may be defined by individual device types or<br>  have their standard meanings.</p>
<p>4.49 KVM_DEASSIGN_PCI_DEVICE</p>
<p>Capability: none<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_assigned_pci_dev (in)<br>Returns: 0 on success, -1 on error</p>
<p>Ends PCI device assignment, releasing all associated resources.</p>
<p>See KVM_ASSIGN_PCI_DEVICE for the data structure. Only assigned_dev_id is<br>used in kvm_assigned_pci_dev to identify the device.</p>
<p>Errors:<br>  ENOTTY: kernel does not support this ioctl</p>
<p>  Other error conditions may be defined by individual device types or<br>  have their standard meanings.</p>
<p>4.50 KVM_ASSIGN_DEV_IRQ</p>
<p>Capability: KVM_CAP_ASSIGN_DEV_IRQ<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_assigned_irq (in)<br>Returns: 0 on success, -1 on error</p>
<p>Assigns an IRQ to a passed-through device.</p>
<p>struct kvm_assigned_irq {<br>    __u32 assigned_dev_id;<br>    __u32 host_irq; /* ignored (legacy field) */<br>    __u32 guest_irq;<br>    __u32 flags;<br>    union {<br>        __u32 reserved[12];<br>    };<br>};</p>
<p>The following flags are defined:</p>
<p>#define KVM_DEV_IRQ_HOST_INTX    (1 &lt;&lt; 0)<br>#define KVM_DEV_IRQ_HOST_MSI     (1 &lt;&lt; 1)<br>#define KVM_DEV_IRQ_HOST_MSIX    (1 &lt;&lt; 2)</p>
<p>#define KVM_DEV_IRQ_GUEST_INTX   (1 &lt;&lt; 8)<br>#define KVM_DEV_IRQ_GUEST_MSI    (1 &lt;&lt; 9)<br>#define KVM_DEV_IRQ_GUEST_MSIX   (1 &lt;&lt; 10)</p>
<p>It is not valid to specify multiple types per host or guest IRQ. However, the<br>IRQ type of host and guest can differ or can even be null.</p>
<p>Errors:<br>  ENOTTY: kernel does not support this ioctl</p>
<p>  Other error conditions may be defined by individual device types or<br>  have their standard meanings.</p>
<p>4.51 KVM_DEASSIGN_DEV_IRQ</p>
<p>Capability: KVM_CAP_ASSIGN_DEV_IRQ<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_assigned_irq (in)<br>Returns: 0 on success, -1 on error</p>
<p>Ends an IRQ assignment to a passed-through device.</p>
<p>See KVM_ASSIGN_DEV_IRQ for the data structure. The target device is specified<br>by assigned_dev_id, flags must correspond to the IRQ type specified on<br>KVM_ASSIGN_DEV_IRQ. Partial deassignment of host or guest IRQ is allowed.</p>
<p>4.52 KVM_SET_GSI_ROUTING</p>
<p>Capability: KVM_CAP_IRQ_ROUTING<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_irq_routing (in)<br>Returns: 0 on success, -1 on error</p>
<p>Sets the GSI routing table entries, overwriting any previously set entries.</p>
<p>struct kvm_irq_routing {<br>    __u32 nr;<br>    __u32 flags;<br>    struct kvm_irq_routing_entry entries[0];<br>};</p>
<p>No flags are specified so far, the corresponding field must be set to zero.</p>
<p>struct kvm_irq_routing_entry {<br>    __u32 gsi;<br>    __u32 type;<br>    __u32 flags;<br>    __u32 pad;<br>    union {<br>        struct kvm_irq_routing_irqchip irqchip;<br>        struct kvm_irq_routing_msi msi;<br>        __u32 pad[8];<br>    } u;<br>};</p>
<p>/* gsi routing entry types */<br>#define KVM_IRQ_ROUTING_IRQCHIP 1<br>#define KVM_IRQ_ROUTING_MSI 2</p>
<p>No flags are specified so far, the corresponding field must be set to zero.</p>
<p>struct kvm_irq_routing_irqchip {<br>    __u32 irqchip;<br>    __u32 pin;<br>};</p>
<p>struct kvm_irq_routing_msi {<br>    __u32 address_lo;<br>    __u32 address_hi;<br>    __u32 data;<br>    __u32 pad;<br>};</p>
<p>On x86, address_hi is ignored unless the KVM_X2APIC_API_USE_32BIT_IDS<br>feature of KVM_CAP_X2APIC_API capability is enabled.  If it is enabled,<br>address_hi bits 31-8 provide bits 31-8 of the destination id.  Bits 7-0 of<br>address_hi must be zero.</p>
<p>4.53 KVM_ASSIGN_SET_MSIX_NR</p>
<p>Capability: none<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_assigned_msix_nr (in)<br>Returns: 0 on success, -1 on error</p>
<p>Set the number of MSI-X interrupts for an assigned device. The number is<br>reset again by terminating the MSI-X assignment of the device via<br>KVM_DEASSIGN_DEV_IRQ. Calling this service more than once at any earlier<br>point will fail.</p>
<p>struct kvm_assigned_msix_nr {<br>    __u32 assigned_dev_id;<br>    __u16 entry_nr;<br>    __u16 padding;<br>};</p>
<p>#define KVM_MAX_MSIX_PER_DEV        256</p>
<p>4.54 KVM_ASSIGN_SET_MSIX_ENTRY</p>
<p>Capability: none<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_assigned_msix_entry (in)<br>Returns: 0 on success, -1 on error</p>
<p>Specifies the routing of an MSI-X assigned device interrupt to a GSI. Setting<br>the GSI vector to zero means disabling the interrupt.</p>
<p>struct kvm_assigned_msix_entry {<br>    __u32 assigned_dev_id;<br>    __u32 gsi;<br>    __u16 entry; /* The index of entry in the MSI-X table */<br>    __u16 padding[3];<br>};</p>
<p>Errors:<br>  ENOTTY: kernel does not support this ioctl</p>
<p>  Other error conditions may be defined by individual device types or<br>  have their standard meanings.</p>
<p>4.55 KVM_SET_TSC_KHZ</p>
<p>Capability: KVM_CAP_TSC_CONTROL<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: virtual tsc_khz<br>Returns: 0 on success, -1 on error</p>
<p>Specifies the tsc frequency for the virtual machine. The unit of the<br>frequency is KHz.</p>
<p>4.56 KVM_GET_TSC_KHZ</p>
<p>Capability: KVM_CAP_GET_TSC_KHZ<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: none<br>Returns: virtual tsc-khz on success, negative value on error</p>
<p>Returns the tsc frequency of the guest. The unit of the return value is<br>KHz. If the host has unstable tsc this ioctl returns -EIO instead as an<br>error.</p>
<p>4.57 KVM_GET_LAPIC</p>
<p>Capability: KVM_CAP_IRQCHIP<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_lapic_state (out)<br>Returns: 0 on success, -1 on error</p>
<p>#define KVM_APIC_REG_SIZE 0x400<br>struct kvm_lapic_state {<br>    char regs[KVM_APIC_REG_SIZE];<br>};</p>
<p>Reads the Local APIC registers and copies them into the input argument.  The<br>data format and layout are the same as documented in the architecture manual.</p>
<p>If KVM_X2APIC_API_USE_32BIT_IDS feature of KVM_CAP_X2APIC_API is<br>enabled, then the format of APIC_ID register depends on the APIC mode<br>(reported by MSR_IA32_APICBASE) of its VCPU.  x2APIC stores APIC ID in<br>the APIC_ID register (bytes 32-35).  xAPIC only allows an 8-bit APIC ID<br>which is stored in bits 31-24 of the APIC register, or equivalently in<br>byte 35 of struct kvm_lapic_state’s regs field.  KVM_GET_LAPIC must then<br>be called after MSR_IA32_APICBASE has been set with KVM_SET_MSR.</p>
<p>If KVM_X2APIC_API_USE_32BIT_IDS feature is disabled, struct kvm_lapic_state<br>always uses xAPIC format.</p>
<p>4.58 KVM_SET_LAPIC</p>
<p>Capability: KVM_CAP_IRQCHIP<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: struct kvm_lapic_state (in)<br>Returns: 0 on success, -1 on error</p>
<p>#define KVM_APIC_REG_SIZE 0x400<br>struct kvm_lapic_state {<br>    char regs[KVM_APIC_REG_SIZE];<br>};</p>
<p>Copies the input argument into the the Local APIC registers.  The data format<br>and layout are the same as documented in the architecture manual.</p>
<p>The format of the APIC ID register (bytes 32-35 of struct kvm_lapic_state’s<br>regs field) depends on the state of the KVM_CAP_X2APIC_API capability.<br>See the note in KVM_GET_LAPIC.</p>
<p>4.59 KVM_IOEVENTFD</p>
<p>Capability: KVM_CAP_IOEVENTFD<br>Architectures: all<br>Type: vm ioctl<br>Parameters: struct kvm_ioeventfd (in)<br>Returns: 0 on success, !0 on error</p>
<p>This ioctl attaches or detaches an ioeventfd to a legal pio/mmio address<br>within the guest.  A guest write in the registered address will signal the<br>provided event instead of triggering an exit.</p>
<p>struct kvm_ioeventfd {<br>    __u64 datamatch;<br>    __u64 addr;        /* legal pio/mmio address <em>/<br>    __u32 len;         /</em> 0, 1, 2, 4, or 8 bytes    */<br>    __s32 fd;<br>    __u32 flags;<br>    __u8  pad[36];<br>};</p>
<p>For the special case of virtio-ccw devices on s390, the ioevent is matched<br>to a subchannel/virtqueue tuple instead.</p>
<p>The following flags are defined:</p>
<p>#define KVM_IOEVENTFD_FLAG_DATAMATCH (1 &lt;&lt; kvm_ioeventfd_flag_nr_datamatch)<br>#define KVM_IOEVENTFD_FLAG_PIO       (1 &lt;&lt; kvm_ioeventfd_flag_nr_pio)<br>#define KVM_IOEVENTFD_FLAG_DEASSIGN  (1 &lt;&lt; kvm_ioeventfd_flag_nr_deassign)<br>#define KVM_IOEVENTFD_FLAG_VIRTIO_CCW_NOTIFY <br>    (1 &lt;&lt; kvm_ioeventfd_flag_nr_virtio_ccw_notify)</p>
<p>If datamatch flag is set, the event will be signaled only if the written value<br>to the registered address is equal to datamatch in struct kvm_ioeventfd.</p>
<p>For virtio-ccw devices, addr contains the subchannel id and datamatch the<br>virtqueue index.</p>
<p>With KVM_CAP_IOEVENTFD_ANY_LENGTH, a zero length ioeventfd is allowed, and<br>the kernel will ignore the length of guest write and may get a faster vmexit.<br>The speedup may only apply to specific architectures, but the ioeventfd will<br>work anyway.</p>
<p>4.60 KVM_DIRTY_TLB</p>
<p>Capability: KVM_CAP_SW_TLB<br>Architectures: ppc<br>Type: vcpu ioctl<br>Parameters: struct kvm_dirty_tlb (in)<br>Returns: 0 on success, -1 on error</p>
<p>struct kvm_dirty_tlb {<br>    __u64 bitmap;<br>    __u32 num_dirty;<br>};</p>
<p>This must be called whenever userspace has changed an entry in the shared<br>TLB, prior to calling KVM_RUN on the associated vcpu.</p>
<p>The “bitmap” field is the userspace address of an array.  This array<br>consists of a number of bits, equal to the total number of TLB entries as<br>determined by the last successful call to KVM_CONFIG_TLB, rounded up to the<br>nearest multiple of 64.</p>
<p>Each bit corresponds to one TLB entry, ordered the same as in the shared TLB<br>array.</p>
<p>The array is little-endian: the bit 0 is the least significant bit of the<br>first byte, bit 8 is the least significant bit of the second byte, etc.<br>This avoids any complications with differing word sizes.</p>
<p>The “num_dirty” field is a performance hint for KVM to determine whether it<br>should skip processing the bitmap and just invalidate everything.  It must<br>be set to the number of set bits in the bitmap.</p>
<p>4.61 KVM_ASSIGN_SET_INTX_MASK</p>
<p>Capability: KVM_CAP_PCI_2_3<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_assigned_pci_dev (in)<br>Returns: 0 on success, -1 on error</p>
<p>Allows userspace to mask PCI INTx interrupts from the assigned device.  The<br>kernel will not deliver INTx interrupts to the guest between setting and<br>clearing of KVM_ASSIGN_SET_INTX_MASK via this interface.  This enables use of<br>and emulation of PCI 2.3 INTx disable command register behavior.</p>
<p>This may be used for both PCI 2.3 devices supporting INTx disable natively and<br>older devices lacking this support. Userspace is responsible for emulating the<br>read value of the INTx disable bit in the guest visible PCI command register.<br>When modifying the INTx disable state, userspace should precede updating the<br>physical device command register by calling this ioctl to inform the kernel of<br>the new intended INTx mask state.</p>
<p>Note that the kernel uses the device INTx disable bit to internally manage the<br>device interrupt state for PCI 2.3 devices.  Reads of this register may<br>therefore not match the expected value.  Writes should always use the guest<br>intended INTx disable value rather than attempting to read-copy-update the<br>current physical device state.  Races between user and kernel updates to the<br>INTx disable bit are handled lazily in the kernel.  It’s possible the device<br>may generate unintended interrupts, but they will not be injected into the<br>guest.</p>
<p>See KVM_ASSIGN_DEV_IRQ for the data structure.  The target device is specified<br>by assigned_dev_id.  In the flags field, only KVM_DEV_ASSIGN_MASK_INTX is<br>evaluated.</p>
<p>4.62 KVM_CREATE_SPAPR_TCE</p>
<p>Capability: KVM_CAP_SPAPR_TCE<br>Architectures: powerpc<br>Type: vm ioctl<br>Parameters: struct kvm_create_spapr_tce (in)<br>Returns: file descriptor for manipulating the created TCE table</p>
<p>This creates a virtual TCE (translation control entry) table, which<br>is an IOMMU for PAPR-style virtual I/O.  It is used to translate<br>logical addresses used in virtual I/O into guest physical addresses,<br>and provides a scatter/gather capability for PAPR virtual I/O.</p>
<p>/* for KVM_CAP_SPAPR_TCE */<br>struct kvm_create_spapr_tce {<br>    __u64 liobn;<br>    __u32 window_size;<br>};</p>
<p>The liobn field gives the logical IO bus number for which to create a<br>TCE table.  The window_size field specifies the size of the DMA window<br>which this TCE table will translate - the table will contain one 64<br>bit TCE entry for every 4kiB of the DMA window.</p>
<p>When the guest issues an H_PUT_TCE hcall on a liobn for which a TCE<br>table has been created using this ioctl(), the kernel will handle it<br>in real mode, updating the TCE table.  H_PUT_TCE calls for other<br>liobns will cause a vm exit and must be handled by userspace.</p>
<p>The return value is a file descriptor which can be passed to mmap(2)<br>to map the created TCE table into userspace.  This lets userspace read<br>the entries written by kernel-handled H_PUT_TCE calls, and also lets<br>userspace update the TCE table directly which is useful in some<br>circumstances.</p>
<p>4.63 KVM_ALLOCATE_RMA</p>
<p>Capability: KVM_CAP_PPC_RMA<br>Architectures: powerpc<br>Type: vm ioctl<br>Parameters: struct kvm_allocate_rma (out)<br>Returns: file descriptor for mapping the allocated RMA</p>
<p>This allocates a Real Mode Area (RMA) from the pool allocated at boot<br>time by the kernel.  An RMA is a physically-contiguous, aligned region<br>of memory used on older POWER processors to provide the memory which<br>will be accessed by real-mode (MMU off) accesses in a KVM guest.<br>POWER processors support a set of sizes for the RMA that usually<br>includes 64MB, 128MB, 256MB and some larger powers of two.</p>
<p>/* for KVM_ALLOCATE_RMA */<br>struct kvm_allocate_rma {<br>    __u64 rma_size;<br>};</p>
<p>The return value is a file descriptor which can be passed to mmap(2)<br>to map the allocated RMA into userspace.  The mapped area can then be<br>passed to the KVM_SET_USER_MEMORY_REGION ioctl to establish it as the<br>RMA for a virtual machine.  The size of the RMA in bytes (which is<br>fixed at host kernel boot time) is returned in the rma_size field of<br>the argument structure.</p>
<p>The KVM_CAP_PPC_RMA capability is 1 or 2 if the KVM_ALLOCATE_RMA ioctl<br>is supported; 2 if the processor requires all virtual machines to have<br>an RMA, or 1 if the processor can use an RMA but doesn’t require it,<br>because it supports the Virtual RMA (VRMA) facility.</p>
<p>4.64 KVM_NMI</p>
<p>Capability: KVM_CAP_USER_NMI<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: none<br>Returns: 0 on success, -1 on error</p>
<p>Queues an NMI on the thread’s vcpu.  Note this is well defined only<br>when KVM_CREATE_IRQCHIP has not been called, since this is an interface<br>between the virtual cpu core and virtual local APIC.  After KVM_CREATE_IRQCHIP<br>has been called, this interface is completely emulated within the kernel.</p>
<p>To use this to emulate the LINT1 input with KVM_CREATE_IRQCHIP, use the<br>following algorithm:</p>
<ul>
<li>pause the vpcu</li>
<li>read the local APIC’s state (KVM_GET_LAPIC)</li>
<li>check whether changing LINT1 will queue an NMI (see the LVT entry for LINT1)</li>
<li>if so, issue KVM_NMI</li>
<li>resume the vcpu</li>
</ul>
<p>Some guests configure the LINT1 NMI input to cause a panic, aiding in<br>debugging.</p>
<p>4.65 KVM_S390_UCAS_MAP</p>
<p>Capability: KVM_CAP_S390_UCONTROL<br>Architectures: s390<br>Type: vcpu ioctl<br>Parameters: struct kvm_s390_ucas_mapping (in)<br>Returns: 0 in case of success</p>
<p>The parameter is defined like this:<br>    struct kvm_s390_ucas_mapping {<br>        __u64 user_addr;<br>        __u64 vcpu_addr;<br>        __u64 length;<br>    };</p>
<p>This ioctl maps the memory at “user_addr” with the length “length” to<br>the vcpu’s address space starting at “vcpu_addr”. All parameters need to<br>be alligned by 1 megabyte.</p>
<p>4.66 KVM_S390_UCAS_UNMAP</p>
<p>Capability: KVM_CAP_S390_UCONTROL<br>Architectures: s390<br>Type: vcpu ioctl<br>Parameters: struct kvm_s390_ucas_mapping (in)<br>Returns: 0 in case of success</p>
<p>The parameter is defined like this:<br>    struct kvm_s390_ucas_mapping {<br>        __u64 user_addr;<br>        __u64 vcpu_addr;<br>        __u64 length;<br>    };</p>
<p>This ioctl unmaps the memory in the vcpu’s address space starting at<br>“vcpu_addr” with the length “length”. The field “user_addr” is ignored.<br>All parameters need to be alligned by 1 megabyte.</p>
<p>4.67 KVM_S390_VCPU_FAULT</p>
<p>Capability: KVM_CAP_S390_UCONTROL<br>Architectures: s390<br>Type: vcpu ioctl<br>Parameters: vcpu absolute address (in)<br>Returns: 0 in case of success</p>
<p>This call creates a page table entry on the virtual cpu’s address space<br>(for user controlled virtual machines) or the virtual machine’s address<br>space (for regular virtual machines). This only works for minor faults,<br>thus it’s recommended to access subject memory page via the user page<br>table upfront. This is useful to handle validity intercepts for user<br>controlled virtual machines to fault in the virtual cpu’s lowcore pages<br>prior to calling the KVM_RUN ioctl.</p>
<p>4.68 KVM_SET_ONE_REG</p>
<p>Capability: KVM_CAP_ONE_REG<br>Architectures: all<br>Type: vcpu ioctl<br>Parameters: struct kvm_one_reg (in)<br>Returns: 0 on success, negative value on failure</p>
<p>struct kvm_one_reg {<br>       __u64 id;<br>       __u64 addr;<br>};</p>
<p>Using this ioctl, a single vcpu register can be set to a specific value<br>defined by user space with the passed in struct kvm_one_reg, where id<br>refers to the register identifier as described below and addr is a pointer<br>to a variable with the respective size. There can be architecture agnostic<br>and architecture specific registers. Each have their own range of operation<br>and their own constants and width. To keep track of the implemented<br>registers, find a list below:</p>
<p>  Arch  |       Register        | Width (bits)<br>        |                       |<br>  PPC   | KVM_REG_PPC_HIOR      | 64<br>  PPC   | KVM_REG_PPC_IAC1      | 64<br>  PPC   | KVM_REG_PPC_IAC2      | 64<br>  PPC   | KVM_REG_PPC_IAC3      | 64<br>  PPC   | KVM_REG_PPC_IAC4      | 64<br>  PPC   | KVM_REG_PPC_DAC1      | 64<br>  PPC   | KVM_REG_PPC_DAC2      | 64<br>  PPC   | KVM_REG_PPC_DABR      | 64<br>  PPC   | KVM_REG_PPC_DSCR      | 64<br>  PPC   | KVM_REG_PPC_PURR      | 64<br>  PPC   | KVM_REG_PPC_SPURR     | 64<br>  PPC   | KVM_REG_PPC_DAR       | 64<br>  PPC   | KVM_REG_PPC_DSISR     | 32<br>  PPC   | KVM_REG_PPC_AMR       | 64<br>  PPC   | KVM_REG_PPC_UAMOR     | 64<br>  PPC   | KVM_REG_PPC_MMCR0     | 64<br>  PPC   | KVM_REG_PPC_MMCR1     | 64<br>  PPC   | KVM_REG_PPC_MMCRA     | 64<br>  PPC   | KVM_REG_PPC_MMCR2     | 64<br>  PPC   | KVM_REG_PPC_MMCRS     | 64<br>  PPC   | KVM_REG_PPC_SIAR      | 64<br>  PPC   | KVM_REG_PPC_SDAR      | 64<br>  PPC   | KVM_REG_PPC_SIER      | 64<br>  PPC   | KVM_REG_PPC_PMC1      | 32<br>  PPC   | KVM_REG_PPC_PMC2      | 32<br>  PPC   | KVM_REG_PPC_PMC3      | 32<br>  PPC   | KVM_REG_PPC_PMC4      | 32<br>  PPC   | KVM_REG_PPC_PMC5      | 32<br>  PPC   | KVM_REG_PPC_PMC6      | 32<br>  PPC   | KVM_REG_PPC_PMC7      | 32<br>  PPC   | KVM_REG_PPC_PMC8      | 32<br>  PPC   | KVM_REG_PPC_FPR0      | 64<br>          …<br>  PPC   | KVM_REG_PPC_FPR31     | 64<br>  PPC   | KVM_REG_PPC_VR0       | 128<br>          …<br>  PPC   | KVM_REG_PPC_VR31      | 128<br>  PPC   | KVM_REG_PPC_VSR0      | 128<br>          …<br>  PPC   | KVM_REG_PPC_VSR31     | 128<br>  PPC   | KVM_REG_PPC_FPSCR     | 64<br>  PPC   | KVM_REG_PPC_VSCR      | 32<br>  PPC   | KVM_REG_PPC_VPA_ADDR  | 64<br>  PPC   | KVM_REG_PPC_VPA_SLB   | 128<br>  PPC   | KVM_REG_PPC_VPA_DTL   | 128<br>  PPC   | KVM_REG_PPC_EPCR    | 32<br>  PPC   | KVM_REG_PPC_EPR    | 32<br>  PPC   | KVM_REG_PPC_TCR    | 32<br>  PPC   | KVM_REG_PPC_TSR    | 32<br>  PPC   | KVM_REG_PPC_OR_TSR    | 32<br>  PPC   | KVM_REG_PPC_CLEAR_TSR    | 32<br>  PPC   | KVM_REG_PPC_MAS0    | 32<br>  PPC   | KVM_REG_PPC_MAS1    | 32<br>  PPC   | KVM_REG_PPC_MAS2    | 64<br>  PPC   | KVM_REG_PPC_MAS7_3    | 64<br>  PPC   | KVM_REG_PPC_MAS4    | 32<br>  PPC   | KVM_REG_PPC_MAS6    | 32<br>  PPC   | KVM_REG_PPC_MMUCFG    | 32<br>  PPC   | KVM_REG_PPC_TLB0CFG    | 32<br>  PPC   | KVM_REG_PPC_TLB1CFG    | 32<br>  PPC   | KVM_REG_PPC_TLB2CFG    | 32<br>  PPC   | KVM_REG_PPC_TLB3CFG    | 32<br>  PPC   | KVM_REG_PPC_TLB0PS    | 32<br>  PPC   | KVM_REG_PPC_TLB1PS    | 32<br>  PPC   | KVM_REG_PPC_TLB2PS    | 32<br>  PPC   | KVM_REG_PPC_TLB3PS    | 32<br>  PPC   | KVM_REG_PPC_EPTCFG    | 32<br>  PPC   | KVM_REG_PPC_ICP_STATE | 64<br>  PPC   | KVM_REG_PPC_TB_OFFSET    | 64<br>  PPC   | KVM_REG_PPC_SPMC1    | 32<br>  PPC   | KVM_REG_PPC_SPMC2    | 32<br>  PPC   | KVM_REG_PPC_IAMR    | 64<br>  PPC   | KVM_REG_PPC_TFHAR    | 64<br>  PPC   | KVM_REG_PPC_TFIAR    | 64<br>  PPC   | KVM_REG_PPC_TEXASR    | 64<br>  PPC   | KVM_REG_PPC_FSCR    | 64<br>  PPC   | KVM_REG_PPC_PSPB    | 32<br>  PPC   | KVM_REG_PPC_EBBHR    | 64<br>  PPC   | KVM_REG_PPC_EBBRR    | 64<br>  PPC   | KVM_REG_PPC_BESCR    | 64<br>  PPC   | KVM_REG_PPC_TAR    | 64<br>  PPC   | KVM_REG_PPC_DPDES    | 64<br>  PPC   | KVM_REG_PPC_DAWR    | 64<br>  PPC   | KVM_REG_PPC_DAWRX    | 64<br>  PPC   | KVM_REG_PPC_CIABR    | 64<br>  PPC   | KVM_REG_PPC_IC    | 64<br>  PPC   | KVM_REG_PPC_VTB    | 64<br>  PPC   | KVM_REG_PPC_CSIGR    | 64<br>  PPC   | KVM_REG_PPC_TACR    | 64<br>  PPC   | KVM_REG_PPC_TCSCR    | 64<br>  PPC   | KVM_REG_PPC_PID    | 64<br>  PPC   | KVM_REG_PPC_ACOP    | 64<br>  PPC   | KVM_REG_PPC_VRSAVE    | 32<br>  PPC   | KVM_REG_PPC_LPCR    | 32<br>  PPC   | KVM_REG_PPC_LPCR_64    | 64<br>  PPC   | KVM_REG_PPC_PPR    | 64<br>  PPC   | KVM_REG_PPC_ARCH_COMPAT 32<br>  PPC   | KVM_REG_PPC_DABRX     | 32<br>  PPC   | KVM_REG_PPC_WORT      | 64<br>  PPC   | KVM_REG_PPC_TM_GPR0    | 64<br>          …<br>  PPC   | KVM_REG_PPC_TM_GPR31    | 64<br>  PPC   | KVM_REG_PPC_TM_VSR0    | 128<br>          …<br>  PPC   | KVM_REG_PPC_TM_VSR63    | 128<br>  PPC   | KVM_REG_PPC_TM_CR    | 64<br>  PPC   | KVM_REG_PPC_TM_LR    | 64<br>  PPC   | KVM_REG_PPC_TM_CTR    | 64<br>  PPC   | KVM_REG_PPC_TM_FPSCR    | 64<br>  PPC   | KVM_REG_PPC_TM_AMR    | 64<br>  PPC   | KVM_REG_PPC_TM_PPR    | 64<br>  PPC   | KVM_REG_PPC_TM_VRSAVE    | 64<br>  PPC   | KVM_REG_PPC_TM_VSCR    | 32<br>  PPC   | KVM_REG_PPC_TM_DSCR    | 64<br>  PPC   | KVM_REG_PPC_TM_TAR    | 64</p>
<p>ARM registers are mapped using the lower 32 bits.  The upper 16 of that<br>is the register group type, or coprocessor number:</p>
<p>ARM core registers have the following id bit patterns:<br>  0x4020 0000 0010 <index into the kvm_regs struct:16></p>
<p>ARM 32-bit CP15 registers have the following id bit patterns:<br>  0x4020 0000 000F <a href="zero:1">zero:1</a> <a href="crn:4">crn:4</a> <a href="crm:4">crm:4</a> <a href="opc1:4">opc1:4</a> <a href="opc2:3">opc2:3</a></p>
<p>ARM 64-bit CP15 registers have the following id bit patterns:<br>  0x4030 0000 000F <a href="zero:1">zero:1</a> <a href="zero:4">zero:4</a> <a href="crm:4">crm:4</a> <a href="opc1:4">opc1:4</a> <a href="zero:3">zero:3</a></p>
<p>ARM CCSIDR registers are demultiplexed by CSSELR value:<br>  0x4020 0000 0011 00 <a href="csselr:8">csselr:8</a></p>
<p>ARM 32-bit VFP control registers have the following id bit patterns:<br>  0x4020 0000 0012 1 <a href="regno:12">regno:12</a></p>
<p>ARM 64-bit FP registers have the following id bit patterns:<br>  0x4030 0000 0012 0 <a href="regno:12">regno:12</a></p>
<p>4.69 KVM_GET_ONE_REG</p>
<p>Capability: KVM_CAP_ONE_REG<br>Architectures: all<br>Type: vcpu ioctl<br>Parameters: struct kvm_one_reg (in and out)<br>Returns: 0 on success, negative value on failure</p>
<p>This ioctl allows to receive the value of a single register implemented<br>in a vcpu. The register to read is indicated by the “id” field of the<br>kvm_one_reg struct passed in. On success, the register value can be found<br>at the memory location pointed to by “addr”.</p>
<p>The list of registers accessible using this interface is identical to the<br>list in 4.68.</p>
<p>4.70 KVM_KVMCLOCK_CTRL</p>
<p>Capability: KVM_CAP_KVMCLOCK_CTRL<br>Architectures: Any that implement pvclocks (currently x86 only)<br>Type: vcpu ioctl<br>Parameters: None<br>Returns: 0 on success, -1 on error</p>
<p>This signals to the host kernel that the specified guest is being paused by<br>userspace.  The host will set a flag in the pvclock structure that is checked<br>from the soft lockup watchdog.  The flag is part of the pvclock structure that<br>is shared between guest and host, specifically the second bit of the flags<br>field of the pvclock_vcpu_time_info structure.  It will be set exclusively by<br>the host and read/cleared exclusively by the guest.  The guest operation of<br>checking and clearing the flag must an atomic operation so<br>load-link/store-conditional, or equivalent must be used.  There are two cases<br>where the guest will clear the flag: when the soft lockup watchdog timer resets<br>itself or when a soft lockup is detected.  This ioctl can be called any time<br>after pausing the vcpu, but before it is resumed.</p>
<p>4.71 KVM_SIGNAL_MSI</p>
<p>Capability: KVM_CAP_SIGNAL_MSI<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_msi (in)<br>Returns: &gt;0 on delivery, 0 if guest blocked the MSI, and -1 on error</p>
<p>Directly inject a MSI message. Only valid with in-kernel irqchip that handles<br>MSI messages.</p>
<p>struct kvm_msi {<br>    __u32 address_lo;<br>    __u32 address_hi;<br>    __u32 data;<br>    __u32 flags;<br>    __u8  pad[16];<br>};</p>
<p>No flags are defined so far. The corresponding field must be 0.</p>
<p>On x86, address_hi is ignored unless the KVM_CAP_X2APIC_API capability is<br>enabled.  If it is enabled, address_hi bits 31-8 provide bits 31-8 of the<br>destination id.  Bits 7-0 of address_hi must be zero.</p>
<p>4.71 KVM_CREATE_PIT2</p>
<p>Capability: KVM_CAP_PIT2<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_pit_config (in)<br>Returns: 0 on success, -1 on error</p>
<p>Creates an in-kernel device model for the i8254 PIT. This call is only valid<br>after enabling in-kernel irqchip support via KVM_CREATE_IRQCHIP. The following<br>parameters have to be passed:</p>
<p>struct kvm_pit_config {<br>    __u32 flags;<br>    __u32 pad[15];<br>};</p>
<p>Valid flags are:</p>
<p>#define KVM_PIT_SPEAKER_DUMMY     1 /* emulate speaker port stub */</p>
<p>PIT timer interrupts may use a per-VM kernel thread for injection. If it<br>exists, this thread will have a name of the following pattern:</p>
<p>kvm-pit/<owner-process-pid></p>
<p>When running a guest with elevated priorities, the scheduling parameters of<br>this thread may have to be adjusted accordingly.</p>
<p>This IOCTL replaces the obsolete KVM_CREATE_PIT.</p>
<p>4.72 KVM_GET_PIT2</p>
<p>Capability: KVM_CAP_PIT_STATE2<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_pit_state2 (out)<br>Returns: 0 on success, -1 on error</p>
<p>Retrieves the state of the in-kernel PIT model. Only valid after<br>KVM_CREATE_PIT2. The state is returned in the following structure:</p>
<p>struct kvm_pit_state2 {<br>    struct kvm_pit_channel_state channels[3];<br>    __u32 flags;<br>    __u32 reserved[9];<br>};</p>
<p>Valid flags are:</p>
<p>/* disable PIT in HPET legacy mode */<br>#define KVM_PIT_FLAGS_HPET_LEGACY  0x00000001</p>
<p>This IOCTL replaces the obsolete KVM_GET_PIT.</p>
<p>4.73 KVM_SET_PIT2</p>
<p>Capability: KVM_CAP_PIT_STATE2<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_pit_state2 (in)<br>Returns: 0 on success, -1 on error</p>
<p>Sets the state of the in-kernel PIT model. Only valid after KVM_CREATE_PIT2.<br>See KVM_GET_PIT2 for details on struct kvm_pit_state2.</p>
<p>This IOCTL replaces the obsolete KVM_SET_PIT.</p>
<p>4.74 KVM_PPC_GET_SMMU_INFO</p>
<p>Capability: KVM_CAP_PPC_GET_SMMU_INFO<br>Architectures: powerpc<br>Type: vm ioctl<br>Parameters: None<br>Returns: 0 on success, -1 on error</p>
<p>This populates and returns a structure describing the features of<br>the “Server” class MMU emulation supported by KVM.<br>This can in turn be used by userspace to generate the appropriate<br>device-tree properties for the guest operating system.</p>
<p>The structure contains some global informations, followed by an<br>array of supported segment page sizes:</p>
<pre><code>  struct kvm_ppc_smmu_info &#123;
     __u64 flags;
     __u32 slb_size;
     __u32 pad;
     struct kvm_ppc_one_seg_page_size sps[KVM_PPC_PAGE_SIZES_MAX_SZ];
  &#125;;
</code></pre>
<p>The supported flags are:</p>
<pre><code>- KVM_PPC_PAGE_SIZES_REAL:
    When that flag is set, guest page sizes must &quot;fit&quot; the backing
    store page sizes. When not set, any page size in the list can
    be used regardless of how they are backed by userspace.

- KVM_PPC_1T_SEGMENTS
    The emulated MMU supports 1T segments in addition to the
    standard 256M ones.
</code></pre>
<p>The “slb_size” field indicates how many SLB entries are supported</p>
<p>The “sps” array contains 8 entries indicating the supported base<br>page sizes for a segment in increasing order. Each entry is defined<br>as follow:</p>
<p>   struct kvm_ppc_one_seg_page_size {<br>    __u32 page_shift;    /* Base page shift of segment (or 0) <em>/<br>    __u32 slb_enc;        /</em> SLB encoding for BookS */<br>    struct kvm_ppc_one_page_size enc[KVM_PPC_PAGE_SIZES_MAX_SZ];<br>   };</p>
<p>An entry with a “page_shift” of 0 is unused. Because the array is<br>organized in increasing order, a lookup can stop when encoutering<br>such an entry.</p>
<p>The “slb_enc” field provides the encoding to use in the SLB for the<br>page size. The bits are in positions such as the value can directly<br>be OR’ed into the “vsid” argument of the slbmte instruction.</p>
<p>The “enc” array is a list which for each of those segment base page<br>size provides the list of supported actual page sizes (which can be<br>only larger or equal to the base page size), along with the<br>corresponding encoding in the hash PTE. Similarily, the array is<br>8 entries sorted by increasing sizes and an entry with a “0” shift<br>is an empty entry and a terminator:</p>
<p>   struct kvm_ppc_one_page_size {<br>    __u32 page_shift;    /* Page shift (or 0) <em>/<br>    __u32 pte_enc;        /</em> Encoding in the HPTE (&gt;&gt;12) */<br>   };</p>
<p>The “pte_enc” field provides a value that can OR’ed into the hash<br>PTE’s RPN field (ie, it needs to be shifted left by 12 to OR it<br>into the hash PTE second double word).</p>
<p>4.75 KVM_IRQFD</p>
<p>Capability: KVM_CAP_IRQFD<br>Architectures: x86<br>Type: vm ioctl<br>Parameters: struct kvm_irqfd (in)<br>Returns: 0 on success, -1 on error</p>
<p>Allows setting an eventfd to directly trigger a guest interrupt.<br>kvm_irqfd.fd specifies the file descriptor to use as the eventfd and<br>kvm_irqfd.gsi specifies the irqchip pin toggled by this event.  When<br>an event is triggered on the eventfd, an interrupt is injected into<br>the guest using the specified gsi pin.  The irqfd is removed using<br>the KVM_IRQFD_FLAG_DEASSIGN flag, specifying both kvm_irqfd.fd<br>and kvm_irqfd.gsi.</p>
<p>With KVM_CAP_IRQFD_RESAMPLE, KVM_IRQFD supports a de-assert and notify<br>mechanism allowing emulation of level-triggered, irqfd-based<br>interrupts.  When KVM_IRQFD_FLAG_RESAMPLE is set the user must pass an<br>additional eventfd in the kvm_irqfd.resamplefd field.  When operating<br>in resample mode, posting of an interrupt through kvm_irq.fd asserts<br>the specified gsi in the irqchip.  When the irqchip is resampled, such<br>as from an EOI, the gsi is de-asserted and the user is notified via<br>kvm_irqfd.resamplefd.  It is the user’s responsibility to re-queue<br>the interrupt if the device making use of it still requires service.<br>Note that closing the resamplefd is not sufficient to disable the<br>irqfd.  The KVM_IRQFD_FLAG_RESAMPLE is only necessary on assignment<br>and need not be specified with KVM_IRQFD_FLAG_DEASSIGN.</p>
<p>4.76 KVM_PPC_ALLOCATE_HTAB</p>
<p>Capability: KVM_CAP_PPC_ALLOC_HTAB<br>Architectures: powerpc<br>Type: vm ioctl<br>Parameters: Pointer to u32 containing hash table order (in/out)<br>Returns: 0 on success, -1 on error</p>
<p>This requests the host kernel to allocate an MMU hash table for a<br>guest using the PAPR paravirtualization interface.  This only does<br>anything if the kernel is configured to use the Book 3S HV style of<br>virtualization.  Otherwise the capability doesn’t exist and the ioctl<br>returns an ENOTTY error.  The rest of this description assumes Book 3S<br>HV.</p>
<p>There must be no vcpus running when this ioctl is called; if there<br>are, it will do nothing and return an EBUSY error.</p>
<p>The parameter is a pointer to a 32-bit unsigned integer variable<br>containing the order (log base 2) of the desired size of the hash<br>table, which must be between 18 and 46.  On successful return from the<br>ioctl, the value will not be changed by the kernel.</p>
<p>If no hash table has been allocated when any vcpu is asked to run<br>(with the KVM_RUN ioctl), the host kernel will allocate a<br>default-sized hash table (16 MB).</p>
<p>If this ioctl is called when a hash table has already been allocated,<br>with a different order from the existing hash table, the existing hash<br>table will be freed and a new one allocated.  If this is ioctl is<br>called when a hash table has already been allocated of the same order<br>as specified, the kernel will clear out the existing hash table (zero<br>all HPTEs).  In either case, if the guest is using the virtualized<br>real-mode area (VRMA) facility, the kernel will re-create the VMRA<br>HPTEs on the next KVM_RUN of any vcpu.</p>
<p>4.77 KVM_S390_INTERRUPT</p>
<p>Capability: basic<br>Architectures: s390<br>Type: vm ioctl, vcpu ioctl<br>Parameters: struct kvm_s390_interrupt (in)<br>Returns: 0 on success, -1 on error</p>
<p>Allows to inject an interrupt to the guest. Interrupts can be floating<br>(vm ioctl) or per cpu (vcpu ioctl), depending on the interrupt type.</p>
<p>Interrupt parameters are passed via kvm_s390_interrupt:</p>
<p>struct kvm_s390_interrupt {<br>    __u32 type;<br>    __u32 parm;<br>    __u64 parm64;<br>};</p>
<p>type can be one of the following:</p>
<p>KVM_S390_SIGP_STOP (vcpu) - sigp restart<br>KVM_S390_PROGRAM_INT (vcpu) - program check; code in parm<br>KVM_S390_SIGP_SET_PREFIX (vcpu) - sigp set prefix; prefix address in parm<br>KVM_S390_RESTART (vcpu) - restart<br>KVM_S390_INT_VIRTIO (vm) - virtio external interrupt; external interrupt<br>               parameters in parm and parm64<br>KVM_S390_INT_SERVICE (vm) - sclp external interrupt; sclp parameter in parm<br>KVM_S390_INT_EMERGENCY (vcpu) - sigp emergency; source cpu in parm<br>KVM_S390_INT_EXTERNAL_CALL (vcpu) - sigp external call; source cpu in parm<br>KVM_S390_INT_IO(ai,cssid,ssid,schid) (vm) - compound value to indicate an<br>    I/O interrupt (ai - adapter interrupt; cssid,ssid,schid - subchannel);<br>    I/O interruption parameters in parm (subchannel) and parm64 (intparm,<br>    interruption subclass)<br>KVM_S390_MCHK (vm, vcpu) - machine check interrupt; cr 14 bits in parm,<br>                           machine check interrupt code in parm64 (note that<br>                           machine checks needing further payload are not<br>                           supported by this ioctl)</p>
<p>Note that the vcpu ioctl is asynchronous to vcpu execution.</p>
<p>4.78 KVM_PPC_GET_HTAB_FD</p>
<p>Capability: KVM_CAP_PPC_HTAB_FD<br>Architectures: powerpc<br>Type: vm ioctl<br>Parameters: Pointer to struct kvm_get_htab_fd (in)<br>Returns: file descriptor number (&gt;= 0) on success, -1 on error</p>
<p>This returns a file descriptor that can be used either to read out the<br>entries in the guest’s hashed page table (HPT), or to write entries to<br>initialize the HPT.  The returned fd can only be written to if the<br>KVM_GET_HTAB_WRITE bit is set in the flags field of the argument, and<br>can only be read if that bit is clear.  The argument struct looks like<br>this:</p>
<p>/* For KVM_PPC_GET_HTAB_FD */<br>struct kvm_get_htab_fd {<br>    __u64    flags;<br>    __u64    start_index;<br>    __u64    reserved[2];<br>};</p>
<p>/* Values for kvm_get_htab_fd.flags */<br>#define KVM_GET_HTAB_BOLTED_ONLY    ((__u64)0x1)<br>#define KVM_GET_HTAB_WRITE        ((__u64)0x2)</p>
<p>The `start_index’ field gives the index in the HPT of the entry at<br>which to start reading.  It is ignored when writing.</p>
<p>Reads on the fd will initially supply information about all<br>“interesting” HPT entries.  Interesting entries are those with the<br>bolted bit set, if the KVM_GET_HTAB_BOLTED_ONLY bit is set, otherwise<br>all entries.  When the end of the HPT is reached, the read() will<br>return.  If read() is called again on the fd, it will start again from<br>the beginning of the HPT, but will only return HPT entries that have<br>changed since they were last read.</p>
<p>Data read or written is structured as a header (8 bytes) followed by a<br>series of valid HPT entries (16 bytes) each.  The header indicates how<br>many valid HPT entries there are and how many invalid entries follow<br>the valid entries.  The invalid entries are not represented explicitly<br>in the stream.  The header format is:</p>
<p>struct kvm_get_htab_header {<br>    __u32    index;<br>    __u16    n_valid;<br>    __u16    n_invalid;<br>};</p>
<p>Writes to the fd create HPT entries starting at the index given in the<br>header; first <code>n_valid&#39; valid entries with contents from the data written, then </code>n_invalid’ invalid entries, invalidating any previously<br>valid entries found.</p>
<p>4.79 KVM_CREATE_DEVICE</p>
<p>Capability: KVM_CAP_DEVICE_CTRL<br>Type: vm ioctl<br>Parameters: struct kvm_create_device (in/out)<br>Returns: 0 on success, -1 on error<br>Errors:<br>  ENODEV: The device type is unknown or unsupported<br>  EEXIST: Device already created, and this type of device may not<br>          be instantiated multiple times</p>
<p>  Other error conditions may be defined by individual device types or<br>  have their standard meanings.</p>
<p>Creates an emulated device in the kernel.  The file descriptor returned<br>in fd can be used with KVM_SET/GET/HAS_DEVICE_ATTR.</p>
<p>If the KVM_CREATE_DEVICE_TEST flag is set, only test whether the<br>device type is supported (not necessarily whether it can be created<br>in the current vm).</p>
<p>Individual devices should not define flags.  Attributes should be used<br>for specifying any behavior that is not implied by the device type<br>number.</p>
<p>struct kvm_create_device {<br>    __u32    type;    /* in: KVM_DEV_TYPE_xxx <em>/<br>    __u32    fd;    /</em> out: device handle <em>/<br>    __u32    flags;    /</em> in: KVM_CREATE_DEVICE_xxx */<br>};</p>
<p>4.80 KVM_SET_DEVICE_ATTR/KVM_GET_DEVICE_ATTR</p>
<p>Capability: KVM_CAP_DEVICE_CTRL<br>Type: device ioctl<br>Parameters: struct kvm_device_attr<br>Returns: 0 on success, -1 on error<br>Errors:<br>  ENXIO:  The group or attribute is unknown/unsupported for this device<br>  EPERM:  The attribute cannot (currently) be accessed this way<br>          (e.g. read-only attribute, or attribute that only makes<br>          sense when the device is in a different state)</p>
<p>  Other error conditions may be defined by individual device types.</p>
<p>Gets/sets a specified piece of device configuration and/or state.  The<br>semantics are device-specific.  See individual device documentation in<br>the “devices” directory.  As with ONE_REG, the size of the data<br>transferred is defined by the particular attribute.</p>
<p>struct kvm_device_attr {<br>    __u32    flags;        /* no flags currently defined <em>/<br>    __u32    group;        /</em> device-defined <em>/<br>    __u64    attr;        /</em> group-defined <em>/<br>    __u64    addr;        /</em> userspace address of attr data */<br>};</p>
<p>4.81 KVM_HAS_DEVICE_ATTR</p>
<p>Capability: KVM_CAP_DEVICE_CTRL<br>Type: device ioctl<br>Parameters: struct kvm_device_attr<br>Returns: 0 on success, -1 on error<br>Errors:<br>  ENXIO:  The group or attribute is unknown/unsupported for this device</p>
<p>Tests whether a device supports a particular attribute.  A successful<br>return indicates the attribute is implemented.  It does not necessarily<br>indicate that the attribute can be read or written in the device’s<br>current state.  “addr” is ignored.</p>
<p>4.82 KVM_ARM_VCPU_INIT</p>
<p>Capability: basic<br>Architectures: arm<br>Type: vcpu ioctl<br>Parameters: struct struct kvm_vcpu_init (in)<br>Returns: 0 on success; -1 on error<br>Errors:<br> Â EINVAL: Â Â Â the target is unknown, or the combination of features is invalid.<br> Â ENOENT: Â Â Â a features bit specified is unknown.</p>
<p>This tells KVM what type of CPU to present to the guest, and what<br>optional features it should have. Â This will cause a reset of the cpu<br>registers to their initial values. Â If this is not called, KVM_RUN will<br>return ENOEXEC for that vcpu.</p>
<p>Note that because some registers reflect machine topology, all vcpus<br>should be created before this ioctl is invoked.</p>
<p>Possible features:<br>    - KVM_ARM_VCPU_POWER_OFF: Starts the CPU in a power-off state.<br>      Depends on KVM_CAP_ARM_PSCI.</p>
<p>4.83 KVM_GET_REG_LIST</p>
<p>Capability: basic<br>Architectures: arm<br>Type: vcpu ioctl<br>Parameters: struct kvm_reg_list (in/out)<br>Returns: 0 on success; -1 on error<br>Errors:<br> Â E2BIG: Â Â Â Â the reg index list is too big to fit in the array specified by<br> Â Â Â Â Â Â Â Â Â Â Â Â the user (the number required will be written into n).</p>
<p>struct kvm_reg_list {<br>    __u64 n; /* number of registers in reg[] */<br>    __u64 reg[0];<br>};</p>
<p>This ioctl returns the guest registers that are supported for the<br>KVM_GET_ONE_REG/KVM_SET_ONE_REG calls.</p>
<p>4.84 KVM_ARM_SET_DEVICE_ADDR</p>
<p>Capability: KVM_CAP_ARM_SET_DEVICE_ADDR<br>Architectures: arm<br>Type: vm ioctl<br>Parameters: struct kvm_arm_device_address (in)<br>Returns: 0 on success, -1 on error<br>Errors:<br>  ENODEV: The device id is unknown<br>  ENXIO:  Device not supported on current system<br>  EEXIST: Address already set<br>  E2BIG:  Address outside guest physical address space<br>  EBUSY:  Address overlaps with other device range</p>
<p>struct kvm_arm_device_addr {<br>    __u64 id;<br>    __u64 addr;<br>};</p>
<p>Specify a device address in the guest’s physical address space where guests<br>can access emulated or directly exposed devices, which the host kernel needs<br>to know about. The id field is an architecture specific identifier for a<br>specific device.</p>
<p>ARM divides the id field into two parts, a device id and an address type id<br>specific to the individual device.</p>
<p> Â bits:  | 63        …       32 | 31    …    16 | 15    …    0 |<br>  field: |        0x00000000      |     device id   |  addr type id  |</p>
<p>ARM currently only require this when using the in-kernel GIC support for the<br>hardware VGIC features, using KVM_ARM_DEVICE_VGIC_V2 as the device id.  When<br>setting the base address for the guest’s mapping of the VGIC virtual CPU<br>and distributor interface, the ioctl must be called after calling<br>KVM_CREATE_IRQCHIP, but before calling KVM_RUN on any of the VCPUs.  Calling<br>this ioctl twice for any of the base addresses will return -EEXIST.</p>
<p>4.85 KVM_PPC_RTAS_DEFINE_TOKEN</p>
<p>Capability: KVM_CAP_PPC_RTAS<br>Architectures: ppc<br>Type: vm ioctl<br>Parameters: struct kvm_rtas_token_args<br>Returns: 0 on success, -1 on error</p>
<p>Defines a token value for a RTAS (Run Time Abstraction Services)<br>service in order to allow it to be handled in the kernel.  The<br>argument struct gives the name of the service, which must be the name<br>of a service that has a kernel-side implementation.  If the token<br>value is non-zero, it will be associated with that service, and<br>subsequent RTAS calls by the guest specifying that token will be<br>handled by the kernel.  If the token value is 0, then any token<br>associated with the service will be forgotten, and subsequent RTAS<br>calls by the guest for that service will be passed to userspace to be<br>handled.</p>
<p>4.87 KVM_SET_GUEST_DEBUG</p>
<p>Capability: KVM_CAP_SET_GUEST_DEBUG<br>Architectures: x86, s390, ppc<br>Type: vcpu ioctl<br>Parameters: struct kvm_guest_debug (in)<br>Returns: 0 on success; -1 on error</p>
<p>struct kvm_guest_debug {<br>       __u32 control;<br>       __u32 pad;<br>       struct kvm_guest_debug_arch arch;<br>};</p>
<p>Set up the processor specific debug registers and configure vcpu for<br>handling guest debug events. There are two parts to the structure, the<br>first a control bitfield indicates the type of debug events to handle<br>when running. Common control bits are:</p>
<ul>
<li>KVM_GUESTDBG_ENABLE:        guest debugging is enabled</li>
<li>KVM_GUESTDBG_SINGLESTEP:    the next run should single-step</li>
</ul>
<p>The top 16 bits of the control field are architecture specific control<br>flags which can include the following:</p>
<ul>
<li>KVM_GUESTDBG_USE_SW_BP:     using software breakpoints [x86]</li>
<li>KVM_GUESTDBG_USE_HW_BP:     using hardware breakpoints [x86, s390]</li>
<li>KVM_GUESTDBG_INJECT_DB:     inject DB type exception [x86]</li>
<li>KVM_GUESTDBG_INJECT_BP:     inject BP type exception [x86]</li>
<li>KVM_GUESTDBG_EXIT_PENDING:  trigger an immediate guest exit [s390]</li>
</ul>
<p>For example KVM_GUESTDBG_USE_SW_BP indicates that software breakpoints<br>are enabled in memory so we need to ensure breakpoint exceptions are<br>correctly trapped and the KVM run loop exits at the breakpoint and not<br>running off into the normal guest vector. For KVM_GUESTDBG_USE_HW_BP<br>we need to ensure the guest vCPUs architecture specific registers are<br>updated to the correct (supplied) values.</p>
<p>The second part of the structure is architecture specific and<br>typically contains a set of debug registers.</p>
<p>When debug events exit the main run loop with the reason<br>KVM_EXIT_DEBUG with the kvm_debug_exit_arch part of the kvm_run<br>structure containing architecture specific debug information.</p>
<p>4.88 KVM_GET_EMULATED_CPUID</p>
<p>Capability: KVM_CAP_EXT_EMUL_CPUID<br>Architectures: x86<br>Type: system ioctl<br>Parameters: struct kvm_cpuid2 (in/out)<br>Returns: 0 on success, -1 on error</p>
<p>struct kvm_cpuid2 {<br>    __u32 nent;<br>    __u32 flags;<br>    struct kvm_cpuid_entry2 entries[0];<br>};</p>
<p>The member ‘flags’ is used for passing flags from userspace.</p>
<p>#define KVM_CPUID_FLAG_SIGNIFCANT_INDEX        BIT(0)<br>#define KVM_CPUID_FLAG_STATEFUL_FUNC        BIT(1)<br>#define KVM_CPUID_FLAG_STATE_READ_NEXT        BIT(2)</p>
<p>struct kvm_cpuid_entry2 {<br>    __u32 function;<br>    __u32 index;<br>    __u32 flags;<br>    __u32 eax;<br>    __u32 ebx;<br>    __u32 ecx;<br>    __u32 edx;<br>    __u32 padding[3];<br>};</p>
<p>This ioctl returns x86 cpuid features which are emulated by<br>kvm.Userspace can use the information returned by this ioctl to query<br>which features are emulated by kvm instead of being present natively.</p>
<p>Userspace invokes KVM_GET_EMULATED_CPUID by passing a kvm_cpuid2<br>structure with the ‘nent’ field indicating the number of entries in<br>the variable-size array ‘entries’. If the number of entries is too low<br>to describe the cpu capabilities, an error (E2BIG) is returned. If the<br>number is too high, the ‘nent’ field is adjusted and an error (ENOMEM)<br>is returned. If the number is just right, the ‘nent’ field is adjusted<br>to the number of valid entries in the ‘entries’ array, which is then<br>filled.</p>
<p>The entries returned are the set CPUID bits of the respective features<br>which kvm emulates, as returned by the CPUID instruction, with unknown<br>or unsupported feature bits cleared.</p>
<p>Features like x2apic, for example, may not be present in the host cpu<br>but are exposed by kvm in KVM_GET_SUPPORTED_CPUID because they can be<br>emulated efficiently and thus not included here.</p>
<p>The fields in each entry are defined as follows:</p>
<p>  function: the eax value used to obtain the entry<br>  index: the ecx value used to obtain the entry (for entries that are<br>         affected by ecx)<br>  flags: an OR of zero or more of the following:<br>        KVM_CPUID_FLAG_SIGNIFCANT_INDEX:<br>           if the index field is valid<br>        KVM_CPUID_FLAG_STATEFUL_FUNC:<br>           if cpuid for this function returns different values for successive<br>           invocations; there will be several entries with the same function,<br>           all with this flag set<br>        KVM_CPUID_FLAG_STATE_READ_NEXT:<br>           for KVM_CPUID_FLAG_STATEFUL_FUNC entries, set if this entry is<br>           the first entry to be read by a cpu<br>   eax, ebx, ecx, edx: the values returned by the cpuid instruction for<br>         this function/index combination</p>
<p>4.90 KVM_SMI</p>
<p>Capability: KVM_CAP_X86_SMM<br>Architectures: x86<br>Type: vcpu ioctl<br>Parameters: none<br>Returns: 0 on success, -1 on error</p>
<p>Queues an SMI on the thread’s vcpu.</p>
<p>4.97 KVM_CAP_PPC_MULTITCE</p>
<p>Capability: KVM_CAP_PPC_MULTITCE<br>Architectures: ppc<br>Type: vm</p>
<p>This capability means the kernel is capable of handling hypercalls<br>H_PUT_TCE_INDIRECT and H_STUFF_TCE without passing those into the user<br>space. This significantly accelerates DMA operations for PPC KVM guests.<br>User space should expect that its handlers for these hypercalls<br>are not going to be called if user space previously registered LIOBN<br>in KVM (via KVM_CREATE_SPAPR_TCE or similar calls).</p>
<p>In order to enable H_PUT_TCE_INDIRECT and H_STUFF_TCE use in the guest,<br>user space might have to advertise it for the guest. For example,<br>IBM pSeries (sPAPR) guest starts using them if “hcall-multi-tce” is<br>present in the “ibm,hypertas-functions” device-tree property.</p>
<p>The hypercalls mentioned above may or may not be processed successfully<br>in the kernel based fast path. If they can not be handled by the kernel,<br>they will get passed on to user space. So user space still has to have<br>an implementation for these despite the in kernel acceleration.</p>
<p>This capability is always enabled.</p>
<p>4.102 KVM_PPC_RESIZE_HPT_PREPARE</p>
<p>Capability: KVM_CAP_SPAPR_RESIZE_HPT<br>Architectures: powerpc<br>Type: vm ioctl<br>Parameters: struct kvm_ppc_resize_hpt (in)<br>Returns: 0 on successful completion,<br>     &gt;0 if a new HPT is being prepared, the value is an estimated<br>             number of milliseconds until preparation is complete<br>         -EFAULT if struct kvm_reinject_control cannot be read,<br>     -EINVAL if the supplied shift or flags are invalid<br>     -ENOMEM if unable to allocate the new HPT<br>     -ENOSPC if there was a hash collision when moving existing<br>                  HPT entries to the new HPT<br>     -EIO on other error conditions</p>
<p>Used to implement the PAPR extension for runtime resizing of a guest’s<br>Hashed Page Table (HPT).  Specifically this starts, stops or monitors<br>the preparation of a new potential HPT for the guest, essentially<br>implementing the H_RESIZE_HPT_PREPARE hypercall.</p>
<p>If called with shift &gt; 0 when there is no pending HPT for the guest,<br>this begins preparation of a new pending HPT of size 2^(shift) bytes.<br>It then returns a positive integer with the estimated number of<br>milliseconds until preparation is complete.</p>
<p>If called when there is a pending HPT whose size does not match that<br>requested in the parameters, discards the existing pending HPT and<br>creates a new one as above.</p>
<p>If called when there is a pending HPT of the size requested, will:</p>
<ul>
<li>If preparation of the pending HPT is already complete, return 0</li>
<li>If preparation of the pending HPT has failed, return an error<br>code, then discard the pending HPT.</li>
<li>If preparation of the pending HPT is still in progress, return an<br>estimated number of milliseconds until preparation is complete.</li>
</ul>
<p>If called with shift == 0, discards any currently pending HPT and<br>returns 0 (i.e. cancels any in-progress preparation).</p>
<p>flags is reserved for future expansion, currently setting any bits in<br>flags will result in an -EINVAL.</p>
<p>Normally this will be called repeatedly with the same parameters until<br>it returns &lt;= 0.  The first call will initiate preparation, subsequent<br>ones will monitor preparation until it completes or fails.</p>
<p>struct kvm_ppc_resize_hpt {<br>    __u64 flags;<br>    __u32 shift;<br>    __u32 pad;<br>};</p>
<p>4.103 KVM_PPC_RESIZE_HPT_COMMIT</p>
<p>Capability: KVM_CAP_SPAPR_RESIZE_HPT<br>Architectures: powerpc<br>Type: vm ioctl<br>Parameters: struct kvm_ppc_resize_hpt (in)<br>Returns: 0 on successful completion,<br>         -EFAULT if struct kvm_reinject_control cannot be read,<br>     -EINVAL if the supplied shift or flags are invalid<br>     -ENXIO is there is no pending HPT, or the pending HPT doesn’t<br>                 have the requested size<br>     -EBUSY if the pending HPT is not fully prepared<br>     -ENOSPC if there was a hash collision when moving existing<br>                  HPT entries to the new HPT<br>     -EIO on other error conditions</p>
<p>Used to implement the PAPR extension for runtime resizing of a guest’s<br>Hashed Page Table (HPT).  Specifically this requests that the guest be<br>transferred to working with the new HPT, essentially implementing the<br>H_RESIZE_HPT_COMMIT hypercall.</p>
<p>This should only be called after KVM_PPC_RESIZE_HPT_PREPARE has<br>returned 0 with the same parameters.  In other cases<br>KVM_PPC_RESIZE_HPT_COMMIT will return an error (usually -ENXIO or<br>-EBUSY, though others may be possible if the preparation was started,<br>but failed).</p>
<p>This will have undefined effects on the guest if it has not already<br>placed itself in a quiescent state where no vcpu will make MMU enabled<br>memory accesses.</p>
<p>On succsful completion, the pending HPT will become the guest’s active<br>HPT and the previous HPT will be discarded.</p>
<p>On failure, the guest will still be operating on its previous HPT.</p>
<p>struct kvm_ppc_resize_hpt {<br>    __u64 flags;<br>    __u32 shift;<br>    __u32 pad;<br>};</p>
<p>4.108 KVM_PPC_GET_CPU_CHAR</p>
<p>Capability: KVM_CAP_PPC_GET_CPU_CHAR<br>Architectures: powerpc<br>Type: vm ioctl<br>Parameters: struct kvm_ppc_cpu_char (out)<br>Returns: 0 on successful completion<br>     -EFAULT if struct kvm_ppc_cpu_char cannot be written</p>
<p>This ioctl gives userspace information about certain characteristics<br>of the CPU relating to speculative execution of instructions and<br>possible information leakage resulting from speculative execution (see<br>CVE-2017-5715, CVE-2017-5753 and CVE-2017-5754).  The information is<br>returned in struct kvm_ppc_cpu_char, which looks like this:</p>
<p>struct kvm_ppc_cpu_char {<br>    __u64    character;        /* characteristics of the CPU <em>/<br>    __u64    behaviour;        /</em> recommended software behaviour <em>/<br>    __u64    character_mask;        /</em> valid bits in character <em>/<br>    __u64    behaviour_mask;        /</em> valid bits in behaviour */<br>};</p>
<p>For extensibility, the character_mask and behaviour_mask fields<br>indicate which bits of character and behaviour have been filled in by<br>the kernel.  If the set of defined bits is extended in future then<br>userspace will be able to tell whether it is running on a kernel that<br>knows about the new bits.</p>
<p>The character field describes attributes of the CPU which can help<br>with preventing inadvertent information disclosure - specifically,<br>whether there is an instruction to flash-invalidate the L1 data cache<br>(ori 30,30,0 or mtspr SPRN_TRIG2,rN), whether the L1 data cache is set<br>to a mode where entries can only be used by the thread that created<br>them, whether the bcctr[l] instruction prevents speculation, and<br>whether a speculation barrier instruction (ori 31,31,0) is provided.</p>
<p>The behaviour field describes actions that software should take to<br>prevent inadvertent information disclosure, and thus describes which<br>vulnerabilities the hardware is subject to; specifically whether the<br>L1 data cache should be flushed when returning to user mode from the<br>kernel, and whether a speculation barrier should be placed between an<br>array bounds check and the array access.</p>
<p>These fields use the same bit definitions as the new<br>H_GET_CPU_CHARACTERISTICS hypercall.</p>
<ol start="5">
<li>The kvm_run structure</li>
</ol>
<hr>
<p>Application code obtains a pointer to the kvm_run structure by<br>mmap()ing a vcpu fd.  From that point, application code can control<br>execution by changing fields in kvm_run prior to calling the KVM_RUN<br>ioctl, and obtain information about the reason KVM_RUN returned by<br>looking up structure members.</p>
<p>struct kvm_run {<br>    /* in */<br>    __u8 request_interrupt_window;</p>
<p>Request that KVM_RUN return when it becomes possible to inject external<br>interrupts into the guest.  Useful in conjunction with KVM_INTERRUPT.</p>
<pre><code>__u8 padding1[7];

/* out */
__u32 exit_reason;
</code></pre>
<p>When KVM_RUN has returned successfully (return value 0), this informs<br>application code why KVM_RUN has returned.  Allowable values for this<br>field are detailed below.</p>
<pre><code>__u8 ready_for_interrupt_injection;
</code></pre>
<p>If request_interrupt_window has been specified, this field indicates<br>an interrupt can be injected now with KVM_INTERRUPT.</p>
<pre><code>__u8 if_flag;
</code></pre>
<p>The value of the current interrupt flag.  Only valid if in-kernel<br>local APIC is not used.</p>
<pre><code>__u16 flags;
</code></pre>
<p>More architecture-specific flags detailing state of the VCPU that may<br>affect the device’s behavior.  The only currently defined flag is<br>KVM_RUN_X86_SMM, which is valid on x86 machines and is set if the<br>VCPU is in system management mode.</p>
<pre><code>/* in (pre_kvm_run), out (post_kvm_run) */
__u64 cr8;
</code></pre>
<p>The value of the cr8 register.  Only valid if in-kernel local APIC is<br>not used.  Both input and output.</p>
<pre><code>__u64 apic_base;
</code></pre>
<p>The value of the APIC BASE msr.  Only valid if in-kernel local<br>APIC is not used.  Both input and output.</p>
<pre><code>union &#123;
    /* KVM_EXIT_UNKNOWN */
    struct &#123;
        __u64 hardware_exit_reason;
    &#125; hw;
</code></pre>
<p>If exit_reason is KVM_EXIT_UNKNOWN, the vcpu has exited due to unknown<br>reasons.  Further architecture-specific information is available in<br>hardware_exit_reason.</p>
<pre><code>    /* KVM_EXIT_FAIL_ENTRY */
    struct &#123;
        __u64 hardware_entry_failure_reason;
    &#125; fail_entry;
</code></pre>
<p>If exit_reason is KVM_EXIT_FAIL_ENTRY, the vcpu could not be run due<br>to unknown reasons.  Further architecture-specific information is<br>available in hardware_entry_failure_reason.</p>
<pre><code>    /* KVM_EXIT_EXCEPTION */
    struct &#123;
        __u32 exception;
        __u32 error_code;
    &#125; ex;
</code></pre>
<p>Unused.</p>
<pre><code>    /* KVM_EXIT_IO */
    struct &#123;
</code></pre>
<p>#define KVM_EXIT_IO_IN  0<br>#define KVM_EXIT_IO_OUT 1<br>            __u8 direction;<br>            __u8 size; /* bytes <em>/<br>            __u16 port;<br>            __u32 count;<br>            __u64 data_offset; /</em> relative to kvm_run start */<br>        } io;</p>
<p>If exit_reason is KVM_EXIT_IO, then the vcpu has<br>executed a port I/O instruction which could not be satisfied by kvm.<br>data_offset describes where the data is located (KVM_EXIT_IO_OUT) or<br>where kvm expects application code to place the data for the next<br>KVM_RUN invocation (KVM_EXIT_IO_IN).  Data format is a packed array.</p>
<pre><code>    struct &#123;
        struct kvm_debug_exit_arch arch;
    &#125; debug;
</code></pre>
<p>Unused.</p>
<pre><code>    /* KVM_EXIT_MMIO */
    struct &#123;
        __u64 phys_addr;
        __u8  data[8];
        __u32 len;
        __u8  is_write;
    &#125; mmio;
</code></pre>
<p>If exit_reason is KVM_EXIT_MMIO, then the vcpu has<br>executed a memory-mapped I/O instruction which could not be satisfied<br>by kvm.  The ‘data’ member contains the written data if ‘is_write’ is<br>true, and should be filled by application code otherwise.</p>
<p>The ‘data’ member contains, in its first ‘len’ bytes, the value as it would<br>appear if the VCPU performed a load or store of the appropriate width directly<br>to the byte array.</p>
<p>NOTE: For KVM_EXIT_IO, KVM_EXIT_MMIO, KVM_EXIT_OSI, KVM_EXIT_DCR,<br>      KVM_EXIT_PAPR and KVM_EXIT_EPR the corresponding<br>operations are complete (and guest state is consistent) only after userspace<br>has re-entered the kernel with KVM_RUN.  The kernel side will first finish<br>incomplete operations and then check for pending signals.  Userspace<br>can re-enter the guest with an unmasked signal pending to complete<br>pending operations.</p>
<pre><code>    /* KVM_EXIT_HYPERCALL */
    struct &#123;
        __u64 nr;
        __u64 args[6];
        __u64 ret;
        __u32 longmode;
        __u32 pad;
    &#125; hypercall;
</code></pre>
<p>Unused.  This was once used for ‘hypercall to userspace’.  To implement<br>such functionality, use KVM_EXIT_IO (x86) or KVM_EXIT_MMIO (all except s390).<br>Note KVM_EXIT_IO is significantly faster than KVM_EXIT_MMIO.</p>
<pre><code>    /* KVM_EXIT_TPR_ACCESS */
    struct &#123;
        __u64 rip;
        __u32 is_write;
        __u32 pad;
    &#125; tpr_access;
</code></pre>
<p>To be documented (KVM_TPR_ACCESS_REPORTING).</p>
<pre><code>    /* KVM_EXIT_S390_SIEIC */
    struct &#123;
        __u8 icptcode;
        __u64 mask; /* psw upper half */
        __u64 addr; /* psw lower half */
        __u16 ipa;
        __u32 ipb;
    &#125; s390_sieic;
</code></pre>
<p>s390 specific.</p>
<pre><code>    /* KVM_EXIT_S390_RESET */
</code></pre>
<p>#define KVM_S390_RESET_POR       1<br>#define KVM_S390_RESET_CLEAR     2<br>#define KVM_S390_RESET_SUBSYSTEM 4<br>#define KVM_S390_RESET_CPU_INIT  8<br>#define KVM_S390_RESET_IPL       16<br>        __u64 s390_reset_flags;</p>
<p>s390 specific.</p>
<pre><code>    /* KVM_EXIT_S390_UCONTROL */
    struct &#123;
        __u64 trans_exc_code;
        __u32 pgm_code;
    &#125; s390_ucontrol;
</code></pre>
<p>s390 specific. A page fault has occurred for a user controlled virtual<br>machine (KVM_VM_S390_UNCONTROL) on it’s host page table that cannot be<br>resolved by the kernel.<br>The program code and the translation exception code that were placed<br>in the cpu’s lowcore are presented here as defined by the z Architecture<br>Principles of Operation Book in the Chapter for Dynamic Address Translation<br>(DAT)</p>
<pre><code>    /* KVM_EXIT_DCR */
    struct &#123;
        __u32 dcrn;
        __u32 data;
        __u8  is_write;
    &#125; dcr;
</code></pre>
<p>powerpc specific.</p>
<pre><code>    /* KVM_EXIT_OSI */
    struct &#123;
        __u64 gprs[32];
    &#125; osi;
</code></pre>
<p>MOL uses a special hypercall interface it calls ‘OSI’. To enable it, we catch<br>hypercalls and exit with this exit struct that contains all the guest gprs.</p>
<p>If exit_reason is KVM_EXIT_OSI, then the vcpu has triggered such a hypercall.<br>Userspace can now handle the hypercall and when it’s done modify the gprs as<br>necessary. Upon guest entry all guest GPRs will then be replaced by the values<br>in this struct.</p>
<pre><code>    /* KVM_EXIT_PAPR_HCALL */
    struct &#123;
        __u64 nr;
        __u64 ret;
        __u64 args[9];
    &#125; papr_hcall;
</code></pre>
<p>This is used on 64-bit PowerPC when emulating a pSeries partition,<br>e.g. with the ‘pseries’ machine type in qemu.  It occurs when the<br>guest does a hypercall using the ‘sc 1’ instruction.  The ‘nr’ field<br>contains the hypercall number (from the guest R3), and ‘args’ contains<br>the arguments (from the guest R4 - R12).  Userspace should put the<br>return code in ‘ret’ and any extra returned values in args[].<br>The possible hypercalls are defined in the Power Architecture Platform<br>Requirements (PAPR) document available from <a target="_blank" rel="noopener" href="http://www.power.org/">www.power.org</a> (free<br>developer registration required to access it).</p>
<pre><code>    /* KVM_EXIT_S390_TSCH */
    struct &#123;
        __u16 subchannel_id;
        __u16 subchannel_nr;
        __u32 io_int_parm;
        __u32 io_int_word;
        __u32 ipb;
        __u8 dequeued;
    &#125; s390_tsch;
</code></pre>
<p>s390 specific. This exit occurs when KVM_CAP_S390_CSS_SUPPORT has been enabled<br>and TEST SUBCHANNEL was intercepted. If dequeued is set, a pending I/O<br>interrupt for the target subchannel has been dequeued and subchannel_id,<br>subchannel_nr, io_int_parm and io_int_word contain the parameters for that<br>interrupt. ipb is needed for instruction parameter decoding.</p>
<pre><code>    /* KVM_EXIT_EPR */
    struct &#123;
        __u32 epr;
    &#125; epr;
</code></pre>
<p>On FSL BookE PowerPC chips, the interrupt controller has a fast patch<br>interrupt acknowledge path to the core. When the core successfully<br>delivers an interrupt, it automatically populates the EPR register with<br>the interrupt vector number and acknowledges the interrupt inside<br>the interrupt controller.</p>
<p>In case the interrupt controller lives in user space, we need to do<br>the interrupt acknowledge cycle through it to fetch the next to be<br>delivered interrupt vector using this exit.</p>
<p>It gets triggered whenever both KVM_CAP_PPC_EPR are enabled and an<br>external interrupt has just been delivered into the guest. User space<br>should put the acknowledged interrupt vector into the ‘epr’ field.</p>
<pre><code>    /* KVM_EXIT_IOAPIC_EOI */
    struct &#123;
        __u8 vector;
    &#125; eoi;
</code></pre>
<p>Indicates that the VCPU’s in-kernel local APIC received an EOI for a<br>level-triggered IOAPIC interrupt.  This exit only triggers when the<br>IOAPIC is implemented in userspace (i.e. KVM_CAP_SPLIT_IRQCHIP is enabled);<br>the userspace IOAPIC should process the EOI and retrigger the interrupt if<br>it is still asserted.  Vector is the LAPIC interrupt vector for which the<br>EOI was received.</p>
<pre><code>           /* KVM_EXIT_SYSTEM_EVENT */
           struct &#123;
</code></pre>
<p>#define KVM_SYSTEM_EVENT_SHUTDOWN       1<br>#define KVM_SYSTEM_EVENT_RESET          2<br>#define KVM_SYSTEM_EVENT_CRASH          3<br>                       __u32 type;<br>                       __u64 flags;<br>               } system_event;</p>
<p>If exit_reason is KVM_EXIT_SYSTEM_EVENT then the vcpu has triggered<br>a system-level event using some architecture specific mechanism (hypercall<br>or some special instruction). In case of ARM/ARM64, this is triggered using<br>HVC instruction based PSCI call from the vcpu. The ‘type’ field describes<br>the system-level event type. The ‘flags’ field describes architecture<br>specific flags for the system-level event.</p>
<pre><code>    /* Fix the size of the union. */
    char padding[256];
&#125;;

/*
 * shared registers between kvm and userspace.
 * kvm_valid_regs specifies the register classes set by the host
 * kvm_dirty_regs specified the register classes dirtied by userspace
 * struct kvm_sync_regs is architecture specific, as well as the
 * bits for kvm_valid_regs and kvm_dirty_regs
 */
__u64 kvm_valid_regs;
__u64 kvm_dirty_regs;
union &#123;
    struct kvm_sync_regs regs;
    char padding[1024];
&#125; s;
</code></pre>
<p>If KVM_CAP_SYNC_REGS is defined, these fields allow userspace to access<br>certain guest registers without having to call SET/GET_*REGS. Thus we can<br>avoid some system call overhead if userspace has to handle the exit.<br>Userspace can query the validity of the structure by checking<br>kvm_valid_regs for specific bits. These bits are architecture specific<br>and usually define the validity of a groups of registers. (e.g. one bit<br> for general purpose registers)</p>
<p>Please note that the kernel is allowed to use the kvm_run structure as the<br>primary storage for certain register types. Therefore, the kernel may use the<br>values in kvm_run even if the corresponding bit in kvm_dirty_regs is not set.</p>
<p>};</p>
<ol start="6">
<li>Capabilities that can be enabled on vCPUs</li>
</ol>
<hr>
<p>There are certain capabilities that change the behavior of the virtual CPU when<br>enabled. To enable them, please see section 4.37. Below you can find a list of<br>capabilities and what their effect on the vCPU is when enabling them.</p>
<p>The following information is provided along with the description:</p>
<p>  Architectures: which instruction set architectures provide this ioctl.<br>      x86 includes both i386 and x86_64.</p>
<p>  Parameters: what parameters are accepted by the capability.</p>
<p>  Returns: the return value.  General error numbers (EBADF, ENOMEM, EINVAL)<br>      are not detailed, but errors with specific meanings are.</p>
<p>6.1 KVM_CAP_PPC_OSI</p>
<p>Architectures: ppc<br>Parameters: none<br>Returns: 0 on success; -1 on error</p>
<p>This capability enables interception of OSI hypercalls that otherwise would<br>be treated as normal system calls to be injected into the guest. OSI hypercalls<br>were invented by Mac-on-Linux to have a standardized communication mechanism<br>between the guest and the host.</p>
<p>When this capability is enabled, KVM_EXIT_OSI can occur.</p>
<p>6.2 KVM_CAP_PPC_PAPR</p>
<p>Architectures: ppc<br>Parameters: none<br>Returns: 0 on success; -1 on error</p>
<p>This capability enables interception of PAPR hypercalls. PAPR hypercalls are<br>done using the hypercall instruction “sc 1”.</p>
<p>It also sets the guest privilege level to “supervisor” mode. Usually the guest<br>runs in “hypervisor” privilege mode with a few missing features.</p>
<p>In addition to the above, it changes the semantics of SDR1. In this mode, the<br>HTAB address part of SDR1 contains an HVA instead of a GPA, as PAPR keeps the<br>HTAB invisible to the guest.</p>
<p>When this capability is enabled, KVM_EXIT_PAPR_HCALL can occur.</p>
<p>6.3 KVM_CAP_SW_TLB</p>
<p>Architectures: ppc<br>Parameters: args[0] is the address of a struct kvm_config_tlb<br>Returns: 0 on success; -1 on error</p>
<p>struct kvm_config_tlb {<br>    __u64 params;<br>    __u64 array;<br>    __u32 mmu_type;<br>    __u32 array_len;<br>};</p>
<p>Configures the virtual CPU’s TLB array, establishing a shared memory area<br>between userspace and KVM.  The “params” and “array” fields are userspace<br>addresses of mmu-type-specific data structures.  The “array_len” field is an<br>safety mechanism, and should be set to the size in bytes of the memory that<br>userspace has reserved for the array.  It must be at least the size dictated<br>by “mmu_type” and “params”.</p>
<p>While KVM_RUN is active, the shared region is under control of KVM.  Its<br>contents are undefined, and any modification by userspace results in<br>boundedly undefined behavior.</p>
<p>On return from KVM_RUN, the shared region will reflect the current state of<br>the guest’s TLB.  If userspace makes any changes, it must call KVM_DIRTY_TLB<br>to tell KVM which entries have been changed, prior to calling KVM_RUN again<br>on this vcpu.</p>
<p>For mmu types KVM_MMU_FSL_BOOKE_NOHV and KVM_MMU_FSL_BOOKE_HV:</p>
<ul>
<li>The “params” field is of type “struct kvm_book3e_206_tlb_params”.</li>
<li>The “array” field points to an array of type “struct<br>kvm_book3e_206_tlb_entry”.</li>
<li>The array consists of all entries in the first TLB, followed by all<br>entries in the second TLB.</li>
<li>Within a TLB, entries are ordered first by increasing set number.  Within a<br>set, entries are ordered by way (increasing ESEL).</li>
<li>The hash for determining set number in TLB0 is: (MAS2 &gt;&gt; 12) &amp; (num_sets - 1)<br>where “num_sets” is the tlb_sizes[] value divided by the tlb_ways[] value.</li>
<li>The tsize field of mas1 shall be set to 4K on TLB0, even though the<br>hardware ignores this value for TLB0.</li>
</ul>
<p>6.4 KVM_CAP_S390_CSS_SUPPORT</p>
<p>Architectures: s390<br>Parameters: none<br>Returns: 0 on success; -1 on error</p>
<p>This capability enables support for handling of channel I/O instructions.</p>
<p>TEST PENDING INTERRUPTION and the interrupt portion of TEST SUBCHANNEL are<br>handled in-kernel, while the other I/O instructions are passed to userspace.</p>
<p>When this capability is enabled, KVM_EXIT_S390_TSCH will occur on TEST<br>SUBCHANNEL intercepts.</p>
<p>6.5 KVM_CAP_PPC_EPR</p>
<p>Architectures: ppc<br>Parameters: args[0] defines whether the proxy facility is active<br>Returns: 0 on success; -1 on error</p>
<p>This capability enables or disables the delivery of interrupts through the<br>external proxy facility.</p>
<p>When enabled (args[0] != 0), every time the guest gets an external interrupt<br>delivered, it automatically exits into user space with a KVM_EXIT_EPR exit<br>to receive the topmost interrupt vector.</p>
<p>When disabled (args[0] == 0), behavior is as if this facility is unsupported.</p>
<p>When this capability is enabled, KVM_EXIT_EPR can occur.</p>
<p>6.6 KVM_CAP_IRQ_MPIC</p>
<p>Architectures: ppc<br>Parameters: args[0] is the MPIC device fd<br>            args[1] is the MPIC CPU number for this vcpu</p>
<p>This capability connects the vcpu to an in-kernel MPIC device.</p>
<p>6.7 KVM_CAP_IRQ_XICS</p>
<p>Architectures: ppc<br>Parameters: args[0] is the XICS device fd<br>            args[1] is the XICS CPU number (server ID) for this vcpu</p>
<p>This capability connects the vcpu to an in-kernel XICS device.</p>
<ol start="7">
<li>Capabilities that can be enabled on VMs</li>
</ol>
<hr>
<p>There are certain capabilities that change the behavior of the virtual<br>machine when enabled. To enable them, please see section 4.37. Below<br>you can find a list of capabilities and what their effect on the VM<br>is when enabling them.</p>
<p>The following information is provided along with the description:</p>
<p>  Architectures: which instruction set architectures provide this ioctl.<br>      x86 includes both i386 and x86_64.</p>
<p>  Parameters: what parameters are accepted by the capability.</p>
<p>  Returns: the return value.  General error numbers (EBADF, ENOMEM, EINVAL)<br>      are not detailed, but errors with specific meanings are.</p>
<p>7.1 KVM_CAP_PPC_ENABLE_HCALL</p>
<p>Architectures: ppc<br>Parameters: args[0] is the sPAPR hcall number<br>        args[1] is 0 to disable, 1 to enable in-kernel handling</p>
<p>This capability controls whether individual sPAPR hypercalls (hcalls)<br>get handled by the kernel or not.  Enabling or disabling in-kernel<br>handling of an hcall is effective across the VM.  On creation, an<br>initial set of hcalls are enabled for in-kernel handling, which<br>consists of those hcalls for which in-kernel handlers were implemented<br>before this capability was implemented.  If disabled, the kernel will<br>not to attempt to handle the hcall, but will always exit to userspace<br>to handle it.  Note that it may not make sense to enable some and<br>disable others of a group of related hcalls, but KVM does not prevent<br>userspace from doing that.</p>
<p>If the hcall number specified is not one that has an in-kernel<br>implementation, the KVM_ENABLE_CAP ioctl will fail with an EINVAL<br>error.</p>
<p>7.5 KVM_CAP_SPLIT_IRQCHIP</p>
<p>Architectures: x86<br>Parameters: args[0] - number of routes reserved for userspace IOAPICs<br>Returns: 0 on success, -1 on error</p>
<p>Create a local apic for each processor in the kernel. This can be used<br>instead of KVM_CREATE_IRQCHIP if the userspace VMM wishes to emulate the<br>IOAPIC and PIC (and also the PIT, even though this has to be enabled<br>separately).</p>
<p>This capability also enables in kernel routing of interrupt requests;<br>when KVM_CAP_SPLIT_IRQCHIP only routes of KVM_IRQ_ROUTING_MSI type are<br>used in the IRQ routing table.  The first args[0] MSI routes are reserved<br>for the IOAPIC pins.  Whenever the LAPIC receives an EOI for these routes,<br>a KVM_EXIT_IOAPIC_EOI vmexit will be reported to userspace.</p>
<p>Fails if VCPU has already been created, or if the irqchip is already in the<br>kernel (i.e. KVM_CREATE_IRQCHIP has already been called).</p>
<p>7.7 KVM_CAP_X2APIC_API</p>
<p>Architectures: x86<br>Parameters: args[0] - features that should be enabled<br>Returns: 0 on success, -EINVAL when args[0] contains invalid features</p>
<p>Valid feature flags in args[0] are</p>
<p>#define KVM_X2APIC_API_USE_32BIT_IDS            (1ULL &lt;&lt; 0)<br>#define KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK  (1ULL &lt;&lt; 1)</p>
<p>Enabling KVM_X2APIC_API_USE_32BIT_IDS changes the behavior of<br>KVM_SET_GSI_ROUTING, KVM_SIGNAL_MSI, KVM_SET_LAPIC, and KVM_GET_LAPIC,<br>allowing the use of 32-bit APIC IDs.  See KVM_CAP_X2APIC_API in their<br>respective sections.</p>
<p>KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK must be enabled for x2APIC to work<br>in logical mode or with more than 255 VCPUs.  Otherwise, KVM treats 0xff<br>as a broadcast even in x2APIC mode in order to support physical x2APIC<br>without interrupt remapping.  This is undesirable in logical mode,<br>where 0xff represents CPUs 0-7 in cluster 0.</p>
<ol start="8">
<li>Other capabilities.</li>
</ol>
<hr>
<p>This section lists capabilities that give information about other<br>features of the KVM implementation.</p>
<p>8.1 KVM_CAP_PPC_HWRNG</p>
<p>Architectures: ppc</p>
<p>This capability, if KVM_CHECK_EXTENSION indicates that it is<br>available, means that that the kernel has an implementation of the<br>H_RANDOM hypercall backed by a hardware random-number generator.<br>If present, the kernel H_RANDOM handler can be enabled for guest use<br>with the KVM_CAP_PPC_ENABLE_HCALL capability.</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_api/" title="Kernel-3.10.0-957.el7_api" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_api/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_arcnet-hardware/" title="Kernel-3.10.0-957.el7_arcnet-hardware"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_proc/" title="Kernel-3.10.0-957.el7_proc"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>