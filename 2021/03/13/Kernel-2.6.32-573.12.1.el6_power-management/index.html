<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-2.6.32-573.12.1.el6_power-management | oosTech.com</title>
  <meta name="description" content="Power Management for USB       Alan Stern &lt;stern@rowland.harvard.edu&gt;              October 5, 2007    What is Power Management? -------------------------  Power Management (PM) is the pr">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-2.6.32-573.12.1.el6_power-management">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_power-management/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="Power Management for USB       Alan Stern &lt;stern@rowland.harvard.edu&gt;              October 5, 2007    What is Power Management? -------------------------  Power Management (PM) is the pr">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_power-management/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-2.6.32-573.12.1.el6_power-management" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-2.6.32-573.12.1.el6_power-management
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_power-management/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_power-management/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_power-management/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <pre><code>        Power Management for USB

     Alan Stern &lt;stern@rowland.harvard.edu&gt;

            October 5, 2007



What is Power Management?
-------------------------
</code></pre>
<p>Power Management (PM) is the practice of saving energy by suspending<br>parts of a computer system when they aren’t being used.  While a<br>component is “suspended” it is in a nonfunctional low-power state; it<br>might even be turned off completely.  A suspended component can be<br>“resumed” (returned to a functional full-power state) when the kernel<br>needs to use it.  (There also are forms of PM in which components are<br>placed in a less functional but still usable state instead of being<br>suspended; an example would be reducing the CPU’s clock rate.  This<br>document will not discuss those other forms.)</p>
<p>When the parts being suspended include the CPU and most of the rest of<br>the system, we speak of it as a “system suspend”.  When a particular<br>device is turned off while the system as a whole remains running, we<br>call it a “dynamic suspend” (also known as a “runtime suspend” or<br>“selective suspend”).  This document concentrates mostly on how<br>dynamic PM is implemented in the USB subsystem, although system PM is<br>covered to some extent (see Documentation/power/*.txt for more<br>information about system PM).</p>
<p>Note: Dynamic PM support for USB is present only if the kernel was<br>built with CONFIG_USB_SUSPEND enabled.  System PM support is present<br>only if the kernel was built with CONFIG_SUSPEND or CONFIG_HIBERNATION<br>enabled.</p>
<pre><code>What is Remote Wakeup?
----------------------
</code></pre>
<p>When a device has been suspended, it generally doesn’t resume until<br>the computer tells it to.  Likewise, if the entire computer has been<br>suspended, it generally doesn’t resume until the user tells it to, say<br>by pressing a power button or opening the cover.</p>
<p>However some devices have the capability of resuming by themselves, or<br>asking the kernel to resume them, or even telling the entire computer<br>to resume.  This capability goes by several names such as “Wake On<br>LAN”; we will refer to it generically as “remote wakeup”.  When a<br>device is enabled for remote wakeup and it is suspended, it may resume<br>itself (or send a request to be resumed) in response to some external<br>event.  Examples include a suspended keyboard resuming when a key is<br>pressed, or a suspended USB hub resuming when a device is plugged in.</p>
<pre><code>When is a USB device idle?
--------------------------
</code></pre>
<p>A device is idle whenever the kernel thinks it’s not busy doing<br>anything important and thus is a candidate for being suspended.  The<br>exact definition depends on the device’s driver; drivers are allowed<br>to declare that a device isn’t idle even when there’s no actual<br>communication taking place.  (For example, a hub isn’t considered idle<br>unless all the devices plugged into that hub are already suspended.)<br>In addition, a device isn’t considered idle so long as a program keeps<br>its usbfs file open, whether or not any I/O is going on.</p>
<p>If a USB device has no driver, its usbfs file isn’t open, and it isn’t<br>being accessed through sysfs, then it definitely is idle.</p>
<pre><code>Forms of dynamic PM
-------------------
</code></pre>
<p>Dynamic suspends can occur in two ways: manual and automatic.<br>“Manual” means that the user has told the kernel to suspend a device,<br>whereas “automatic” means that the kernel has decided all by itself to<br>suspend a device.  Automatic suspend is called “autosuspend” for<br>short.  In general, a device won’t be autosuspended unless it has been<br>idle for some minimum period of time, the so-called idle-delay time.</p>
<p>Of course, nothing the kernel does on its own initiative should<br>prevent the computer or its devices from working properly.  If a<br>device has been autosuspended and a program tries to use it, the<br>kernel will automatically resume the device (autoresume).  For the<br>same reason, an autosuspended device will usually have remote wakeup<br>enabled, if the device supports remote wakeup.</p>
<p>It is worth mentioning that many USB drivers don’t support<br>autosuspend.  In fact, at the time of this writing (Linux 2.6.23) the<br>only drivers which do support it are the hub driver, kaweth, asix,<br>usblp, usblcd, and usb-skeleton (which doesn’t count).  If a<br>non-supporting driver is bound to a device, the device won’t be<br>autosuspended.  In effect, the kernel pretends the device is never<br>idle.</p>
<p>We can categorize power management events in two broad classes:<br>external and internal.  External events are those triggered by some<br>agent outside the USB stack: system suspend/resume (triggered by<br>userspace), manual dynamic suspend/resume (also triggered by<br>userspace), and remote wakeup (triggered by the device).  Internal<br>events are those triggered within the USB stack: autosuspend and<br>autoresume.</p>
<pre><code>The user interface for dynamic PM
---------------------------------
</code></pre>
<p>The user interface for controlling dynamic PM is located in the power/<br>subdirectory of each USB device’s sysfs directory, that is, in<br>/sys/bus/usb/devices/…/power/ where “…” is the device’s ID.  The<br>relevant attribute files are: wakeup, level, and autosuspend.</p>
<pre><code>power/wakeup

    This file is empty if the device does not support
    remote wakeup.  Otherwise the file contains either the
    word &quot;enabled&quot; or the word &quot;disabled&quot;, and you can
    write those words to the file.  The setting determines
    whether or not remote wakeup will be enabled when the
    device is next suspended.  (If the setting is changed
    while the device is suspended, the change won&#39;t take
    effect until the following suspend.)

power/level

    This file contains one of three words: &quot;on&quot;, &quot;auto&quot;,
    or &quot;suspend&quot;.  You can write those words to the file
    to change the device&#39;s setting.

    &quot;on&quot; means that the device should be resumed and
    autosuspend is not allowed.  (Of course, system
    suspends are still allowed.)

    &quot;auto&quot; is the normal state in which the kernel is
    allowed to autosuspend and autoresume the device.

    &quot;suspend&quot; means that the device should remain
    suspended, and autoresume is not allowed.  (But remote
    wakeup may still be allowed, since it is controlled
    separately by the power/wakeup attribute.)

power/autosuspend

    This file contains an integer value, which is the
    number of seconds the device should remain idle before
    the kernel will autosuspend it (the idle-delay time).
    The default is 2.  0 means to autosuspend as soon as
    the device becomes idle, and -1 means never to
    autosuspend.  You can write a number to the file to
    change the autosuspend idle-delay time.
</code></pre>
<p>Writing “-1” to power/autosuspend and writing “on” to power/level do<br>essentially the same thing – they both prevent the device from being<br>autosuspended.  Yes, this is a redundancy in the API.</p>
<p>(In 2.6.21 writing “0” to power/autosuspend would prevent the device<br>from being autosuspended; the behavior was changed in 2.6.22.  The<br>power/autosuspend attribute did not exist prior to 2.6.21, and the<br>power/level attribute did not exist prior to 2.6.22.)</p>
<pre><code>Changing the default idle-delay time
------------------------------------
</code></pre>
<p>The default autosuspend idle-delay time is controlled by a module<br>parameter in usbcore.  You can specify the value when usbcore is<br>loaded.  For example, to set it to 5 seconds instead of 2 you would<br>do:</p>
<pre><code>modprobe usbcore autosuspend=5
</code></pre>
<p>Equivalently, you could add to /etc/modprobe.conf a line saying:</p>
<pre><code>options usbcore autosuspend=5
</code></pre>
<p>Some distributions load the usbcore module very early during the boot<br>process, by means of a program or script running from an initramfs<br>image.  To alter the parameter value you would have to rebuild that<br>image.</p>
<p>If usbcore is compiled into the kernel rather than built as a loadable<br>module, you can add</p>
<pre><code>usbcore.autosuspend=5
</code></pre>
<p>to the kernel’s boot command line.</p>
<p>Finally, the parameter value can be changed while the system is<br>running.  If you do:</p>
<pre><code>echo 5 &gt;/sys/module/usbcore/parameters/autosuspend
</code></pre>
<p>then each new USB device will have its autosuspend idle-delay<br>initialized to 5.  (The idle-delay values for already existing devices<br>will not be affected.)</p>
<p>Setting the initial default idle-delay to -1 will prevent any<br>autosuspend of any USB device.  This is a simple alternative to<br>disabling CONFIG_USB_SUSPEND and rebuilding the kernel, and it has the<br>added benefit of allowing you to enable autosuspend for selected<br>devices.</p>
<pre><code>Warnings
--------
</code></pre>
<p>The USB specification states that all USB devices must support power<br>management.  Nevertheless, the sad fact is that many devices do not<br>support it very well.  You can suspend them all right, but when you<br>try to resume them they disconnect themselves from the USB bus or<br>they stop working entirely.  This seems to be especially prevalent<br>among printers and scanners, but plenty of other types of device have<br>the same deficiency.</p>
<p>For this reason, by default the kernel disables autosuspend (the<br>power/level attribute is initialized to “on”) for all devices other<br>than hubs.  Hubs, at least, appear to be reasonably well-behaved in<br>this regard.</p>
<p>(In 2.6.21 and 2.6.22 this wasn’t the case.  Autosuspend was enabled<br>by default for almost all USB devices.  A number of people experienced<br>problems as a result.)</p>
<p>This means that non-hub devices won’t be autosuspended unless the user<br>or a program explicitly enables it.  As of this writing there aren’t<br>any widespread programs which will do this; we hope that in the near<br>future device managers such as HAL will take on this added<br>responsibility.  In the meantime you can always carry out the<br>necessary operations by hand or add them to a udev script.  You can<br>also change the idle-delay time; 2 seconds is not the best choice for<br>every device.</p>
<p>Sometimes it turns out that even when a device does work okay with<br>autosuspend there are still problems.  For example, there are<br>experimental patches adding autosuspend support to the usbhid driver,<br>which manages keyboards and mice, among other things.  Tests with a<br>number of keyboards showed that typing on a suspended keyboard, while<br>causing the keyboard to do a remote wakeup all right, would<br>nonetheless frequently result in lost keystrokes.  Tests with mice<br>showed that some of them would issue a remote-wakeup request in<br>response to button presses but not to motion, and some in response to<br>neither.</p>
<p>The kernel will not prevent you from enabling autosuspend on devices<br>that can’t handle it.  It is even possible in theory to damage a<br>device by suspending it at the wrong time – for example, suspending a<br>USB hard disk might cause it to spin down without parking the heads.<br>(Highly unlikely, but possible.)  Take care.</p>
<pre><code>The driver interface for Power Management
-----------------------------------------
</code></pre>
<p>The requirements for a USB driver to support external power management<br>are pretty modest; the driver need only define</p>
<pre><code>.suspend
.resume
.reset_resume
</code></pre>
<p>methods in its usb_driver structure, and the reset_resume method is<br>optional.  The methods’ jobs are quite simple:</p>
<pre><code>The suspend method is called to warn the driver that the
device is going to be suspended.  If the driver returns a
negative error code, the suspend will be aborted.  Normally
the driver will return 0, in which case it must cancel all
outstanding URBs (usb_kill_urb()) and not submit any more.

The resume method is called to tell the driver that the
device has been resumed and the driver can return to normal
operation.  URBs may once more be submitted.

The reset_resume method is called to tell the driver that
the device has been resumed and it also has been reset.
The driver should redo any necessary device initialization,
since the device has probably lost most or all of its state
(although the interfaces will be in the same altsettings as
before the suspend).
</code></pre>
<p>If the device is disconnected or powered down while it is suspended,<br>the disconnect method will be called instead of the resume or<br>reset_resume method.  This is also quite likely to happen when<br>waking up from hibernation, as many systems do not maintain suspend<br>current to the USB host controllers during hibernation.  (It’s<br>possible to work around the hibernation-forces-disconnect problem by<br>using the USB Persist facility.)</p>
<p>The reset_resume method is used by the USB Persist facility (see<br>Documentation/usb/persist.txt) and it can also be used under certain<br>circumstances when CONFIG_USB_PERSIST is not enabled.  Currently, if a<br>device is reset during a resume and the driver does not have a<br>reset_resume method, the driver won’t receive any notification about<br>the resume.  Later kernels will call the driver’s disconnect method;<br>2.6.23 doesn’t do this.</p>
<p>USB drivers are bound to interfaces, so their suspend and resume<br>methods get called when the interfaces are suspended or resumed.  In<br>principle one might want to suspend some interfaces on a device (i.e.,<br>force the drivers for those interface to stop all activity) without<br>suspending the other interfaces.  The USB core doesn’t allow this; all<br>interfaces are suspended when the device itself is suspended and all<br>interfaces are resumed when the device is resumed.  It isn’t possible<br>to suspend or resume some but not all of a device’s interfaces.  The<br>closest you can come is to unbind the interfaces’ drivers.</p>
<pre><code>The driver interface for autosuspend and autoresume
---------------------------------------------------
</code></pre>
<p>To support autosuspend and autoresume, a driver should implement all<br>three of the methods listed above.  In addition, a driver indicates<br>that it supports autosuspend by setting the .supports_autosuspend flag<br>in its usb_driver structure.  It is then responsible for informing the<br>USB core whenever one of its interfaces becomes busy or idle.  The<br>driver does so by calling these five functions:</p>
<pre><code>int  usb_autopm_get_interface(struct usb_interface *intf);
void usb_autopm_put_interface(struct usb_interface *intf);
int  usb_autopm_set_interface(struct usb_interface *intf);
int  usb_autopm_get_interface_async(struct usb_interface *intf);
void usb_autopm_put_interface_async(struct usb_interface *intf);
</code></pre>
<p>The functions work by maintaining a counter in the usb_interface<br>structure.  When intf-&gt;pm_usage_count is &gt; 0 then the interface is<br>deemed to be busy, and the kernel will not autosuspend the interface’s<br>device.  When intf-&gt;pm_usage_count is &lt;= 0 then the interface is<br>considered to be idle, and the kernel may autosuspend the device.</p>
<p>(There is a similar pm_usage_count field in struct usb_device,<br>associated with the device itself rather than any of its interfaces.<br>This field is used only by the USB core.)</p>
<p>The driver owns intf-&gt;pm_usage_count; it can modify the value however<br>and whenever it likes.  A nice aspect of the non-async usb_autopm_*<br>routines is that the changes they make are protected by the usb_device<br>structure’s PM mutex (udev-&gt;pm_mutex); however drivers may change<br>pm_usage_count without holding the mutex.  Drivers using the async<br>routines are responsible for their own synchronization and mutual<br>exclusion.</p>
<pre><code>usb_autopm_get_interface() increments pm_usage_count and
attempts an autoresume if the new value is &gt; 0 and the
device is suspended.

usb_autopm_put_interface() decrements pm_usage_count and
attempts an autosuspend if the new value is &lt;= 0 and the
device isn&#39;t suspended.

usb_autopm_set_interface() leaves pm_usage_count alone.
It attempts an autoresume if the value is &gt; 0 and the device
is suspended, and it attempts an autosuspend if the value is
&lt;= 0 and the device isn&#39;t suspended.

usb_autopm_get_interface_async() and
usb_autopm_put_interface_async() do almost the same things as
their non-async counterparts.  The differences are: they do
not acquire the PM mutex, and they use a workqueue to do their
jobs.  As a result they can be called in an atomic context,
such as an URB&#39;s completion handler, but when they return the
device will not generally not yet be in the desired state.
</code></pre>
<p>There also are a couple of utility routines drivers can use:</p>
<pre><code>usb_autopm_enable() sets pm_usage_cnt to 0 and then calls
usb_autopm_set_interface(), which will attempt an autosuspend.

usb_autopm_disable() sets pm_usage_cnt to 1 and then calls
usb_autopm_set_interface(), which will attempt an autoresume.
</code></pre>
<p>The conventional usage pattern is that a driver calls<br>usb_autopm_get_interface() in its open routine and<br>usb_autopm_put_interface() in its close or release routine.  But<br>other patterns are possible.</p>
<p>The autosuspend attempts mentioned above will often fail for one<br>reason or another.  For example, the power/level attribute might be<br>set to “on”, or another interface in the same device might not be<br>idle.  This is perfectly normal.  If the reason for failure was that<br>the device hasn’t been idle for long enough, a delayed workqueue<br>routine is automatically set up to carry out the operation when the<br>autosuspend idle-delay has expired.</p>
<p>Autoresume attempts also can fail.  This will happen if power/level is<br>set to “suspend” or if the device doesn’t manage to resume properly.<br>Unlike autosuspend, there’s no delay for an autoresume.</p>
<pre><code>Other parts of the driver interface
-----------------------------------
</code></pre>
<p>Sometimes a driver needs to make sure that remote wakeup is enabled<br>during autosuspend.  For example, there’s not much point<br>autosuspending a keyboard if the user can’t cause the keyboard to do a<br>remote wakeup by typing on it.  If the driver sets<br>intf-&gt;needs_remote_wakeup to 1, the kernel won’t autosuspend the<br>device if remote wakeup isn’t available or has been disabled through<br>the power/wakeup attribute.  (If the device is already autosuspended,<br>though, setting this flag won’t cause the kernel to autoresume it.<br>Normally a driver would set this flag in its probe method, at which<br>time the device is guaranteed not to be autosuspended.)</p>
<p>The usb_autopm_* routines have to run in a sleepable process context;<br>they must not be called from an interrupt handler or while holding a<br>spinlock.  In fact, the entire autosuspend mechanism is not well geared<br>toward interrupt-driven operation.  However there is one thing a<br>driver can do in an interrupt handler:</p>
<pre><code>usb_mark_last_busy(struct usb_device *udev);
</code></pre>
<p>This sets udev-&gt;last_busy to the current time.  udev-&gt;last_busy is the<br>field used for idle-delay calculations; updating it will cause any<br>pending autosuspend to be moved back.  The usb_autopm_* routines will<br>also set the last_busy field to the current time.</p>
<p>Calling urb_mark_last_busy() from within an URB completion handler is<br>subject to races: The kernel may have just finished deciding the<br>device has been idle for long enough but not yet gotten around to<br>calling the driver’s suspend method.  The driver would have to be<br>responsible for synchronizing its suspend method with its URB<br>completion handler and causing the autosuspend to fail with -EBUSY if<br>an URB had completed too recently.</p>
<p>External suspend calls should never be allowed to fail in this way,<br>only autosuspend calls.  The driver can tell them apart by checking<br>udev-&gt;auto_pm; this flag will be set to 1 for internal PM events<br>(autosuspend or autoresume) and 0 for external PM events.</p>
<p>Many of the ingredients in the autosuspend framework are oriented<br>towards interfaces: The usb_interface structure contains the<br>pm_usage_cnt field, and the usb_autopm_* routines take an interface<br>pointer as their argument.  But somewhat confusingly, a few of the<br>pieces (usb_mark_last_busy() and udev-&gt;auto_pm) use the usb_device<br>structure instead.  Drivers need to keep this straight; they can call<br>interface_to_usbdev() to find the device structure for a given<br>interface.</p>
<pre><code>Locking requirements
--------------------
</code></pre>
<p>All three suspend/resume methods are always called while holding the<br>usb_device’s PM mutex.  For external events – but not necessarily for<br>autosuspend or autoresume – the device semaphore (udev-&gt;dev.sem) will<br>also be held.  This implies that external suspend/resume events are<br>mutually exclusive with calls to probe, disconnect, pre_reset, and<br>post_reset; the USB core guarantees that this is true of internal<br>suspend/resume events as well.</p>
<p>If a driver wants to block all suspend/resume calls during some<br>critical section, it can simply acquire udev-&gt;pm_mutex. Note that<br>calls to resume may be triggered indirectly. Block IO due to memory<br>allocations can make the vm subsystem resume a device. Thus while<br>holding this lock you must not allocate memory with GFP_KERNEL or<br>GFP_NOFS.</p>
<p>Alternatively, if the critical section might call some of the<br>usb_autopm_* routines, the driver can avoid deadlock by doing:</p>
<pre><code>down(&amp;udev-&gt;dev.sem);
rc = usb_autopm_get_interface(intf);
</code></pre>
<p>and at the end of the critical section:</p>
<pre><code>if (!rc)
    usb_autopm_put_interface(intf);
up(&amp;udev-&gt;dev.sem);
</code></pre>
<p>Holding the device semaphore will block all external PM calls, and the<br>usb_autopm_get_interface() will prevent any internal PM calls, even if<br>it fails.  (Exercise: Why?)</p>
<p>The rules for locking order are:</p>
<pre><code>Never acquire any device semaphore while holding any PM mutex.

Never acquire udev-&gt;pm_mutex while holding the PM mutex for
a device that isn&#39;t a descendant of udev.
</code></pre>
<p>In other words, PM mutexes should only be acquired going up the device<br>tree, and they should be acquired only after locking all the device<br>semaphores you need to hold.  These rules don’t matter to drivers very<br>much; they usually affect just the USB core.</p>
<p>Still, drivers do need to be careful.  For example, many drivers use a<br>private mutex to synchronize their normal I/O activities with their<br>disconnect method.  Now if the driver supports autosuspend then it<br>must call usb_autopm_put_interface() from somewhere – maybe from its<br>close method.  It should make the call while holding the private mutex,<br>since a driver shouldn’t call any of the usb_autopm_* functions for an<br>interface from which it has been unbound.</p>
<p>But the usb_autpm_* routines always acquire the device’s PM mutex, and<br>consequently the locking order has to be: private mutex first, PM<br>mutex second.  Since the suspend method is always called with the PM<br>mutex held, it mustn’t try to acquire the private mutex.  It has to<br>synchronize with the driver’s I/O activities in some other way.</p>
<pre><code>Interaction between dynamic PM and system PM
--------------------------------------------
</code></pre>
<p>Dynamic power management and system power management can interact in<br>a couple of ways.</p>
<p>Firstly, a device may already be manually suspended or autosuspended<br>when a system suspend occurs.  Since system suspends are supposed to<br>be as transparent as possible, the device should remain suspended<br>following the system resume.  The 2.6.23 kernel obeys this principle<br>for manually suspended devices but not for autosuspended devices; they<br>do get resumed when the system wakes up.  (Presumably they will be<br>autosuspended again after their idle-delay time expires.)  In later<br>kernels this behavior will be fixed.</p>
<p>(There is an exception.  If a device would undergo a reset-resume<br>instead of a normal resume, and the device is enabled for remote<br>wakeup, then the reset-resume takes place even if the device was<br>already suspended when the system suspend began.  The justification is<br>that a reset-resume is a kind of remote-wakeup event.  Or to put it<br>another way, a device which needs a reset won’t be able to generate<br>normal remote-wakeup signals, so it ought to be resumed immediately.)</p>
<p>Secondly, a dynamic power-management event may occur as a system<br>suspend is underway.  The window for this is short, since system<br>suspends don’t take long (a few seconds usually), but it can happen.<br>For example, a suspended device may send a remote-wakeup signal while<br>the system is suspending.  The remote wakeup may succeed, which would<br>cause the system suspend to abort.  If the remote wakeup doesn’t<br>succeed, it may still remain active and thus cause the system to<br>resume as soon as the system suspend is complete.  Or the remote<br>wakeup may fail and get lost.  Which outcome occurs depends on timing<br>and on the hardware and firmware design.</p>
<p>More interestingly, a device might undergo a manual resume or<br>autoresume during system suspend.  With current kernels this shouldn’t<br>happen, because manual resumes must be initiated by userspace and<br>autoresumes happen in response to I/O requests, but all user processes<br>and I/O should be quiescent during a system suspend – thanks to the<br>freezer.  However there are plans to do away with the freezer, which<br>would mean these things would become possible.  If and when this comes<br>about, the USB core will carefully arrange matters so that either type<br>of resume will block until the entire system has resumed.</p>
<pre><code>xHCI hardware link PM
---------------------
</code></pre>
<p>xHCI host controller provides hardware link power management to usb2.0<br>(xHCI 1.0 feature) and usb3.0 devices which support link PM. By<br>enabling hardware LPM, the host can automatically put the device into<br>lower power state(L1 for usb2.0 devices, or U1/U2 for usb3.0 devices),<br>which state device can enter and resume very quickly.</p>
<p>The user interface for controlling USB2 hardware LPM is located in the<br>power/ subdirectory of each USB device’s sysfs directory, that is, in<br>/sys/bus/usb/devices/…/power/ where “…” is the device’s ID. The<br>relevant attribute files is usb2_hardware_lpm.</p>
<pre><code>power/usb2_hardware_lpm

    When a USB2 device which support LPM is plugged to a
    xHCI host root hub which support software LPM, the
    host will run a software LPM test for it; if the device
    enters L1 state and resume successfully and the host
    supports USB2 hardware LPM, this file will show up and
    driver will enable hardware LPM    for the device. You
    can write y/Y/1 or n/N/0 to the file to    enable/disable
    USB2 hardware LPM manually. This is for    test purpose mainly.
</code></pre>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_power-management/" title="Kernel-2.6.32-573.12.1.el6_power-management" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_power-management/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_ppp_generic/" title="Kernel-2.6.32-573.12.1.el6_ppp_generic"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_pci/" title="Kernel-2.6.32-573.12.1.el6_pci"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>