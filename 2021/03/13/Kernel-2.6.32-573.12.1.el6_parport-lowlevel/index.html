<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-2.6.32-573.12.1.el6_parport-lowlevel | oosTech.com</title>
  <meta name="description" content="PARPORT interface documentationTime-stamp: &lt;2000-02-24 13:30:20 twaugh&gt; Described here are the following functions: Global functions:  parport_register_driver  parport_unregister_driver  parport">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-2.6.32-573.12.1.el6_parport-lowlevel">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_parport-lowlevel/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="PARPORT interface documentationTime-stamp: &lt;2000-02-24 13:30:20 twaugh&gt; Described here are the following functions: Global functions:  parport_register_driver  parport_unregister_driver  parport">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_parport-lowlevel/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#PARPORT-interface-documentation"><span class="toc-number">1.</span> <span class="toc-text">PARPORT interface documentation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parport-register-driver-register-a-device-driver-with-parport"><span class="toc-number">2.</span> <span class="toc-text">parport_register_driver - register a device driver with parport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#port-gt-ops-gt-read-data-read-the-data-register"><span class="toc-number">3.</span> <span class="toc-text">port-&gt;ops-&gt;read_data - read the data register</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-2.6.32-573.12.1.el6_parport-lowlevel" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-2.6.32-573.12.1.el6_parport-lowlevel
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_parport-lowlevel/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_parport-lowlevel/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_parport-lowlevel/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h2 id="PARPORT-interface-documentation"><a href="#PARPORT-interface-documentation" class="headerlink" title="PARPORT interface documentation"></a>PARPORT interface documentation</h2><p>Time-stamp: &lt;2000-02-24 13:30:20 twaugh&gt;</p>
<p>Described here are the following functions:</p>
<p>Global functions:<br>  parport_register_driver<br>  parport_unregister_driver<br>  parport_enumerate<br>  parport_register_device<br>  parport_unregister_device<br>  parport_claim<br>  parport_claim_or_block<br>  parport_release<br>  parport_yield<br>  parport_yield_blocking<br>  parport_wait_peripheral<br>  parport_poll_peripheral<br>  parport_wait_event<br>  parport_negotiate<br>  parport_read<br>  parport_write<br>  parport_open<br>  parport_close<br>  parport_device_id<br>  parport_device_coords<br>  parport_find_class<br>  parport_find_device<br>  parport_set_timeout</p>
<p>Port functions (can be overridden by low-level drivers):<br>  SPP:<br>    port-&gt;ops-&gt;read_data<br>    port-&gt;ops-&gt;write_data<br>    port-&gt;ops-&gt;read_status<br>    port-&gt;ops-&gt;read_control<br>    port-&gt;ops-&gt;write_control<br>    port-&gt;ops-&gt;frob_control<br>    port-&gt;ops-&gt;enable_irq<br>    port-&gt;ops-&gt;disable_irq<br>    port-&gt;ops-&gt;data_forward<br>    port-&gt;ops-&gt;data_reverse</p>
<p>  EPP:<br>    port-&gt;ops-&gt;epp_write_data<br>    port-&gt;ops-&gt;epp_read_data<br>    port-&gt;ops-&gt;epp_write_addr<br>    port-&gt;ops-&gt;epp_read_addr</p>
<p>  ECP:<br>    port-&gt;ops-&gt;ecp_write_data<br>    port-&gt;ops-&gt;ecp_read_data<br>    port-&gt;ops-&gt;ecp_write_addr</p>
<p>  Other:<br>    port-&gt;ops-&gt;nibble_read_data<br>    port-&gt;ops-&gt;byte_read_data<br>    port-&gt;ops-&gt;compat_write_data</p>
<p>The parport subsystem comprises ‘parport’ (the core port-sharing<br>code), and a variety of low-level drivers that actually do the port<br>accesses.  Each low-level driver handles a particular style of port<br>(PC, Amiga, and so on).</p>
<p>The parport interface to the device driver author can be broken down<br>into global functions and port functions.</p>
<p>The global functions are mostly for communicating between the device<br>driver and the parport subsystem: acquiring a list of available ports,<br>claiming a port for exclusive use, and so on.  They also include<br>‘generic’ functions for doing standard things that will work on any<br>IEEE 1284-capable architecture.</p>
<p>The port functions are provided by the low-level drivers, although the<br>core parport module provides generic ‘defaults’ for some routines.<br>The port functions can be split into three groups: SPP, EPP, and ECP.</p>
<p>SPP (Standard Parallel Port) functions modify so-called ‘SPP’<br>registers: data, status, and control.  The hardware may not actually<br>have registers exactly like that, but the PC does and this interface is<br>modelled after common PC implementations.  Other low-level drivers may<br>be able to emulate most of the functionality.</p>
<p>EPP (Enhanced Parallel Port) functions are provided for reading and<br>writing in IEEE 1284 EPP mode, and ECP (Extended Capabilities Port)<br>functions are used for IEEE 1284 ECP mode. (What about BECP? Does<br>anyone care?)</p>
<p>Hardware assistance for EPP and/or ECP transfers may or may not be<br>available, and if it is available it may or may not be used.  If<br>hardware is not used, the transfer will be software-driven.  In order<br>to cope with peripherals that only tenuously support IEEE 1284, a<br>low-level driver specific function is provided, for altering ‘fudge<br>factors’.<br><br>GLOBAL FUNCTIONS</p>
<hr>
<h2 id="parport-register-driver-register-a-device-driver-with-parport"><a href="#parport-register-driver-register-a-device-driver-with-parport" class="headerlink" title="parport_register_driver - register a device driver with parport"></a>parport_register_driver - register a device driver with parport</h2><p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_driver {<br>    const char *name;<br>    void (*attach) (struct parport *);<br>    void (*detach) (struct parport *);<br>    struct parport_driver *next;<br>};<br>int parport_register_driver (struct parport_driver *driver);</p>
<p>DESCRIPTION</p>
<p>In order to be notified about parallel ports when they are detected,<br>parport_register_driver should be called.  Your driver will<br>immediately be notified of all ports that have already been detected,<br>and of each new port as low-level drivers are loaded.</p>
<p>A ‘struct parport_driver’ contains the textual name of your driver,<br>a pointer to a function to handle new ports, and a pointer to a<br>function to handle ports going away due to a low-level driver<br>unloading.  Ports will only be detached if they are not being used<br>(i.e. there are no devices registered on them).</p>
<p>The visible parts of the ‘struct parport *’ argument given to<br>attach/detach are:</p>
<p>struct parport<br>{<br>    struct parport <em>next; /</em> next parport in list */<br>    const char <em>name;     /</em> port’s name <em>/<br>    unsigned int modes;   /</em> bitfield of hardware modes <em>/<br>    struct parport_device_info probe_info;<br>                  /</em> IEEE1284 info <em>/<br>    int number;           /</em> parport index */<br>    struct parport_operations *ops;<br>    …<br>};</p>
<p>There are other members of the structure, but they should not be<br>touched.</p>
<p>The ‘modes’ member summarises the capabilities of the underlying<br>hardware.  It consists of flags which may be bitwise-ored together:</p>
<p>  PARPORT_MODE_PCSPP        IBM PC registers are available,<br>                i.e. functions that act on data,<br>                control and status registers are<br>                probably writing directly to the<br>                hardware.<br>  PARPORT_MODE_TRISTATE        The data drivers may be turned off.<br>                This allows the data lines to be used<br>                for reverse (peripheral to host)<br>                transfers.<br>  PARPORT_MODE_COMPAT        The hardware can assist with<br>                compatibility-mode (printer)<br>                transfers, i.e. compat_write_block.<br>  PARPORT_MODE_EPP        The hardware can assist with EPP<br>                transfers.<br>  PARPORT_MODE_ECP        The hardware can assist with ECP<br>                transfers.<br>  PARPORT_MODE_DMA        The hardware can use DMA, so you might<br>                want to pass ISA DMA-able memory<br>                (i.e. memory allocated using the<br>                GFP_DMA flag with kmalloc) to the<br>                low-level driver in order to take<br>                advantage of it.</p>
<p>There may be other flags in ‘modes’ as well.</p>
<p>The contents of ‘modes’ is advisory only.  For example, if the<br>hardware is capable of DMA, and PARPORT_MODE_DMA is in ‘modes’, it<br>doesn’t necessarily mean that DMA will always be used when possible.<br>Similarly, hardware that is capable of assisting ECP transfers won’t<br>necessarily be used.</p>
<p>RETURN VALUE</p>
<p>Zero on success, otherwise an error code.</p>
<p>ERRORS</p>
<p>None. (Can it fail? Why return int?)</p>
<p>EXAMPLE</p>
<p>static void lp_attach (struct parport *port)<br>{<br>    …<br>    private = kmalloc (…);<br>    dev[count++] = parport_register_device (…);<br>    …<br>}</p>
<p>static void lp_detach (struct parport *port)<br>{<br>    …<br>}</p>
<p>static struct parport_driver lp_driver = {<br>    “lp”,<br>    lp_attach,<br>    lp_detach,<br>    NULL /* always put NULL here */<br>};</p>
<p>int lp_init (void)<br>{<br>    …<br>    if (parport_register_driver (&amp;lp_driver)) {<br>        /* Failed; nothing we can do. */<br>        return -EIO;<br>    }<br>    …<br>}</p>
<p>SEE ALSO</p>
<p>parport_unregister_driver, parport_register_device, parport_enumerate<br><br>parport_unregister_driver - tell parport to forget about this driver</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_driver {<br>    const char *name;<br>    void (*attach) (struct parport *);<br>    void (*detach) (struct parport *);<br>    struct parport_driver *next;<br>};<br>void parport_unregister_driver (struct parport_driver *driver);</p>
<p>DESCRIPTION</p>
<p>This tells parport not to notify the device driver of new ports or of<br>ports going away.  Registered devices belonging to that driver are NOT<br>unregistered: parport_unregister_device must be used for each one.</p>
<p>EXAMPLE</p>
<p>void cleanup_module (void)<br>{<br>    …<br>    /* Stop notifications. */<br>    parport_unregister_driver (&amp;lp_driver);</p>
<pre><code>/* Unregister devices. */
for (i = 0; i &lt; NUM_DEVS; i++)
    parport_unregister_device (dev[i]);
...
</code></pre>
<p>}</p>
<p>SEE ALSO</p>
<p>parport_register_driver, parport_enumerate<br><br>parport_enumerate - retrieve a list of parallel ports (DEPRECATED)</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport *parport_enumerate (void);</p>
<p>DESCRIPTION</p>
<p>Retrieve the first of a list of valid parallel ports for this machine.<br>Successive parallel ports can be found using the ‘struct parport<br>*next’ element of the ‘struct parport *’ that is returned.  If ‘next’<br>is NULL, there are no more parallel ports in the list.  The number of<br>ports in the list will not exceed PARPORT_MAX.</p>
<p>RETURN VALUE</p>
<p>A ‘struct parport *’ describing a valid parallel port for the machine,<br>or NULL if there are none.</p>
<p>ERRORS</p>
<p>This function can return NULL to indicate that there are no parallel<br>ports to use.</p>
<p>EXAMPLE</p>
<p>int detect_device (void)<br>{<br>    struct parport *port;</p>
<pre><code>for (port = parport_enumerate ();
     port != NULL;
     port = port-&gt;next) &#123;
    /* Try to detect a device on the port... */
    ...
         &#125;
&#125;

...
</code></pre>
<p>}</p>
<p>NOTES</p>
<p>parport_enumerate is deprecated; parport_register_driver should be<br>used instead.</p>
<p>SEE ALSO</p>
<p>parport_register_driver, parport_unregister_driver<br><br>parport_register_device - register to use a port</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>typedef int (*preempt_func) (void *handle);<br>typedef void (*wakeup_func) (void *handle);<br>typedef int (*irq_func) (int irq, void *handle, struct pt_regs *);</p>
<p>struct pardevice *parport_register_device(struct parport *port,<br>                                          const char *name,<br>                                          preempt_func preempt,<br>                                          wakeup_func wakeup,<br>                                          irq_func irq,<br>                                          int flags,<br>                                          void *handle);</p>
<p>DESCRIPTION</p>
<p>Use this function to register your device driver on a parallel port<br>(‘port’).  Once you have done that, you will be able to use<br>parport_claim and parport_release in order to use the port.</p>
<p>The (‘name’) argument is the name of the device that appears in /proc<br>filesystem. The string must be valid for the whole lifetime of the<br>device (until parport_unregister_device is called).</p>
<p>This function will register three callbacks into your driver:<br>‘preempt’, ‘wakeup’ and ‘irq’.  Each of these may be NULL in order to<br>indicate that you do not want a callback.</p>
<p>When the ‘preempt’ function is called, it is because another driver<br>wishes to use the parallel port.  The ‘preempt’ function should return<br>non-zero if the parallel port cannot be released yet – if zero is<br>returned, the port is lost to another driver and the port must be<br>re-claimed before use.</p>
<p>The ‘wakeup’ function is called once another driver has released the<br>port and no other driver has yet claimed it.  You can claim the<br>parallel port from within the ‘wakeup’ function (in which case the<br>claim is guaranteed to succeed), or choose not to if you don’t need it<br>now.</p>
<p>If an interrupt occurs on the parallel port your driver has claimed,<br>the ‘irq’ function will be called. (Write something about shared<br>interrupts here.)</p>
<p>The ‘handle’ is a pointer to driver-specific data, and is passed to<br>the callback functions.</p>
<p>‘flags’ may be a bitwise combination of the following flags:</p>
<pre><code>    Flag            Meaning
</code></pre>
<p>  PARPORT_DEV_EXCL    The device cannot share the parallel port at all.<br>            Use this only when absolutely necessary.</p>
<p>The typedefs are not actually defined – they are only shown in order<br>to make the function prototype more readable.</p>
<p>The visible parts of the returned ‘struct pardevice’ are:</p>
<p>struct pardevice {<br>    struct parport <em>port;    /</em> Associated port */<br>    void <em>private;        /</em> Device driver’s ‘handle’ */<br>    …<br>};</p>
<p>RETURN VALUE</p>
<p>A ‘struct pardevice *’: a handle to the registered parallel port<br>device that can be used for parport_claim, parport_release, etc.</p>
<p>ERRORS</p>
<p>A return value of NULL indicates that there was a problem registering<br>a device on that port.</p>
<p>EXAMPLE</p>
<p>static int preempt (void *handle)<br>{<br>    if (busy_right_now)<br>        return 1;</p>
<pre><code>must_reclaim_port = 1;
return 0;
</code></pre>
<p>}</p>
<p>static void wakeup (void <em>handle)<br>{<br>    struct toaster *private = handle;<br>    struct pardevice *dev = private-&gt;dev;<br>    if (!dev) return; /</em> avoid races */</p>
<pre><code>if (want_port)
    parport_claim (dev);
</code></pre>
<p>}</p>
<p>static int toaster_detect (struct toaster *private, struct parport <em>port)<br>{<br>    private-&gt;dev = parport_register_device (port, “toaster”, preempt,<br>                            wakeup, NULL, 0,<br>                        private);<br>    if (!private-&gt;dev)<br>        /</em> Couldn’t register with parport. */<br>        return -EIO;</p>
<pre><code>must_reclaim_port = 0;
busy_right_now = 1;
parport_claim_or_block (private-&gt;dev);
...
/* Don&#39;t need the port while the toaster warms up. */
busy_right_now = 0;
...
busy_right_now = 1;
if (must_reclaim_port) &#123;
    parport_claim_or_block (private-&gt;dev);
    must_reclaim_port = 0;
&#125;
...
</code></pre>
<p>}</p>
<p>SEE ALSO</p>
<p>parport_unregister_device, parport_claim<br><br>parport_unregister_device - finish using a port</p>
<hr>
<p>SYNPOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>void parport_unregister_device (struct pardevice *dev);</p>
<p>DESCRIPTION</p>
<p>This function is the opposite of parport_register_device.  After using<br>parport_unregister_device, ‘dev’ is no longer a valid device handle.</p>
<p>You should not unregister a device that is currently claimed, although<br>if you do it will be released automatically.</p>
<p>EXAMPLE</p>
<pre><code>...
kfree (dev-&gt;private); /* before we lose the pointer */
parport_unregister_device (dev);
...
</code></pre>
<p>SEE ALSO</p>
<p>parport_unregister_driver<br><br>parport_claim, parport_claim_or_block - claim the parallel port for a device</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>int parport_claim (struct pardevice *dev);<br>int parport_claim_or_block (struct pardevice *dev);</p>
<p>DESCRIPTION</p>
<p>These functions attempt to gain control of the parallel port on which<br>‘dev’ is registered.  ‘parport_claim’ does not block, but<br>‘parport_claim_or_block’ may do. (Put something here about blocking<br>interruptibly or non-interruptibly.)</p>
<p>You should not try to claim a port that you have already claimed.</p>
<p>RETURN VALUE</p>
<p>A return value of zero indicates that the port was successfully<br>claimed, and the caller now has possession of the parallel port.</p>
<p>If ‘parport_claim_or_block’ blocks before returning successfully, the<br>return value is positive.</p>
<p>ERRORS</p>
<p>  -EAGAIN  The port is unavailable at the moment, but another attempt<br>           to claim it may succeed.</p>
<p>SEE ALSO</p>
<p>parport_release<br><br>parport_release - release the parallel port</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>void parport_release (struct pardevice *dev);</p>
<p>DESCRIPTION</p>
<p>Once a parallel port device has been claimed, it can be released using<br>‘parport_release’.  It cannot fail, but you should not release a<br>device that you do not have possession of.</p>
<p>EXAMPLE</p>
<p>static size_t write (struct pardevice *dev, const void *buf,<br>             size_t len)<br>{<br>    …<br>    written = dev-&gt;port-&gt;ops-&gt;write_ecp_data (dev-&gt;port, buf,<br>                          len);<br>    parport_release (dev);<br>    …<br>}</p>
<p>SEE ALSO</p>
<p>change_mode, parport_claim, parport_claim_or_block, parport_yield<br><br>parport_yield, parport_yield_blocking - temporarily release a parallel port</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>int parport_yield (struct pardevice *dev)<br>int parport_yield_blocking (struct pardevice *dev);</p>
<p>DESCRIPTION</p>
<p>When a driver has control of a parallel port, it may allow another<br>driver to temporarily ‘borrow’ it.  ‘parport_yield’ does not block;<br>‘parport_yield_blocking’ may do.</p>
<p>RETURN VALUE</p>
<p>A return value of zero indicates that the caller still owns the port<br>and the call did not block.</p>
<p>A positive return value from ‘parport_yield_blocking’ indicates that<br>the caller still owns the port and the call blocked.</p>
<p>A return value of -EAGAIN indicates that the caller no longer owns the<br>port, and it must be re-claimed before use.</p>
<p>ERRORS</p>
<p>  -EAGAIN  Ownership of the parallel port was given away.</p>
<p>SEE ALSO</p>
<p>parport_release<br><br>parport_wait_peripheral - wait for status lines, up to 35ms</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>int parport_wait_peripheral (struct parport *port,<br>                 unsigned char mask,<br>                 unsigned char val);</p>
<p>DESCRIPTION</p>
<p>Wait for the status lines in mask to match the values in val.</p>
<p>RETURN VALUE</p>
<p> -EINTR  a signal is pending<br>      0  the status lines in mask have values in val<br>      1  timed out while waiting (35ms elapsed)</p>
<p>SEE ALSO</p>
<p>parport_poll_peripheral<br><br>parport_poll_peripheral - wait for status lines, in usec</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>int parport_poll_peripheral (struct parport *port,<br>                 unsigned char mask,<br>                 unsigned char val,<br>                 int usec);</p>
<p>DESCRIPTION</p>
<p>Wait for the status lines in mask to match the values in val.</p>
<p>RETURN VALUE</p>
<p> -EINTR  a signal is pending<br>      0  the status lines in mask have values in val<br>      1  timed out while waiting (usec microseconds have elapsed)</p>
<p>SEE ALSO</p>
<p>parport_wait_peripheral<br><br>parport_wait_event - wait for an event on a port</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>int parport_wait_event (struct parport *port, signed long timeout)</p>
<p>DESCRIPTION</p>
<p>Wait for an event (e.g. interrupt) on a port.  The timeout is in<br>jiffies.</p>
<p>RETURN VALUE</p>
<pre><code>  0  success
 &lt;0  error (exit as soon as possible)
 &gt;0  timed out
</code></pre>
<p><br>parport_negotiate - perform IEEE 1284 negotiation</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>int parport_negotiate (struct parport *, int mode);</p>
<p>DESCRIPTION</p>
<p>Perform IEEE 1284 negotiation.</p>
<p>RETURN VALUE</p>
<pre><code> 0  handshake OK; IEEE 1284 peripheral and mode available
-1  handshake failed; peripheral not compliant (or none present)
 1  handshake OK; IEEE 1284 peripheral present but mode not
    available
</code></pre>
<p>SEE ALSO</p>
<p>parport_read, parport_write<br><br>parport_read - read data from device</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>ssize_t parport_read (struct parport *, void *buf, size_t len);</p>
<p>DESCRIPTION</p>
<p>Read data from device in current IEEE 1284 transfer mode.  This only<br>works for modes that support reverse data transfer.</p>
<p>RETURN VALUE</p>
<p>If negative, an error code; otherwise the number of bytes transferred.</p>
<p>SEE ALSO</p>
<p>parport_write, parport_negotiate<br><br>parport_write - write data to device</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>ssize_t parport_write (struct parport *, const void *buf, size_t len);</p>
<p>DESCRIPTION</p>
<p>Write data to device in current IEEE 1284 transfer mode.  This only<br>works for modes that support forward data transfer.</p>
<p>RETURN VALUE</p>
<p>If negative, an error code; otherwise the number of bytes transferred.</p>
<p>SEE ALSO</p>
<p>parport_read, parport_negotiate<br><br>parport_open - register device for particular device number</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct pardevice *parport_open (int devnum, const char *name,<br>                    int (*pf) (void *),<br>                void (*kf) (void *),<br>                void (*irqf) (int, void *,<br>                          struct pt_regs *),<br>                int flags, void *handle);</p>
<p>DESCRIPTION</p>
<p>This is like parport_register_device but takes a device number instead<br>of a pointer to a struct parport.</p>
<p>RETURN VALUE</p>
<p>See parport_register_device.  If no device is associated with devnum,<br>NULL is returned.</p>
<p>SEE ALSO</p>
<p>parport_register_device<br><br>parport_close - unregister device for particular device number</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>void parport_close (struct pardevice *dev);</p>
<p>DESCRIPTION</p>
<p>This is the equivalent of parport_unregister_device for parport_open.</p>
<p>SEE ALSO</p>
<p>parport_unregister_device, parport_open<br><br>parport_device_id - obtain IEEE 1284 Device ID</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>ssize_t parport_device_id (int devnum, char *buffer, size_t len);</p>
<p>DESCRIPTION</p>
<p>Obtains the IEEE 1284 Device ID associated with a given device.</p>
<p>RETURN VALUE</p>
<p>If negative, an error code; otherwise, the number of bytes of buffer<br>that contain the device ID.  The format of the device ID is as<br>follows:</p>
<p>[length][ID]</p>
<p>The first two bytes indicate the inclusive length of the entire Device<br>ID, and are in big-endian order.  The ID is a sequence of pairs of the<br>form:</p>
<p>key:value;</p>
<p>NOTES</p>
<p>Many devices have ill-formed IEEE 1284 Device IDs.</p>
<p>SEE ALSO</p>
<p>parport_find_class, parport_find_device<br><br>parport_device_coords - convert device number to device coordinates</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>int parport_device_coords (int devnum, int *parport, int *mux,<br>               int *daisy);</p>
<p>DESCRIPTION</p>
<p>Convert between device number (zero-based) and device coordinates<br>(port, multiplexor, daisy chain address).</p>
<p>RETURN VALUE</p>
<p>Zero on success, in which case the coordinates are (*parport, *mux,<br>*daisy).</p>
<p>SEE ALSO</p>
<p>parport_open, parport_device_id<br><br>parport_find_class - find a device by its class</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>typedef enum {<br>    PARPORT_CLASS_LEGACY = 0,       /* Non-IEEE1284 device <em>/<br>    PARPORT_CLASS_PRINTER,<br>    PARPORT_CLASS_MODEM,<br>    PARPORT_CLASS_NET,<br>    PARPORT_CLASS_HDC,              /</em> Hard disk controller <em>/<br>    PARPORT_CLASS_PCMCIA,<br>    PARPORT_CLASS_MEDIA,            /</em> Multimedia device <em>/<br>    PARPORT_CLASS_FDC,              /</em> Floppy disk controller <em>/<br>    PARPORT_CLASS_PORTS,<br>    PARPORT_CLASS_SCANNER,<br>    PARPORT_CLASS_DIGCAM,<br>    PARPORT_CLASS_OTHER,            /</em> Anything else <em>/<br>    PARPORT_CLASS_UNSPEC,           /</em> No CLS field in ID */<br>    PARPORT_CLASS_SCSIADAPTER<br>} parport_device_class;</p>
<p>int parport_find_class (parport_device_class cls, int from);</p>
<p>DESCRIPTION</p>
<p>Find a device by class.  The search starts from device number from+1.</p>
<p>RETURN VALUE</p>
<p>The device number of the next device in that class, or -1 if no such<br>device exists.</p>
<p>NOTES</p>
<p>Example usage:</p>
<p>int devnum = -1;<br>while ((devnum = parport_find_class (PARPORT_CLASS_DIGCAM, devnum)) != -1) {<br>    struct pardevice *dev = parport_open (devnum, …);<br>    …<br>}</p>
<p>SEE ALSO</p>
<p>parport_find_device, parport_open, parport_device_id<br><br>parport_find_device - find a device by its class</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>int parport_find_device (const char *mfg, const char *mdl, int from);</p>
<p>DESCRIPTION</p>
<p>Find a device by vendor and model.  The search starts from device<br>number from+1.</p>
<p>RETURN VALUE</p>
<p>The device number of the next device matching the specifications, or<br>-1 if no such device exists.</p>
<p>NOTES</p>
<p>Example usage:</p>
<p>int devnum = -1;<br>while ((devnum = parport_find_device (“IOMEGA”, “ZIP+”, devnum)) != -1) {<br>    struct pardevice *dev = parport_open (devnum, …);<br>    …<br>}</p>
<p>SEE ALSO</p>
<p>parport_find_class, parport_open, parport_device_id<br><br>parport_set_timeout - set the inactivity timeout</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>long parport_set_timeout (struct pardevice *dev, long inactivity);</p>
<p>DESCRIPTION</p>
<p>Set the inactivity timeout, in jiffies, for a registered device.  The<br>previous timeout is returned.</p>
<p>RETURN VALUE</p>
<p>The previous timeout, in jiffies.</p>
<p>NOTES</p>
<p>Some of the port-&gt;ops functions for a parport may take time, owing to<br>delays at the peripheral.  After the peripheral has not responded for<br>‘inactivity’ jiffies, a timeout will occur and the blocking function<br>will return.</p>
<p>A timeout of 0 jiffies is a special case: the function must do as much<br>as it can without blocking or leaving the hardware in an unknown<br>state.  If port operations are performed from within an interrupt<br>handler, for instance, a timeout of 0 jiffies should be used.</p>
<p>Once set for a registered device, the timeout will remain at the set<br>value until set again.</p>
<p>SEE ALSO</p>
<p>port-&gt;ops-&gt;xxx_read/write_yyy<br><br>PORT FUNCTIONS</p>
<hr>
<p>The functions in the port-&gt;ops structure (struct parport_operations)<br>are provided by the low-level driver responsible for that port.</p>
<h2 id="port-gt-ops-gt-read-data-read-the-data-register"><a href="#port-gt-ops-gt-read-data-read-the-data-register" class="headerlink" title="port-&gt;ops-&gt;read_data - read the data register"></a>port-&gt;ops-&gt;read_data - read the data register</h2><p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    unsigned char (*read_data) (struct parport *port);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>If port-&gt;modes contains the PARPORT_MODE_TRISTATE flag and the<br>PARPORT_CONTROL_DIRECTION bit in the control register is set, this<br>returns the value on the data pins.  If port-&gt;modes contains the<br>PARPORT_MODE_TRISTATE flag and the PARPORT_CONTROL_DIRECTION bit is<br>not set, the return value <em>may</em> be the last value written to the data<br>register.  Otherwise the return value is undefined.</p>
<p>SEE ALSO</p>
<p>write_data, read_status, write_control<br><br>port-&gt;ops-&gt;write_data - write the data register</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    void (*write_data) (struct parport *port, unsigned char d);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>Writes to the data register.  May have side-effects (a STROBE pulse,<br>for instance).</p>
<p>SEE ALSO</p>
<p>read_data, read_status, write_control<br><br>port-&gt;ops-&gt;read_status - read the status register</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    unsigned char (*read_status) (struct parport *port);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>Reads from the status register.  This is a bitmask:</p>
<ul>
<li>PARPORT_STATUS_ERROR (printer fault, “nFault”)</li>
<li>PARPORT_STATUS_SELECT (on-line, “Select”)</li>
<li>PARPORT_STATUS_PAPEROUT (no paper, “PError”)</li>
<li>PARPORT_STATUS_ACK (handshake, “nAck”)</li>
<li>PARPORT_STATUS_BUSY (busy, “Busy”)</li>
</ul>
<p>There may be other bits set.</p>
<p>SEE ALSO</p>
<p>read_data, write_data, write_control<br><br>port-&gt;ops-&gt;read_control - read the control register</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    unsigned char (*read_control) (struct parport *port);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>Returns the last value written to the control register (either from<br>write_control or frob_control).  No port access is performed.</p>
<p>SEE ALSO</p>
<p>read_data, write_data, read_status, write_control<br><br>port-&gt;ops-&gt;write_control - write the control register</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    void (*write_control) (struct parport *port, unsigned char s);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>Writes to the control register. This is a bitmask:<br>                          _______</p>
<ul>
<li>PARPORT_CONTROL_STROBE (nStrobe)<pre><code>                    _______
</code></pre>
</li>
<li>PARPORT_CONTROL_AUTOFD (nAutoFd)<pre><code>                  _____
</code></pre>
</li>
<li>PARPORT_CONTROL_INIT (nInit)<pre><code>                    _________
</code></pre>
</li>
<li>PARPORT_CONTROL_SELECT (nSelectIn)</li>
</ul>
<p>SEE ALSO</p>
<p>read_data, write_data, read_status, frob_control<br><br>port-&gt;ops-&gt;frob_control - write control register bits</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    unsigned char (*frob_control) (struct parport *port,<br>                       unsigned char mask,<br>                       unsigned char val);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>This is equivalent to reading from the control register, masking out<br>the bits in mask, exclusive-or’ing with the bits in val, and writing<br>the result to the control register.</p>
<p>As some ports don’t allow reads from the control port, a software copy<br>of its contents is maintained, so frob_control is in fact only one<br>port access.</p>
<p>SEE ALSO</p>
<p>read_data, write_data, read_status, write_control<br><br>port-&gt;ops-&gt;enable_irq - enable interrupt generation</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    void (*enable_irq) (struct parport *port);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>The parallel port hardware is instructed to generate interrupts at<br>appropriate moments, although those moments are<br>architecture-specific.  For the PC architecture, interrupts are<br>commonly generated on the rising edge of nAck.</p>
<p>SEE ALSO</p>
<p>disable_irq<br><br>port-&gt;ops-&gt;disable_irq - disable interrupt generation</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    void (*disable_irq) (struct parport *port);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>The parallel port hardware is instructed not to generate interrupts.<br>The interrupt itself is not masked.</p>
<p>SEE ALSO</p>
<p>enable_irq<br><br>port-&gt;ops-&gt;data_forward - enable data drivers</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    void (*data_forward) (struct parport *port);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>Enables the data line drivers, for 8-bit host-to-peripheral<br>communications.</p>
<p>SEE ALSO</p>
<p>data_reverse<br><br>port-&gt;ops-&gt;data_reverse - tristate the buffer</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    void (*data_reverse) (struct parport *port);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>Places the data bus in a high impedance state, if port-&gt;modes has the<br>PARPORT_MODE_TRISTATE bit set.</p>
<p>SEE ALSO</p>
<p>data_forward<br><br>port-&gt;ops-&gt;epp_write_data - write EPP data</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    size_t (*epp_write_data) (struct parport *port, const void *buf,<br>                  size_t len, int flags);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>Writes data in EPP mode, and returns the number of bytes written.</p>
<p>The ‘flags’ parameter may be one or more of the following,<br>bitwise-or’ed together:</p>
<p>PARPORT_EPP_FAST    Use fast transfers. Some chips provide 16-bit and<br>            32-bit registers.  However, if a transfer<br>            times out, the return value may be unreliable.</p>
<p>SEE ALSO</p>
<p>epp_read_data, epp_write_addr, epp_read_addr<br><br>port-&gt;ops-&gt;epp_read_data - read EPP data</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    size_t (*epp_read_data) (struct parport *port, void *buf,<br>                 size_t len, int flags);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>Reads data in EPP mode, and returns the number of bytes read.</p>
<p>The ‘flags’ parameter may be one or more of the following,<br>bitwise-or’ed together:</p>
<p>PARPORT_EPP_FAST    Use fast transfers. Some chips provide 16-bit and<br>            32-bit registers.  However, if a transfer<br>            times out, the return value may be unreliable.</p>
<p>SEE ALSO</p>
<p>epp_write_data, epp_write_addr, epp_read_addr<br><br>port-&gt;ops-&gt;epp_write_addr - write EPP address</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    size_t (*epp_write_addr) (struct parport *port,<br>                  const void *buf, size_t len, int flags);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>Writes EPP addresses (8 bits each), and returns the number written.</p>
<p>The ‘flags’ parameter may be one or more of the following,<br>bitwise-or’ed together:</p>
<p>PARPORT_EPP_FAST    Use fast transfers. Some chips provide 16-bit and<br>            32-bit registers.  However, if a transfer<br>            times out, the return value may be unreliable.</p>
<p>(Does PARPORT_EPP_FAST make sense for this function?)</p>
<p>SEE ALSO</p>
<p>epp_write_data, epp_read_data, epp_read_addr<br><br>port-&gt;ops-&gt;epp_read_addr - read EPP address</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    size_t (*epp_read_addr) (struct parport *port, void *buf,<br>                 size_t len, int flags);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>Reads EPP addresses (8 bits each), and returns the number read.</p>
<p>The ‘flags’ parameter may be one or more of the following,<br>bitwise-or’ed together:</p>
<p>PARPORT_EPP_FAST    Use fast transfers. Some chips provide 16-bit and<br>            32-bit registers.  However, if a transfer<br>            times out, the return value may be unreliable.</p>
<p>(Does PARPORT_EPP_FAST make sense for this function?)</p>
<p>SEE ALSO</p>
<p>epp_write_data, epp_read_data, epp_write_addr<br><br>port-&gt;ops-&gt;ecp_write_data - write a block of ECP data</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    size_t (*ecp_write_data) (struct parport *port,<br>                  const void *buf, size_t len, int flags);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>Writes a block of ECP data.  The ‘flags’ parameter is ignored.</p>
<p>RETURN VALUE</p>
<p>The number of bytes written.</p>
<p>SEE ALSO</p>
<p>ecp_read_data, ecp_write_addr<br><br>port-&gt;ops-&gt;ecp_read_data - read a block of ECP data</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    size_t (*ecp_read_data) (struct parport *port,<br>                 void *buf, size_t len, int flags);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>Reads a block of ECP data.  The ‘flags’ parameter is ignored.</p>
<p>RETURN VALUE</p>
<p>The number of bytes read.  NB. There may be more unread data in a<br>FIFO.  Is there a way of stunning the FIFO to prevent this?</p>
<p>SEE ALSO</p>
<p>ecp_write_block, ecp_write_addr<br><br>port-&gt;ops-&gt;ecp_write_addr - write a block of ECP addresses</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    size_t (*ecp_write_addr) (struct parport *port,<br>                  const void *buf, size_t len, int flags);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>Writes a block of ECP addresses.  The ‘flags’ parameter is ignored.</p>
<p>RETURN VALUE</p>
<p>The number of bytes written.</p>
<p>NOTES</p>
<p>This may use a FIFO, and if so shall not return until the FIFO is empty.</p>
<p>SEE ALSO</p>
<p>ecp_read_data, ecp_write_data<br><br>port-&gt;ops-&gt;nibble_read_data - read a block of data in nibble mode</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    size_t (*nibble_read_data) (struct parport *port,<br>                    void *buf, size_t len, int flags);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>Reads a block of data in nibble mode.  The ‘flags’ parameter is ignored.</p>
<p>RETURN VALUE</p>
<p>The number of whole bytes read.</p>
<p>SEE ALSO</p>
<p>byte_read_data, compat_write_data<br><br>port-&gt;ops-&gt;byte_read_data - read a block of data in byte mode</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    size_t (*byte_read_data) (struct parport *port,<br>                  void *buf, size_t len, int flags);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>Reads a block of data in byte mode.  The ‘flags’ parameter is ignored.</p>
<p>RETURN VALUE</p>
<p>The number of bytes read.</p>
<p>SEE ALSO</p>
<p>nibble_read_data, compat_write_data<br><br>port-&gt;ops-&gt;compat_write_data - write a block of data in compatibility mode</p>
<hr>
<p>SYNOPSIS</p>
<p>#include &lt;linux/parport.h&gt;</p>
<p>struct parport_operations {<br>    …<br>    size_t (*compat_write_data) (struct parport *port,<br>                     const void *buf, size_t len, int flags);<br>    …<br>};</p>
<p>DESCRIPTION</p>
<p>Writes a block of data in compatibility mode.  The ‘flags’ parameter<br>is ignored.</p>
<p>RETURN VALUE</p>
<p>The number of bytes written.</p>
<p>SEE ALSO</p>
<p>nibble_read_data, byte_read_data</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_parport-lowlevel/" title="Kernel-2.6.32-573.12.1.el6_parport-lowlevel" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-2.6.32-573.12.1.el6_parport-lowlevel/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_rt-mutex-design/" title="Kernel-2.6.32-573.12.1.el6_rt-mutex-design"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_makefiles/" title="Kernel-2.6.32-573.12.1.el6_makefiles"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>