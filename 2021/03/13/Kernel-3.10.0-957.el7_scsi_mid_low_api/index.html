<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-3.10.0-957.el7_scsi_mid_low_api | oosTech.com</title>
  <meta name="description" content="Linux Kernel 2.6 series              SCSI mid_level - lower_level driver interface              &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  IntroductionThis document outlines">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-3.10.0-957.el7_scsi_mid_low_api">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_scsi_mid_low_api/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="Linux Kernel 2.6 series              SCSI mid_level - lower_level driver interface              &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  IntroductionThis document outlines">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_scsi_mid_low_api/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_mpc5200/" class="title">Kernel-3.10.0-957.el7_mpc5200</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_6pack/" class="title">Kernel-3.10.0-957.el7_6pack</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Documentation"><span class="toc-number">2.</span> <span class="toc-text">Documentation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Driver-structure"><span class="toc-number">3.</span> <span class="toc-text">Driver structure</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hotplug-initialization-model"><span class="toc-number">4.</span> <span class="toc-text">Hotplug initialization model</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Passive-initialization-model"><span class="toc-number">5.</span> <span class="toc-text">Passive initialization model</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference-Counting"><span class="toc-number">6.</span> <span class="toc-text">Reference Counting</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Conventions"><span class="toc-number">7.</span> <span class="toc-text">Conventions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mid-level-supplied-functions"><span class="toc-number">8.</span> <span class="toc-text">Mid level supplied functions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Interface-Functions"><span class="toc-number">9.</span> <span class="toc-text">Interface Functions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Data-Structures"><span class="toc-number">10.</span> <span class="toc-text">Data Structures</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-scsi-host-template"><span class="toc-number">10.1.</span> <span class="toc-text">struct scsi_host_template</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-Scsi-Host"><span class="toc-number">10.2.</span> <span class="toc-text">struct Scsi_Host</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-scsi-device"><span class="toc-number">10.3.</span> <span class="toc-text">struct scsi_device</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-scsi-cmnd"><span class="toc-number">10.4.</span> <span class="toc-text">struct scsi_cmnd</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Locks"><span class="toc-number">11.</span> <span class="toc-text">Locks</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Autosense"><span class="toc-number">12.</span> <span class="toc-text">Autosense</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Changes-since-lk-2-4-series"><span class="toc-number">13.</span> <span class="toc-text">Changes since lk 2.4 series</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Credits"><span class="toc-number">14.</span> <span class="toc-text">Credits</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-3.10.0-957.el7_scsi_mid_low_api" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-3.10.0-957.el7_scsi_mid_low_api
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_scsi_mid_low_api/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_scsi_mid_low_api/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-3.10.0-957.el7_scsi_mid_low_api/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <pre><code>                      Linux Kernel 2.6 series
             SCSI mid_level - lower_level driver interface
             =============================================
</code></pre>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This document outlines the interface between the Linux SCSI mid level and<br>SCSI lower level drivers. Lower level drivers (LLDs) are variously called<br>host bus adapter (HBA) drivers and host drivers (HD). A “host” in this<br>context is a bridge between a computer IO bus (e.g. PCI or ISA) and a<br>single SCSI initiator port on a SCSI transport. An “initiator” port<br>(SCSI terminology, see SAM-3 at <a target="_blank" rel="noopener" href="http://www.t10.org/">http://www.t10.org</a>) sends SCSI commands<br>to “target” SCSI ports (e.g. disks). There can be many LLDs in a running<br>system, but only one per hardware type. Most LLDs can control one or more<br>SCSI HBAs. Some HBAs contain multiple hosts.</p>
<p>In some cases the SCSI transport is an external bus that already has<br>its own subsystem in Linux (e.g. USB and ieee1394). In such cases the<br>SCSI subsystem LLD is a software bridge to the other driver subsystem.<br>Examples are the usb-storage driver (found in the drivers/usb/storage<br>directory) and the ieee1394/sbp2 driver (found in the drivers/ieee1394<br>directory).</p>
<p>For example, the aic7xxx LLD controls Adaptec SCSI parallel interface<br>(SPI) controllers based on that company’s 7xxx chip series. The aic7xxx<br>LLD can be built into the kernel or loaded as a module. There can only be<br>one aic7xxx LLD running in a Linux system but it may be controlling many<br>HBAs. These HBAs might be either on PCI daughter-boards or built into<br>the motherboard (or both). Some aic7xxx based HBAs are dual controllers<br>and thus represent two hosts. Like most modern HBAs, each aic7xxx host<br>has its own PCI device address. [The one-to-one correspondence between<br>a SCSI host and a PCI device is common but not required (e.g. with<br>ISA adapters).]</p>
<p>The SCSI mid level isolates an LLD from other layers such as the SCSI<br>upper layer drivers and the block layer.</p>
<p>This version of the document roughly matches linux kernel version 2.6.8 .</p>
<h1 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h1><p>There is a SCSI documentation directory within the kernel source tree,<br>typically Documentation/scsi . Most documents are in plain<br>(i.e. ASCII) text. This file is named scsi_mid_low_api.txt and can be<br>found in that directory. A more recent copy of this document may be found<br>at <a target="_blank" rel="noopener" href="http://web.archive.org/web/20070107183357rn_1/sg.torque.net/scsi/">http://web.archive.org/web/20070107183357rn_1/sg.torque.net/scsi/</a>.<br>Many LLDs are documented there (e.g. aic7xxx.txt). The SCSI mid-level is<br>briefly described in scsi.txt which contains a url to a document<br>describing the SCSI subsystem in the lk 2.4 series. Two upper level<br>drivers have documents in that directory: st.txt (SCSI tape driver) and<br>scsi-generic.txt (for the sg driver).</p>
<p>Some documentation (or urls) for LLDs may be found in the C source code<br>or in the same directory as the C source code. For example to find a url<br>about the USB mass storage driver see the<br>/usr/src/linux/drivers/usb/storage directory.</p>
<h1 id="Driver-structure"><a href="#Driver-structure" class="headerlink" title="Driver structure"></a>Driver structure</h1><p>Traditionally an LLD for the SCSI subsystem has been at least two files in<br>the drivers/scsi directory. For example, a driver called “xyz” has a header<br>file “xyz.h” and a source file “xyz.c”. [Actually there is no good reason<br>why this couldn’t all be in one file; the header file is superfluous.] Some<br>drivers that have been ported to several operating systems have more than<br>two files. For example the aic7xxx driver has separate files for generic<br>and OS-specific code (e.g. FreeBSD and Linux). Such drivers tend to have<br>their own directory under the drivers/scsi directory.</p>
<p>When a new LLD is being added to Linux, the following files (found in the<br>drivers/scsi directory) will need some attention: Makefile and Kconfig .<br>It is probably best to study how existing LLDs are organized.</p>
<p>As the 2.5 series development kernels evolve into the 2.6 series<br>production series, changes are being introduced into this interface. An<br>example of this is driver initialization code where there are now 2 models<br>available. The older one, similar to what was found in the lk 2.4 series,<br>is based on hosts that are detected at HBA driver load time. This will be<br>referred to the “passive” initialization model. The newer model allows HBAs<br>to be hot plugged (and unplugged) during the lifetime of the LLD and will<br>be referred to as the “hotplug” initialization model. The newer model is<br>preferred as it can handle both traditional SCSI equipment that is<br>permanently connected as well as modern “SCSI” devices (e.g. USB or<br>IEEE 1394 connected digital cameras) that are hotplugged. Both<br>initialization models are discussed in the following sections.</p>
<p>An LLD interfaces to the SCSI subsystem several ways:<br>  a) directly invoking functions supplied by the mid level<br>  b) passing a set of function pointers to a registration function<br>     supplied by the mid level. The mid level will then invoke these<br>     functions at some point in the future. The LLD will supply<br>     implementations of these functions.<br>  c) direct access to instances of well known data structures maintained<br>     by the mid level</p>
<p>Those functions in group a) are listed in a section entitled “Mid level<br>supplied functions” below.</p>
<p>Those functions in group b) are listed in a section entitled “Interface<br>functions” below. Their function pointers are placed in the members of<br>“struct scsi_host_template”, an instance of which is passed to<br>scsi_host_alloc() ** .  Those interface functions that the LLD does not<br>wish to supply should have NULL placed in the corresponding member of<br>struct scsi_host_template.  Defining an instance of struct<br>scsi_host_template at file scope will cause NULL to be  placed in function<br> pointer members not explicitly initialized.</p>
<p>Those usages in group c) should be handled with care, especially in a<br>“hotplug” environment. LLDs should be aware of the lifetime of instances<br>that are shared with the mid level and other layers.</p>
<p>All functions defined within an LLD and all data defined at file scope<br>should be static. For example the slave_alloc() function in an LLD<br>called “xxx” could be defined as<br>“static int xxx_slave_alloc(struct scsi_device * sdev) { /* code */ }”</p>
<p>** the scsi_host_alloc() function is a replacement for the rather vaguely<br>named scsi_register() function in most situations. The scsi_register()<br>and scsi_unregister() functions remain to support legacy LLDs that use<br>the passive initialization model.</p>
<h1 id="Hotplug-initialization-model"><a href="#Hotplug-initialization-model" class="headerlink" title="Hotplug initialization model"></a>Hotplug initialization model</h1><p>In this model an LLD controls when SCSI hosts are introduced and removed<br>from the SCSI subsystem. Hosts can be introduced as early as driver<br>initialization and removed as late as driver shutdown. Typically a driver<br>will respond to a sysfs probe() callback that indicates an HBA has been<br>detected. After confirming that the new device is one that the LLD wants<br>to control, the LLD will initialize the HBA and then register a new host<br>with the SCSI mid level.</p>
<p>During LLD initialization the driver should register itself with the<br>appropriate IO bus on which it expects to find HBA(s) (e.g. the PCI bus).<br>This can probably be done via sysfs. Any driver parameters (especially<br>those that are writable after the driver is loaded) could also be<br>registered with sysfs at this point. The SCSI mid level first becomes<br>aware of an LLD when that LLD registers its first HBA.</p>
<p>At some later time, the LLD becomes aware of an HBA and what follows<br>is a typical sequence of calls between the LLD and the mid level.<br>This example shows the mid level scanning the newly introduced HBA for 3<br>scsi devices of which only the first 2 respond:</p>
<pre><code> HBA PROBE: assume 2 SCSI devices found in scan
</code></pre>
<p>LLD                   mid level                    LLD<br>===——————-=========——————–===——<br>scsi_host_alloc()  –&gt;<br>scsi_add_host()  —-&gt;<br>scsi_scan_host()  ——-+<br>                         |<br>                    slave_alloc()<br>                    slave_configure() –&gt;  scsi_adjust_queue_depth()<br>                         |<br>                    slave_alloc()<br>                    slave_configure()<br>                         |<br>                    slave_alloc()   <strong>*<br>                    slave_destroy() *</strong></p>
<hr>
<p>If the LLD wants to adjust the default queue settings, it can invoke<br>scsi_adjust_queue_depth() in its slave_configure() routine.</p>
<p>*** For scsi devices that the mid level tries to scan but do not<br>    respond, a slave_alloc(), slave_destroy() pair is called.</p>
<p>When an HBA is being removed it could be as part of an orderly shutdown<br>associated with the LLD module being unloaded (e.g. with the “rmmod”<br>command) or in response to a “hot unplug” indicated by sysfs()’s<br>remove() callback being invoked. In either case, the sequence is the<br>same:</p>
<pre><code>    HBA REMOVE: assume 2 SCSI devices attached
</code></pre>
<p>LLD                      mid level                 LLD<br>===———————-=========—————–===——<br>scsi_remove_host() ———+<br>                            |<br>                     slave_destroy()<br>                     slave_destroy()<br>scsi_host_put()</p>
<hr>
<p>It may be useful for a LLD to keep track of struct Scsi_Host instances<br>(a pointer is returned by scsi_host_alloc()). Such instances are “owned”<br>by the mid-level.  struct Scsi_Host instances are freed from<br>scsi_host_put() when the reference count hits zero.</p>
<p>Hot unplugging an HBA that controls a disk which is processing SCSI<br>commands on a mounted file system is an interesting situation. Reference<br>counting logic is being introduced into the mid level to cope with many<br>of the issues involved. See the section on reference counting below.</p>
<p>The hotplug concept may be extended to SCSI devices. Currently, when an<br>HBA is added, the scsi_scan_host() function causes a scan for SCSI devices<br>attached to the HBA’s SCSI transport. On newer SCSI transports the HBA<br>may become aware of a new SCSI device <em>after</em> the scan has completed.<br>An LLD can use this sequence to make the mid level aware of a SCSI device:</p>
<pre><code>             SCSI DEVICE hotplug
</code></pre>
<p>LLD                   mid level                    LLD<br>===——————-=========——————–===——<br>scsi_add_device()  ——+<br>                         |<br>                    slave_alloc()<br>                    slave_configure()   [–&gt; scsi_adjust_queue_depth()]</p>
<hr>
<p>In a similar fashion, an LLD may become aware that a SCSI device has been<br>removed (unplugged) or the connection to it has been interrupted. Some<br>existing SCSI transports (e.g. SPI) may not become aware that a SCSI<br>device has been removed until a subsequent SCSI command fails which will<br>probably cause that device to be set offline by the mid level. An LLD that<br>detects the removal of a SCSI device can instigate its removal from<br>upper layers with this sequence:</p>
<pre><code>              SCSI DEVICE hot unplug
</code></pre>
<p>LLD                      mid level                 LLD<br>===———————-=========—————–===——<br>scsi_remove_device() ——-+<br>                            |<br>                     slave_destroy()</p>
<hr>
<p>It may be useful for an LLD to keep track of struct scsi_device instances<br>(a pointer is passed as the parameter to slave_alloc() and<br>slave_configure() callbacks). Such instances are “owned” by the mid-level.<br>struct scsi_device instances are freed after slave_destroy().</p>
<h1 id="Passive-initialization-model"><a href="#Passive-initialization-model" class="headerlink" title="Passive initialization model"></a>Passive initialization model</h1><p>These older LLDs include a file called “scsi_module.c” [yes the “.c” is a<br>little surprising] in their source code. For that file to work an<br>instance of struct scsi_host_template with the name “driver_template”<br>needs to be defined. Here is a typical code sequence used in this model:<br>    static struct scsi_host_template driver_template = {<br>        …<br>    };<br>    #include “scsi_module.c”</p>
<p>The scsi_module.c file contains two functions:</p>
<ul>
<li>init_this_scsi_driver() which is executed when the LLD is<br>initialized (i.e. boot time or module load time)</li>
<li>exit_this_scsi_driver() which is executed when the LLD is shut<br>down (i.e. module unload time)<br>Note: since these functions are tagged with __init and __exit qualifiers<br>an LLD should not call them explicitly (since the kernel does that).</li>
</ul>
<p>Here is an example of an initialization sequence when two hosts are<br>detected (so detect() returns 2) and the SCSI bus scan on each host<br>finds 1 SCSI device (and a second device does not respond).</p>
<p>LLD                      mid level                 LLD<br>===———————-=========—————–===——<br>init_this_scsi_driver() —-+<br>                            |<br>                         detect()  —————–+<br>                            |                       |<br>                            |                scsi_register()<br>                            |                scsi_register()<br>                            |<br>                      slave_alloc()<br>                      slave_configure()  –&gt;  scsi_adjust_queue_depth()<br>                      slave_alloc()   <strong>*<br>                      slave_destroy() *</strong><br>                            |<br>                      slave_alloc()<br>                      slave_configure()<br>                      slave_alloc()   <strong>*<br>                      slave_destroy() *</strong></p>
<hr>
<p>The mid level invokes scsi_adjust_queue_depth() with tagged queuing off and<br>“cmd_per_lun” for that host as the queue length. These settings can be<br>overridden by a slave_configure() supplied by the LLD.</p>
<p>*** For scsi devices that the mid level tries to scan but do not<br>    respond, a slave_alloc(), slave_destroy() pair is called.</p>
<p>Here is an LLD shutdown sequence:</p>
<p>LLD                      mid level                 LLD<br>===———————-=========—————–===——<br>exit_this_scsi_driver() —-+<br>                            |<br>                     slave_destroy()<br>                        release()   –&gt;   scsi_unregister()<br>                            |<br>                     slave_destroy()<br>                        release()   –&gt;   scsi_unregister()</p>
<hr>
<p>An LLD need not define slave_destroy() (i.e. it is optional). </p>
<p>The shortcoming of the “passive initialization model” is that host<br>registration and de-registration are (typically) tied to LLD initialization<br>and shutdown. Once the LLD is initialized then a new host that appears<br>(e.g. via hotplugging) cannot easily be added without a redundant<br>driver shutdown and re-initialization. It may be possible to write an LLD<br>that uses both initialization models.</p>
<h1 id="Reference-Counting"><a href="#Reference-Counting" class="headerlink" title="Reference Counting"></a>Reference Counting</h1><p>The Scsi_Host structure has had reference counting infrastructure added.<br>This effectively spreads the ownership of struct Scsi_Host instances<br>across the various SCSI layers which use them. Previously such instances<br>were exclusively owned by the mid level. LLDs would not usually need to<br>directly manipulate these reference counts but there may be some cases<br>where they do.</p>
<p>There are 3 reference counting functions of interest associated with<br>struct Scsi_Host:</p>
<ul>
<li>scsi_host_alloc(): returns a pointer to new instance of struct <pre><code>Scsi_Host which has its reference count ^^ set to 1
</code></pre>
</li>
<li>scsi_host_get(): adds 1 to the reference count of the given instance</li>
<li>scsi_host_put(): decrements 1 from the reference count of the given<pre><code>instance. If the reference count reaches 0 then the given instance
is freed
</code></pre>
</li>
</ul>
<p>The Scsi_device structure has had reference counting infrastructure added.<br>This effectively spreads the ownership of struct Scsi_device instances<br>across the various SCSI layers which use them. Previously such instances<br>were exclusively owned by the mid level. See the access functions declared<br>towards the end of include/scsi/scsi_device.h . If an LLD wants to keep<br>a copy of a pointer to a Scsi_device instance it should use scsi_device_get()<br>to bump its reference count. When it is finished with the pointer it can<br>use scsi_device_put() to decrement its reference count (and potentially<br>delete it).</p>
<p>^^ struct Scsi_Host actually has 2 reference counts which are manipulated<br>in parallel by these functions.</p>
<h1 id="Conventions"><a href="#Conventions" class="headerlink" title="Conventions"></a>Conventions</h1><p>First, Linus Torvalds’s thoughts on C coding style can be found in the<br>Documentation/CodingStyle file. </p>
<p>Next, there is a movement to “outlaw” typedefs introducing synonyms for<br>struct tags. Both can be still found in the SCSI subsystem, but<br>the typedefs have been moved to a single file, scsi_typedefs.h to<br>make their future removal easier, for example:<br>“typedef struct scsi_cmnd Scsi_Cmnd;”</p>
<p>Also, most C99 enhancements are encouraged to the extent they are supported<br>by the relevant gcc compilers. So C99 style structure and array<br>initializers are encouraged where appropriate. Don’t go too far,<br>VLAs are not properly supported yet.  An exception to this is the use of<br>“//“ style comments; /<em>…</em>/ comments are still preferred in Linux.</p>
<p>Well written, tested and documented code, need not be re-formatted to<br>comply with the above conventions. For example, the aic7xxx driver<br>comes to Linux from FreeBSD and Adaptec’s own labs. No doubt FreeBSD<br>and Adaptec have their own coding conventions.</p>
<h1 id="Mid-level-supplied-functions"><a href="#Mid-level-supplied-functions" class="headerlink" title="Mid level supplied functions"></a>Mid level supplied functions</h1><p>These functions are supplied by the SCSI mid level for use by LLDs.<br>The names (i.e. entry points) of these functions are exported<br>so an LLD that is a module can access them. The kernel will<br>arrange for the SCSI mid level to be loaded and initialized before any LLD<br>is initialized. The functions below are listed alphabetically and their<br>names all start with “scsi_”.</p>
<p>Summary:<br>   scsi_activate_tcq - turn on tag command queueing<br>   scsi_add_device - creates new scsi device (lu) instance<br>   scsi_add_host - perform sysfs registration and set up transport class<br>   scsi_adjust_queue_depth - change the queue depth on a SCSI device<br>   scsi_bios_ptable - return copy of block device’s partition table<br>   scsi_block_requests - prevent further commands being queued to given host<br>   scsi_deactivate_tcq - turn off tag command queueing<br>   scsi_host_alloc - return a new scsi_host instance whose refcount==1<br>   scsi_host_get - increments Scsi_Host instance’s refcount<br>   scsi_host_put - decrements Scsi_Host instance’s refcount (free if 0)<br>   scsi_partsize - parse partition table into cylinders, heads + sectors<br>   scsi_register - create and register a scsi host adapter instance.<br>   scsi_remove_device - detach and remove a SCSI device<br>   scsi_remove_host - detach and remove all SCSI devices owned by host<br>   scsi_report_bus_reset - report scsi <em>bus</em> reset observed<br>   scsi_scan_host - scan SCSI bus<br>   scsi_track_queue_full - track successive QUEUE_FULL events<br>   scsi_unblock_requests - allow further commands to be queued to given host<br>   scsi_unregister - [calls scsi_host_put()]</p>
<p>Details:</p>
<p>/**</p>
<ul>
<li>scsi_activate_tcq - turn on tag command queueing (“ordered” task attribute)</li>
<li>@sdev:       device to turn on TCQ for</li>
<li>@depth:      queue depth</li>
<li></li>
<li><pre><code> Returns nothing
</code></pre>
</li>
<li></li>
<li><pre><code> Might block: no
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: Eventually, it is hoped depth would be the maximum depth
</code></pre>
</li>
<li><pre><code> the device could cope with and the real queue depth
</code></pre>
</li>
<li><pre><code> would be adjustable from 0 to depth.
</code></pre>
</li>
<li></li>
<li><pre><code> Defined (inline) in: include/scsi/scsi_tcq.h
</code></pre>
</li>
<li>*/<br>void scsi_activate_tcq(struct scsi_device *sdev, int depth)</li>
</ul>
<p>/**</p>
<ul>
<li>scsi_add_device - creates new scsi device (lu) instance</li>
<li>@shost:   pointer to scsi host instance</li>
<li>@channel: channel number (rarely other than 0)</li>
<li>@id:      target id number</li>
<li>@lun:     logical unit number</li>
<li></li>
<li><pre><code> Returns pointer to new struct scsi_device instance or 
</code></pre>
</li>
<li><pre><code> ERR_PTR(-ENODEV) (or some other bent pointer) if something is
</code></pre>
</li>
<li><pre><code> wrong (e.g. no lu responds at given address)
</code></pre>
</li>
<li></li>
<li><pre><code> Might block: yes
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: This call is usually performed internally during a scsi
</code></pre>
</li>
<li><pre><code> bus scan when an HBA is added (i.e. scsi_scan_host()). So it
</code></pre>
</li>
<li><pre><code> should only be called if the HBA becomes aware of a new scsi
</code></pre>
</li>
<li><pre><code> device (lu) after scsi_scan_host() has completed. If successful
</code></pre>
</li>
<li><pre><code> this call can lead to slave_alloc() and slave_configure() callbacks
</code></pre>
</li>
<li><pre><code> into the LLD.
</code></pre>
</li>
<li></li>
<li><pre><code> Defined in: drivers/scsi/scsi_scan.c
</code></pre>
</li>
<li>*/<br>struct scsi_device * scsi_add_device(struct Scsi_Host *shost, <pre><code>                               unsigned int channel,
                               unsigned int id, unsigned int lun)
</code></pre>
</li>
</ul>
<p>/**</p>
<ul>
<li>scsi_add_host - perform sysfs registration and set up transport class</li>
<li>@shost:   pointer to scsi host instance</li>
<li>@dev:     pointer to struct device of type scsi class</li>
<li></li>
<li><pre><code> Returns 0 on success, negative errno of failure (e.g. -ENOMEM)
</code></pre>
</li>
<li></li>
<li><pre><code> Might block: no
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: Only required in &quot;hotplug initialization model&quot; after a
</code></pre>
</li>
<li><pre><code> successful call to scsi_host_alloc().  This function does not
</code></pre>
</li>
<li>   scan the bus; this can be done by calling scsi_scan_host() or</li>
<li>   in some other transport-specific way.  The LLD must set up</li>
<li>   the transport template before calling this function and may only</li>
<li>   access the transport class data after this function has been called.</li>
<li></li>
<li><pre><code> Defined in: drivers/scsi/hosts.c
</code></pre>
</li>
<li>*/<br>int scsi_add_host(struct Scsi_Host *shost, struct device * dev)</li>
</ul>
<p>/**</p>
<ul>
<li>scsi_adjust_queue_depth - allow LLD to change queue depth on a SCSI device</li>
<li>@sdev:       pointer to SCSI device to change queue depth on</li>
<li>@tagged:     0 - no tagged queuing</li>
<li><pre><code>         MSG_SIMPLE_TAG - simple tagged queuing
</code></pre>
</li>
<li><pre><code>         MSG_ORDERED_TAG - ordered tagged queuing
</code></pre>
</li>
<li>@tags        Number of tags allowed if tagged queuing enabled,</li>
<li><pre><code>         or number of commands the LLD can queue up
</code></pre>
</li>
<li><pre><code>         in non-tagged mode (as per cmd_per_lun).
</code></pre>
</li>
<li></li>
<li><pre><code> Returns nothing
</code></pre>
</li>
<li></li>
<li><pre><code> Might block: no
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: Can be invoked any time on a SCSI device controlled by this
</code></pre>
</li>
<li><pre><code> LLD. [Specifically during and after slave_configure() and prior to
</code></pre>
</li>
<li><pre><code> slave_destroy().] Can safely be invoked from interrupt code. Actual
</code></pre>
</li>
<li><pre><code> queue depth change may be delayed until the next command is being
</code></pre>
</li>
<li><pre><code> processed. See also scsi_activate_tcq() and scsi_deactivate_tcq().
</code></pre>
</li>
<li></li>
<li><pre><code> Defined in: drivers/scsi/scsi.c [see source code for more notes]
</code></pre>
</li>
<li></li>
<li>*/<br>void scsi_adjust_queue_depth(struct scsi_device * sdev, int tagged, <pre><code>                       int tags)
</code></pre>
</li>
</ul>
<p>/**</p>
<ul>
<li>scsi_bios_ptable - return copy of block device’s partition table</li>
<li>@dev:        pointer to block device</li>
<li></li>
<li><pre><code> Returns pointer to partition table, or NULL for failure
</code></pre>
</li>
<li></li>
<li><pre><code> Might block: yes
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: Caller owns memory returned (free with kfree() )
</code></pre>
</li>
<li></li>
<li><pre><code> Defined in: drivers/scsi/scsicam.c
</code></pre>
</li>
<li>*/<br>unsigned char *scsi_bios_ptable(struct block_device *dev)</li>
</ul>
<p>/**</p>
<ul>
<li>scsi_block_requests - prevent further commands being queued to given host</li>
<li></li>
<li>@shost: pointer to host to block commands on</li>
<li></li>
<li><pre><code> Returns nothing
</code></pre>
</li>
<li></li>
<li><pre><code> Might block: no
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: There is no timer nor any other means by which the requests
</code></pre>
</li>
<li><pre><code> get unblocked other than the LLD calling scsi_unblock_requests().
</code></pre>
</li>
<li></li>
<li><pre><code> Defined in: drivers/scsi/scsi_lib.c
</code></pre>
</li>
<li>*/<br>void scsi_block_requests(struct Scsi_Host * shost)</li>
</ul>
<p>/**</p>
<ul>
<li>scsi_deactivate_tcq - turn off tag command queueing</li>
<li>@sdev:       device to turn off TCQ for</li>
<li>@depth:      queue depth (stored in sdev)</li>
<li></li>
<li><pre><code> Returns nothing
</code></pre>
</li>
<li></li>
<li><pre><code> Might block: no
</code></pre>
</li>
<li></li>
<li><pre><code> Defined (inline) in: include/scsi/scsi_tcq.h
</code></pre>
</li>
<li>*/<br>void scsi_deactivate_tcq(struct scsi_device *sdev, int depth)</li>
</ul>
<p>/**</p>
<ul>
<li>scsi_host_alloc - create a scsi host adapter instance and perform basic</li>
<li><pre><code>              initialization.
</code></pre>
</li>
<li>@sht:        pointer to scsi host template</li>
<li>@privsize:   extra bytes to allocate in hostdata array (which is the</li>
<li><pre><code>         last member of the returned Scsi_Host instance)
</code></pre>
</li>
<li></li>
<li><pre><code> Returns pointer to new Scsi_Host instance or NULL on failure
</code></pre>
</li>
<li></li>
<li><pre><code> Might block: yes
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: When this call returns to the LLD, the SCSI bus scan on
</code></pre>
</li>
<li><pre><code> this host has _not_ yet been done.
</code></pre>
</li>
<li><pre><code> The hostdata array (by default zero length) is a per host scratch 
</code></pre>
</li>
<li><pre><code> area for the LLD&#39;s exclusive use.
</code></pre>
</li>
<li><pre><code> Both associated refcounting objects have their refcount set to 1.
</code></pre>
</li>
<li><pre><code> Full registration (in sysfs) and a bus scan are performed later when
</code></pre>
</li>
<li><pre><code> scsi_add_host() and scsi_scan_host() are called.
</code></pre>
</li>
<li></li>
<li><pre><code> Defined in: drivers/scsi/hosts.c .
</code></pre>
</li>
<li>*/<br>struct Scsi_Host * scsi_host_alloc(struct scsi_host_template * sht,<pre><code>                             int privsize)
</code></pre>
</li>
</ul>
<p>/**</p>
<ul>
<li>scsi_host_get - increment Scsi_Host instance refcount</li>
<li>@shost:   pointer to struct Scsi_Host instance</li>
<li></li>
<li><pre><code> Returns nothing
</code></pre>
</li>
<li></li>
<li><pre><code> Might block: currently may block but may be changed to not block
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: Actually increments the counts in two sub-objects
</code></pre>
</li>
<li></li>
<li><pre><code> Defined in: drivers/scsi/hosts.c
</code></pre>
</li>
<li>*/<br>void scsi_host_get(struct Scsi_Host *shost)</li>
</ul>
<p>/**</p>
<ul>
<li>scsi_host_put - decrement Scsi_Host instance refcount, free if 0</li>
<li>@shost:   pointer to struct Scsi_Host instance</li>
<li></li>
<li><pre><code> Returns nothing
</code></pre>
</li>
<li></li>
<li><pre><code> Might block: currently may block but may be changed to not block
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: Actually decrements the counts in two sub-objects. If the
</code></pre>
</li>
<li><pre><code> latter refcount reaches 0, the Scsi_Host instance is freed.
</code></pre>
</li>
<li><pre><code> The LLD need not worry exactly when the Scsi_Host instance is
</code></pre>
</li>
<li><pre><code> freed, it just shouldn&#39;t access the instance after it has balanced
</code></pre>
</li>
<li><pre><code> out its refcount usage.
</code></pre>
</li>
<li></li>
<li><pre><code> Defined in: drivers/scsi/hosts.c
</code></pre>
</li>
<li>*/<br>void scsi_host_put(struct Scsi_Host *shost)</li>
</ul>
<p>/**</p>
<ul>
<li>scsi_partsize - parse partition table into cylinders, heads + sectors</li>
<li>@buf: pointer to partition table</li>
<li>@capacity: size of (total) disk in 512 byte sectors</li>
<li>@cyls: outputs number of cylinders calculated via this pointer</li>
<li>@hds: outputs number of heads calculated via this pointer</li>
<li>@secs: outputs number of sectors calculated via this pointer</li>
<li></li>
<li><pre><code> Returns 0 on success, -1 on failure
</code></pre>
</li>
<li></li>
<li><pre><code> Might block: no
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: Caller owns memory returned (free with kfree() )
</code></pre>
</li>
<li></li>
<li><pre><code> Defined in: drivers/scsi/scsicam.c
</code></pre>
</li>
<li>*/<br>int scsi_partsize(unsigned char *buf, unsigned long capacity,<pre><code>            unsigned int *cyls, unsigned int *hds, unsigned int *secs)
</code></pre>
</li>
</ul>
<p>/**</p>
<ul>
<li>scsi_register - create and register a scsi host adapter instance.</li>
<li>@sht:        pointer to scsi host template</li>
<li>@privsize:   extra bytes to allocate in hostdata array (which is the</li>
<li><pre><code>         last member of the returned Scsi_Host instance)
</code></pre>
</li>
<li></li>
<li><pre><code> Returns pointer to new Scsi_Host instance or NULL on failure
</code></pre>
</li>
<li></li>
<li><pre><code> Might block: yes
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: When this call returns to the LLD, the SCSI bus scan on
</code></pre>
</li>
<li><pre><code> this host has _not_ yet been done.
</code></pre>
</li>
<li><pre><code> The hostdata array (by default zero length) is a per host scratch 
</code></pre>
</li>
<li><pre><code> area for the LLD.
</code></pre>
</li>
<li></li>
<li><pre><code> Defined in: drivers/scsi/hosts.c .
</code></pre>
</li>
<li>*/<br>struct Scsi_Host * scsi_register(struct scsi_host_template * sht,<pre><code>                           int privsize)
</code></pre>
</li>
</ul>
<p>/**</p>
<ul>
<li>scsi_remove_device - detach and remove a SCSI device</li>
<li>@sdev:      a pointer to a scsi device instance</li>
<li></li>
<li><pre><code> Returns value: 0 on success, -EINVAL if device not attached
</code></pre>
</li>
<li></li>
<li><pre><code> Might block: yes
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: If an LLD becomes aware that a scsi device (lu) has
</code></pre>
</li>
<li><pre><code> been removed but its host is still present then it can request
</code></pre>
</li>
<li><pre><code> the removal of that scsi device. If successful this call will
</code></pre>
</li>
<li><pre><code> lead to the slave_destroy() callback being invoked. sdev is an 
</code></pre>
</li>
<li><pre><code> invalid pointer after this call.
</code></pre>
</li>
<li></li>
<li><pre><code> Defined in: drivers/scsi/scsi_sysfs.c .
</code></pre>
</li>
<li>*/<br>int scsi_remove_device(struct scsi_device *sdev)</li>
</ul>
<p>/**</p>
<ul>
<li>scsi_remove_host - detach and remove all SCSI devices owned by host</li>
<li>@shost:      a pointer to a scsi host instance</li>
<li></li>
<li><pre><code> Returns value: 0 on success, 1 on failure (e.g. LLD busy ??)
</code></pre>
</li>
<li></li>
<li><pre><code> Might block: yes
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: Should only be invoked if the &quot;hotplug initialization
</code></pre>
</li>
<li><pre><code> model&quot; is being used. It should be called _prior_ to  
</code></pre>
</li>
<li><pre><code> scsi_unregister().
</code></pre>
</li>
<li></li>
<li><pre><code> Defined in: drivers/scsi/hosts.c .
</code></pre>
</li>
<li>*/<br>int scsi_remove_host(struct Scsi_Host *shost)</li>
</ul>
<p>/**</p>
<ul>
<li>scsi_report_bus_reset - report scsi <em>bus</em> reset observed</li>
<li>@shost: a pointer to a scsi host involved</li>
<li>@channel: channel (within) host on which scsi bus reset occurred</li>
<li></li>
<li><pre><code> Returns nothing
</code></pre>
</li>
<li></li>
<li><pre><code> Might block: no
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: This only needs to be called if the reset is one which
</code></pre>
</li>
<li><pre><code> originates from an unknown location.  Resets originated by the 
</code></pre>
</li>
<li><pre><code> mid level itself don&#39;t need to call this, but there should be 
</code></pre>
</li>
<li><pre><code> no harm.  The main purpose of this is to make sure that a
</code></pre>
</li>
<li><pre><code> CHECK_CONDITION is properly treated.
</code></pre>
</li>
<li></li>
<li><pre><code> Defined in: drivers/scsi/scsi_error.c .
</code></pre>
</li>
<li>*/<br>void scsi_report_bus_reset(struct Scsi_Host * shost, int channel)</li>
</ul>
<p>/**</p>
<ul>
<li>scsi_scan_host - scan SCSI bus</li>
<li>@shost: a pointer to a scsi host instance</li>
<li></li>
<li>   Might block: yes</li>
<li></li>
<li>   Notes: Should be called after scsi_add_host()</li>
<li></li>
<li>   Defined in: drivers/scsi/scsi_scan.c</li>
<li>*/<br>void scsi_scan_host(struct Scsi_Host *shost)</li>
</ul>
<p>/**</p>
<ul>
<li>scsi_track_queue_full - track successive QUEUE_FULL events on given</li>
<li><pre><code>                 device to determine if and when there is a need
</code></pre>
</li>
<li><pre><code>                 to adjust the queue depth on the device.
</code></pre>
</li>
<li>@sdev:  pointer to SCSI device instance</li>
<li>@depth: Current number of outstanding SCSI commands on this device,</li>
<li><pre><code>    not counting the one returned as QUEUE_FULL.
</code></pre>
</li>
<li></li>
<li><pre><code> Returns 0  - no change needed
</code></pre>
</li>
<li><pre><code>         &gt;0 - adjust queue depth to this new depth
</code></pre>
</li>
<li><pre><code>         -1 - drop back to untagged operation using host-&gt;cmd_per_lun
</code></pre>
</li>
<li><pre><code>              as the untagged command depth
</code></pre>
</li>
<li></li>
<li><pre><code> Might block: no
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: LLDs may call this at any time and we will do &quot;The Right
</code></pre>
</li>
<li><pre><code>         Thing&quot;; interrupt context safe. 
</code></pre>
</li>
<li></li>
<li><pre><code> Defined in: drivers/scsi/scsi.c .
</code></pre>
</li>
<li>*/<br>int scsi_track_queue_full(struct scsi_device *sdev, int depth)</li>
</ul>
<p>/**</p>
<ul>
<li>scsi_unblock_requests - allow further commands to be queued to given host</li>
<li></li>
<li>@shost: pointer to host to unblock commands on</li>
<li></li>
<li><pre><code> Returns nothing
</code></pre>
</li>
<li></li>
<li><pre><code> Might block: no
</code></pre>
</li>
<li></li>
<li><pre><code> Defined in: drivers/scsi/scsi_lib.c .
</code></pre>
</li>
<li>*/<br>void scsi_unblock_requests(struct Scsi_Host * shost)</li>
</ul>
<p>/**</p>
<ul>
<li>scsi_unregister - unregister and free memory used by host instance</li>
<li>@shp:        pointer to scsi host instance to unregister.</li>
<li></li>
<li><pre><code> Returns nothing
</code></pre>
</li>
<li></li>
<li><pre><code> Might block: no
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: Should not be invoked if the &quot;hotplug initialization
</code></pre>
</li>
<li><pre><code> model&quot; is being used. Called internally by exit_this_scsi_driver()
</code></pre>
</li>
<li><pre><code> in the &quot;passive initialization model&quot;. Hence a LLD has no need to
</code></pre>
</li>
<li><pre><code> call this function directly.
</code></pre>
</li>
<li></li>
<li><pre><code> Defined in: drivers/scsi/hosts.c .
</code></pre>
</li>
<li>*/<br>void scsi_unregister(struct Scsi_Host * shp)</li>
</ul>
<h1 id="Interface-Functions"><a href="#Interface-Functions" class="headerlink" title="Interface Functions"></a>Interface Functions</h1><p>Interface functions are supplied (defined) by LLDs and their function<br>pointers are placed in an instance of struct scsi_host_template which<br>is passed to scsi_host_alloc() [or scsi_register() / init_this_scsi_driver()].<br>Some are mandatory. Interface functions should be declared static. The<br>accepted convention is that driver “xyz” will declare its slave_configure()<br>function as:<br>    static int xyz_slave_configure(struct scsi_device * sdev);<br>and so forth for all interface functions listed below.</p>
<p>A pointer to this function should be placed in the ‘slave_configure’ member<br>of a “struct scsi_host_template” instance. A pointer to such an instance<br>should be passed to the mid level’s scsi_host_alloc() [or scsi_register() /<br>init_this_scsi_driver()].</p>
<p>The interface functions are also described in the include/scsi/scsi_host.h<br>file immediately above their definition point in “struct scsi_host_template”.<br>In some cases more detail is given in scsi_host.h than below.</p>
<p>The interface functions are listed below in alphabetical order.</p>
<p>Summary:<br>   bios_param - fetch head, sector, cylinder info for a disk<br>   detect - detects HBAs this driver wants to control<br>   eh_timed_out - notify the host that a command timer expired<br>   eh_abort_handler - abort given command<br>   eh_bus_reset_handler - issue SCSI bus reset<br>   eh_device_reset_handler - issue SCSI device reset<br>   eh_host_reset_handler - reset host (host bus adapter)<br>   info - supply information about given host<br>   ioctl - driver can respond to ioctls<br>   proc_info - supports /proc/scsi/{driver_name}/{host_no}<br>   queuecommand - queue scsi command, invoke ‘done’ on completion<br>   release - release all resources associated with given host<br>   slave_alloc - prior to any commands being sent to a new device<br>   slave_configure - driver fine tuning for given device after attach<br>   slave_destroy - given device is about to be shut down</p>
<p>Details:</p>
<p>/**</p>
<ul>
<li><pre><code> bios_param - fetch head, sector, cylinder info for a disk
</code></pre>
</li>
<li><pre><code> @sdev: pointer to scsi device context (defined in 
</code></pre>
</li>
<li><pre><code>        include/scsi/scsi_device.h)
</code></pre>
</li>
<li><pre><code> @bdev: pointer to block device context (defined in fs.h)
</code></pre>
</li>
<li><pre><code> @capacity:  device size (in 512 byte sectors)
</code></pre>
</li>
<li><pre><code> @params: three element array to place output:
</code></pre>
</li>
<li><pre><code>         params[0] number of heads (max 255)
</code></pre>
</li>
<li><pre><code>         params[1] number of sectors (max 63)
</code></pre>
</li>
<li><pre><code>         params[2] number of cylinders 
</code></pre>
</li>
<li></li>
<li><pre><code> Return value is ignored
</code></pre>
</li>
<li></li>
<li><pre><code> Locks: none
</code></pre>
</li>
<li></li>
<li><pre><code> Calling context: process (sd)
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: an arbitrary geometry (based on READ CAPACITY) is used
</code></pre>
</li>
<li><pre><code> if this function is not provided. The params array is
</code></pre>
</li>
<li><pre><code> pre-initialized with made up values just in case this function 
</code></pre>
</li>
<li><pre><code> doesn&#39;t output anything.
</code></pre>
</li>
<li></li>
<li><pre><code> Optionally defined in: LLD
</code></pre>
</li>
<li>*/<br>  int bios_param(struct scsi_device * sdev, struct block_device *bdev,<pre><code>             sector_t capacity, int params[3])
</code></pre>
</li>
</ul>
<p>/**</p>
<ul>
<li><pre><code> detect - detects HBAs this driver wants to control
</code></pre>
</li>
<li><pre><code> @shtp: host template for this driver.
</code></pre>
</li>
<li></li>
<li><pre><code> Returns number of hosts this driver wants to control. 0 means no
</code></pre>
</li>
<li><pre><code> suitable hosts found.
</code></pre>
</li>
<li></li>
<li><pre><code> Locks: none held
</code></pre>
</li>
<li></li>
<li><pre><code> Calling context: process [invoked from init_this_scsi_driver()]
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: First function called from the SCSI mid level on this
</code></pre>
</li>
<li><pre><code> driver. Upper level drivers (e.g. sd) may not (yet) be present.
</code></pre>
</li>
<li><pre><code> For each host found, this method should call scsi_register() 
</code></pre>
</li>
<li><pre><code> [see hosts.c].
</code></pre>
</li>
<li></li>
<li><pre><code> Defined in: LLD (required if &quot;passive initialization mode&quot; is used,
</code></pre>
</li>
<li><pre><code>                  not invoked in &quot;hotplug initialization mode&quot;)
</code></pre>
</li>
<li>*/<br>  int detect(struct scsi_host_template * shtp)</li>
</ul>
<p>/**</p>
<ul>
<li><pre><code> eh_timed_out - The timer for the command has just fired
</code></pre>
</li>
<li><pre><code> @scp: identifies command timing out
</code></pre>
</li>
<li></li>
<li><pre><code> Returns:
</code></pre>
</li>
<li></li>
<li><pre><code> EH_HANDLED:             I fixed the error, please complete the command
</code></pre>
</li>
<li><pre><code> EH_RESET_TIMER:         I need more time, reset the timer and
</code></pre>
</li>
<li><pre><code>                         begin counting again
</code></pre>
</li>
<li><pre><code> EH_NOT_HANDLED          Begin normal error recovery
</code></pre>
</li>
<li></li>
<li></li>
<li><pre><code> Locks: None held
</code></pre>
</li>
<li></li>
<li><pre><code> Calling context: interrupt
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: This is to give the LLD an opportunity to do local recovery.
</code></pre>
</li>
<li><pre><code> This recovery is limited to determining if the outstanding command
</code></pre>
</li>
<li><pre><code> will ever complete.  You may not abort and restart the command from
</code></pre>
</li>
<li><pre><code> this callback.
</code></pre>
</li>
<li></li>
<li><pre><code> Optionally defined in: LLD
</code></pre>
</li>
<li>*/<br>   int eh_timed_out(struct scsi_cmnd * scp)</li>
</ul>
<p>/**</p>
<ul>
<li><pre><code> eh_abort_handler - abort command associated with scp
</code></pre>
</li>
<li><pre><code> @scp: identifies command to be aborted
</code></pre>
</li>
<li></li>
<li><pre><code> Returns SUCCESS if command aborted else FAILED
</code></pre>
</li>
<li></li>
<li><pre><code> Locks: None held
</code></pre>
</li>
<li></li>
<li><pre><code> Calling context: kernel thread
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: If &#39;no_async_abort&#39; is defined this callback
</code></pre>
</li>
<li><pre><code> will be invoked from scsi_eh thread. No other commands
</code></pre>
</li>
<li>   will then be queued on current host during eh.</li>
<li>   Otherwise it will be called whenever scsi_times_out()</li>
<li><pre><code> is called due to a command timeout.
</code></pre>
</li>
<li></li>
<li><pre><code> Optionally defined in: LLD
</code></pre>
</li>
<li>*/<br>   int eh_abort_handler(struct scsi_cmnd * scp)</li>
</ul>
<p>/**</p>
<ul>
<li><pre><code> eh_bus_reset_handler - issue SCSI bus reset
</code></pre>
</li>
<li><pre><code> @scp: SCSI bus that contains this device should be reset
</code></pre>
</li>
<li></li>
<li><pre><code> Returns SUCCESS if command aborted else FAILED
</code></pre>
</li>
<li></li>
<li><pre><code> Locks: None held
</code></pre>
</li>
<li></li>
<li><pre><code> Calling context: kernel thread
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: Invoked from scsi_eh thread. No other commands will be
</code></pre>
</li>
<li><pre><code> queued on current host during eh.
</code></pre>
</li>
<li></li>
<li><pre><code> Optionally defined in: LLD
</code></pre>
</li>
<li>*/<br>   int eh_bus_reset_handler(struct scsi_cmnd * scp)</li>
</ul>
<p>/**</p>
<ul>
<li><pre><code> eh_device_reset_handler - issue SCSI device reset
</code></pre>
</li>
<li><pre><code> @scp: identifies SCSI device to be reset
</code></pre>
</li>
<li></li>
<li><pre><code> Returns SUCCESS if command aborted else FAILED
</code></pre>
</li>
<li></li>
<li><pre><code> Locks: None held
</code></pre>
</li>
<li></li>
<li><pre><code> Calling context: kernel thread
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: Invoked from scsi_eh thread. No other commands will be
</code></pre>
</li>
<li><pre><code> queued on current host during eh.
</code></pre>
</li>
<li></li>
<li><pre><code> Optionally defined in: LLD
</code></pre>
</li>
<li>*/<br>   int eh_device_reset_handler(struct scsi_cmnd * scp)</li>
</ul>
<p>/**</p>
<ul>
<li><pre><code> eh_host_reset_handler - reset host (host bus adapter)
</code></pre>
</li>
<li><pre><code> @scp: SCSI host that contains this device should be reset
</code></pre>
</li>
<li></li>
<li><pre><code> Returns SUCCESS if command aborted else FAILED
</code></pre>
</li>
<li></li>
<li><pre><code> Locks: None held
</code></pre>
</li>
<li></li>
<li><pre><code> Calling context: kernel thread
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: Invoked from scsi_eh thread. No other commands will be
</code></pre>
</li>
<li><pre><code> queued on current host during eh. 
</code></pre>
</li>
<li><pre><code> With the default eh_strategy in place, if none of the _abort_, 
</code></pre>
</li>
<li><pre><code> _device_reset_, _bus_reset_ or this eh handler function are 
</code></pre>
</li>
<li><pre><code> defined (or they all return FAILED) then the device in question 
</code></pre>
</li>
<li><pre><code> will be set offline whenever eh is invoked.
</code></pre>
</li>
<li></li>
<li><pre><code> Optionally defined in: LLD
</code></pre>
</li>
<li>*/<br>   int eh_host_reset_handler(struct scsi_cmnd * scp)</li>
</ul>
<p>/**</p>
<ul>
<li><pre><code> info - supply information about given host: driver name plus data
</code></pre>
</li>
<li><pre><code>        to distinguish given host
</code></pre>
</li>
<li><pre><code> @shp: host to supply information about
</code></pre>
</li>
<li></li>
<li><pre><code> Return ASCII null terminated string. [This driver is assumed to
</code></pre>
</li>
<li><pre><code> manage the memory pointed to and maintain it, typically for the
</code></pre>
</li>
<li><pre><code> lifetime of this host.]
</code></pre>
</li>
<li></li>
<li><pre><code> Locks: none
</code></pre>
</li>
<li></li>
<li><pre><code> Calling context: process
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: Often supplies PCI or ISA information such as IO addresses
</code></pre>
</li>
<li><pre><code> and interrupt numbers. If not supplied struct Scsi_Host::name used
</code></pre>
</li>
<li><pre><code> instead. It is assumed the returned information fits on one line 
</code></pre>
</li>
<li><pre><code> (i.e. does not included embedded newlines).
</code></pre>
</li>
<li><pre><code> The SCSI_IOCTL_PROBE_HOST ioctl yields the string returned by this
</code></pre>
</li>
<li><pre><code> function (or struct Scsi_Host::name if this function is not
</code></pre>
</li>
<li><pre><code> available).
</code></pre>
</li>
<li><pre><code> In a similar manner, init_this_scsi_driver() outputs to the console
</code></pre>
</li>
<li><pre><code> each host&#39;s &quot;info&quot; (or name) for the driver it is registering.
</code></pre>
</li>
<li><pre><code> Also if proc_info() is not supplied, the output of this function
</code></pre>
</li>
<li><pre><code> is used instead.
</code></pre>
</li>
<li></li>
<li><pre><code> Optionally defined in: LLD
</code></pre>
</li>
<li>*/<br>  const char * info(struct Scsi_Host * shp)</li>
</ul>
<p>/**</p>
<ul>
<li><pre><code> ioctl - driver can respond to ioctls
</code></pre>
</li>
<li><pre><code> @sdp: device that ioctl was issued for
</code></pre>
</li>
<li><pre><code> @cmd: ioctl number
</code></pre>
</li>
<li><pre><code> @arg: pointer to read or write data from. Since it points to
</code></pre>
</li>
<li><pre><code>       user space, should use appropriate kernel functions
</code></pre>
</li>
<li><pre><code>       (e.g. copy_from_user() ). In the Unix style this argument
</code></pre>
</li>
<li><pre><code>       can also be viewed as an unsigned long.
</code></pre>
</li>
<li></li>
<li><pre><code> Returns negative &quot;errno&quot; value when there is a problem. 0 or a
</code></pre>
</li>
<li><pre><code> positive value indicates success and is returned to the user space.
</code></pre>
</li>
<li></li>
<li><pre><code> Locks: none
</code></pre>
</li>
<li></li>
<li><pre><code> Calling context: process
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: The SCSI subsystem uses a &quot;trickle down&quot; ioctl model.
</code></pre>
</li>
<li><pre><code> The user issues an ioctl() against an upper level driver
</code></pre>
</li>
<li><pre><code> (e.g. /dev/sdc) and if the upper level driver doesn&#39;t recognize
</code></pre>
</li>
<li><pre><code> the &#39;cmd&#39; then it is passed to the SCSI mid level. If the SCSI
</code></pre>
</li>
<li><pre><code> mid level does not recognize it, then the LLD that controls
</code></pre>
</li>
<li><pre><code> the device receives the ioctl. According to recent Unix standards
</code></pre>
</li>
<li><pre><code> unsupported ioctl() &#39;cmd&#39; numbers should return -ENOTTY.
</code></pre>
</li>
<li></li>
<li><pre><code> Optionally defined in: LLD
</code></pre>
</li>
<li>*/<br>  int ioctl(struct scsi_device *sdp, int cmd, void *arg)</li>
</ul>
<p>/**</p>
<ul>
<li><pre><code> proc_info - supports /proc/scsi/&#123;driver_name&#125;/&#123;host_no&#125;
</code></pre>
</li>
<li><pre><code> @buffer: anchor point to output to (0==writeto1_read0) or fetch from
</code></pre>
</li>
<li><pre><code>          (1==writeto1_read0).
</code></pre>
</li>
<li><pre><code> @start: where &quot;interesting&quot; data is written to. Ignored when
</code></pre>
</li>
<li><pre><code>         1==writeto1_read0.
</code></pre>
</li>
<li><pre><code> @offset: offset within buffer 0==writeto1_read0 is actually
</code></pre>
</li>
<li><pre><code>          interested in. Ignored when 1==writeto1_read0 .
</code></pre>
</li>
<li><pre><code> @length: maximum (or actual) extent of buffer
</code></pre>
</li>
<li><pre><code> @host_no: host number of interest (struct Scsi_Host::host_no)
</code></pre>
</li>
<li><pre><code> @writeto1_read0: 1 -&gt; data coming from user space towards driver
</code></pre>
</li>
<li><pre><code>                       (e.g. &quot;echo some_string &gt; /proc/scsi/xyz/2&quot;)
</code></pre>
</li>
<li><pre><code>                  0 -&gt; user what data from this driver
</code></pre>
</li>
<li><pre><code>                       (e.g. &quot;cat /proc/scsi/xyz/2&quot;)
</code></pre>
</li>
<li></li>
<li><pre><code> Returns length when 1==writeto1_read0. Otherwise number of chars
</code></pre>
</li>
<li><pre><code> output to buffer past offset.
</code></pre>
</li>
<li></li>
<li><pre><code> Locks: none held
</code></pre>
</li>
<li></li>
<li><pre><code> Calling context: process
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: Driven from scsi_proc.c which interfaces to proc_fs. proc_fs
</code></pre>
</li>
<li><pre><code> support can now be configured out of the scsi subsystem.
</code></pre>
</li>
<li></li>
<li><pre><code> Optionally defined in: LLD
</code></pre>
</li>
<li><em>/<br>  int proc_info(char * buffer, char *</em> start, off_t offset, <pre><code>            int length, int host_no, int writeto1_read0)
</code></pre>
</li>
</ul>
<p>/**</p>
<ul>
<li><pre><code> queuecommand - queue scsi command, invoke scp-&gt;scsi_done on completion
</code></pre>
</li>
<li><pre><code> @shost: pointer to the scsi host object
</code></pre>
</li>
<li><pre><code> @scp: pointer to scsi command object
</code></pre>
</li>
<li></li>
<li><pre><code> Returns 0 on success.
</code></pre>
</li>
<li></li>
<li><pre><code> If there&#39;s a failure, return either:
</code></pre>
</li>
<li></li>
<li><pre><code> SCSI_MLQUEUE_DEVICE_BUSY if the device queue is full, or
</code></pre>
</li>
<li><pre><code> SCSI_MLQUEUE_HOST_BUSY if the entire host queue is full
</code></pre>
</li>
<li></li>
<li><pre><code> On both of these returns, the mid-layer will requeue the I/O
</code></pre>
</li>
<li></li>
<li><pre><code> - if the return is SCSI_MLQUEUE_DEVICE_BUSY, only that particular
</code></pre>
</li>
<li><pre><code> device will be paused, and it will be unpaused when a command to
</code></pre>
</li>
<li><pre><code> the device returns (or after a brief delay if there are no more
</code></pre>
</li>
<li><pre><code> outstanding commands to it).  Commands to other devices continue
</code></pre>
</li>
<li><pre><code> to be processed normally.
</code></pre>
</li>
<li></li>
<li><pre><code> - if the return is SCSI_MLQUEUE_HOST_BUSY, all I/O to the host
</code></pre>
</li>
<li><pre><code> is paused and will be unpaused when any command returns from
</code></pre>
</li>
<li><pre><code> the host (or after a brief delay if there are no outstanding
</code></pre>
</li>
<li><pre><code> commands to the host).
</code></pre>
</li>
<li></li>
<li><pre><code> For compatibility with earlier versions of queuecommand, any
</code></pre>
</li>
<li><pre><code> other return value is treated the same as
</code></pre>
</li>
<li><pre><code> SCSI_MLQUEUE_HOST_BUSY.
</code></pre>
</li>
<li></li>
<li><pre><code> Other types of errors that are detected immediately may be
</code></pre>
</li>
<li><pre><code> flagged by setting scp-&gt;result to an appropriate value,
</code></pre>
</li>
<li><pre><code> invoking the scp-&gt;scsi_done callback, and then returning 0
</code></pre>
</li>
<li><pre><code> from this function. If the command is not performed
</code></pre>
</li>
<li><pre><code> immediately (and the LLD is starting (or will start) the given
</code></pre>
</li>
<li><pre><code> command) then this function should place 0 in scp-&gt;result and
</code></pre>
</li>
<li><pre><code> return 0.
</code></pre>
</li>
<li></li>
<li><pre><code> Command ownership.  If the driver returns zero, it owns the
</code></pre>
</li>
<li><pre><code> command and must take responsibility for ensuring the
</code></pre>
</li>
<li><pre><code> scp-&gt;scsi_done callback is executed.  Note: the driver may
</code></pre>
</li>
<li><pre><code> call scp-&gt;scsi_done before returning zero, but after it has
</code></pre>
</li>
<li><pre><code> called scp-&gt;scsi_done, it may not return any value other than
</code></pre>
</li>
<li><pre><code> zero.  If the driver makes a non-zero return, it must not
</code></pre>
</li>
<li><pre><code> execute the command&#39;s scsi_done callback at any time.
</code></pre>
</li>
<li></li>
<li><pre><code> Locks: up to and including 2.6.36, struct Scsi_Host::host_lock
</code></pre>
</li>
<li><pre><code>        held on entry (with &quot;irqsave&quot;) and is expected to be
</code></pre>
</li>
<li><pre><code>        held on return. From 2.6.37 onwards, queuecommand is
</code></pre>
</li>
<li><pre><code>        called without any locks held.
</code></pre>
</li>
<li></li>
<li><pre><code> Calling context: in interrupt (soft irq) or process context
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: This function should be relatively fast. Normally it
</code></pre>
</li>
<li><pre><code> will not wait for IO to complete. Hence the scp-&gt;scsi_done
</code></pre>
</li>
<li><pre><code> callback is invoked (often directly from an interrupt service
</code></pre>
</li>
<li><pre><code> routine) some time after this function has returned. In some
</code></pre>
</li>
<li><pre><code> cases (e.g. pseudo adapter drivers that manufacture the
</code></pre>
</li>
<li><pre><code> response to a SCSI INQUIRY) the scp-&gt;scsi_done callback may be
</code></pre>
</li>
<li><pre><code> invoked before this function returns.  If the scp-&gt;scsi_done
</code></pre>
</li>
<li><pre><code> callback is not invoked within a certain period the SCSI mid
</code></pre>
</li>
<li><pre><code> level will commence error processing.  If a status of CHECK
</code></pre>
</li>
<li><pre><code> CONDITION is placed in &quot;result&quot; when the scp-&gt;scsi_done
</code></pre>
</li>
<li><pre><code> callback is invoked, then the LLD driver should perform
</code></pre>
</li>
<li><pre><code> autosense and fill in the struct scsi_cmnd::sense_buffer
</code></pre>
</li>
<li><pre><code> array. The scsi_cmnd::sense_buffer array is zeroed prior to
</code></pre>
</li>
<li><pre><code> the mid level queuing a command to an LLD.
</code></pre>
</li>
<li></li>
<li><pre><code> Defined in: LLD
</code></pre>
</li>
<li>*/<br>  int queuecommand(struct Scsi_Host *shost, struct scsi_cmnd * scp)</li>
</ul>
<p>/**</p>
<ul>
<li><pre><code> release - release all resources associated with given host
</code></pre>
</li>
<li><pre><code> @shp: host to be released.
</code></pre>
</li>
<li></li>
<li><pre><code> Return value ignored (could soon be a function returning void).
</code></pre>
</li>
<li></li>
<li><pre><code> Locks: none held
</code></pre>
</li>
<li></li>
<li><pre><code> Calling context: process
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: Invoked from scsi_module.c&#39;s exit_this_scsi_driver().
</code></pre>
</li>
<li><pre><code> LLD&#39;s implementation of this function should call 
</code></pre>
</li>
<li><pre><code> scsi_unregister(shp) prior to returning.
</code></pre>
</li>
<li><pre><code> Only needed for old-style host templates.
</code></pre>
</li>
<li></li>
<li><pre><code> Defined in: LLD (required in &quot;passive initialization model&quot;,
</code></pre>
</li>
<li><pre><code>                  should not be defined in hotplug model)
</code></pre>
</li>
<li>*/<br>  int release(struct Scsi_Host * shp)</li>
</ul>
<p>/**</p>
<ul>
<li><pre><code> slave_alloc -   prior to any commands being sent to a new device 
</code></pre>
</li>
<li><pre><code>                 (i.e. just prior to scan) this call is made
</code></pre>
</li>
<li><pre><code> @sdp: pointer to new device (about to be scanned)
</code></pre>
</li>
<li></li>
<li><pre><code> Returns 0 if ok. Any other return is assumed to be an error and
</code></pre>
</li>
<li><pre><code> the device is ignored.
</code></pre>
</li>
<li></li>
<li><pre><code> Locks: none
</code></pre>
</li>
<li></li>
<li><pre><code> Calling context: process
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: Allows the driver to allocate any resources for a device
</code></pre>
</li>
<li><pre><code> prior to its initial scan. The corresponding scsi device may not
</code></pre>
</li>
<li><pre><code> exist but the mid level is just about to scan for it (i.e. send
</code></pre>
</li>
<li><pre><code> and INQUIRY command plus ...). If a device is found then
</code></pre>
</li>
<li><pre><code> slave_configure() will be called while if a device is not found
</code></pre>
</li>
<li><pre><code> slave_destroy() is called.
</code></pre>
</li>
<li><pre><code> For more details see the include/scsi/scsi_host.h file.
</code></pre>
</li>
<li></li>
<li><pre><code> Optionally defined in: LLD
</code></pre>
</li>
<li>*/<br>  int slave_alloc(struct scsi_device *sdp)</li>
</ul>
<p>/**</p>
<ul>
<li><pre><code> slave_configure - driver fine tuning for given device just after it
</code></pre>
</li>
<li><pre><code>                has been first scanned (i.e. it responded to an
</code></pre>
</li>
<li><pre><code>                INQUIRY)
</code></pre>
</li>
<li><pre><code> @sdp: device that has just been attached
</code></pre>
</li>
<li></li>
<li><pre><code> Returns 0 if ok. Any other return is assumed to be an error and
</code></pre>
</li>
<li><pre><code> the device is taken offline. [offline devices will _not_ have
</code></pre>
</li>
<li><pre><code> slave_destroy() called on them so clean up resources.]
</code></pre>
</li>
<li></li>
<li><pre><code> Locks: none
</code></pre>
</li>
<li></li>
<li><pre><code> Calling context: process
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: Allows the driver to inspect the response to the initial
</code></pre>
</li>
<li><pre><code> INQUIRY done by the scanning code and take appropriate action.
</code></pre>
</li>
<li><pre><code> For more details see the include/scsi/scsi_host.h file.
</code></pre>
</li>
<li></li>
<li><pre><code> Optionally defined in: LLD
</code></pre>
</li>
<li>*/<br>  int slave_configure(struct scsi_device *sdp)</li>
</ul>
<p>/**</p>
<ul>
<li><pre><code> slave_destroy - given device is about to be shut down. All
</code></pre>
</li>
<li><pre><code>                 activity has ceased on this device.
</code></pre>
</li>
<li><pre><code> @sdp: device that is about to be shut down
</code></pre>
</li>
<li></li>
<li><pre><code> Returns nothing
</code></pre>
</li>
<li></li>
<li><pre><code> Locks: none
</code></pre>
</li>
<li></li>
<li><pre><code> Calling context: process
</code></pre>
</li>
<li></li>
<li><pre><code> Notes: Mid level structures for given device are still in place
</code></pre>
</li>
<li><pre><code> but are about to be torn down. Any per device resources allocated
</code></pre>
</li>
<li><pre><code> by this driver for given device should be freed now. No further
</code></pre>
</li>
<li><pre><code> commands will be sent for this sdp instance. [However the device
</code></pre>
</li>
<li><pre><code> could be re-attached in the future in which case a new instance
</code></pre>
</li>
<li><pre><code> of struct scsi_device would be supplied by future slave_alloc()
</code></pre>
</li>
<li><pre><code> and slave_configure() calls.]
</code></pre>
</li>
<li></li>
<li><pre><code> Optionally defined in: LLD
</code></pre>
</li>
<li>*/<br>  void slave_destroy(struct scsi_device *sdp)</li>
</ul>
<h1 id="Data-Structures"><a href="#Data-Structures" class="headerlink" title="Data Structures"></a>Data Structures</h1><h2 id="struct-scsi-host-template"><a href="#struct-scsi-host-template" class="headerlink" title="struct scsi_host_template"></a>struct scsi_host_template</h2><p>There is one “struct scsi_host_template” instance per LLD ***. It is<br>typically initialized as a file scope static in a driver’s header file. That<br>way members that are not explicitly initialized will be set to 0 or NULL.<br>Member of interest:<br>    name         - name of driver (may contain spaces, please limit to<br>                   less than 80 characters)<br>    proc_name    - name used in “/proc/scsi/<proc_name>/<host_no>“ and<br>                   by sysfs in one of its “drivers” directories. Hence<br>                   “proc_name” should only contain characters acceptable<br>                   to a Unix file name.<br>   (*queuecommand)() - primary callback that the mid level uses to inject<br>                   SCSI commands into an LLD.<br>The structure is defined and commented in include/scsi/scsi_host.h</p>
<p>*** In extreme situations a single driver may have several instances<br>    if it controls several different classes of hardware (e.g. an LLD<br>    that handles both ISA and PCI cards and has a separate instance of<br>    struct scsi_host_template for each class).</p>
<h2 id="struct-Scsi-Host"><a href="#struct-Scsi-Host" class="headerlink" title="struct Scsi_Host"></a>struct Scsi_Host</h2><p>There is one struct Scsi_Host instance per host (HBA) that an LLD<br>controls. The struct Scsi_Host structure has many members in common<br>with “struct scsi_host_template”. When a new struct Scsi_Host instance<br>is created (in scsi_host_alloc() in hosts.c) those common members are<br>initialized from the driver’s struct scsi_host_template instance. Members<br>of interest:<br>    host_no      - system wide unique number that is used for identifying<br>                   this host. Issued in ascending order from 0.<br>    can_queue    - must be greater than 0; do not send more than can_queue<br>                   commands to the adapter.<br>    this_id      - scsi id of host (scsi initiator) or -1 if not known<br>    sg_tablesize - maximum scatter gather elements allowed by host.<br>                   0 implies scatter gather not supported by host<br>    max_sectors  - maximum number of sectors (usually 512 bytes) allowed<br>                   in a single SCSI command. The default value of 0 leads<br>                   to a setting of SCSI_DEFAULT_MAX_SECTORS (defined in<br>                   scsi_host.h) which is currently set to 1024. So for a<br>                   disk the maximum transfer size is 512 KB when max_sectors<br>                   is not defined. Note that this size may not be sufficient<br>                   for disk firmware uploads.<br>    cmd_per_lun  - maximum number of commands that can be queued on devices<br>                   controlled by the host. Overridden by LLD calls to<br>                   scsi_adjust_queue_depth().<br>    unchecked_isa_dma - 1=&gt;only use bottom 16 MB of ram (ISA DMA addressing<br>                   restriction), 0=&gt;can use full 32 bit (or better) DMA<br>                   address space<br>    use_clustering - 1=&gt;SCSI commands in mid level’s queue can be merged,<br>                     0=&gt;disallow SCSI command merging<br>    no_async_abort - 1=&gt;Asynchronous aborts are not supported<br>                     0=&gt;Timed-out commands will be aborted asynchronously<br>    hostt        - pointer to driver’s struct scsi_host_template from which<br>                   this struct Scsi_Host instance was spawned<br>    hostt-&gt;proc_name  - name of LLD. This is the driver name that sysfs uses<br>    transportt   - pointer to driver’s struct scsi_transport_template instance<br>                   (if any). FC and SPI transports currently supported.<br>    sh_list      - a double linked list of pointers to all struct Scsi_Host<br>                   instances (currently ordered by ascending host_no)<br>    my_devices   - a double linked list of pointers to struct scsi_device<br>                   instances that belong to this host.<br>    hostdata[0]  - area reserved for LLD at end of struct Scsi_Host. Size<br>                   is set by the second argument (named ‘xtr_bytes’) to<br>                   scsi_host_alloc() or scsi_register().<br>    vendor_id    - a unique value that identifies the vendor supplying<br>                   the LLD for the Scsi_Host.  Used most often in validating<br>                   vendor-specific message requests.  Value consists of an<br>                   identifier type and a vendor-specific value.<br>                   See scsi_netlink.h for a description of valid formats.</p>
<p>The scsi_host structure is defined in include/scsi/scsi_host.h</p>
<h2 id="struct-scsi-device"><a href="#struct-scsi-device" class="headerlink" title="struct scsi_device"></a>struct scsi_device</h2><p>Generally, there is one instance of this structure for each SCSI logical unit<br>on a host. Scsi devices connected to a host are uniquely identified by a<br>channel number, target id and logical unit number (lun).<br>The structure is defined in include/scsi/scsi_device.h</p>
<h2 id="struct-scsi-cmnd"><a href="#struct-scsi-cmnd" class="headerlink" title="struct scsi_cmnd"></a>struct scsi_cmnd</h2><p>Instances of this structure convey SCSI commands to the LLD and responses<br>back to the mid level. The SCSI mid level will ensure that no more SCSI<br>commands become queued against the LLD than are indicated by<br>scsi_adjust_queue_depth() (or struct Scsi_Host::cmd_per_lun). There will<br>be at least one instance of struct scsi_cmnd available for each SCSI device.<br>Members of interest:<br>    cmnd         - array containing SCSI command<br>    cmnd_len     - length (in bytes) of SCSI command<br>    sc_data_direction - direction of data transfer in data phase. See<br>                “enum dma_data_direction” in include/linux/dma-mapping.h<br>    request_bufflen - number of data bytes to transfer (0 if no data phase)<br>    use_sg       - ==0 -&gt; no scatter gather list, hence transfer data<br>                          to/from request_buffer<br>                 - &gt;0 -&gt;  scatter gather list (actually an array) in<br>                          request_buffer with use_sg elements<br>    request_buffer - either contains data buffer or scatter gather list<br>                     depending on the setting of use_sg. Scatter gather<br>                     elements are defined by ‘struct scatterlist’ found<br>                     in include/asm/scatterlist.h .<br>    done         - function pointer that should be invoked by LLD when the<br>                   SCSI command is completed (successfully or otherwise).<br>                   Should only be called by an LLD if the LLD has accepted<br>                   the command (i.e. queuecommand() returned or will return<br>                   0). The LLD may invoke ‘done’  prior to queuecommand()<br>                   finishing.<br>    result       - should be set by LLD prior to calling ‘done’. A value<br>                   of 0 implies a successfully completed command (and all<br>                   data (if any) has been transferred to or from the SCSI<br>                   target device). ‘result’ is a 32 bit unsigned integer that<br>                   can be viewed as 4 related bytes. The SCSI status value is<br>                   in the LSB. See include/scsi/scsi.h status_byte(),<br>                   msg_byte(), host_byte() and driver_byte() macros and<br>                   related constants.<br>    sense_buffer - an array (maximum size: SCSI_SENSE_BUFFERSIZE bytes) that<br>                   should be written when the SCSI status (LSB of ‘result’)<br>                   is set to CHECK_CONDITION (2). When CHECK_CONDITION is<br>                   set, if the top nibble of sense_buffer[0] has the value 7<br>                   then the mid level will assume the sense_buffer array<br>                   contains a valid SCSI sense buffer; otherwise the mid<br>                   level will issue a REQUEST_SENSE SCSI command to<br>                   retrieve the sense buffer. The latter strategy is error<br>                   prone in the presence of command queuing so the LLD should<br>                   always “auto-sense”.<br>    device       - pointer to scsi_device object that this command is<br>                   associated with.<br>    resid        - an LLD should set this signed integer to the requested<br>                   transfer length (i.e. ‘request_bufflen’) less the number<br>                   of bytes that are actually transferred. ‘resid’ is<br>                   preset to 0 so an LLD can ignore it if it cannot detect<br>                   underruns (overruns should be rare). If possible an LLD<br>                   should set ‘resid’ prior to invoking ‘done’. The most<br>                   interesting case is data transfers from a SCSI target<br>                   device (e.g. READs) that underrun.<br>    underflow    - LLD should place (DID_ERROR &lt;&lt; 16) in ‘result’ if<br>                   actual number of bytes transferred is less than this<br>                   figure. Not many LLDs implement this check and some that<br>                   do just output an error message to the log rather than<br>                   report a DID_ERROR. Better for an LLD to implement<br>                   ‘resid’.</p>
<p>It is recommended that a LLD set ‘resid’ on data transfers from a SCSI<br>target device (e.g. READs). It is especially important that ‘resid’ is set<br>when such data transfers have sense keys of MEDIUM ERROR and HARDWARE ERROR<br>(and possibly RECOVERED ERROR). In these cases if a LLD is in doubt how much<br>data has been received then the safest approach is to indicate no bytes have<br>been received. For example: to indicate that no valid data has been received<br>a LLD might use these helpers:<br>    scsi_set_resid(SCpnt, scsi_bufflen(SCpnt));<br>where ‘SCpnt’ is a pointer to a scsi_cmnd object. To indicate only three 512<br>bytes blocks has been received ‘resid’ could be set like this:<br>    scsi_set_resid(SCpnt, scsi_bufflen(SCpnt) - (3 * 512));</p>
<p>The scsi_cmnd structure is defined in include/scsi/scsi_cmnd.h</p>
<h1 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h1><p>Each struct Scsi_Host instance has a spin_lock called struct<br>Scsi_Host::default_lock which is initialized in scsi_host_alloc() [found in<br>hosts.c]. Within the same function the struct Scsi_Host::host_lock pointer<br>is initialized to point at default_lock.  Thereafter lock and unlock<br>operations performed by the mid level use the struct Scsi_Host::host_lock<br>pointer.  Previously drivers could override the host_lock pointer but<br>this is not allowed anymore.</p>
<h1 id="Autosense"><a href="#Autosense" class="headerlink" title="Autosense"></a>Autosense</h1><p>Autosense (or auto-sense) is defined in the SAM-2 document as “the<br>automatic return of sense data to the application client coincident<br>with the completion of a SCSI command” when a status of CHECK CONDITION<br>occurs. LLDs should perform autosense. This should be done when the LLD<br>detects a CHECK CONDITION status by either:<br>    a) instructing the SCSI protocol (e.g. SCSI Parallel Interface (SPI))<br>       to perform an extra data in phase on such responses<br>    b) or, the LLD issuing a REQUEST SENSE command itself</p>
<p>Either way, when a status of CHECK CONDITION is detected, the mid level<br>decides whether the LLD has performed autosense by checking struct<br>scsi_cmnd::sense_buffer[0] . If this byte has an upper nibble of 7 (or 0xf)<br>then autosense is assumed to have taken place. If it has another value (and<br>this byte is initialized to 0 before each command) then the mid level will<br>issue a REQUEST SENSE command.</p>
<p>In the presence of queued commands the “nexus” that maintains sense<br>buffer data from the command that failed until a following REQUEST SENSE<br>may get out of synchronization. This is why it is best for the LLD<br>to perform autosense.</p>
<h1 id="Changes-since-lk-2-4-series"><a href="#Changes-since-lk-2-4-series" class="headerlink" title="Changes since lk 2.4 series"></a>Changes since lk 2.4 series</h1><p>io_request_lock has been replaced by several finer grained locks. The lock<br>relevant to LLDs is struct Scsi_Host::host_lock and there is<br>one per SCSI host.</p>
<p>The older error handling mechanism has been removed. This means the<br>LLD interface functions abort() and reset() have been removed.<br>The struct scsi_host_template::use_new_eh_code flag has been removed.</p>
<p>In the 2.4 series the SCSI subsystem configuration descriptions were<br>aggregated with the configuration descriptions from all other Linux<br>subsystems in the Documentation/Configure.help file. In the 2.6 series,<br>the SCSI subsystem now has its own (much smaller) drivers/scsi/Kconfig<br>file that contains both configuration and help information.</p>
<p>struct SHT has been renamed to struct scsi_host_template.</p>
<p>Addition of the “hotplug initialization model” and many extra functions<br>to support it.</p>
<h1 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h1><p>The following people have contributed to this document:<br>        Mike Anderson <andmike at us dot ibm dot com><br>        James Bottomley <James dot Bottomley at hansenpartnership dot com><br>        Patrick Mansfield <patmans at us dot ibm dot com><br>        Christoph Hellwig <hch at infradead dot org><br>        Doug Ledford <dledford at redhat dot com><br>        Andries Brouwer <Andries dot Brouwer at cwi dot nl><br>        Randy Dunlap <rdunlap at xenotime dot net><br>        Alan Stern <stern at rowland dot harvard dot edu></p>
<p>Douglas Gilbert<br>dgilbert at interlog dot com<br>21st September 2004</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_scsi_mid_low_api/" title="Kernel-3.10.0-957.el7_scsi_mid_low_api" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_scsi_mid_low_api/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_pci/" title="Kernel-3.10.0-957.el7_pci"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_thinkpad-acpi/" title="Kernel-3.10.0-957.el7_thinkpad-acpi"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>