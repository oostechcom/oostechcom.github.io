<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-3.10.0-957.el7_timekeeping | oosTech.com</title>
  <meta name="description" content="Timekeeping Virtualization for X86-Based Architectures  Zachary Amsden &lt;zamsden@redhat.com&gt; Copyright (c) 2010, Red Hat.  All rights reserved.   Overview Timing Devices TSC Hardware Virtualizati">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-3.10.0-957.el7_timekeeping">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_timekeeping/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="Timekeeping Virtualization for X86-Based Architectures  Zachary Amsden &lt;zamsden@redhat.com&gt; Copyright (c) 2010, Red Hat.  All rights reserved.   Overview Timing Devices TSC Hardware Virtualizati">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_timekeeping/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Location-Size-Description"><span class="toc-number">1.</span> <span class="toc-text">Location    Size    Description</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-3.10.0-957.el7_timekeeping" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-3.10.0-957.el7_timekeeping
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_timekeeping/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_timekeeping/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-3.10.0-957.el7_timekeeping/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <pre><code>Timekeeping Virtualization for X86-Based Architectures

Zachary Amsden &lt;zamsden@redhat.com&gt;
Copyright (c) 2010, Red Hat.  All rights reserved.
</code></pre>
<ol>
<li>Overview</li>
<li>Timing Devices</li>
<li>TSC Hardware</li>
<li>Virtualization Problems</li>
</ol>
<p>=========================================================================</p>
<ol>
<li>Overview</li>
</ol>
<p>One of the most complicated parts of the X86 platform, and specifically,<br>the virtualization of this platform is the plethora of timing devices available<br>and the complexity of emulating those devices.  In addition, virtualization of<br>time introduces a new set of challenges because it introduces a multiplexed<br>division of time beyond the control of the guest CPU.</p>
<p>First, we will describe the various timekeeping hardware available, then<br>present some of the problems which arise and solutions available, giving<br>specific recommendations for certain classes of KVM guests.</p>
<p>The purpose of this document is to collect data and information relevant to<br>timekeeping which may be difficult to find elsewhere, specifically,<br>information relevant to KVM and hardware-based virtualization.</p>
<p>=========================================================================</p>
<ol start="2">
<li>Timing Devices</li>
</ol>
<p>First we discuss the basic hardware devices available.  TSC and the related<br>KVM clock are special enough to warrant a full exposition and are described in<br>the following section.</p>
<p>2.1) i8254 - PIT</p>
<p>One of the first timer devices available is the programmable interrupt timer,<br>or PIT.  The PIT has a fixed frequency 1.193182 MHz base clock and three<br>channels which can be programmed to deliver periodic or one-shot interrupts.<br>These three channels can be configured in different modes and have individual<br>counters.  Channel 1 and 2 were not available for general use in the original<br>IBM PC, and historically were connected to control RAM refresh and the PC<br>speaker.  Now the PIT is typically integrated as part of an emulated chipset<br>and a separate physical PIT is not used.</p>
<p>The PIT uses I/O ports 0x40 - 0x43.  Access to the 16-bit counters is done<br>using single or multiple byte access to the I/O ports.  There are 6 modes<br>available, but not all modes are available to all timers, as only timer 2<br>has a connected gate input, required for modes 1 and 5.  The gate line is<br>controlled by port 61h, bit 0, as illustrated in the following diagram.</p>
<hr>
<p>|              |           |                |<br>|  1.1932 MHz  |———-&gt;| CLOCK      OUT | ———&gt; IRQ 0<br>|    Clock     |   |       |                |<br> ————–    |    +-&gt;| GATE  TIMER 0  |<br>                   |        —————-<br>                   |<br>                   |        —————-<br>                   |       |                |<br>                   |——&gt;| CLOCK      OUT | ———&gt; 66.3 KHZ DRAM<br>                   |       |                |            (aka /dev/null)<br>                   |    +-&gt;| GATE  TIMER 1  |<br>                   |        —————-<br>                   |<br>                   |        —————-<br>                   |       |                |<br>                   |——&gt;| CLOCK      OUT | ———&gt; Port 61h, bit 5<br>                           |                |      |<br>Port 61h, bit 0 ———-&gt;| GATE  TIMER 2  |       _.—-   <strong>__<br>                            —————-         <em>|    )–|LPF|—Speaker<br>                                                    / *—-   \</em></strong>/<br>Port 61h, bit 1 ———————————–/</p>
<p>The timer modes are now described.</p>
<p>Mode 0: Single Timeout.   This is a one-shot software timeout that counts down<br> when the gate is high (always true for timers 0 and 1).  When the count<br> reaches zero, the output goes high.</p>
<p>Mode 1: Triggered One-shot.  The output is initially set high.  When the gate<br> line is set high, a countdown is initiated (which does not stop if the gate is<br> lowered), during which the output is set low.  When the count reaches zero,<br> the output goes high.</p>
<p>Mode 2: Rate Generator.  The output is initially set high.  When the countdown<br> reaches 1, the output goes low for one count and then returns high.  The value<br> is reloaded and the countdown automatically resumes.  If the gate line goes<br> low, the count is halted.  If the output is low when the gate is lowered, the<br> output automatically goes high (this only affects timer 2).</p>
<p>Mode 3: Square Wave.   This generates a high / low square wave.  The count<br> determines the length of the pulse, which alternates between high and low<br> when zero is reached.  The count only proceeds when gate is high and is<br> automatically reloaded on reaching zero.  The count is decremented twice at<br> each clock to generate a full high / low cycle at the full periodic rate.<br> If the count is even, the clock remains high for N/2 counts and low for N/2<br> counts; if the clock is odd, the clock is high for (N+1)/2 counts and low<br> for (N-1)/2 counts.  Only even values are latched by the counter, so odd<br> values are not observed when reading.  This is the intended mode for timer 2,<br> which generates sine-like tones by low-pass filtering the square wave output.</p>
<p>Mode 4: Software Strobe.  After programming this mode and loading the counter,<br> the output remains high until the counter reaches zero.  Then the output<br> goes low for 1 clock cycle and returns high.  The counter is not reloaded.<br> Counting only occurs when gate is high.</p>
<p>Mode 5: Hardware Strobe.  After programming and loading the counter, the<br> output remains high.  When the gate is raised, a countdown is initiated<br> (which does not stop if the gate is lowered).  When the counter reaches zero,<br> the output goes low for 1 clock cycle and then returns high.  The counter is<br> not reloaded.</p>
<p>In addition to normal binary counting, the PIT supports BCD counting.  The<br>command port, 0x43 is used to set the counter and mode for each of the three<br>timers.</p>
<p>PIT commands, issued to port 0x43, using the following bit encoding:</p>
<p>Bit 7-4: Command (See table below)<br>Bit 3-1: Mode (000 = Mode 0, 101 = Mode 5, 11X = undefined)<br>Bit 0  : Binary (0) / BCD (1)</p>
<p>Command table:</p>
<p>0000 - Latch Timer 0 count for port 0x40<br>    sample and hold the count to be read in port 0x40;<br>    additional commands ignored until counter is read;<br>    mode bits ignored.</p>
<p>0001 - Set Timer 0 LSB mode for port 0x40<br>    set timer to read LSB only and force MSB to zero;<br>    mode bits set timer mode</p>
<p>0010 - Set Timer 0 MSB mode for port 0x40<br>    set timer to read MSB only and force LSB to zero;<br>    mode bits set timer mode</p>
<p>0011 - Set Timer 0 16-bit mode for port 0x40<br>    set timer to read / write LSB first, then MSB;<br>    mode bits set timer mode</p>
<p>0100 - Latch Timer 1 count for port 0x41 - as described above<br>0101 - Set Timer 1 LSB mode for port 0x41 - as described above<br>0110 - Set Timer 1 MSB mode for port 0x41 - as described above<br>0111 - Set Timer 1 16-bit mode for port 0x41 - as described above</p>
<p>1000 - Latch Timer 2 count for port 0x42 - as described above<br>1001 - Set Timer 2 LSB mode for port 0x42 - as described above<br>1010 - Set Timer 2 MSB mode for port 0x42 - as described above<br>1011 - Set Timer 2 16-bit mode for port 0x42 as described above</p>
<p>1101 - General counter latch<br>    Latch combination of counters into corresponding ports<br>    Bit 3 = Counter 2<br>    Bit 2 = Counter 1<br>    Bit 1 = Counter 0<br>    Bit 0 = Unused</p>
<p>1110 - Latch timer status<br>    Latch combination of counter mode into corresponding ports<br>    Bit 3 = Counter 2<br>    Bit 2 = Counter 1<br>    Bit 1 = Counter 0</p>
<pre><code>The output of ports 0x40-0x42 following this command will be:

Bit 7 = Output pin
Bit 6 = Count loaded (0 if timer has expired)
Bit 5-4 = Read / Write mode
    01 = MSB only
    10 = LSB only
    11 = LSB / MSB (16-bit)
Bit 3-1 = Mode
Bit 0 = Binary (0) / BCD mode (1)
</code></pre>
<p>2.2) RTC</p>
<p>The second device which was available in the original PC was the MC146818 real<br>time clock.  The original device is now obsolete, and usually emulated by the<br>system chipset, sometimes by an HPET and some frankenstein IRQ routing.</p>
<p>The RTC is accessed through CMOS variables, which uses an index register to<br>control which bytes are read.  Since there is only one index register, read<br>of the CMOS and read of the RTC require lock protection (in addition, it is<br>dangerous to allow userspace utilities such as hwclock to have direct RTC<br>access, as they could corrupt kernel reads and writes of CMOS memory).</p>
<p>The RTC generates an interrupt which is usually routed to IRQ 8.  The interrupt<br>can function as a periodic timer, an additional once a day alarm, and can issue<br>interrupts after an update of the CMOS registers by the MC146818 is complete.<br>The type of interrupt is signalled in the RTC status registers.</p>
<p>The RTC will update the current time fields by battery power even while the<br>system is off.  The current time fields should not be read while an update is<br>in progress, as indicated in the status register.</p>
<p>The clock uses a 32.768kHz crystal, so bits 6-4 of register A should be<br>programmed to a 32kHz divider if the RTC is to count seconds.</p>
<p>This is the RAM map originally used for the RTC/CMOS:</p>
<h2 id="Location-Size-Description"><a href="#Location-Size-Description" class="headerlink" title="Location    Size    Description"></a>Location    Size    Description</h2><p>00h         byte    Current second (BCD)<br>01h         byte    Seconds alarm (BCD)<br>02h         byte    Current minute (BCD)<br>03h         byte    Minutes alarm (BCD)<br>04h         byte    Current hour (BCD)<br>05h         byte    Hours alarm (BCD)<br>06h         byte    Current day of week (BCD)<br>07h         byte    Current day of month (BCD)<br>08h         byte    Current month (BCD)<br>09h         byte    Current year (BCD)<br>0Ah         byte    Register A<br>                       bit 7   = Update in progress<br>                       bit 6-4 = Divider for clock<br>                                  000 = 4.194 MHz<br>                                  001 = 1.049 MHz<br>                                  010 = 32 kHz<br>                                  10X = test modes<br>                                  110 = reset / disable<br>                                  111 = reset / disable<br>                       bit 3-0 = Rate selection for periodic interrupt<br>                                  000 = periodic timer disabled<br>                                  001 = 3.90625 uS<br>                                  010 = 7.8125 uS<br>                                  011 = .122070 mS<br>                                  100 = .244141 mS<br>                                     …<br>                                 1101 = 125 mS<br>                                 1110 = 250 mS<br>                                 1111 = 500 mS<br>0Bh         byte    Register B<br>                       bit 7   = Run (0) / Halt (1)<br>                       bit 6   = Periodic interrupt enable<br>                       bit 5   = Alarm interrupt enable<br>                       bit 4   = Update-ended interrupt enable<br>                       bit 3   = Square wave interrupt enable<br>                       bit 2   = BCD calendar (0) / Binary (1)<br>                       bit 1   = 12-hour mode (0) / 24-hour mode (1)<br>                       bit 0   = 0 (DST off) / 1 (DST enabled)<br>OCh         byte    Register C (read only)<br>                       bit 7   = interrupt request flag (IRQF)<br>                       bit 6   = periodic interrupt flag (PF)<br>                       bit 5   = alarm interrupt flag (AF)<br>                       bit 4   = update interrupt flag (UF)<br>                       bit 3-0 = reserved<br>ODh         byte    Register D (read only)<br>                       bit 7   = RTC has power<br>                       bit 6-0 = reserved<br>32h         byte    Current century BCD (<em>)<br>  (</em>) location vendor specific and now determined from ACPI global tables</p>
<p>2.3) APIC</p>
<p>On Pentium and later processors, an on-board timer is available to each CPU<br>as part of the Advanced Programmable Interrupt Controller.  The APIC is<br>accessed through memory-mapped registers and provides interrupt service to each<br>CPU, used for IPIs and local timer interrupts.</p>
<p>Although in theory the APIC is a safe and stable source for local interrupts,<br>in practice, many bugs and glitches have occurred due to the special nature of<br>the APIC CPU-local memory-mapped hardware.  Beware that CPU errata may affect<br>the use of the APIC and that workarounds may be required.  In addition, some of<br>these workarounds pose unique constraints for virtualization - requiring either<br>extra overhead incurred from extra reads of memory-mapped I/O or additional<br>functionality that may be more computationally expensive to implement.</p>
<p>Since the APIC is documented quite well in the Intel and AMD manuals, we will<br>avoid repetition of the detail here.  It should be pointed out that the APIC<br>timer is programmed through the LVT (local vector timer) register, is capable<br>of one-shot or periodic operation, and is based on the bus clock divided down<br>by the programmable divider register.</p>
<p>2.4) HPET</p>
<p>HPET is quite complex, and was originally intended to replace the PIT / RTC<br>support of the X86 PC.  It remains to be seen whether that will be the case, as<br>the de facto standard of PC hardware is to emulate these older devices.  Some<br>systems designated as legacy free may support only the HPET as a hardware timer<br>device.</p>
<p>The HPET spec is rather loose and vague, requiring at least 3 hardware timers,<br>but allowing implementation freedom to support many more.  It also imposes no<br>fixed rate on the timer frequency, but does impose some extremal values on<br>frequency, error and slew.</p>
<p>In general, the HPET is recommended as a high precision (compared to PIT /RTC)<br>time source which is independent of local variation (as there is only one HPET<br>in any given system).  The HPET is also memory-mapped, and its presence is<br>indicated through ACPI tables by the BIOS.</p>
<p>Detailed specification of the HPET is beyond the current scope of this<br>document, as it is also very well documented elsewhere.</p>
<p>2.5) Offboard Timers</p>
<p>Several cards, both proprietary (watchdog boards) and commonplace (e1000) have<br>timing chips built into the cards which may have registers which are accessible<br>to kernel or user drivers.  To the author’s knowledge, using these to generate<br>a clocksource for a Linux or other kernel has not yet been attempted and is in<br>general frowned upon as not playing by the agreed rules of the game.  Such a<br>timer device would require additional support to be virtualized properly and is<br>not considered important at this time as no known operating system does this.</p>
<p>=========================================================================</p>
<ol start="3">
<li>TSC Hardware</li>
</ol>
<p>The TSC or time stamp counter is relatively simple in theory; it counts<br>instruction cycles issued by the processor, which can be used as a measure of<br>time.  In practice, due to a number of problems, it is the most complicated<br>timekeeping device to use.</p>
<p>The TSC is represented internally as a 64-bit MSR which can be read with the<br>RDMSR, RDTSC, or RDTSCP (when available) instructions.  In the past, hardware<br>limitations made it possible to write the TSC, but generally on old hardware it<br>was only possible to write the low 32-bits of the 64-bit counter, and the upper<br>32-bits of the counter were cleared.  Now, however, on Intel processors family<br>0Fh, for models 3, 4 and 6, and family 06h, models e and f, this restriction<br>has been lifted and all 64-bits are writable.  On AMD systems, the ability to<br>write the TSC MSR is not an architectural guarantee.</p>
<p>The TSC is accessible from CPL-0 and conditionally, for CPL &gt; 0 software by<br>means of the CR4.TSD bit, which when enabled, disables CPL &gt; 0 TSC access.</p>
<p>Some vendors have implemented an additional instruction, RDTSCP, which returns<br>atomically not just the TSC, but an indicator which corresponds to the<br>processor number.  This can be used to index into an array of TSC variables to<br>determine offset information in SMP systems where TSCs are not synchronized.<br>The presence of this instruction must be determined by consulting CPUID feature<br>bits.</p>
<p>Both VMX and SVM provide extension fields in the virtualization hardware which<br>allows the guest visible TSC to be offset by a constant.  Newer implementations<br>promise to allow the TSC to additionally be scaled, but this hardware is not<br>yet widely available.</p>
<p>3.1) TSC synchronization</p>
<p>The TSC is a CPU-local clock in most implementations.  This means, on SMP<br>platforms, the TSCs of different CPUs may start at different times depending<br>on when the CPUs are powered on.  Generally, CPUs on the same die will share<br>the same clock, however, this is not always the case.</p>
<p>The BIOS may attempt to resynchronize the TSCs during the poweron process and<br>the operating system or other system software may attempt to do this as well.<br>Several hardware limitations make the problem worse - if it is not possible to<br>write the full 64-bits of the TSC, it may be impossible to match the TSC in<br>newly arriving CPUs to that of the rest of the system, resulting in<br>unsynchronized TSCs.  This may be done by BIOS or system software, but in<br>practice, getting a perfectly synchronized TSC will not be possible unless all<br>values are read from the same clock, which generally only is possible on single<br>socket systems or those with special hardware support.</p>
<p>3.2) TSC and CPU hotplug</p>
<p>As touched on already, CPUs which arrive later than the boot time of the system<br>may not have a TSC value that is synchronized with the rest of the system.<br>Either system software, BIOS, or SMM code may actually try to establish the TSC<br>to a value matching the rest of the system, but a perfect match is usually not<br>a guarantee.  This can have the effect of bringing a system from a state where<br>TSC is synchronized back to a state where TSC synchronization flaws, however<br>small, may be exposed to the OS and any virtualization environment.</p>
<p>3.3) TSC and multi-socket / NUMA</p>
<p>Multi-socket systems, especially large multi-socket systems are likely to have<br>individual clocksources rather than a single, universally distributed clock.<br>Since these clocks are driven by different crystals, they will not have<br>perfectly matched frequency, and temperature and electrical variations will<br>cause the CPU clocks, and thus the TSCs to drift over time.  Depending on the<br>exact clock and bus design, the drift may or may not be fixed in absolute<br>error, and may accumulate over time.</p>
<p>In addition, very large systems may deliberately slew the clocks of individual<br>cores.  This technique, known as spread-spectrum clocking, reduces EMI at the<br>clock frequency and harmonics of it, which may be required to pass FCC<br>standards for telecommunications and computer equipment.</p>
<p>It is recommended not to trust the TSCs to remain synchronized on NUMA or<br>multiple socket systems for these reasons.</p>
<p>3.4) TSC and C-states</p>
<p>C-states, or idling states of the processor, especially C1E and deeper sleep<br>states may be problematic for TSC as well.  The TSC may stop advancing in such<br>a state, resulting in a TSC which is behind that of other CPUs when execution<br>is resumed.  Such CPUs must be detected and flagged by the operating system<br>based on CPU and chipset identifications.</p>
<p>The TSC in such a case may be corrected by catching it up to a known external<br>clocksource.</p>
<p>3.5) TSC frequency change / P-states</p>
<p>To make things slightly more interesting, some CPUs may change frequency.  They<br>may or may not run the TSC at the same rate, and because the frequency change<br>may be staggered or slewed, at some points in time, the TSC rate may not be<br>known other than falling within a range of values.  In this case, the TSC will<br>not be a stable time source, and must be calibrated against a known, stable,<br>external clock to be a usable source of time.</p>
<p>Whether the TSC runs at a constant rate or scales with the P-state is model<br>dependent and must be determined by inspecting CPUID, chipset or vendor<br>specific MSR fields.</p>
<p>In addition, some vendors have known bugs where the P-state is actually<br>compensated for properly during normal operation, but when the processor is<br>inactive, the P-state may be raised temporarily to service cache misses from<br>other processors.  In such cases, the TSC on halted CPUs could advance faster<br>than that of non-halted processors.  AMD Turion processors are known to have<br>this problem.</p>
<p>3.6) TSC and STPCLK / T-states</p>
<p>External signals given to the processor may also have the effect of stopping<br>the TSC.  This is typically done for thermal emergency power control to prevent<br>an overheating condition, and typically, there is no way to detect that this<br>condition has happened.</p>
<p>3.7) TSC virtualization - VMX</p>
<p>VMX provides conditional trapping of RDTSC, RDMSR, WRMSR and RDTSCP<br>instructions, which is enough for full virtualization of TSC in any manner.  In<br>addition, VMX allows passing through the host TSC plus an additional TSC_OFFSET<br>field specified in the VMCS.  Special instructions must be used to read and<br>write the VMCS field.</p>
<p>3.8) TSC virtualization - SVM</p>
<p>SVM provides conditional trapping of RDTSC, RDMSR, WRMSR and RDTSCP<br>instructions, which is enough for full virtualization of TSC in any manner.  In<br>addition, SVM allows passing through the host TSC plus an additional offset<br>field specified in the SVM control block.</p>
<p>3.9) TSC feature bits in Linux</p>
<p>In summary, there is no way to guarantee the TSC remains in perfect<br>synchronization unless it is explicitly guaranteed by the architecture.  Even<br>if so, the TSCs in multi-sockets or NUMA systems may still run independently<br>despite being locally consistent.</p>
<p>The following feature bits are used by Linux to signal various TSC attributes,<br>but they can only be taken to be meaningful for UP or single node systems.</p>
<p>X86_FEATURE_TSC         : The TSC is available in hardware<br>X86_FEATURE_RDTSCP        : The RDTSCP instruction is available<br>X86_FEATURE_CONSTANT_TSC     : The TSC rate is unchanged with P-states<br>X86_FEATURE_NONSTOP_TSC        : The TSC does not stop in C-states<br>X86_FEATURE_TSC_RELIABLE    : TSC sync checks are skipped (VMware)</p>
<ol start="4">
<li>Virtualization Problems</li>
</ol>
<p>Timekeeping is especially problematic for virtualization because a number of<br>challenges arise.  The most obvious problem is that time is now shared between<br>the host and, potentially, a number of virtual machines.  Thus the virtual<br>operating system does not run with 100% usage of the CPU, despite the fact that<br>it may very well make that assumption.  It may expect it to remain true to very<br>exacting bounds when interrupt sources are disabled, but in reality only its<br>virtual interrupt sources are disabled, and the machine may still be preempted<br>at any time.  This causes problems as the passage of real time, the injection<br>of machine interrupts and the associated clock sources are no longer completely<br>synchronized with real time.</p>
<p>This same problem can occur on native hardware to a degree, as SMM mode may<br>steal cycles from the naturally on X86 systems when SMM mode is used by the<br>BIOS, but not in such an extreme fashion.  However, the fact that SMM mode may<br>cause similar problems to virtualization makes it a good justification for<br>solving many of these problems on bare metal.</p>
<p>4.1) Interrupt clocking</p>
<p>One of the most immediate problems that occurs with legacy operating systems<br>is that the system timekeeping routines are often designed to keep track of<br>time by counting periodic interrupts.  These interrupts may come from the PIT<br>or the RTC, but the problem is the same: the host virtualization engine may not<br>be able to deliver the proper number of interrupts per second, and so guest<br>time may fall behind.  This is especially problematic if a high interrupt rate<br>is selected, such as 1000 HZ, which is unfortunately the default for many Linux<br>guests.</p>
<p>There are three approaches to solving this problem; first, it may be possible<br>to simply ignore it.  Guests which have a separate time source for tracking<br>‘wall clock’ or ‘real time’ may not need any adjustment of their interrupts to<br>maintain proper time.  If this is not sufficient, it may be necessary to inject<br>additional interrupts into the guest in order to increase the effective<br>interrupt rate.  This approach leads to complications in extreme conditions,<br>where host load or guest lag is too much to compensate for, and thus another<br>solution to the problem has risen: the guest may need to become aware of lost<br>ticks and compensate for them internally.  Although promising in theory, the<br>implementation of this policy in Linux has been extremely error prone, and a<br>number of buggy variants of lost tick compensation are distributed across<br>commonly used Linux systems.</p>
<p>Windows uses periodic RTC clocking as a means of keeping time internally, and<br>thus requires interrupt slewing to keep proper time.  It does use a low enough<br>rate (ed: is it 18.2 Hz?) however that it has not yet been a problem in<br>practice.</p>
<p>4.2) TSC sampling and serialization</p>
<p>As the highest precision time source available, the cycle counter of the CPU<br>has aroused much interest from developers.  As explained above, this timer has<br>many problems unique to its nature as a local, potentially unstable and<br>potentially unsynchronized source.  One issue which is not unique to the TSC,<br>but is highlighted because of its very precise nature is sampling delay.  By<br>definition, the counter, once read is already old.  However, it is also<br>possible for the counter to be read ahead of the actual use of the result.<br>This is a consequence of the superscalar execution of the instruction stream,<br>which may execute instructions out of order.  Such execution is called<br>non-serialized.  Forcing serialized execution is necessary for precise<br>measurement with the TSC, and requires a serializing instruction, such as CPUID<br>or an MSR read.</p>
<p>Since CPUID may actually be virtualized by a trap and emulate mechanism, this<br>serialization can pose a performance issue for hardware virtualization.  An<br>accurate time stamp counter reading may therefore not always be available, and<br>it may be necessary for an implementation to guard against “backwards” reads of<br>the TSC as seen from other CPUs, even in an otherwise perfectly synchronized<br>system.</p>
<p>4.3) Timespec aliasing</p>
<p>Additionally, this lack of serialization from the TSC poses another challenge<br>when using results of the TSC when measured against another time source.  As<br>the TSC is much higher precision, many possible values of the TSC may be read<br>while another clock is still expressing the same value.</p>
<p>That is, you may read (T,T+10) while external clock C maintains the same value.<br>Due to non-serialized reads, you may actually end up with a range which<br>fluctuates - from (T-1.. T+10).  Thus, any time calculated from a TSC, but<br>calibrated against an external value may have a range of valid values.<br>Re-calibrating this computation may actually cause time, as computed after the<br>calibration, to go backwards, compared with time computed before the<br>calibration.</p>
<p>This problem is particularly pronounced with an internal time source in Linux,<br>the kernel time, which is expressed in the theoretically high resolution<br>timespec - but which advances in much larger granularity intervals, sometimes<br>at the rate of jiffies, and possibly in catchup modes, at a much larger step.</p>
<p>This aliasing requires care in the computation and recalibration of kvmclock<br>and any other values derived from TSC computation (such as TSC virtualization<br>itself).</p>
<p>4.4) Migration</p>
<p>Migration of a virtual machine raises problems for timekeeping in two ways.<br>First, the migration itself may take time, during which interrupts cannot be<br>delivered, and after which, the guest time may need to be caught up.  NTP may<br>be able to help to some degree here, as the clock correction required is<br>typically small enough to fall in the NTP-correctable window.</p>
<p>An additional concern is that timers based off the TSC (or HPET, if the raw bus<br>clock is exposed) may now be running at different rates, requiring compensation<br>in some way in the hypervisor by virtualizing these timers.  In addition,<br>migrating to a faster machine may preclude the use of a passthrough TSC, as a<br>faster clock cannot be made visible to a guest without the potential of time<br>advancing faster than usual.  A slower clock is less of a problem, as it can<br>always be caught up to the original rate.  KVM clock avoids these problems by<br>simply storing multipliers and offsets against the TSC for the guest to convert<br>back into nanosecond resolution values.</p>
<p>4.5) Scheduling</p>
<p>Since scheduling may be based on precise timing and firing of interrupts, the<br>scheduling algorithms of an operating system may be adversely affected by<br>virtualization.  In theory, the effect is random and should be universally<br>distributed, but in contrived as well as real scenarios (guest device access,<br>causes of virtualization exits, possible context switch), this may not always<br>be the case.  The effect of this has not been well studied.</p>
<p>In an attempt to work around this, several implementations have provided a<br>paravirtualized scheduler clock, which reveals the true amount of CPU time for<br>which a virtual machine has been running.</p>
<p>4.6) Watchdogs</p>
<p>Watchdog timers, such as the lock detector in Linux may fire accidentally when<br>running under hardware virtualization due to timer interrupts being delayed or<br>misinterpretation of the passage of real time.  Usually, these warnings are<br>spurious and can be ignored, but in some circumstances it may be necessary to<br>disable such detection.</p>
<p>4.7) Delays and precision timing</p>
<p>Precise timing and delays may not be possible in a virtualized system.  This<br>can happen if the system is controlling physical hardware, or issues delays to<br>compensate for slower I/O to and from devices.  The first issue is not solvable<br>in general for a virtualized system; hardware control software can’t be<br>adequately virtualized without a full real-time operating system, which would<br>require an RT aware virtualization platform.</p>
<p>The second issue may cause performance problems, but this is unlikely to be a<br>significant issue.  In many cases these delays may be eliminated through<br>configuration or paravirtualization.</p>
<p>4.8) Covert channels and leaks</p>
<p>In addition to the above problems, time information will inevitably leak to the<br>guest about the host in anything but a perfect implementation of virtualized<br>time.  This may allow the guest to infer the presence of a hypervisor (as in a<br>red-pill type detection), and it may allow information to leak between guests<br>by using CPU utilization itself as a signalling channel.  Preventing such<br>problems would require completely isolated virtual time which may not track<br>real time any longer.  This may be useful in certain security or QA contexts,<br>but in general isn’t recommended for real-world deployment scenarios.</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_timekeeping/" title="Kernel-3.10.0-957.el7_timekeeping" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_timekeeping/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_tmscsim/" title="Kernel-3.10.0-957.el7_tmscsi"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_sysfs/" title="Kernel-3.10.0-957.el7_sysfs"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>