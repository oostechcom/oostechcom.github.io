<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-3.10.0-957.el7_devices | oosTech.com</title>
  <meta name="description" content="Device Power Management Copyright (c) 2010-2011 Rafael J. Wysocki &amp;#114;&amp;#106;&amp;#x77;&amp;#64;&amp;#x73;&amp;#105;&amp;#115;&amp;#107;&amp;#46;&amp;#x70;&amp;#x6c;, Novell Inc.Copyright (c) 2010 Alan Stern &amp;#x73;&amp;#116;&amp;#101;&amp;#114;&amp;#1">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-3.10.0-957.el7_devices">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_devices/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="Device Power Management Copyright (c) 2010-2011 Rafael J. Wysocki &amp;#114;&amp;#106;&amp;#x77;&amp;#64;&amp;#x73;&amp;#105;&amp;#115;&amp;#107;&amp;#46;&amp;#x70;&amp;#x6c;, Novell Inc.Copyright (c) 2010 Alan Stern &amp;#x73;&amp;#116;&amp;#101;&amp;#114;&amp;#1">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_devices/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a><span class="category-list-count">830</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-2-6-32-573-12-1-el6-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_2.6.32-573.12.1.el6_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-2.6.32-573.12.1.el6_devices/" class="title">Kernel-2.6.32-573.12.1.el6_devices</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3c509/" class="title">Kernel-3.10.0-957.el7_3c509</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Two-Models-for-Device-Power-Management"><span class="toc-number">1.</span> <span class="toc-text">Two Models for Device Power Management</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Interfaces-for-Entering-System-Sleep-States"><span class="toc-number">2.</span> <span class="toc-text">Interfaces for Entering System Sleep States</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Device-Power-Management-Operations"><span class="toc-number">2.1.</span> <span class="toc-text">Device Power Management Operations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Subsystem-Level-Methods"><span class="toc-number">2.2.</span> <span class="toc-text">Subsystem-Level Methods</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sys-devices-%E2%80%A6-power-wakeup-files"><span class="toc-number">2.3.</span> <span class="toc-text">&#x2F;sys&#x2F;devices&#x2F;…&#x2F;power&#x2F;wakeup files</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sys-devices-%E2%80%A6-power-control-files"><span class="toc-number">2.4.</span> <span class="toc-text">&#x2F;sys&#x2F;devices&#x2F;…&#x2F;power&#x2F;control files</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Calling-Drivers-to-Enter-and-Leave-System-Sleep-States"><span class="toc-number">3.</span> <span class="toc-text">Calling Drivers to Enter and Leave System Sleep States</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Call-Sequence-Guarantees"><span class="toc-number">3.1.</span> <span class="toc-text">Call Sequence Guarantees</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-Power-Management-Phases"><span class="toc-number">3.2.</span> <span class="toc-text">System Power Management Phases</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Entering-System-Suspend"><span class="toc-number">3.3.</span> <span class="toc-text">Entering System Suspend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Leaving-System-Suspend"><span class="toc-number">3.4.</span> <span class="toc-text">Leaving System Suspend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Entering-Hibernation"><span class="toc-number">3.5.</span> <span class="toc-text">Entering Hibernation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Leaving-Hibernation"><span class="toc-number">3.6.</span> <span class="toc-text">Leaving Hibernation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Device-Power-Management-Domains"><span class="toc-number">3.7.</span> <span class="toc-text">Device Power Management Domains</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Device-Low-Power-suspend-States"><span class="toc-number">3.8.</span> <span class="toc-text">Device Low Power (suspend) States</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Power-Management-Notifiers"><span class="toc-number">3.9.</span> <span class="toc-text">Power Management Notifiers</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Runtime-Power-Management"><span class="toc-number">4.</span> <span class="toc-text">Runtime Power Management</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-3.10.0-957.el7_devices" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-3.10.0-957.el7_devices
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_devices/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_devices/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-3.10.0-957.el7_devices/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>Device Power Management</p>
<p>Copyright (c) 2010-2011 Rafael J. Wysocki <a href="mailto:&#114;&#106;&#x77;&#64;&#x73;&#105;&#115;&#107;&#46;&#x70;&#x6c;">&#114;&#106;&#x77;&#64;&#x73;&#105;&#115;&#107;&#46;&#x70;&#x6c;</a>, Novell Inc.<br>Copyright (c) 2010 Alan Stern <a href="mailto:&#x73;&#116;&#101;&#114;&#110;&#64;&#114;&#x6f;&#x77;&#x6c;&#97;&#110;&#x64;&#46;&#x68;&#97;&#114;&#x76;&#x61;&#x72;&#x64;&#46;&#x65;&#100;&#x75;">&#x73;&#116;&#101;&#114;&#110;&#64;&#114;&#x6f;&#x77;&#x6c;&#97;&#110;&#x64;&#46;&#x68;&#97;&#114;&#x76;&#x61;&#x72;&#x64;&#46;&#x65;&#100;&#x75;</a></p>
<p>Most of the code in Linux is device drivers, so most of the Linux power<br>management (PM) code is also driver-specific.  Most drivers will do very<br>little; others, especially for platforms with small batteries (like cell<br>phones), will do a lot.</p>
<p>This writeup gives an overview of how drivers interact with system-wide<br>power management goals, emphasizing the models and interfaces that are<br>shared by everything that hooks up to the driver model core.  Read it as<br>background for the domain-specific work you’d do with any specific driver.</p>
<h1 id="Two-Models-for-Device-Power-Management"><a href="#Two-Models-for-Device-Power-Management" class="headerlink" title="Two Models for Device Power Management"></a>Two Models for Device Power Management</h1><p>Drivers will use one or both of these models to put devices into low-power<br>states:</p>
<pre><code>System Sleep model:
Drivers can enter low-power states as part of entering system-wide
low-power states like &quot;suspend&quot; (also known as &quot;suspend-to-RAM&quot;), or
(mostly for systems with disks) &quot;hibernation&quot; (also known as
&quot;suspend-to-disk&quot;).

This is something that device, bus, and class drivers collaborate on
by implementing various role-specific suspend and resume methods to
cleanly power down hardware and software subsystems, then reactivate
them without loss of data.

Some drivers can manage hardware wakeup events, which make the system
leave the low-power state.  This feature may be enabled or disabled
using the relevant /sys/devices/.../power/wakeup file (for Ethernet
drivers the ioctl interface used by ethtool may also be used for this
purpose); enabling it may cost some power usage, but let the whole
system enter low-power states more often.

Runtime Power Management model:
Devices may also be put into low-power states while the system is
running, independently of other power management activity in principle.
However, devices are not generally independent of each other (for
example, a parent device cannot be suspended unless all of its child
devices have been suspended).  Moreover, depending on the bus type the
device is on, it may be necessary to carry out some bus-specific
operations on the device for this purpose.  Devices put into low power
states at run time may require special handling during system-wide power
transitions (suspend or hibernation).

For these reasons not only the device driver itself, but also the
appropriate subsystem (bus type, device type or device class) driver and
the PM core are involved in runtime power management.  As in the system
sleep power management case, they need to collaborate by implementing
various role-specific suspend and resume methods, so that the hardware
is cleanly powered down and reactivated without data or service loss.
</code></pre>
<p>There’s not a lot to be said about those low-power states except that they are<br>very system-specific, and often device-specific.  Also, that if enough devices<br>have been put into low-power states (at runtime), the effect may be very similar<br>to entering some system-wide low-power state (system sleep) … and that<br>synergies exist, so that several drivers using runtime PM might put the system<br>into a state where even deeper power saving options are available.</p>
<p>Most suspended devices will have quiesced all I/O: no more DMA or IRQs (except<br>for wakeup events), no more data read or written, and requests from upstream<br>drivers are no longer accepted.  A given bus or platform may have different<br>requirements though.</p>
<p>Examples of hardware wakeup events include an alarm from a real time clock,<br>network wake-on-LAN packets, keyboard or mouse activity, and media insertion<br>or removal (for PCMCIA, MMC/SD, USB, and so on).</p>
<h1 id="Interfaces-for-Entering-System-Sleep-States"><a href="#Interfaces-for-Entering-System-Sleep-States" class="headerlink" title="Interfaces for Entering System Sleep States"></a>Interfaces for Entering System Sleep States</h1><p>There are programming interfaces provided for subsystems (bus type, device type,<br>device class) and device drivers to allow them to participate in the power<br>management of devices they are concerned with.  These interfaces cover both<br>system sleep and runtime power management.</p>
<h2 id="Device-Power-Management-Operations"><a href="#Device-Power-Management-Operations" class="headerlink" title="Device Power Management Operations"></a>Device Power Management Operations</h2><p>Device power management operations, at the subsystem level as well as at the<br>device driver level, are implemented by defining and populating objects of type<br>struct dev_pm_ops:</p>
<p>struct dev_pm_ops {<br>    int (*prepare)(struct device *dev);<br>    void (*complete)(struct device *dev);<br>    int (*suspend)(struct device *dev);<br>    int (*resume)(struct device *dev);<br>    int (*freeze)(struct device *dev);<br>    int (*thaw)(struct device *dev);<br>    int (*poweroff)(struct device *dev);<br>    int (*restore)(struct device *dev);<br>    int (*suspend_late)(struct device *dev);<br>    int (*resume_early)(struct device *dev);<br>    int (*freeze_late)(struct device *dev);<br>    int (*thaw_early)(struct device *dev);<br>    int (*poweroff_late)(struct device *dev);<br>    int (*restore_early)(struct device *dev);<br>    int (*suspend_noirq)(struct device *dev);<br>    int (*resume_noirq)(struct device *dev);<br>    int (*freeze_noirq)(struct device *dev);<br>    int (*thaw_noirq)(struct device *dev);<br>    int (*poweroff_noirq)(struct device *dev);<br>    int (*restore_noirq)(struct device *dev);<br>    int (*runtime_suspend)(struct device *dev);<br>    int (*runtime_resume)(struct device *dev);<br>    int (*runtime_idle)(struct device *dev);<br>};</p>
<p>This structure is defined in include/linux/pm.h and the methods included in it<br>are also described in that file.  Their roles will be explained in what follows.<br>For now, it should be sufficient to remember that the last three methods are<br>specific to runtime power management while the remaining ones are used during<br>system-wide power transitions.</p>
<p>There also is a deprecated “old” or “legacy” interface for power management<br>operations available at least for some subsystems.  This approach does not use<br>struct dev_pm_ops objects and it is suitable only for implementing system sleep<br>power management methods.  Therefore it is not described in this document, so<br>please refer directly to the source code for more information about it.</p>
<h2 id="Subsystem-Level-Methods"><a href="#Subsystem-Level-Methods" class="headerlink" title="Subsystem-Level Methods"></a>Subsystem-Level Methods</h2><p>The core methods to suspend and resume devices reside in struct dev_pm_ops<br>pointed to by the ops member of struct dev_pm_domain, or by the pm member of<br>struct bus_type, struct device_type and struct class.  They are mostly of<br>interest to the people writing infrastructure for platforms and buses, like PCI<br>or USB, or device type and device class drivers.  They also are relevant to the<br>writers of device drivers whose subsystems (PM domains, device types, device<br>classes and bus types) don’t provide all power management methods.</p>
<p>Bus drivers implement these methods as appropriate for the hardware and the<br>drivers using it; PCI works differently from USB, and so on.  Not many people<br>write subsystem-level drivers; most driver code is a “device driver” that builds<br>on top of bus-specific framework code.</p>
<p>For more information on these driver calls, see the description later;<br>they are called in phases for every device, respecting the parent-child<br>sequencing in the driver model tree.</p>
<h2 id="sys-devices-…-power-wakeup-files"><a href="#sys-devices-…-power-wakeup-files" class="headerlink" title="/sys/devices/…/power/wakeup files"></a>/sys/devices/…/power/wakeup files</h2><p>All device objects in the driver model contain fields that control the handling<br>of system wakeup events (hardware signals that can force the system out of a<br>sleep state).  These fields are initialized by bus or device driver code using<br>device_set_wakeup_capable() and device_set_wakeup_enable(), defined in<br>include/linux/pm_wakeup.h.</p>
<p>The “power.can_wakeup” flag just records whether the device (and its driver) can<br>physically support wakeup events.  The device_set_wakeup_capable() routine<br>affects this flag.  The “power.wakeup” field is a pointer to an object of type<br>struct wakeup_source used for controlling whether or not the device should use<br>its system wakeup mechanism and for notifying the PM core of system wakeup<br>events signaled by the device.  This object is only present for wakeup-capable<br>devices (i.e. devices whose “can_wakeup” flags are set) and is created (or<br>removed) by device_set_wakeup_capable().</p>
<p>Whether or not a device is capable of issuing wakeup events is a hardware<br>matter, and the kernel is responsible for keeping track of it.  By contrast,<br>whether or not a wakeup-capable device should issue wakeup events is a policy<br>decision, and it is managed by user space through a sysfs attribute: the<br>“power/wakeup” file.  User space can write the strings “enabled” or “disabled”<br>to it to indicate whether or not, respectively, the device is supposed to signal<br>system wakeup.  This file is only present if the “power.wakeup” object exists<br>for the given device and is created (or removed) along with that object, by<br>device_set_wakeup_capable().  Reads from the file will return the corresponding<br>string.</p>
<p>The “power/wakeup” file is supposed to contain the “disabled” string initially<br>for the majority of devices; the major exceptions are power buttons, keyboards,<br>and Ethernet adapters whose WoL (wake-on-LAN) feature has been set up with<br>ethtool.  It should also default to “enabled” for devices that don’t generate<br>wakeup requests on their own but merely forward wakeup requests from one bus to<br>another (like PCI Express ports).</p>
<p>The device_may_wakeup() routine returns true only if the “power.wakeup” object<br>exists and the corresponding “power/wakeup” file contains the string “enabled”.<br>This information is used by subsystems, like the PCI bus type code, to see<br>whether or not to enable the devices’ wakeup mechanisms.  If device wakeup<br>mechanisms are enabled or disabled directly by drivers, they also should use<br>device_may_wakeup() to decide what to do during a system sleep transition.<br>Device drivers, however, are not supposed to call device_set_wakeup_enable()<br>directly in any case.</p>
<p>It ought to be noted that system wakeup is conceptually different from “remote<br>wakeup” used by runtime power management, although it may be supported by the<br>same physical mechanism.  Remote wakeup is a feature allowing devices in<br>low-power states to trigger specific interrupts to signal conditions in which<br>they should be put into the full-power state.  Those interrupts may or may not<br>be used to signal system wakeup events, depending on the hardware design.  On<br>some systems it is impossible to trigger them from system sleep states.  In any<br>case, remote wakeup should always be enabled for runtime power management for<br>all devices and drivers that support it.</p>
<h2 id="sys-devices-…-power-control-files"><a href="#sys-devices-…-power-control-files" class="headerlink" title="/sys/devices/…/power/control files"></a>/sys/devices/…/power/control files</h2><p>Each device in the driver model has a flag to control whether it is subject to<br>runtime power management.  This flag, called runtime_auto, is initialized by the<br>bus type (or generally subsystem) code using pm_runtime_allow() or<br>pm_runtime_forbid(); the default is to allow runtime power management.</p>
<p>The setting can be adjusted by user space by writing either “on” or “auto” to<br>the device’s power/control sysfs file.  Writing “auto” calls pm_runtime_allow(),<br>setting the flag and allowing the device to be runtime power-managed by its<br>driver.  Writing “on” calls pm_runtime_forbid(), clearing the flag, returning<br>the device to full power if it was in a low-power state, and preventing the<br>device from being runtime power-managed.  User space can check the current value<br>of the runtime_auto flag by reading the file.</p>
<p>The device’s runtime_auto flag has no effect on the handling of system-wide<br>power transitions.  In particular, the device can (and in the majority of cases<br>should and will) be put into a low-power state during a system-wide transition<br>to a sleep state even though its runtime_auto flag is clear.</p>
<p>For more information about the runtime power management framework, refer to<br>Documentation/power/runtime_pm.txt.</p>
<h1 id="Calling-Drivers-to-Enter-and-Leave-System-Sleep-States"><a href="#Calling-Drivers-to-Enter-and-Leave-System-Sleep-States" class="headerlink" title="Calling Drivers to Enter and Leave System Sleep States"></a>Calling Drivers to Enter and Leave System Sleep States</h1><p>When the system goes into a sleep state, each device’s driver is asked to<br>suspend the device by putting it into a state compatible with the target<br>system state.  That’s usually some version of “off”, but the details are<br>system-specific.  Also, wakeup-enabled devices will usually stay partly<br>functional in order to wake the system.</p>
<p>When the system leaves that low-power state, the device’s driver is asked to<br>resume it by returning it to full power.  The suspend and resume operations<br>always go together, and both are multi-phase operations.</p>
<p>For simple drivers, suspend might quiesce the device using class code<br>and then turn its hardware as “off” as possible during suspend_noirq.  The<br>matching resume calls would then completely reinitialize the hardware<br>before reactivating its class I/O queues.</p>
<p>More power-aware drivers might prepare the devices for triggering system wakeup<br>events.</p>
<h2 id="Call-Sequence-Guarantees"><a href="#Call-Sequence-Guarantees" class="headerlink" title="Call Sequence Guarantees"></a>Call Sequence Guarantees</h2><p>To ensure that bridges and similar links needing to talk to a device are<br>available when the device is suspended or resumed, the device tree is<br>walked in a bottom-up order to suspend devices.  A top-down order is<br>used to resume those devices.</p>
<p>The ordering of the device tree is defined by the order in which devices<br>get registered:  a child can never be registered, probed or resumed before<br>its parent; and can’t be removed or suspended after that parent.</p>
<p>The policy is that the device tree should match hardware bus topology.<br>(Or at least the control bus, for devices which use multiple busses.)<br>In particular, this means that a device registration may fail if the parent of<br>the device is suspending (i.e. has been chosen by the PM core as the next<br>device to suspend) or has already suspended, as well as after all of the other<br>devices have been suspended.  Device drivers must be prepared to cope with such<br>situations.</p>
<h2 id="System-Power-Management-Phases"><a href="#System-Power-Management-Phases" class="headerlink" title="System Power Management Phases"></a>System Power Management Phases</h2><p>Suspending or resuming the system is done in several phases.  Different phases<br>are used for freeze, standby, and memory sleep states (“suspend-to-RAM”) and the<br>hibernation state (“suspend-to-disk”).  Each phase involves executing callbacks<br>for every device before the next phase begins.  Not all busses or classes<br>support all these callbacks and not all drivers use all the callbacks.  The<br>various phases always run after tasks have been frozen and before they are<br>unfrozen.  Furthermore, the *_noirq phases run at a time when IRQ handlers have<br>been disabled (except for those marked with the IRQF_NO_SUSPEND flag).</p>
<p>All phases use PM domain, bus, type, class or driver callbacks (that is, methods<br>defined in dev-&gt;pm_domain-&gt;ops, dev-&gt;bus-&gt;pm, dev-&gt;type-&gt;pm, dev-&gt;class-&gt;pm or<br>dev-&gt;driver-&gt;pm).  These callbacks are regarded by the PM core as mutually<br>exclusive.  Moreover, PM domain callbacks always take precedence over all of the<br>other callbacks and, for example, type callbacks take precedence over bus, class<br>and driver callbacks.  To be precise, the following rules are used to determine<br>which callback to execute in the given phase:</p>
<pre><code>1.    If dev-&gt;pm_domain is present, the PM core will choose the callback
included in dev-&gt;pm_domain-&gt;ops for execution

2.    Otherwise, if both dev-&gt;type and dev-&gt;type-&gt;pm are present, the callback
included in dev-&gt;type-&gt;pm will be chosen for execution.

3.    Otherwise, if both dev-&gt;class and dev-&gt;class-&gt;pm are present, the
callback included in dev-&gt;class-&gt;pm will be chosen for execution.

4.    Otherwise, if both dev-&gt;bus and dev-&gt;bus-&gt;pm are present, the callback
included in dev-&gt;bus-&gt;pm will be chosen for execution.
</code></pre>
<p>This allows PM domains and device types to override callbacks provided by bus<br>types or device classes if necessary.</p>
<p>The PM domain, type, class and bus callbacks may in turn invoke device- or<br>driver-specific methods stored in dev-&gt;driver-&gt;pm, but they don’t have to do<br>that.</p>
<p>If the subsystem callback chosen for execution is not present, the PM core will<br>execute the corresponding method from dev-&gt;driver-&gt;pm instead if there is one.</p>
<h2 id="Entering-System-Suspend"><a href="#Entering-System-Suspend" class="headerlink" title="Entering System Suspend"></a>Entering System Suspend</h2><p>When the system goes into the freeze, standby or memory sleep state,<br>the phases are:</p>
<pre><code>    prepare, suspend, suspend_late, suspend_noirq.

1.    The prepare phase is meant to prevent races by preventing new devices
from being registered; the PM core would never know that all the
children of a device had been suspended if new children could be
registered at will.  (By contrast, devices may be unregistered at any
time.)  Unlike the other suspend-related phases, during the prepare
phase the device tree is traversed top-down.

After the prepare callback method returns, no new children may be
registered below the device.  The method may also prepare the device or
driver in some way for the upcoming system power transition, but it
should not put the device into a low-power state.

2.    The suspend methods should quiesce the device to stop it from performing
I/O.  They also may save the device registers and put it into the
appropriate low-power state, depending on the bus type the device is on,
and they may enable wakeup events.

3    For a number of devices it is convenient to split suspend into the
&quot;quiesce device&quot; and &quot;save device state&quot; phases, in which cases
suspend_late is meant to do the latter.  It is always executed after
runtime power management has been disabled for all devices.

4.    The suspend_noirq phase occurs after IRQ handlers have been disabled,
which means that the driver&#39;s interrupt handler will not be called while
the callback method is running.  The methods should save the values of
the device&#39;s registers that weren&#39;t saved previously and finally put the
device into the appropriate low-power state.

The majority of subsystems and device drivers need not implement this
callback.  However, bus types allowing devices to share interrupt
vectors, like PCI, generally need it; otherwise a driver might encounter
an error during the suspend phase by fielding a shared interrupt
generated by some other device after its own device had been set to low
power.
</code></pre>
<p>At the end of these phases, drivers should have stopped all I/O transactions<br>(DMA, IRQs), saved enough state that they can re-initialize or restore previous<br>state (as needed by the hardware), and placed the device into a low-power state.<br>On many platforms they will gate off one or more clock sources; sometimes they<br>will also switch off power supplies or reduce voltages.  (Drivers supporting<br>runtime PM may already have performed some or all of these steps.)</p>
<p>If device_may_wakeup(dev) returns true, the device should be prepared for<br>generating hardware wakeup signals to trigger a system wakeup event when the<br>system is in the sleep state.  For example, enable_irq_wake() might identify<br>GPIO signals hooked up to a switch or other external hardware, and<br>pci_enable_wake() does something similar for the PCI PME signal.</p>
<p>If any of these callbacks returns an error, the system won’t enter the desired<br>low-power state.  Instead the PM core will unwind its actions by resuming all<br>the devices that were suspended.</p>
<h2 id="Leaving-System-Suspend"><a href="#Leaving-System-Suspend" class="headerlink" title="Leaving System Suspend"></a>Leaving System Suspend</h2><p>When resuming from freeze, standby or memory sleep, the phases are:</p>
<pre><code>    resume_noirq, resume_early, resume, complete.

1.    The resume_noirq callback methods should perform any actions needed
before the driver&#39;s interrupt handlers are invoked.  This generally
means undoing the actions of the suspend_noirq phase.  If the bus type
permits devices to share interrupt vectors, like PCI, the method should
bring the device and its driver into a state in which the driver can
recognize if the device is the source of incoming interrupts, if any,
and handle them correctly.

For example, the PCI bus type&#39;s -&gt;pm.resume_noirq() puts the device into
the full-power state (D0 in the PCI terminology) and restores the
standard configuration registers of the device.  Then it calls the
device driver&#39;s -&gt;pm.resume_noirq() method to perform device-specific
actions.

2.    The resume_early methods should prepare devices for the execution of
the resume methods.  This generally involves undoing the actions of the
preceding suspend_late phase.

3    The resume methods should bring the the device back to its operating
state, so that it can perform normal I/O.  This generally involves
undoing the actions of the suspend phase.

4.    The complete phase should undo the actions of the prepare phase.  Note,
however, that new children may be registered below the device as soon as
the resume callbacks occur; it&#39;s not necessary to wait until the
complete phase.
</code></pre>
<p>At the end of these phases, drivers should be as functional as they were before<br>suspending: I/O can be performed using DMA and IRQs, and the relevant clocks are<br>gated on.  Even if the device was in a low-power state before the system sleep<br>because of runtime power management, afterwards it should be back in its<br>full-power state.  There are multiple reasons why it’s best to do this; they are<br>discussed in more detail in Documentation/power/runtime_pm.txt.</p>
<p>However, the details here may again be platform-specific.  For example,<br>some systems support multiple “run” states, and the mode in effect at<br>the end of resume might not be the one which preceded suspension.<br>That means availability of certain clocks or power supplies changed,<br>which could easily affect how a driver works.</p>
<p>Drivers need to be able to handle hardware which has been reset since the<br>suspend methods were called, for example by complete reinitialization.<br>This may be the hardest part, and the one most protected by NDA’d documents<br>and chip errata.  It’s simplest if the hardware state hasn’t changed since<br>the suspend was carried out, but that can’t be guaranteed (in fact, it usually<br>is not the case).</p>
<p>Drivers must also be prepared to notice that the device has been removed<br>while the system was powered down, whenever that’s physically possible.<br>PCMCIA, MMC, USB, Firewire, SCSI, and even IDE are common examples of busses<br>where common Linux platforms will see such removal.  Details of how drivers<br>will notice and handle such removals are currently bus-specific, and often<br>involve a separate thread.</p>
<p>These callbacks may return an error value, but the PM core will ignore such<br>errors since there’s nothing it can do about them other than printing them in<br>the system log.</p>
<h2 id="Entering-Hibernation"><a href="#Entering-Hibernation" class="headerlink" title="Entering Hibernation"></a>Entering Hibernation</h2><p>Hibernating the system is more complicated than putting it into the other<br>sleep states, because it involves creating and saving a system image.<br>Therefore there are more phases for hibernation, with a different set of<br>callbacks.  These phases always run after tasks have been frozen and memory has<br>been freed.</p>
<p>The general procedure for hibernation is to quiesce all devices (freeze), create<br>an image of the system memory while everything is stable, reactivate all<br>devices (thaw), write the image to permanent storage, and finally shut down the<br>system (poweroff).  The phases used to accomplish this are:</p>
<pre><code>prepare, freeze, freeze_late, freeze_noirq, thaw_noirq, thaw_early,
thaw, complete, prepare, poweroff, poweroff_late, poweroff_noirq

1.    The prepare phase is discussed in the &quot;Entering System Suspend&quot; section
above.

2.    The freeze methods should quiesce the device so that it doesn&#39;t generate
IRQs or DMA, and they may need to save the values of device registers.
However the device does not have to be put in a low-power state, and to
save time it&#39;s best not to do so.  Also, the device should not be
prepared to generate wakeup events.

3.    The freeze_late phase is analogous to the suspend_late phase described
above, except that the device should not be put in a low-power state and
should not be allowed to generate wakeup events by it.

4.    The freeze_noirq phase is analogous to the suspend_noirq phase discussed
above, except again that the device should not be put in a low-power
state and should not be allowed to generate wakeup events.
</code></pre>
<p>At this point the system image is created.  All devices should be inactive and<br>the contents of memory should remain undisturbed while this happens, so that the<br>image forms an atomic snapshot of the system state.</p>
<pre><code>5.    The thaw_noirq phase is analogous to the resume_noirq phase discussed
above.  The main difference is that its methods can assume the device is
in the same state as at the end of the freeze_noirq phase.

6.    The thaw_early phase is analogous to the resume_early phase described
above.  Its methods should undo the actions of the preceding
freeze_late, if necessary.

7.    The thaw phase is analogous to the resume phase discussed above.  Its
methods should bring the device back to an operating state, so that it
can be used for saving the image if necessary.

8.    The complete phase is discussed in the &quot;Leaving System Suspend&quot; section
above.
</code></pre>
<p>At this point the system image is saved, and the devices then need to be<br>prepared for the upcoming system shutdown.  This is much like suspending them<br>before putting the system into the freeze, standby or memory sleep state,<br>and the phases are similar.</p>
<pre><code>9.    The prepare phase is discussed above.

10.    The poweroff phase is analogous to the suspend phase.

11.    The poweroff_late phase is analogous to the suspend_late phase.

12.    The poweroff_noirq phase is analogous to the suspend_noirq phase.
</code></pre>
<p>The poweroff, poweroff_late and poweroff_noirq callbacks should do essentially<br>the same things as the suspend, suspend_late and suspend_noirq callbacks,<br>respectively.  The only notable difference is that they need not store the<br>device register values, because the registers should already have been stored<br>during the freeze, freeze_late or freeze_noirq phases.</p>
<h2 id="Leaving-Hibernation"><a href="#Leaving-Hibernation" class="headerlink" title="Leaving Hibernation"></a>Leaving Hibernation</h2><p>Resuming from hibernation is, again, more complicated than resuming from a sleep<br>state in which the contents of main memory are preserved, because it requires<br>a system image to be loaded into memory and the pre-hibernation memory contents<br>to be restored before control can be passed back to the image kernel.</p>
<p>Although in principle, the image might be loaded into memory and the<br>pre-hibernation memory contents restored by the boot loader, in practice this<br>can’t be done because boot loaders aren’t smart enough and there is no<br>established protocol for passing the necessary information.  So instead, the<br>boot loader loads a fresh instance of the kernel, called the boot kernel, into<br>memory and passes control to it in the usual way.  Then the boot kernel reads<br>the system image, restores the pre-hibernation memory contents, and passes<br>control to the image kernel.  Thus two different kernels are involved in<br>resuming from hibernation.  In fact, the boot kernel may be completely different<br>from the image kernel: a different configuration and even a different version.<br>This has important consequences for device drivers and their subsystems.</p>
<p>To be able to load the system image into memory, the boot kernel needs to<br>include at least a subset of device drivers allowing it to access the storage<br>medium containing the image, although it doesn’t need to include all of the<br>drivers present in the image kernel.  After the image has been loaded, the<br>devices managed by the boot kernel need to be prepared for passing control back<br>to the image kernel.  This is very similar to the initial steps involved in<br>creating a system image, and it is accomplished in the same way, using prepare,<br>freeze, and freeze_noirq phases.  However the devices affected by these phases<br>are only those having drivers in the boot kernel; other devices will still be in<br>whatever state the boot loader left them.</p>
<p>Should the restoration of the pre-hibernation memory contents fail, the boot<br>kernel would go through the “thawing” procedure described above, using the<br>thaw_noirq, thaw, and complete phases, and then continue running normally.  This<br>happens only rarely.  Most often the pre-hibernation memory contents are<br>restored successfully and control is passed to the image kernel, which then<br>becomes responsible for bringing the system back to the working state.</p>
<p>To achieve this, the image kernel must restore the devices’ pre-hibernation<br>functionality.  The operation is much like waking up from the memory sleep<br>state, although it involves different phases:</p>
<pre><code>restore_noirq, restore_early, restore, complete

1.    The restore_noirq phase is analogous to the resume_noirq phase.

2.    The restore_early phase is analogous to the resume_early phase.

3.    The restore phase is analogous to the resume phase.

4.    The complete phase is discussed above.
</code></pre>
<p>The main difference from resume[_early|_noirq] is that restore[_early|_noirq]<br>must assume the device has been accessed and reconfigured by the boot loader or<br>the boot kernel.  Consequently the state of the device may be different from the<br>state remembered from the freeze, freeze_late and freeze_noirq phases.  The<br>device may even need to be reset and completely re-initialized.  In many cases<br>this difference doesn’t matter, so the resume[_early|_noirq] and<br>restore[_early|_norq] method pointers can be set to the same routines.<br>Nevertheless, different callback pointers are used in case there is a situation<br>where it actually does matter.</p>
<h2 id="Device-Power-Management-Domains"><a href="#Device-Power-Management-Domains" class="headerlink" title="Device Power Management Domains"></a>Device Power Management Domains</h2><p>Sometimes devices share reference clocks or other power resources.  In those<br>cases it generally is not possible to put devices into low-power states<br>individually.  Instead, a set of devices sharing a power resource can be put<br>into a low-power state together at the same time by turning off the shared<br>power resource.  Of course, they also need to be put into the full-power state<br>together, by turning the shared power resource on.  A set of devices with this<br>property is often referred to as a power domain.</p>
<p>Support for power domains is provided through the pm_domain field of struct<br>device.  This field is a pointer to an object of type struct dev_pm_domain,<br>defined in include/linux/pm.h, providing a set of power management callbacks<br>analogous to the subsystem-level and device driver callbacks that are executed<br>for the given device during all power transitions, instead of the respective<br>subsystem-level callbacks.  Specifically, if a device’s pm_domain pointer is<br>not NULL, the -&gt;suspend() callback from the object pointed to by it will be<br>executed instead of its subsystem’s (e.g. bus type’s) -&gt;suspend() callback and<br>analogously for all of the remaining callbacks.  In other words, power<br>management domain callbacks, if defined for the given device, always take<br>precedence over the callbacks provided by the device’s subsystem (e.g. bus<br>type).</p>
<p>The support for device power management domains is only relevant to platforms<br>needing to use the same device driver power management callbacks in many<br>different power domain configurations and wanting to avoid incorporating the<br>support for power domains into subsystem-level callbacks, for example by<br>modifying the platform bus type.  Other platforms need not implement it or take<br>it into account in any way.</p>
<h2 id="Device-Low-Power-suspend-States"><a href="#Device-Low-Power-suspend-States" class="headerlink" title="Device Low Power (suspend) States"></a>Device Low Power (suspend) States</h2><p>Device low-power states aren’t standard.  One device might only handle<br>“on” and “off”, while another might support a dozen different versions of<br>“on” (how many engines are active?), plus a state that gets back to “on”<br>faster than from a full “off”.</p>
<p>Some busses define rules about what different suspend states mean.  PCI<br>gives one example:  after the suspend sequence completes, a non-legacy<br>PCI device may not perform DMA or issue IRQs, and any wakeup events it<br>issues would be issued through the PME# bus signal.  Plus, there are<br>several PCI-standard device states, some of which are optional.</p>
<p>In contrast, integrated system-on-chip processors often use IRQs as the<br>wakeup event sources (so drivers would call enable_irq_wake) and might<br>be able to treat DMA completion as a wakeup event (sometimes DMA can stay<br>active too, it’d only be the CPU and some peripherals that sleep).</p>
<p>Some details here may be platform-specific.  Systems may have devices that<br>can be fully active in certain sleep states, such as an LCD display that’s<br>refreshed using DMA while most of the system is sleeping lightly … and<br>its frame buffer might even be updated by a DSP or other non-Linux CPU while<br>the Linux control processor stays idle.</p>
<p>Moreover, the specific actions taken may depend on the target system state.<br>One target system state might allow a given device to be very operational;<br>another might require a hard shut down with re-initialization on resume.<br>And two different target systems might use the same device in different<br>ways; the aforementioned LCD might be active in one product’s “standby”,<br>but a different product using the same SOC might work differently.</p>
<h2 id="Power-Management-Notifiers"><a href="#Power-Management-Notifiers" class="headerlink" title="Power Management Notifiers"></a>Power Management Notifiers</h2><p>There are some operations that cannot be carried out by the power management<br>callbacks discussed above, because the callbacks occur too late or too early.<br>To handle these cases, subsystems and device drivers may register power<br>management notifiers that are called before tasks are frozen and after they have<br>been thawed.  Generally speaking, the PM notifiers are suitable for performing<br>actions that either require user space to be available, or at least won’t<br>interfere with user space.</p>
<p>For details refer to Documentation/power/notifiers.txt.</p>
<h1 id="Runtime-Power-Management"><a href="#Runtime-Power-Management" class="headerlink" title="Runtime Power Management"></a>Runtime Power Management</h1><p>Many devices are able to dynamically power down while the system is still<br>running. This feature is useful for devices that are not being used, and<br>can offer significant power savings on a running system.  These devices<br>often support a range of runtime power states, which might use names such<br>as “off”, “sleep”, “idle”, “active”, and so on.  Those states will in some<br>cases (like PCI) be partially constrained by the bus the device uses, and will<br>usually include hardware states that are also used in system sleep states.</p>
<p>A system-wide power transition can be started while some devices are in low<br>power states due to runtime power management.  The system sleep PM callbacks<br>should recognize such situations and react to them appropriately, but the<br>necessary actions are subsystem-specific.</p>
<p>In some cases the decision may be made at the subsystem level while in other<br>cases the device driver may be left to decide.  In some cases it may be<br>desirable to leave a suspended device in that state during a system-wide power<br>transition, but in other cases the device must be put back into the full-power<br>state temporarily, for example so that its system wakeup capability can be<br>disabled.  This all depends on the hardware and the design of the subsystem and<br>device driver in question.</p>
<p>During system-wide resume from a sleep state it’s easiest to put devices into<br>the full-power state, as explained in Documentation/power/runtime_pm.txt.  Refer<br>to that document for more information regarding this particular issue as well as<br>for information on the device runtime power management framework in general.</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_devices/" title="Kernel-3.10.0-957.el7_devices" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_devices/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_fsl,mxs-pinctrl/" title="Kernel-3.10.0-957.el7_fsl,mxs-pinctrl"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_cpusets/" title="Kernel-3.10.0-957.el7_cpusets"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>