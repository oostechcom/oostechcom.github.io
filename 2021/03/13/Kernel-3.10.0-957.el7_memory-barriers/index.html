<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Kernel-3.10.0-957.el7_memory-barriers | oosTech.com</title>
  <meta name="description" content="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;          LINUX KERNEL MEMORY BARRIERS          &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  By: David Howells &amp;#x64;&amp;#104;&amp;#x6f;&amp;#x77;&amp;#101;&amp;#108;&amp;#108;&amp;#x73;&amp;#64;&amp;#x72;&amp;#101;&amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel-3.10.0-957.el7_memory-barriers">
<meta property="og:url" content="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_memory-barriers/index.html">
<meta property="og:site_name" content="oosTech">
<meta property="og:description" content="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;          LINUX KERNEL MEMORY BARRIERS          &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  By: David Howells &amp;#x64;&amp;#104;&amp;#x6f;&amp;#x77;&amp;#101;&amp;#108;&amp;#108;&amp;#x73;&amp;#64;&amp;#x72;&amp;#101;&amp;#">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-12T16:00:00.000Z">
<meta property="article:author" content="Sam Lee">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_memory-barriers/index.html">
  
    <link rel="alternate" href="/atom.xml" title="oosTech" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="" target="_blank">
          <img src="/images/avatar.png" width="400" height="400">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">oosTech by Sam Lee</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="站内搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">站点首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档文档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">文档分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">常用链接</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">共享白板</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告牌</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p> 欢迎来到oosTech ，我是一个Linux 拥趸：D。 目前正在用的Linux 版本是 Red Hat Enterprise Linux release 8.3 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">文档分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a><span class="category-list-count">1658</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kernel-4-18-0-80-el8-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_4.18.0-80.el8_内核文档</a><span class="category-list-count">3937</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_mpc5200/" class="title">Kernel-3.10.0-957.el7_mpc5200</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_3270/" class="title">Kernel-3.10.0-957.el7_3270</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_4CCs/" class="title">Kernel-3.10.0-957.el7_4CCs</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_53c700/" class="title">Kernel-3.10.0-957.el7_53c700</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
              </p>
              <p class="item-title">
                <a href="/2021/03/13/Kernel-3.10.0-957.el7_6pack/" class="title">Kernel-3.10.0-957.el7_6pack</a>
              </p>
              <p class="item-date">
                <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#DEVICE-OPERATIONS"><span class="toc-number">1.</span> <span class="toc-text">DEVICE OPERATIONS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GUARANTEES"><span class="toc-number">2.</span> <span class="toc-text">GUARANTEES</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VARIETIES-OF-MEMORY-BARRIER"><span class="toc-number">3.</span> <span class="toc-text">VARIETIES OF MEMORY BARRIER</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WHAT-MAY-NOT-BE-ASSUMED-ABOUT-MEMORY-BARRIERS"><span class="toc-number">4.</span> <span class="toc-text">WHAT MAY NOT BE ASSUMED ABOUT MEMORY BARRIERS?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DATA-DEPENDENCY-BARRIERS"><span class="toc-number">5.</span> <span class="toc-text">DATA DEPENDENCY BARRIERS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CONTROL-DEPENDENCIES"><span class="toc-number">6.</span> <span class="toc-text">CONTROL DEPENDENCIES</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SMP-BARRIER-PAIRING"><span class="toc-number">7.</span> <span class="toc-text">SMP BARRIER PAIRING</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXAMPLES-OF-MEMORY-BARRIER-SEQUENCES"><span class="toc-number">8.</span> <span class="toc-text">EXAMPLES OF MEMORY BARRIER SEQUENCES</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#READ-MEMORY-BARRIERS-VS-LOAD-SPECULATION"><span class="toc-number">9.</span> <span class="toc-text">READ MEMORY BARRIERS VS LOAD SPECULATION</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TRANSITIVITY"><span class="toc-number">10.</span> <span class="toc-text">TRANSITIVITY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#COMPILER-BARRIER"><span class="toc-number">11.</span> <span class="toc-text">COMPILER BARRIER</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-MEMORY-BARRIERS"><span class="toc-number">12.</span> <span class="toc-text">CPU MEMORY BARRIERS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MMIO-WRITE-BARRIER"><span class="toc-number">13.</span> <span class="toc-text">MMIO WRITE BARRIER</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LOCKING-FUNCTIONS"><span class="toc-number">14.</span> <span class="toc-text">LOCKING FUNCTIONS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#INTERRUPT-DISABLING-FUNCTIONS"><span class="toc-number">15.</span> <span class="toc-text">INTERRUPT DISABLING FUNCTIONS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SLEEP-AND-WAKE-UP-FUNCTIONS"><span class="toc-number">16.</span> <span class="toc-text">SLEEP AND WAKE-UP FUNCTIONS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MISCELLANEOUS-FUNCTIONS"><span class="toc-number">17.</span> <span class="toc-text">MISCELLANEOUS FUNCTIONS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LOCKS-VS-MEMORY-ACCESSES"><span class="toc-number">18.</span> <span class="toc-text">LOCKS VS MEMORY ACCESSES</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LOCKS-VS-I-O-ACCESSES"><span class="toc-number">19.</span> <span class="toc-text">LOCKS VS I&#x2F;O ACCESSES</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#INTERPROCESSOR-INTERACTION"><span class="toc-number">20.</span> <span class="toc-text">INTERPROCESSOR INTERACTION</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ATOMIC-OPERATIONS"><span class="toc-number">21.</span> <span class="toc-text">ATOMIC OPERATIONS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ACCESSING-DEVICES"><span class="toc-number">22.</span> <span class="toc-text">ACCESSING DEVICES</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#INTERRUPTS"><span class="toc-number">23.</span> <span class="toc-text">INTERRUPTS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CACHE-COHERENCY"><span class="toc-number">24.</span> <span class="toc-text">CACHE COHERENCY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CACHE-COHERENCY-VS-DMA"><span class="toc-number">25.</span> <span class="toc-text">CACHE COHERENCY VS DMA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CACHE-COHERENCY-VS-MMIO"><span class="toc-number">26.</span> <span class="toc-text">CACHE COHERENCY VS MMIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AND-THEN-THERE%E2%80%99S-THE-ALPHA"><span class="toc-number">27.</span> <span class="toc-text">AND THEN THERE’S THE ALPHA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CIRCULAR-BUFFERS"><span class="toc-number">28.</span> <span class="toc-text">CIRCULAR BUFFERS</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Kernel-3.10.0-957.el7_memory-barriers" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Kernel-3.10.0-957.el7_memory-barriers
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_memory-barriers/" class="article-date">
	 published: <time datetime="2021-03-12T16:00:00.000Z" itemprop="datePublished">2021-03-13</time>
	</a>
</span>

        
	<a href="/2021/03/13/Kernel-3.10.0-957.el7_memory-barriers/" class="article-date">
	   updated: <time datetime="2021-03-12T16:00:00.000Z" itemprop="dateUpdated">2021-03-13</time>
	</a>


        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Kernel-3-10-0-957-el7-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/">Kernel_3.10.0-957.el7_内核文档</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill"></i>
	    <!--<span id="busuanzi_container_page_pv" style="display:inline;">-->
			<span id="busuanzi_value_page_pv" style="display:inline;"></span>
		<!--</span>-->
	</span>



        <!--<span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/03/13/Kernel-3.10.0-957.el7_memory-barriers/#comments" class="article-comment-link">评论</a></span> -->
        
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <pre><code>         ============================
         LINUX KERNEL MEMORY BARRIERS
         ============================
</code></pre>
<p>By: David Howells <a href="mailto:&#x64;&#104;&#x6f;&#x77;&#101;&#108;&#108;&#x73;&#64;&#x72;&#101;&#100;&#104;&#x61;&#x74;&#x2e;&#x63;&#x6f;&#109;">&#x64;&#104;&#x6f;&#x77;&#101;&#108;&#108;&#x73;&#64;&#x72;&#101;&#100;&#104;&#x61;&#x74;&#x2e;&#x63;&#x6f;&#109;</a><br>    Paul E. McKenney <a href="mailto:&#x70;&#97;&#x75;&#x6c;&#109;&#99;&#107;&#64;&#108;&#x69;&#x6e;&#117;&#x78;&#x2e;&#118;&#x6e;&#101;&#116;&#46;&#x69;&#x62;&#x6d;&#x2e;&#x63;&#x6f;&#109;">&#x70;&#97;&#x75;&#x6c;&#109;&#99;&#107;&#64;&#108;&#x69;&#x6e;&#117;&#x78;&#x2e;&#118;&#x6e;&#101;&#116;&#46;&#x69;&#x62;&#x6d;&#x2e;&#x63;&#x6f;&#109;</a></p>
<p>Contents:</p>
<p> (*) Abstract memory access model.</p>
<pre><code> - Device operations.
 - Guarantees.
</code></pre>
<p> (*) What are memory barriers?</p>
<pre><code> - Varieties of memory barrier.
 - What may not be assumed about memory barriers?
 - Data dependency barriers.
 - Control dependencies.
 - SMP barrier pairing.
 - Examples of memory barrier sequences.
 - Read memory barriers vs load speculation.
 - Transitivity
</code></pre>
<p> (*) Explicit kernel barriers.</p>
<pre><code> - Compiler barrier.
 - CPU memory barriers.
 - MMIO write barrier.
</code></pre>
<p> (*) Implicit kernel memory barriers.</p>
<pre><code> - Locking functions.
 - Interrupt disabling functions.
 - Sleep and wake-up functions.
 - Miscellaneous functions.
</code></pre>
<p> (*) Inter-CPU locking barrier effects.</p>
<pre><code> - Locks vs memory accesses.
 - Locks vs I/O accesses.
</code></pre>
<p> (*) Where are memory barriers needed?</p>
<pre><code> - Interprocessor interaction.
 - Atomic operations.
 - Accessing devices.
 - Interrupts.
</code></pre>
<p> (*) Kernel I/O barrier effects.</p>
<p> (*) Assumed minimum execution ordering model.</p>
<p> (*) The effects of the cpu cache.</p>
<pre><code> - Cache coherency.
 - Cache coherency vs DMA.
 - Cache coherency vs MMIO.
</code></pre>
<p> (*) The things CPUs get up to.</p>
<pre><code> - And then there&#39;s the Alpha.
</code></pre>
<p> (*) Example uses.</p>
<pre><code> - Circular buffers.
</code></pre>
<p> (*) References.</p>
<p>============================<br>ABSTRACT MEMORY ACCESS MODEL<br>============================</p>
<p>Consider the following abstract model of the system:</p>
<pre><code>                :                :
                :                :
                :                :
    +-------+   :   +--------+   :   +-------+
    |       |   :   |        |   :   |       |
    |       |   :   |        |   :   |       |
    | CPU 1 |&lt;-----&gt;| Memory |&lt;-----&gt;| CPU 2 |
    |       |   :   |        |   :   |       |
    |       |   :   |        |   :   |       |
    +-------+   :   +--------+   :   +-------+
        ^       :       ^        :       ^
        |       :       |        :       |
        |       :       |        :       |
        |       :       v        :       |
        |       :   +--------+   :       |
        |       :   |        |   :       |
        |       :   |        |   :       |
        +----------&gt;| Device |&lt;----------+
                :   |        |   :
                :   |        |   :
                :   +--------+   :
                :                :
</code></pre>
<p>Each CPU executes a program that generates memory access operations.  In the<br>abstract CPU, memory operation ordering is very relaxed, and a CPU may actually<br>perform the memory operations in any order it likes, provided program causality<br>appears to be maintained.  Similarly, the compiler may also arrange the<br>instructions it emits in any order it likes, provided it doesn’t affect the<br>apparent operation of the program.</p>
<p>So in the above diagram, the effects of the memory operations performed by a<br>CPU are perceived by the rest of the system as the operations cross the<br>interface between the CPU and rest of the system (the dotted lines).</p>
<p>For example, consider the following sequence of events:</p>
<pre><code>CPU 1        CPU 2
===============    ===============
&#123; A == 1; B == 2 &#125;
A = 3;        x = A;
B = 4;        y = B;
</code></pre>
<p>The set of accesses as seen by the memory system in the middle can be arranged<br>in 24 different combinations:</p>
<pre><code>STORE A=3,    STORE B=4,    x=LOAD A-&gt;3,    y=LOAD B-&gt;4
STORE A=3,    STORE B=4,    y=LOAD B-&gt;4,    x=LOAD A-&gt;3
STORE A=3,    x=LOAD A-&gt;3,    STORE B=4,    y=LOAD B-&gt;4
STORE A=3,    x=LOAD A-&gt;3,    y=LOAD B-&gt;2,    STORE B=4
STORE A=3,    y=LOAD B-&gt;2,    STORE B=4,    x=LOAD A-&gt;3
STORE A=3,    y=LOAD B-&gt;2,    x=LOAD A-&gt;3,    STORE B=4
STORE B=4,    STORE A=3,    x=LOAD A-&gt;3,    y=LOAD B-&gt;4
STORE B=4, ...
...
</code></pre>
<p>and can thus result in four different combinations of values:</p>
<pre><code>x == 1, y == 2
x == 1, y == 4
x == 3, y == 2
x == 3, y == 4
</code></pre>
<p>Furthermore, the stores committed by a CPU to the memory system may not be<br>perceived by the loads made by another CPU in the same order as the stores were<br>committed.</p>
<p>As a further example, consider this sequence of events:</p>
<pre><code>CPU 1        CPU 2
===============    ===============
&#123; A == 1, B == 2, C = 3, P == &amp;A, Q == &amp;C &#125;
B = 4;        Q = P;
P = &amp;B        D = *Q;
</code></pre>
<p>There is an obvious data dependency here, as the value loaded into D depends on<br>the address retrieved from P by CPU 2.  At the end of the sequence, any of the<br>following results are possible:</p>
<pre><code>(Q == &amp;A) and (D == 1)
(Q == &amp;B) and (D == 2)
(Q == &amp;B) and (D == 4)
</code></pre>
<p>Note that CPU 2 will never try and load C into D because the CPU will load P<br>into Q before issuing the load of *Q.</p>
<h2 id="DEVICE-OPERATIONS"><a href="#DEVICE-OPERATIONS" class="headerlink" title="DEVICE OPERATIONS"></a>DEVICE OPERATIONS</h2><p>Some devices present their control interfaces as collections of memory<br>locations, but the order in which the control registers are accessed is very<br>important.  For instance, imagine an ethernet card with a set of internal<br>registers that are accessed through an address port register (A) and a data<br>port register (D).  To read internal register 5, the following code might then<br>be used:</p>
<pre><code>*A = 5;
x = *D;
</code></pre>
<p>but this might show up as either of the following two sequences:</p>
<pre><code>STORE *A = 5, x = LOAD *D
x = LOAD *D, STORE *A = 5
</code></pre>
<p>the second of which will almost certainly result in a malfunction, since it set<br>the address <em>after</em> attempting to read the register.</p>
<h2 id="GUARANTEES"><a href="#GUARANTEES" class="headerlink" title="GUARANTEES"></a>GUARANTEES</h2><p>There are some minimal guarantees that may be expected of a CPU:</p>
<p> (*) On any given CPU, dependent memory accesses will be issued in order, with<br>     respect to itself.  This means that for:</p>
<pre><code>Q = P; D = *Q;

 the CPU will issue the following memory operations:

Q = LOAD P, D = LOAD *Q

 and always in that order.
</code></pre>
<p> (*) Overlapping loads and stores within a particular CPU will appear to be<br>     ordered within that CPU.  This means that for:</p>
<pre><code>a = *X; *X = b;

 the CPU will only issue the following sequence of memory operations:

a = LOAD *X, STORE *X = b

 And for:

*X = c; d = *X;

 the CPU will only issue:

STORE *X = c, d = LOAD *X

 (Loads and stores overlap if they are targeted at overlapping pieces of
 memory).
</code></pre>
<p>And there are a number of things that <em>must</em> or _must_not_ be assumed:</p>
<p> (*) It _must_not_ be assumed that independent loads and stores will be issued<br>     in the order given.  This means that for:</p>
<pre><code>X = *A; Y = *B; *D = Z;

 we may get any of the following sequences:

X = LOAD *A,  Y = LOAD *B,  STORE *D = Z
X = LOAD *A,  STORE *D = Z, Y = LOAD *B
Y = LOAD *B,  X = LOAD *A,  STORE *D = Z
Y = LOAD *B,  STORE *D = Z, X = LOAD *A
STORE *D = Z, X = LOAD *A,  Y = LOAD *B
STORE *D = Z, Y = LOAD *B,  X = LOAD *A
</code></pre>
<p> (*) It <em>must</em> be assumed that overlapping memory accesses may be merged or<br>     discarded.  This means that for:</p>
<pre><code>X = *A; Y = *(A + 4);

 we may get any one of the following sequences:

X = LOAD *A; Y = LOAD *(A + 4);
Y = LOAD *(A + 4); X = LOAD *A;
&#123;X, Y&#125; = LOAD &#123;*A, *(A + 4) &#125;;

 And for:

*A = X; *(A + 4) = Y;

 we may get any of:

STORE *A = X; STORE *(A + 4) = Y;
STORE *(A + 4) = Y; STORE *A = X;
STORE &#123;*A, *(A + 4) &#125; = &#123;X, Y&#125;;
</code></pre>
<p>=========================<br>WHAT ARE MEMORY BARRIERS?<br>=========================</p>
<p>As can be seen above, independent memory operations are effectively performed<br>in random order, but this can be a problem for CPU-CPU interaction and for I/O.<br>What is required is some way of intervening to instruct the compiler and the<br>CPU to restrict the order.</p>
<p>Memory barriers are such interventions.  They impose a perceived partial<br>ordering over the memory operations on either side of the barrier.</p>
<p>Such enforcement is important because the CPUs and other devices in a system<br>can use a variety of tricks to improve performance, including reordering,<br>deferral and combination of memory operations; speculative loads; speculative<br>branch prediction and various types of caching.  Memory barriers are used to<br>override or suppress these tricks, allowing the code to sanely control the<br>interaction of multiple CPUs and/or devices.</p>
<h2 id="VARIETIES-OF-MEMORY-BARRIER"><a href="#VARIETIES-OF-MEMORY-BARRIER" class="headerlink" title="VARIETIES OF MEMORY BARRIER"></a>VARIETIES OF MEMORY BARRIER</h2><p>Memory barriers come in four basic varieties:</p>
<p> (1) Write (or store) memory barriers.</p>
<pre><code> A write memory barrier gives a guarantee that all the STORE operations
 specified before the barrier will appear to happen before all the STORE
 operations specified after the barrier with respect to the other
 components of the system.

 A write barrier is a partial ordering on stores only; it is not required
 to have any effect on loads.

 A CPU can be viewed as committing a sequence of store operations to the
 memory system as time progresses.  All stores before a write barrier will
 occur in the sequence _before_ all the stores after the write barrier.

 [!] Note that write barriers should normally be paired with read or data
 dependency barriers; see the &quot;SMP barrier pairing&quot; subsection.
</code></pre>
<p> (2) Data dependency barriers.</p>
<pre><code> A data dependency barrier is a weaker form of read barrier.  In the case
 where two loads are performed such that the second depends on the result
 of the first (eg: the first load retrieves the address to which the second
 load will be directed), a data dependency barrier would be required to
 make sure that the target of the second load is updated before the address
 obtained by the first load is accessed.

 A data dependency barrier is a partial ordering on interdependent loads
 only; it is not required to have any effect on stores, independent loads
 or overlapping loads.

 As mentioned in (1), the other CPUs in the system can be viewed as
 committing sequences of stores to the memory system that the CPU being
 considered can then perceive.  A data dependency barrier issued by the CPU
 under consideration guarantees that for any load preceding it, if that
 load touches one of a sequence of stores from another CPU, then by the
 time the barrier completes, the effects of all the stores prior to that
 touched by the load will be perceptible to any loads issued after the data
 dependency barrier.

 See the &quot;Examples of memory barrier sequences&quot; subsection for diagrams
 showing the ordering constraints.

 [!] Note that the first load really has to have a _data_ dependency and
 not a control dependency.  If the address for the second load is dependent
 on the first load, but the dependency is through a conditional rather than
 actually loading the address itself, then it&#39;s a _control_ dependency and
 a full read barrier or better is required.  See the &quot;Control dependencies&quot;
 subsection for more information.

 [!] Note that data dependency barriers should normally be paired with
 write barriers; see the &quot;SMP barrier pairing&quot; subsection.
</code></pre>
<p> (3) Read (or load) memory barriers.</p>
<pre><code> A read barrier is a data dependency barrier plus a guarantee that all the
 LOAD operations specified before the barrier will appear to happen before
 all the LOAD operations specified after the barrier with respect to the
 other components of the system.

 A read barrier is a partial ordering on loads only; it is not required to
 have any effect on stores.

 Read memory barriers imply data dependency barriers, and so can substitute
 for them.

 [!] Note that read barriers should normally be paired with write barriers;
 see the &quot;SMP barrier pairing&quot; subsection.
</code></pre>
<p> (4) General memory barriers.</p>
<pre><code> A general memory barrier gives a guarantee that all the LOAD and STORE
 operations specified before the barrier will appear to happen before all
 the LOAD and STORE operations specified after the barrier with respect to
 the other components of the system.

 A general memory barrier is a partial ordering over both loads and stores.

 General memory barriers imply both read and write memory barriers, and so
 can substitute for either.
</code></pre>
<p>And a couple of implicit varieties:</p>
<p> (5) LOCK operations.</p>
<pre><code> This acts as a one-way permeable barrier.  It guarantees that all memory
 operations after the LOCK operation will appear to happen after the LOCK
 operation with respect to the other components of the system.

 Memory operations that occur before a LOCK operation may appear to happen
 after it completes.

 A LOCK operation should almost always be paired with an UNLOCK operation.
</code></pre>
<p> (6) UNLOCK operations.</p>
<pre><code> This also acts as a one-way permeable barrier.  It guarantees that all
 memory operations before the UNLOCK operation will appear to happen before
 the UNLOCK operation with respect to the other components of the system.

 Memory operations that occur after an UNLOCK operation may appear to
 happen before it completes.

 LOCK and UNLOCK operations are guaranteed to appear with respect to each
 other strictly in the order specified.

 The use of LOCK and UNLOCK operations generally precludes the need for
 other sorts of memory barrier (but note the exceptions mentioned in the
 subsection &quot;MMIO write barrier&quot;).
</code></pre>
<p>Memory barriers are only required where there’s a possibility of interaction<br>between two CPUs or between a CPU and a device.  If it can be guaranteed that<br>there won’t be any such interaction in any particular piece of code, then<br>memory barriers are unnecessary in that piece of code.</p>
<p>Note that these are the <em>minimum</em> guarantees.  Different architectures may give<br>more substantial guarantees, but they may <em>not</em> be relied upon outside of arch<br>specific code.</p>
<h2 id="WHAT-MAY-NOT-BE-ASSUMED-ABOUT-MEMORY-BARRIERS"><a href="#WHAT-MAY-NOT-BE-ASSUMED-ABOUT-MEMORY-BARRIERS" class="headerlink" title="WHAT MAY NOT BE ASSUMED ABOUT MEMORY BARRIERS?"></a>WHAT MAY NOT BE ASSUMED ABOUT MEMORY BARRIERS?</h2><p>There are certain things that the Linux kernel memory barriers do not guarantee:</p>
<p> (*) There is no guarantee that any of the memory accesses specified before a<br>     memory barrier will be <em>complete</em> by the completion of a memory barrier<br>     instruction; the barrier can be considered to draw a line in that CPU’s<br>     access queue that accesses of the appropriate type may not cross.</p>
<p> (*) There is no guarantee that issuing a memory barrier on one CPU will have<br>     any direct effect on another CPU or any other hardware in the system.  The<br>     indirect effect will be the order in which the second CPU sees the effects<br>     of the first CPU’s accesses occur, but see the next point:</p>
<p> (*) There is no guarantee that a CPU will see the correct order of effects<br>     from a second CPU’s accesses, even <em>if</em> the second CPU uses a memory<br>     barrier, unless the first CPU <em>also</em> uses a matching memory barrier (see<br>     the subsection on “SMP Barrier Pairing”).</p>
<p> (<em>) There is no guarantee that some intervening piece of off-the-CPU<br>     hardware[</em>] will not reorder the memory accesses.  CPU cache coherency<br>     mechanisms should propagate the indirect effects of a memory barrier<br>     between CPUs, but might not do so in order.</p>
<pre><code>[*] For information on bus mastering DMA and coherency please read:

    Documentation/PCI/pci.txt
    Documentation/DMA-API-HOWTO.txt
    Documentation/DMA-API.txt
</code></pre>
<h2 id="DATA-DEPENDENCY-BARRIERS"><a href="#DATA-DEPENDENCY-BARRIERS" class="headerlink" title="DATA DEPENDENCY BARRIERS"></a>DATA DEPENDENCY BARRIERS</h2><p>The usage requirements of data dependency barriers are a little subtle, and<br>it’s not always obvious that they’re needed.  To illustrate, consider the<br>following sequence of events:</p>
<pre><code>CPU 1        CPU 2
===============    ===============
&#123; A == 1, B == 2, C = 3, P == &amp;A, Q == &amp;C &#125;
B = 4;
&lt;write barrier&gt;
P = &amp;B
        Q = P;
        D = *Q;
</code></pre>
<p>There’s a clear data dependency here, and it would seem that by the end of the<br>sequence, Q must be either &amp;A or &amp;B, and that:</p>
<pre><code>(Q == &amp;A) implies (D == 1)
(Q == &amp;B) implies (D == 4)
</code></pre>
<p>But!  CPU 2’s perception of P may be updated <em>before</em> its perception of B, thus<br>leading to the following situation:</p>
<pre><code>(Q == &amp;B) and (D == 2) ????
</code></pre>
<p>Whilst this may seem like a failure of coherency or causality maintenance, it<br>isn’t, and this behaviour can be observed on certain real CPUs (such as the DEC<br>Alpha).</p>
<p>To deal with this, a data dependency barrier or better must be inserted<br>between the address load and the data load:</p>
<pre><code>CPU 1        CPU 2
===============    ===============
&#123; A == 1, B == 2, C = 3, P == &amp;A, Q == &amp;C &#125;
B = 4;
&lt;write barrier&gt;
P = &amp;B
        Q = P;
        &lt;data dependency barrier&gt;
        D = *Q;
</code></pre>
<p>This enforces the occurrence of one of the two implications, and prevents the<br>third possibility from arising.</p>
<p>[!] Note that this extremely counterintuitive situation arises most easily on<br>machines with split caches, so that, for example, one cache bank processes<br>even-numbered cache lines and the other bank processes odd-numbered cache<br>lines.  The pointer P might be stored in an odd-numbered cache line, and the<br>variable B might be stored in an even-numbered cache line.  Then, if the<br>even-numbered bank of the reading CPU’s cache is extremely busy while the<br>odd-numbered bank is idle, one can see the new value of the pointer P (&amp;B),<br>but the old value of the variable B (2).</p>
<p>Another example of where data dependency barriers might by required is where a<br>number is read from memory and then used to calculate the index for an array<br>access:</p>
<pre><code>CPU 1        CPU 2
===============    ===============
&#123; M[0] == 1, M[1] == 2, M[3] = 3, P == 0, Q == 3 &#125;
M[1] = 4;
&lt;write barrier&gt;
P = 1
        Q = P;
        &lt;data dependency barrier&gt;
        D = M[Q];
</code></pre>
<p>The data dependency barrier is very important to the RCU system, for example.<br>See rcu_dereference() in include/linux/rcupdate.h.  This permits the current<br>target of an RCU’d pointer to be replaced with a new modified target, without<br>the replacement target appearing to be incompletely initialised.</p>
<p>See also the subsection on “Cache Coherency” for a more thorough example.</p>
<h2 id="CONTROL-DEPENDENCIES"><a href="#CONTROL-DEPENDENCIES" class="headerlink" title="CONTROL DEPENDENCIES"></a>CONTROL DEPENDENCIES</h2><p>A control dependency requires a full read memory barrier, not simply a data<br>dependency barrier to make it work correctly.  Consider the following bit of<br>code:</p>
<pre><code>q = &amp;a;
if (p)
    q = &amp;b;
&lt;data dependency barrier&gt;
x = *q;
</code></pre>
<p>This will not have the desired effect because there is no actual data<br>dependency, but rather a control dependency that the CPU may short-circuit by<br>attempting to predict the outcome in advance.  In such a case what’s actually<br>required is:</p>
<pre><code>q = &amp;a;
if (p)
    q = &amp;b;
&lt;read barrier&gt;
x = *q;
</code></pre>
<h2 id="SMP-BARRIER-PAIRING"><a href="#SMP-BARRIER-PAIRING" class="headerlink" title="SMP BARRIER PAIRING"></a>SMP BARRIER PAIRING</h2><p>When dealing with CPU-CPU interactions, certain types of memory barrier should<br>always be paired.  A lack of appropriate pairing is almost certainly an error.</p>
<p>A write barrier should always be paired with a data dependency barrier or read<br>barrier, though a general barrier would also be viable.  Similarly a read<br>barrier or a data dependency barrier should always be paired with at least an<br>write barrier, though, again, a general barrier is viable:</p>
<pre><code>CPU 1        CPU 2
===============    ===============
a = 1;
&lt;write barrier&gt;
b = 2;        x = b;
        &lt;read barrier&gt;
        y = a;
</code></pre>
<p>Or:</p>
<pre><code>CPU 1        CPU 2
===============    ===============================
a = 1;
&lt;write barrier&gt;
b = &amp;a;        x = b;
        &lt;data dependency barrier&gt;
        y = *x;
</code></pre>
<p>Basically, the read barrier always has to be there, even though it can be of<br>the “weaker” type.</p>
<p>[!] Note that the stores before the write barrier would normally be expected to<br>match the loads after the read barrier or the data dependency barrier, and vice<br>versa:</p>
<pre><code>CPU 1                           CPU 2
===============                 ===============
a = 1;           &#125;----   ---&gt;&#123;  v = c
b = 2;           &#125;    \ /    &#123;  w = d
&lt;write barrier&gt;        \        &lt;read barrier&gt;
c = 3;           &#125;    / \    &#123;  x = a;
d = 4;           &#125;----   ---&gt;&#123;  y = b;
</code></pre>
<h2 id="EXAMPLES-OF-MEMORY-BARRIER-SEQUENCES"><a href="#EXAMPLES-OF-MEMORY-BARRIER-SEQUENCES" class="headerlink" title="EXAMPLES OF MEMORY BARRIER SEQUENCES"></a>EXAMPLES OF MEMORY BARRIER SEQUENCES</h2><p>Firstly, write barriers act as partial orderings on store operations.<br>Consider the following sequence of events:</p>
<pre><code>CPU 1
=======================
STORE A = 1
STORE B = 2
STORE C = 3
&lt;write barrier&gt;
STORE D = 4
STORE E = 5
</code></pre>
<p>This sequence of events is committed to the memory coherence system in an order<br>that the rest of the system might perceive as the unordered set of { STORE A,<br>STORE B, STORE C } all occurring before the unordered set of { STORE D, STORE E<br>}:</p>
<pre><code>+-------+       :      :
|       |       +------+
|       |------&gt;| C=3  |     &#125;     /\
|       |  :    +------+     &#125;-----  \  -----&gt; Events perceptible to
|       |  :    | A=1  |     &#125;        \/       the rest of the system
|       |  :    +------+     &#125;
| CPU 1 |  :    | B=2  |     &#125;
|       |       +------+     &#125;
|       |   wwwwwwwwwwwwwwww &#125;   &lt;--- At this point the write barrier
|       |       +------+     &#125;        requires all stores prior to the
|       |  :    | E=5  |     &#125;        barrier to be committed before
|       |  :    +------+     &#125;        further stores may take place
|       |------&gt;| D=4  |     &#125;
|       |       +------+
+-------+       :      :
                   |
                   | Sequence in which stores are committed to the
                   | memory system by CPU 1
                   V
</code></pre>
<p>Secondly, data dependency barriers act as partial orderings on data-dependent<br>loads.  Consider the following sequence of events:</p>
<pre><code>CPU 1            CPU 2
=======================    =======================
    &#123; B = 7; X = 9; Y = 8; C = &amp;Y &#125;
STORE A = 1
STORE B = 2
&lt;write barrier&gt;
STORE C = &amp;B        LOAD X
STORE D = 4        LOAD C (gets &amp;B)
            LOAD *C (reads B)
</code></pre>
<p>Without intervention, CPU 2 may perceive the events on CPU 1 in some<br>effectively random order, despite the write barrier issued by CPU 1:</p>
<pre><code>+-------+       :      :                :       :
|       |       +------+                +-------+  | Sequence of update
|       |------&gt;| B=2  |-----       ---&gt;| Y-&gt;8  |  | of perception on
|       |  :    +------+     \          +-------+  | CPU 2
| CPU 1 |  :    | A=1  |      \     ---&gt;| C-&gt;&amp;Y |  V
|       |       +------+       |        +-------+
|       |   wwwwwwwwwwwwwwww   |        :       :
|       |       +------+       |        :       :
|       |  :    | C=&amp;B |---    |        :       :       +-------+
|       |  :    +------+   \   |        +-------+       |       |
|       |------&gt;| D=4  |    -----------&gt;| C-&gt;&amp;B |------&gt;|       |
|       |       +------+       |        +-------+       |       |
+-------+       :      :       |        :       :       |       |
                               |        :       :       |       |
                               |        :       :       | CPU 2 |
                               |        +-------+       |       |
    Apparently incorrect ---&gt;  |        | B-&gt;7  |------&gt;|       |
    perception of B (!)        |        +-------+       |       |
                               |        :       :       |       |
                               |        +-------+       |       |
    The load of X holds ---&gt;    \       | X-&gt;9  |------&gt;|       |
    up the maintenance           \      +-------+       |       |
    of coherence of B             -----&gt;| B-&gt;2  |       +-------+
                                        +-------+
                                        :       :
</code></pre>
<p>In the above example, CPU 2 perceives that B is 7, despite the load of *C<br>(which would be B) coming after the LOAD of C.</p>
<p>If, however, a data dependency barrier were to be placed between the load of C<br>and the load of *C (ie: B) on CPU 2:</p>
<pre><code>CPU 1            CPU 2
=======================    =======================
    &#123; B = 7; X = 9; Y = 8; C = &amp;Y &#125;
STORE A = 1
STORE B = 2
&lt;write barrier&gt;
STORE C = &amp;B        LOAD X
STORE D = 4        LOAD C (gets &amp;B)
            &lt;data dependency barrier&gt;
            LOAD *C (reads B)
</code></pre>
<p>then the following will occur:</p>
<pre><code>+-------+       :      :                :       :
|       |       +------+                +-------+
|       |------&gt;| B=2  |-----       ---&gt;| Y-&gt;8  |
|       |  :    +------+     \          +-------+
| CPU 1 |  :    | A=1  |      \     ---&gt;| C-&gt;&amp;Y |
|       |       +------+       |        +-------+
|       |   wwwwwwwwwwwwwwww   |        :       :
|       |       +------+       |        :       :
|       |  :    | C=&amp;B |---    |        :       :       +-------+
|       |  :    +------+   \   |        +-------+       |       |
|       |------&gt;| D=4  |    -----------&gt;| C-&gt;&amp;B |------&gt;|       |
|       |       +------+       |        +-------+       |       |
+-------+       :      :       |        :       :       |       |
                               |        :       :       |       |
                               |        :       :       | CPU 2 |
                               |        +-------+       |       |
                               |        | X-&gt;9  |------&gt;|       |
                               |        +-------+       |       |
  Makes sure all effects ---&gt;   \   ddddddddddddddddd   |       |
  prior to the store of C        \      +-------+       |       |
  are perceptible to              -----&gt;| B-&gt;2  |------&gt;|       |
  subsequent loads                      +-------+       |       |
                                        :       :       +-------+
</code></pre>
<p>And thirdly, a read barrier acts as a partial order on loads.  Consider the<br>following sequence of events:</p>
<pre><code>CPU 1            CPU 2
=======================    =======================
    &#123; A = 0, B = 9 &#125;
STORE A=1
&lt;write barrier&gt;
STORE B=2
            LOAD B
            LOAD A
</code></pre>
<p>Without intervention, CPU 2 may then choose to perceive the events on CPU 1 in<br>some effectively random order, despite the write barrier issued by CPU 1:</p>
<pre><code>+-------+       :      :                :       :
|       |       +------+                +-------+
|       |------&gt;| A=1  |------      ---&gt;| A-&gt;0  |
|       |       +------+      \         +-------+
| CPU 1 |   wwwwwwwwwwwwwwww   \    ---&gt;| B-&gt;9  |
|       |       +------+        |       +-------+
|       |------&gt;| B=2  |---     |       :       :
|       |       +------+   \    |       :       :       +-------+
+-------+       :      :    \   |       +-------+       |       |
                             ----------&gt;| B-&gt;2  |------&gt;|       |
                                |       +-------+       | CPU 2 |
                                |       | A-&gt;0  |------&gt;|       |
                                |       +-------+       |       |
                                |       :       :       +-------+
                                 \      :       :
                                  \     +-------+
                                   ----&gt;| A-&gt;1  |
                                        +-------+
                                        :       :
</code></pre>
<p>If, however, a read barrier were to be placed between the load of B and the<br>load of A on CPU 2:</p>
<pre><code>CPU 1            CPU 2
=======================    =======================
    &#123; A = 0, B = 9 &#125;
STORE A=1
&lt;write barrier&gt;
STORE B=2
            LOAD B
            &lt;read barrier&gt;
            LOAD A
</code></pre>
<p>then the partial ordering imposed by CPU 1 will be perceived correctly by CPU<br>2:</p>
<pre><code>+-------+       :      :                :       :
|       |       +------+                +-------+
|       |------&gt;| A=1  |------      ---&gt;| A-&gt;0  |
|       |       +------+      \         +-------+
| CPU 1 |   wwwwwwwwwwwwwwww   \    ---&gt;| B-&gt;9  |
|       |       +------+        |       +-------+
|       |------&gt;| B=2  |---     |       :       :
|       |       +------+   \    |       :       :       +-------+
+-------+       :      :    \   |       +-------+       |       |
                             ----------&gt;| B-&gt;2  |------&gt;|       |
                                |       +-------+       | CPU 2 |
                                |       :       :       |       |
                                |       :       :       |       |
  At this point the read ----&gt;   \  rrrrrrrrrrrrrrrrr   |       |
  barrier causes all effects      \     +-------+       |       |
  prior to the storage of B        ----&gt;| A-&gt;1  |------&gt;|       |
  to be perceptible to CPU 2            +-------+       |       |
                                        :       :       +-------+
</code></pre>
<p>To illustrate this more completely, consider what could happen if the code<br>contained a load of A either side of the read barrier:</p>
<pre><code>CPU 1            CPU 2
=======================    =======================
    &#123; A = 0, B = 9 &#125;
STORE A=1
&lt;write barrier&gt;
STORE B=2
            LOAD B
            LOAD A [first load of A]
            &lt;read barrier&gt;
            LOAD A [second load of A]
</code></pre>
<p>Even though the two loads of A both occur after the load of B, they may both<br>come up with different values:</p>
<pre><code>+-------+       :      :                :       :
|       |       +------+                +-------+
|       |------&gt;| A=1  |------      ---&gt;| A-&gt;0  |
|       |       +------+      \         +-------+
| CPU 1 |   wwwwwwwwwwwwwwww   \    ---&gt;| B-&gt;9  |
|       |       +------+        |       +-------+
|       |------&gt;| B=2  |---     |       :       :
|       |       +------+   \    |       :       :       +-------+
+-------+       :      :    \   |       +-------+       |       |
                             ----------&gt;| B-&gt;2  |------&gt;|       |
                                |       +-------+       | CPU 2 |
                                |       :       :       |       |
                                |       :       :       |       |
                                |       +-------+       |       |
                                |       | A-&gt;0  |------&gt;| 1st   |
                                |       +-------+       |       |
  At this point the read ----&gt;   \  rrrrrrrrrrrrrrrrr   |       |
  barrier causes all effects      \     +-------+       |       |
  prior to the storage of B        ----&gt;| A-&gt;1  |------&gt;| 2nd   |
  to be perceptible to CPU 2            +-------+       |       |
                                        :       :       +-------+
</code></pre>
<p>But it may be that the update to A from CPU 1 becomes perceptible to CPU 2<br>before the read barrier completes anyway:</p>
<pre><code>+-------+       :      :                :       :
|       |       +------+                +-------+
|       |------&gt;| A=1  |------      ---&gt;| A-&gt;0  |
|       |       +------+      \         +-------+
| CPU 1 |   wwwwwwwwwwwwwwww   \    ---&gt;| B-&gt;9  |
|       |       +------+        |       +-------+
|       |------&gt;| B=2  |---     |       :       :
|       |       +------+   \    |       :       :       +-------+
+-------+       :      :    \   |       +-------+       |       |
                             ----------&gt;| B-&gt;2  |------&gt;|       |
                                |       +-------+       | CPU 2 |
                                |       :       :       |       |
                                 \      :       :       |       |
                                  \     +-------+       |       |
                                   ----&gt;| A-&gt;1  |------&gt;| 1st   |
                                        +-------+       |       |
                                    rrrrrrrrrrrrrrrrr   |       |
                                        +-------+       |       |
                                        | A-&gt;1  |------&gt;| 2nd   |
                                        +-------+       |       |
                                        :       :       +-------+
</code></pre>
<p>The guarantee is that the second load will always come up with A == 1 if the<br>load of B came up with B == 2.  No such guarantee exists for the first load of<br>A; that may come up with either A == 0 or A == 1.</p>
<h2 id="READ-MEMORY-BARRIERS-VS-LOAD-SPECULATION"><a href="#READ-MEMORY-BARRIERS-VS-LOAD-SPECULATION" class="headerlink" title="READ MEMORY BARRIERS VS LOAD SPECULATION"></a>READ MEMORY BARRIERS VS LOAD SPECULATION</h2><p>Many CPUs speculate with loads: that is they see that they will need to load an<br>item from memory, and they find a time where they’re not using the bus for any<br>other loads, and so do the load in advance - even though they haven’t actually<br>got to that point in the instruction execution flow yet.  This permits the<br>actual load instruction to potentially complete immediately because the CPU<br>already has the value to hand.</p>
<p>It may turn out that the CPU didn’t actually need the value - perhaps because a<br>branch circumvented the load - in which case it can discard the value or just<br>cache it for later use.</p>
<p>Consider:</p>
<pre><code>CPU 1               CPU 2
=======================    =======================
                LOAD B
                DIVIDE        &#125; Divide instructions generally
                DIVIDE        &#125; take a long time to perform
                LOAD A
</code></pre>
<p>Which might appear as this:</p>
<pre><code>                                        :       :       +-------+
                                        +-------+       |       |
                                    ---&gt;| B-&gt;2  |------&gt;|       |
                                        +-------+       | CPU 2 |
                                        :       :DIVIDE |       |
                                        +-------+       |       |
The CPU being busy doing a ---&gt;     ---&gt;| A-&gt;0  |~~~~   |       |
division speculates on the              +-------+   ~   |       |
LOAD of A                               :       :   ~   |       |
                                        :       :DIVIDE |       |
                                        :       :   ~   |       |
Once the divisions are complete --&gt;     :       :   ~--&gt;|       |
the CPU can then perform the            :       :       |       |
LOAD with immediate effect              :       :       +-------+
</code></pre>
<p>Placing a read barrier or a data dependency barrier just before the second<br>load:</p>
<pre><code>CPU 1               CPU 2
=======================    =======================
                LOAD B
                DIVIDE
                DIVIDE
            &lt;read barrier&gt;
                LOAD A
</code></pre>
<p>will force any value speculatively obtained to be reconsidered to an extent<br>dependent on the type of barrier used.  If there was no change made to the<br>speculated memory location, then the speculated value will just be used:</p>
<pre><code>                                        :       :       +-------+
                                        +-------+       |       |
                                    ---&gt;| B-&gt;2  |------&gt;|       |
                                        +-------+       | CPU 2 |
                                        :       :DIVIDE |       |
                                        +-------+       |       |
The CPU being busy doing a ---&gt;     ---&gt;| A-&gt;0  |~~~~   |       |
division speculates on the              +-------+   ~   |       |
LOAD of A                               :       :   ~   |       |
                                        :       :DIVIDE |       |
                                        :       :   ~   |       |
                                        :       :   ~   |       |
                                    rrrrrrrrrrrrrrrr~   |       |
                                        :       :   ~   |       |
                                        :       :   ~--&gt;|       |
                                        :       :       |       |
                                        :       :       +-------+
</code></pre>
<p>but if there was an update or an invalidation from another CPU pending, then<br>the speculation will be cancelled and the value reloaded:</p>
<pre><code>                                        :       :       +-------+
                                        +-------+       |       |
                                    ---&gt;| B-&gt;2  |------&gt;|       |
                                        +-------+       | CPU 2 |
                                        :       :DIVIDE |       |
                                        +-------+       |       |
The CPU being busy doing a ---&gt;     ---&gt;| A-&gt;0  |~~~~   |       |
division speculates on the              +-------+   ~   |       |
LOAD of A                               :       :   ~   |       |
                                        :       :DIVIDE |       |
                                        :       :   ~   |       |
                                        :       :   ~   |       |
                                    rrrrrrrrrrrrrrrrr   |       |
                                        +-------+       |       |
The speculation is discarded ---&gt;   ---&gt;| A-&gt;1  |------&gt;|       |
and an updated value is                 +-------+       |       |
retrieved                               :       :       +-------+
</code></pre>
<h2 id="TRANSITIVITY"><a href="#TRANSITIVITY" class="headerlink" title="TRANSITIVITY"></a>TRANSITIVITY</h2><p>Transitivity is a deeply intuitive notion about ordering that is not<br>always provided by real computer systems.  The following example<br>demonstrates transitivity (also called “cumulativity”):</p>
<pre><code>CPU 1            CPU 2            CPU 3
=======================    =======================    =======================
    &#123; X = 0, Y = 0 &#125;
STORE X=1        LOAD X            STORE Y=1
            &lt;general barrier&gt;    &lt;general barrier&gt;
            LOAD Y            LOAD X
</code></pre>
<p>Suppose that CPU 2’s load from X returns 1 and its load from Y returns 0.<br>This indicates that CPU 2’s load from X in some sense follows CPU 1’s<br>store to X and that CPU 2’s load from Y in some sense preceded CPU 3’s<br>store to Y.  The question is then “Can CPU 3’s load from X return 0?”</p>
<p>Because CPU 2’s load from X in some sense came after CPU 1’s store, it<br>is natural to expect that CPU 3’s load from X must therefore return 1.<br>This expectation is an example of transitivity: if a load executing on<br>CPU A follows a load from the same variable executing on CPU B, then<br>CPU A’s load must either return the same value that CPU B’s load did,<br>or must return some later value.</p>
<p>In the Linux kernel, use of general memory barriers guarantees<br>transitivity.  Therefore, in the above example, if CPU 2’s load from X<br>returns 1 and its load from Y returns 0, then CPU 3’s load from X must<br>also return 1.</p>
<p>However, transitivity is -not- guaranteed for read or write barriers.<br>For example, suppose that CPU 2’s general barrier in the above example<br>is changed to a read barrier as shown below:</p>
<pre><code>CPU 1            CPU 2            CPU 3
=======================    =======================    =======================
    &#123; X = 0, Y = 0 &#125;
STORE X=1        LOAD X            STORE Y=1
            &lt;read barrier&gt;        &lt;general barrier&gt;
            LOAD Y            LOAD X
</code></pre>
<p>This substitution destroys transitivity: in this example, it is perfectly<br>legal for CPU 2’s load from X to return 1, its load from Y to return 0,<br>and CPU 3’s load from X to return 0.</p>
<p>The key point is that although CPU 2’s read barrier orders its pair<br>of loads, it does not guarantee to order CPU 1’s store.  Therefore, if<br>this example runs on a system where CPUs 1 and 2 share a store buffer<br>or a level of cache, CPU 2 might have early access to CPU 1’s writes.<br>General barriers are therefore required to ensure that all CPUs agree<br>on the combined order of CPU 1’s and CPU 2’s accesses.</p>
<p>To reiterate, if your code requires transitivity, use general barriers<br>throughout.</p>
<p>========================<br>EXPLICIT KERNEL BARRIERS<br>========================</p>
<p>The Linux kernel has a variety of different barriers that act at different<br>levels:</p>
<p>  (*) Compiler barrier.</p>
<p>  (*) CPU memory barriers.</p>
<p>  (*) MMIO write barrier.</p>
<h2 id="COMPILER-BARRIER"><a href="#COMPILER-BARRIER" class="headerlink" title="COMPILER BARRIER"></a>COMPILER BARRIER</h2><p>The Linux kernel has an explicit compiler barrier function that prevents the<br>compiler from moving the memory accesses either side of it to the other side:</p>
<pre><code>barrier();
</code></pre>
<p>This is a general barrier - lesser varieties of compiler barrier do not exist.</p>
<p>The compiler barrier has no direct effect on the CPU, which may then reorder<br>things however it wishes.</p>
<h2 id="CPU-MEMORY-BARRIERS"><a href="#CPU-MEMORY-BARRIERS" class="headerlink" title="CPU MEMORY BARRIERS"></a>CPU MEMORY BARRIERS</h2><p>The Linux kernel has eight basic CPU memory barriers:</p>
<pre><code>TYPE        MANDATORY        SMP CONDITIONAL
===============    =======================    ===========================
GENERAL        mb()            smp_mb()
WRITE        wmb()            smp_wmb()
READ        rmb()            smp_rmb()
DATA DEPENDENCY    read_barrier_depends()    smp_read_barrier_depends()
</code></pre>
<p>All memory barriers except the data dependency barriers imply a compiler<br>barrier. Data dependencies do not impose any additional compiler ordering.</p>
<p>Aside: In the case of data dependencies, the compiler would be expected to<br>issue the loads in the correct order (eg. <code>a[b]</code> would have to load the value<br>of b before loading a[b]), however there is no guarantee in the C specification<br>that the compiler may not speculate the value of b (eg. is equal to 1) and load<br>a before b (eg. tmp = a[1]; if (b != 1) tmp = a[b]; ). There is also the<br>problem of a compiler reloading b after having loaded a[b], thus having a newer<br>copy of b than a[b]. A consensus has not yet been reached about these problems,<br>however the ACCESS_ONCE macro is a good place to start looking.</p>
<p>SMP memory barriers are reduced to compiler barriers on uniprocessor compiled<br>systems because it is assumed that a CPU will appear to be self-consistent,<br>and will order overlapping accesses correctly with respect to itself.</p>
<p>[!] Note that SMP memory barriers <em>must</em> be used to control the ordering of<br>references to shared memory on SMP systems, though the use of locking instead<br>is sufficient.</p>
<p>Mandatory barriers should not be used to control SMP effects, since mandatory<br>barriers unnecessarily impose overhead on UP systems. They may, however, be<br>used to control MMIO effects on accesses through relaxed memory I/O windows.<br>These are required even on non-SMP systems as they affect the order in which<br>memory operations appear to a device by prohibiting both the compiler and the<br>CPU from reordering them.</p>
<p>There are some more advanced barrier functions:</p>
<p> (*) set_mb(var, value)</p>
<pre><code> This assigns the value to the variable and then inserts a full memory
 barrier after it, depending on the function.  It isn&#39;t guaranteed to
 insert anything more than a compiler barrier in a UP compilation.
</code></pre>
<p> (<em>) smp_mb__before_atomic_dec();<br> (</em>) smp_mb__after_atomic_dec();<br> (<em>) smp_mb__before_atomic_inc();<br> (</em>) smp_mb__after_atomic_inc();</p>
<pre><code> These are for use with atomic add, subtract, increment and decrement
 functions that don&#39;t return a value, especially when used for reference
 counting.  These functions do not imply memory barriers.

 As an example, consider a piece of code that marks an object as being dead
 and then decrements the object&#39;s reference count:

obj-&gt;dead = 1;
smp_mb__before_atomic_dec();
atomic_dec(&amp;obj-&gt;ref_count);

 This makes sure that the death mark on the object is perceived to be set
 *before* the reference counter is decremented.

 See Documentation/atomic_ops.txt for more information.  See the &quot;Atomic
 operations&quot; subsection for information on where to use these.
</code></pre>
<p> (<em>) smp_mb__before_clear_bit(void);<br> (</em>) smp_mb__after_clear_bit(void);</p>
<pre><code> These are for use similar to the atomic inc/dec barriers.  These are
 typically used for bitwise unlocking operations, so care must be taken as
 there are no implicit memory barriers here either.

 Consider implementing an unlock operation of some nature by clearing a
 locking bit.  The clear_bit() would then need to be barriered like this:

smp_mb__before_clear_bit();
clear_bit( ... );

 This prevents memory operations before the clear leaking to after it.  See
 the subsection on &quot;Locking Functions&quot; with reference to UNLOCK operation
 implications.

 See Documentation/atomic_ops.txt for more information.  See the &quot;Atomic
 operations&quot; subsection for information on where to use these.
</code></pre>
<p> (<em>) dma_wmb();<br> (</em>) dma_rmb();</p>
<pre><code> These are for use with consistent memory to guarantee the ordering
 of writes or reads of shared memory accessible to both the CPU and a
 DMA capable device.

 For example, consider a device driver that shares memory with a device
 and uses a descriptor status value to indicate if the descriptor belongs
 to the device or the CPU, and a doorbell to notify it when new
 descriptors are available:

if (desc-&gt;status != DEVICE_OWN) &#123;
    /* do not read data until we own descriptor */
    dma_rmb();

    /* read/modify data */
    read_data = desc-&gt;data;
    desc-&gt;data = write_data;

    /* flush modifications before status update */
    dma_wmb();

    /* assign ownership */
    desc-&gt;status = DEVICE_OWN;

    /* force memory to sync before notifying device via MMIO */
    wmb();

    /* notify device of new descriptors */
    writel(DESC_NOTIFY, doorbell);
&#125;

 The dma_rmb() allows us guarantee the device has released ownership
 before we read the data from the descriptor, and he dma_wmb() allows
 us to guarantee the data is written to the descriptor before the device
 can see it now has ownership.  The wmb() is needed to guarantee that the
 cache coherent memory writes have completed before attempting a write to
 the cache incoherent MMIO region.

 See Documentation/DMA-API.txt for more information on consistent memory.
</code></pre>
<h2 id="MMIO-WRITE-BARRIER"><a href="#MMIO-WRITE-BARRIER" class="headerlink" title="MMIO WRITE BARRIER"></a>MMIO WRITE BARRIER</h2><p>The Linux kernel also has a special barrier for use with memory-mapped I/O<br>writes:</p>
<pre><code>mmiowb();
</code></pre>
<p>This is a variation on the mandatory write barrier that causes writes to weakly<br>ordered I/O regions to be partially ordered.  Its effects may go beyond the<br>CPU-&gt;Hardware interface and actually affect the hardware at some level.</p>
<p>See the subsection “Locks vs I/O accesses” for more information.</p>
<p>===============================<br>IMPLICIT KERNEL MEMORY BARRIERS<br>===============================</p>
<p>Some of the other functions in the linux kernel imply memory barriers, amongst<br>which are locking and scheduling functions.</p>
<p>This specification is a <em>minimum</em> guarantee; any particular architecture may<br>provide more substantial guarantees, but these may not be relied upon outside<br>of arch specific code.</p>
<h2 id="LOCKING-FUNCTIONS"><a href="#LOCKING-FUNCTIONS" class="headerlink" title="LOCKING FUNCTIONS"></a>LOCKING FUNCTIONS</h2><p>The Linux kernel has a number of locking constructs:</p>
<p> (<em>) spin locks<br> (</em>) R/W spin locks<br> (<em>) mutexes<br> (</em>) semaphores<br> (<em>) R/W semaphores<br> (</em>) RCU</p>
<p>In all cases there are variants on “LOCK” operations and “UNLOCK” operations<br>for each construct.  These operations all imply certain barriers:</p>
<p> (1) LOCK operation implication:</p>
<pre><code> Memory operations issued after the LOCK will be completed after the LOCK
 operation has completed.

 Memory operations issued before the LOCK may be completed after the LOCK
 operation has completed.
</code></pre>
<p> (2) UNLOCK operation implication:</p>
<pre><code> Memory operations issued before the UNLOCK will be completed before the
 UNLOCK operation has completed.

 Memory operations issued after the UNLOCK may be completed before the
 UNLOCK operation has completed.
</code></pre>
<p> (3) LOCK vs LOCK implication:</p>
<pre><code> All LOCK operations issued before another LOCK operation will be completed
 before that LOCK operation.
</code></pre>
<p> (4) LOCK vs UNLOCK implication:</p>
<pre><code> All LOCK operations issued before an UNLOCK operation will be completed
 before the UNLOCK operation.

 All UNLOCK operations issued before a LOCK operation will be completed
 before the LOCK operation.
</code></pre>
<p> (5) Failed conditional LOCK implication:</p>
<pre><code> Certain variants of the LOCK operation may fail, either due to being
 unable to get the lock immediately, or due to receiving an unblocked
 signal whilst asleep waiting for the lock to become available.  Failed
 locks do not imply any sort of barrier.
</code></pre>
<p>Therefore, from (1), (2) and (4) an UNLOCK followed by an unconditional LOCK is<br>equivalent to a full barrier, but a LOCK followed by an UNLOCK is not.</p>
<p>[!] Note: one of the consequences of LOCKs and UNLOCKs being only one-way<br>    barriers is that the effects of instructions outside of a critical section<br>    may seep into the inside of the critical section.</p>
<p>A LOCK followed by an UNLOCK may not be assumed to be full memory barrier<br>because it is possible for an access preceding the LOCK to happen after the<br>LOCK, and an access following the UNLOCK to happen before the UNLOCK, and the<br>two accesses can themselves then cross:</p>
<pre><code>*A = a;
LOCK
UNLOCK
*B = b;
</code></pre>
<p>may occur as:</p>
<pre><code>LOCK, STORE *B, STORE *A, UNLOCK
</code></pre>
<p>Locks and semaphores may not provide any guarantee of ordering on UP compiled<br>systems, and so cannot be counted on in such a situation to actually achieve<br>anything at all - especially with respect to I/O accesses - unless combined<br>with interrupt disabling operations.</p>
<p>See also the section on “Inter-CPU locking barrier effects”.</p>
<p>As an example, consider the following:</p>
<pre><code>*A = a;
*B = b;
LOCK
*C = c;
*D = d;
UNLOCK
*E = e;
*F = f;
</code></pre>
<p>The following sequence of events is acceptable:</p>
<pre><code>LOCK, &#123;*F,*A&#125;, *E, &#123;*C,*D&#125;, *B, UNLOCK

[+] Note that &#123;*F,*A&#125; indicates a combined access.
</code></pre>
<p>But none of the following are:</p>
<pre><code>&#123;*F,*A&#125;, *B,    LOCK, *C, *D,    UNLOCK, *E
*A, *B, *C,    LOCK, *D,    UNLOCK, *E, *F
*A, *B,        LOCK, *C,    UNLOCK, *D, *E, *F
*B,        LOCK, *C, *D,    UNLOCK, &#123;*F,*A&#125;, *E
</code></pre>
<h2 id="INTERRUPT-DISABLING-FUNCTIONS"><a href="#INTERRUPT-DISABLING-FUNCTIONS" class="headerlink" title="INTERRUPT DISABLING FUNCTIONS"></a>INTERRUPT DISABLING FUNCTIONS</h2><p>Functions that disable interrupts (LOCK equivalent) and enable interrupts<br>(UNLOCK equivalent) will act as compiler barriers only.  So if memory or I/O<br>barriers are required in such a situation, they must be provided from some<br>other means.</p>
<h2 id="SLEEP-AND-WAKE-UP-FUNCTIONS"><a href="#SLEEP-AND-WAKE-UP-FUNCTIONS" class="headerlink" title="SLEEP AND WAKE-UP FUNCTIONS"></a>SLEEP AND WAKE-UP FUNCTIONS</h2><p>Sleeping and waking on an event flagged in global data can be viewed as an<br>interaction between two pieces of data: the task state of the task waiting for<br>the event and the global data used to indicate the event.  To make sure that<br>these appear to happen in the right order, the primitives to begin the process<br>of going to sleep, and the primitives to initiate a wake up imply certain<br>barriers.</p>
<p>Firstly, the sleeper normally follows something like this sequence of events:</p>
<pre><code>for (;;) &#123;
    set_current_state(TASK_UNINTERRUPTIBLE);
    if (event_indicated)
        break;
    schedule();
&#125;
</code></pre>
<p>A general memory barrier is interpolated automatically by set_current_state()<br>after it has altered the task state:</p>
<pre><code>CPU 1
===============================
set_current_state();
  set_mb();
    STORE current-&gt;state
    &lt;general barrier&gt;
LOAD event_indicated
</code></pre>
<p>set_current_state() may be wrapped by:</p>
<pre><code>prepare_to_wait();
prepare_to_wait_exclusive();
</code></pre>
<p>which therefore also imply a general memory barrier after setting the state.<br>The whole sequence above is available in various canned forms, all of which<br>interpolate the memory barrier in the right place:</p>
<pre><code>wait_event();
wait_event_interruptible();
wait_event_interruptible_exclusive();
wait_event_interruptible_timeout();
wait_event_killable();
wait_event_timeout();
wait_on_bit();
wait_on_bit_lock();
</code></pre>
<p>Secondly, code that performs a wake up normally follows something like this:</p>
<pre><code>event_indicated = 1;
wake_up(&amp;event_wait_queue);
</code></pre>
<p>or:</p>
<pre><code>event_indicated = 1;
wake_up_process(event_daemon);
</code></pre>
<p>A write memory barrier is implied by wake_up() and co. if and only if they wake<br>something up.  The barrier occurs before the task state is cleared, and so sits<br>between the STORE to indicate the event and the STORE to set TASK_RUNNING:</p>
<pre><code>CPU 1                CPU 2
===============================    ===============================
set_current_state();        STORE event_indicated
  set_mb();            wake_up();
    STORE current-&gt;state      &lt;write barrier&gt;
    &lt;general barrier&gt;          STORE current-&gt;state
LOAD event_indicated
</code></pre>
<p>The available waker functions include:</p>
<pre><code>complete();
wake_up();
wake_up_all();
wake_up_bit();
wake_up_interruptible();
wake_up_interruptible_all();
wake_up_interruptible_nr();
wake_up_interruptible_poll();
wake_up_interruptible_sync();
wake_up_interruptible_sync_poll();
wake_up_locked();
wake_up_locked_poll();
wake_up_nr();
wake_up_poll();
wake_up_process();
</code></pre>
<p>[!] Note that the memory barriers implied by the sleeper and the waker do <em>not</em><br>order multiple stores before the wake-up with respect to loads of those stored<br>values after the sleeper has called set_current_state().  For instance, if the<br>sleeper does:</p>
<pre><code>set_current_state(TASK_INTERRUPTIBLE);
if (event_indicated)
    break;
__set_current_state(TASK_RUNNING);
do_something(my_data);
</code></pre>
<p>and the waker does:</p>
<pre><code>my_data = value;
event_indicated = 1;
wake_up(&amp;event_wait_queue);
</code></pre>
<p>there’s no guarantee that the change to event_indicated will be perceived by<br>the sleeper as coming after the change to my_data.  In such a circumstance, the<br>code on both sides must interpolate its own memory barriers between the<br>separate data accesses.  Thus the above sleeper ought to do:</p>
<pre><code>set_current_state(TASK_INTERRUPTIBLE);
if (event_indicated) &#123;
    smp_rmb();
    do_something(my_data);
&#125;
</code></pre>
<p>and the waker should do:</p>
<pre><code>my_data = value;
smp_wmb();
event_indicated = 1;
wake_up(&amp;event_wait_queue);
</code></pre>
<h2 id="MISCELLANEOUS-FUNCTIONS"><a href="#MISCELLANEOUS-FUNCTIONS" class="headerlink" title="MISCELLANEOUS FUNCTIONS"></a>MISCELLANEOUS FUNCTIONS</h2><p>Other functions that imply barriers:</p>
<p> (*) schedule() and similar imply full memory barriers.</p>
<p>=================================<br>INTER-CPU LOCKING BARRIER EFFECTS<br>=================================</p>
<p>On SMP systems locking primitives give a more substantial form of barrier: one<br>that does affect memory access ordering on other CPUs, within the context of<br>conflict on any particular lock.</p>
<h2 id="LOCKS-VS-MEMORY-ACCESSES"><a href="#LOCKS-VS-MEMORY-ACCESSES" class="headerlink" title="LOCKS VS MEMORY ACCESSES"></a>LOCKS VS MEMORY ACCESSES</h2><p>Consider the following: the system has a pair of spinlocks (M) and (Q), and<br>three CPUs; then should the following sequence of events occur:</p>
<pre><code>CPU 1                CPU 2
===============================    ===============================
*A = a;                *E = e;
LOCK M                LOCK Q
*B = b;                *F = f;
*C = c;                *G = g;
UNLOCK M            UNLOCK Q
*D = d;                *H = h;
</code></pre>
<p>Then there is no guarantee as to what order CPU 3 will see the accesses to *A<br>through *H occur in, other than the constraints imposed by the separate locks<br>on the separate CPUs. It might, for example, see:</p>
<pre><code>*E, LOCK M, LOCK Q, *G, *C, *F, *A, *B, UNLOCK Q, *D, *H, UNLOCK M
</code></pre>
<p>But it won’t see any of:</p>
<pre><code>*B, *C or *D preceding LOCK M
*A, *B or *C following UNLOCK M
*F, *G or *H preceding LOCK Q
*E, *F or *G following UNLOCK Q
</code></pre>
<p>However, if the following occurs:</p>
<pre><code>CPU 1                CPU 2
===============================    ===============================
*A = a;
LOCK M        [1]
*B = b;
*C = c;
UNLOCK M    [1]
*D = d;                *E = e;
                LOCK M        [2]
                *F = f;
                *G = g;
                UNLOCK M    [2]
                *H = h;
</code></pre>
<p>CPU 3 might see:</p>
<pre><code>*E, LOCK M [1], *C, *B, *A, UNLOCK M [1],
    LOCK M [2], *H, *F, *G, UNLOCK M [2], *D
</code></pre>
<p>But assuming CPU 1 gets the lock first, CPU 3 won’t see any of:</p>
<pre><code>*B, *C, *D, *F, *G or *H preceding LOCK M [1]
*A, *B or *C following UNLOCK M [1]
*F, *G or *H preceding LOCK M [2]
*A, *B, *C, *E, *F or *G following UNLOCK M [2]
</code></pre>
<h2 id="LOCKS-VS-I-O-ACCESSES"><a href="#LOCKS-VS-I-O-ACCESSES" class="headerlink" title="LOCKS VS I/O ACCESSES"></a>LOCKS VS I/O ACCESSES</h2><p>Under certain circumstances (especially involving NUMA), I/O accesses within<br>two spinlocked sections on two different CPUs may be seen as interleaved by the<br>PCI bridge, because the PCI bridge does not necessarily participate in the<br>cache-coherence protocol, and is therefore incapable of issuing the required<br>read memory barriers.</p>
<p>For example:</p>
<pre><code>CPU 1                CPU 2
===============================    ===============================
spin_lock(Q)
writel(0, ADDR)
writel(1, DATA);
spin_unlock(Q);
                spin_lock(Q);
                writel(4, ADDR);
                writel(5, DATA);
                spin_unlock(Q);
</code></pre>
<p>may be seen by the PCI bridge as follows:</p>
<pre><code>STORE *ADDR = 0, STORE *ADDR = 4, STORE *DATA = 1, STORE *DATA = 5
</code></pre>
<p>which would probably cause the hardware to malfunction.</p>
<p>What is necessary here is to intervene with an mmiowb() before dropping the<br>spinlock, for example:</p>
<pre><code>CPU 1                CPU 2
===============================    ===============================
spin_lock(Q)
writel(0, ADDR)
writel(1, DATA);
mmiowb();
spin_unlock(Q);
                spin_lock(Q);
                writel(4, ADDR);
                writel(5, DATA);
                mmiowb();
                spin_unlock(Q);
</code></pre>
<p>this will ensure that the two stores issued on CPU 1 appear at the PCI bridge<br>before either of the stores issued on CPU 2.</p>
<p>Furthermore, following a store by a load from the same device obviates the need<br>for the mmiowb(), because the load forces the store to complete before the load<br>is performed:</p>
<pre><code>CPU 1                CPU 2
===============================    ===============================
spin_lock(Q)
writel(0, ADDR)
a = readl(DATA);
spin_unlock(Q);
                spin_lock(Q);
                writel(4, ADDR);
                b = readl(DATA);
                spin_unlock(Q);
</code></pre>
<p>See Documentation/DocBook/deviceiobook.tmpl for more information.</p>
<p>=================================<br>WHERE ARE MEMORY BARRIERS NEEDED?<br>=================================</p>
<p>Under normal operation, memory operation reordering is generally not going to<br>be a problem as a single-threaded linear piece of code will still appear to<br>work correctly, even if it’s in an SMP kernel.  There are, however, four<br>circumstances in which reordering definitely <em>could</em> be a problem:</p>
<p> (*) Interprocessor interaction.</p>
<p> (*) Atomic operations.</p>
<p> (*) Accessing devices.</p>
<p> (*) Interrupts.</p>
<h2 id="INTERPROCESSOR-INTERACTION"><a href="#INTERPROCESSOR-INTERACTION" class="headerlink" title="INTERPROCESSOR INTERACTION"></a>INTERPROCESSOR INTERACTION</h2><p>When there’s a system with more than one processor, more than one CPU in the<br>system may be working on the same data set at the same time.  This can cause<br>synchronisation problems, and the usual way of dealing with them is to use<br>locks.  Locks, however, are quite expensive, and so it may be preferable to<br>operate without the use of a lock if at all possible.  In such a case<br>operations that affect both CPUs may have to be carefully ordered to prevent<br>a malfunction.</p>
<p>Consider, for example, the R/W semaphore slow path.  Here a waiting process is<br>queued on the semaphore, by virtue of it having a piece of its stack linked to<br>the semaphore’s list of waiting processes:</p>
<pre><code>struct rw_semaphore &#123;
    ...
    spinlock_t lock;
    struct list_head waiters;
&#125;;

struct rwsem_waiter &#123;
    struct list_head list;
    struct task_struct *task;
&#125;;
</code></pre>
<p>To wake up a particular waiter, the up_read() or up_write() functions have to:</p>
<p> (1) read the next pointer from this waiter’s record to know as to where the<br>     next waiter record is;</p>
<p> (2) read the pointer to the waiter’s task structure;</p>
<p> (3) clear the task pointer to tell the waiter it has been given the semaphore;</p>
<p> (4) call wake_up_process() on the task; and</p>
<p> (5) release the reference held on the waiter’s task struct.</p>
<p>In other words, it has to perform this sequence of events:</p>
<pre><code>LOAD waiter-&gt;list.next;
LOAD waiter-&gt;task;
STORE waiter-&gt;task;
CALL wakeup
RELEASE task
</code></pre>
<p>and if any of these steps occur out of order, then the whole thing may<br>malfunction.</p>
<p>Once it has queued itself and dropped the semaphore lock, the waiter does not<br>get the lock again; it instead just waits for its task pointer to be cleared<br>before proceeding.  Since the record is on the waiter’s stack, this means that<br>if the task pointer is cleared <em>before</em> the next pointer in the list is read,<br>another CPU might start processing the waiter and might clobber the waiter’s<br>stack before the up*() function has a chance to read the next pointer.</p>
<p>Consider then what might happen to the above sequence of events:</p>
<pre><code>CPU 1                CPU 2
===============================    ===============================
                down_xxx()
                Queue waiter
                Sleep
up_yyy()
LOAD waiter-&gt;task;
STORE waiter-&gt;task;
                Woken up by other event
&lt;preempt&gt;
                Resume processing
                down_xxx() returns
                call foo()
                foo() clobbers *waiter
&lt;/preempt&gt;
LOAD waiter-&gt;list.next;
--- OOPS ---
</code></pre>
<p>This could be dealt with using the semaphore lock, but then the down_xxx()<br>function has to needlessly get the spinlock again after being woken up.</p>
<p>The way to deal with this is to insert a general SMP memory barrier:</p>
<pre><code>LOAD waiter-&gt;list.next;
LOAD waiter-&gt;task;
smp_mb();
STORE waiter-&gt;task;
CALL wakeup
RELEASE task
</code></pre>
<p>In this case, the barrier makes a guarantee that all memory accesses before the<br>barrier will appear to happen before all the memory accesses after the barrier<br>with respect to the other CPUs on the system.  It does <em>not</em> guarantee that all<br>the memory accesses before the barrier will be complete by the time the barrier<br>instruction itself is complete.</p>
<p>On a UP system - where this wouldn’t be a problem - the smp_mb() is just a<br>compiler barrier, thus making sure the compiler emits the instructions in the<br>right order without actually intervening in the CPU.  Since there’s only one<br>CPU, that CPU’s dependency ordering logic will take care of everything else.</p>
<h2 id="ATOMIC-OPERATIONS"><a href="#ATOMIC-OPERATIONS" class="headerlink" title="ATOMIC OPERATIONS"></a>ATOMIC OPERATIONS</h2><p>Whilst they are technically interprocessor interaction considerations, atomic<br>operations are noted specially as some of them imply full memory barriers and<br>some don’t, but they’re very heavily relied on as a group throughout the<br>kernel.</p>
<p>Any atomic operation that modifies some state in memory and returns information<br>about the state (old or new) implies an SMP-conditional general memory barrier<br>(smp_mb()) on each side of the actual operation (with the exception of<br>explicit lock operations, described later).  These include:</p>
<pre><code>xchg();
cmpxchg();
atomic_xchg();
atomic_cmpxchg();
atomic_inc_return();
atomic_dec_return();
atomic_add_return();
atomic_sub_return();
atomic_inc_and_test();
atomic_dec_and_test();
atomic_sub_and_test();
atomic_add_negative();
atomic_add_unless();    /* when succeeds (returns 1) */
test_and_set_bit();
test_and_clear_bit();
test_and_change_bit();
</code></pre>
<p>These are used for such things as implementing LOCK-class and UNLOCK-class<br>operations and adjusting reference counters towards object destruction, and as<br>such the implicit memory barrier effects are necessary.</p>
<p>The following operations are potential problems as they do <em>not</em> imply memory<br>barriers, but might be used for implementing such things as UNLOCK-class<br>operations:</p>
<pre><code>atomic_set();
set_bit();
clear_bit();
change_bit();
</code></pre>
<p>With these the appropriate explicit memory barrier should be used if necessary<br>(smp_mb__before_clear_bit() for instance).</p>
<p>The following also do <em>not</em> imply memory barriers, and so may require explicit<br>memory barriers under some circumstances (smp_mb__before_atomic_dec() for<br>instance):</p>
<pre><code>atomic_add();
atomic_sub();
atomic_inc();
atomic_dec();
</code></pre>
<p>If they’re used for statistics generation, then they probably don’t need memory<br>barriers, unless there’s a coupling between statistical data.</p>
<p>If they’re used for reference counting on an object to control its lifetime,<br>they probably don’t need memory barriers because either the reference count<br>will be adjusted inside a locked section, or the caller will already hold<br>sufficient references to make the lock, and thus a memory barrier unnecessary.</p>
<p>If they’re used for constructing a lock of some description, then they probably<br>do need memory barriers as a lock primitive generally has to do things in a<br>specific order.</p>
<p>Basically, each usage case has to be carefully considered as to whether memory<br>barriers are needed or not.</p>
<p>The following operations are special locking primitives:</p>
<pre><code>test_and_set_bit_lock();
clear_bit_unlock();
__clear_bit_unlock();
</code></pre>
<p>These implement LOCK-class and UNLOCK-class operations. These should be used in<br>preference to other operations when implementing locking primitives, because<br>their implementations can be optimised on many architectures.</p>
<p>[!] Note that special memory barrier primitives are available for these<br>situations because on some CPUs the atomic instructions used imply full memory<br>barriers, and so barrier instructions are superfluous in conjunction with them,<br>and in such cases the special barrier primitives will be no-ops.</p>
<p>See Documentation/atomic_ops.txt for more information.</p>
<h2 id="ACCESSING-DEVICES"><a href="#ACCESSING-DEVICES" class="headerlink" title="ACCESSING DEVICES"></a>ACCESSING DEVICES</h2><p>Many devices can be memory mapped, and so appear to the CPU as if they’re just<br>a set of memory locations.  To control such a device, the driver usually has to<br>make the right memory accesses in exactly the right order.</p>
<p>However, having a clever CPU or a clever compiler creates a potential problem<br>in that the carefully sequenced accesses in the driver code won’t reach the<br>device in the requisite order if the CPU or the compiler thinks it is more<br>efficient to reorder, combine or merge accesses - something that would cause<br>the device to malfunction.</p>
<p>Inside of the Linux kernel, I/O should be done through the appropriate accessor<br>routines - such as inb() or writel() - which know how to make such accesses<br>appropriately sequential.  Whilst this, for the most part, renders the explicit<br>use of memory barriers unnecessary, there are a couple of situations where they<br>might be needed:</p>
<p> (1) On some systems, I/O stores are not strongly ordered across all CPUs, and<br>     so for <em>all</em> general drivers locks should be used and mmiowb() must be<br>     issued prior to unlocking the critical section.</p>
<p> (2) If the accessor functions are used to refer to an I/O memory window with<br>     relaxed memory access properties, then <em>mandatory</em> memory barriers are<br>     required to enforce ordering.</p>
<p>See Documentation/DocBook/deviceiobook.tmpl for more information.</p>
<h2 id="INTERRUPTS"><a href="#INTERRUPTS" class="headerlink" title="INTERRUPTS"></a>INTERRUPTS</h2><p>A driver may be interrupted by its own interrupt service routine, and thus the<br>two parts of the driver may interfere with each other’s attempts to control or<br>access the device.</p>
<p>This may be alleviated - at least in part - by disabling local interrupts (a<br>form of locking), such that the critical operations are all contained within<br>the interrupt-disabled section in the driver.  Whilst the driver’s interrupt<br>routine is executing, the driver’s core may not run on the same CPU, and its<br>interrupt is not permitted to happen again until the current interrupt has been<br>handled, thus the interrupt handler does not need to lock against that.</p>
<p>However, consider a driver that was talking to an ethernet card that sports an<br>address register and a data register.  If that driver’s core talks to the card<br>under interrupt-disablement and then the driver’s interrupt handler is invoked:</p>
<pre><code>LOCAL IRQ DISABLE
writew(ADDR, 3);
writew(DATA, y);
LOCAL IRQ ENABLE
&lt;interrupt&gt;
writew(ADDR, 4);
q = readw(DATA);
&lt;/interrupt&gt;
</code></pre>
<p>The store to the data register might happen after the second store to the<br>address register if ordering rules are sufficiently relaxed:</p>
<pre><code>STORE *ADDR = 3, STORE *ADDR = 4, STORE *DATA = y, q = LOAD *DATA
</code></pre>
<p>If ordering rules are relaxed, it must be assumed that accesses done inside an<br>interrupt disabled section may leak outside of it and may interleave with<br>accesses performed in an interrupt - and vice versa - unless implicit or<br>explicit barriers are used.</p>
<p>Normally this won’t be a problem because the I/O accesses done inside such<br>sections will include synchronous load operations on strictly ordered I/O<br>registers that form implicit I/O barriers. If this isn’t sufficient then an<br>mmiowb() may need to be used explicitly.</p>
<p>A similar situation may occur between an interrupt routine and two routines<br>running on separate CPUs that communicate with each other. If such a case is<br>likely, then interrupt-disabling locks should be used to guarantee ordering.</p>
<p>==========================<br>KERNEL I/O BARRIER EFFECTS<br>==========================</p>
<p>When accessing I/O memory, drivers should use the appropriate accessor<br>functions:</p>
<p> (*) inX(), outX():</p>
<pre><code> These are intended to talk to I/O space rather than memory space, but
 that&#39;s primarily a CPU-specific concept. The i386 and x86_64 processors do
 indeed have special I/O space access cycles and instructions, but many
 CPUs don&#39;t have such a concept.

 The PCI bus, amongst others, defines an I/O space concept which - on such
 CPUs as i386 and x86_64 - readily maps to the CPU&#39;s concept of I/O
 space.  However, it may also be mapped as a virtual I/O space in the CPU&#39;s
 memory map, particularly on those CPUs that don&#39;t support alternate I/O
 spaces.

 Accesses to this space may be fully synchronous (as on i386), but
 intermediary bridges (such as the PCI host bridge) may not fully honour
 that.

 They are guaranteed to be fully ordered with respect to each other.

 They are not guaranteed to be fully ordered with respect to other types of
 memory and I/O operation.
</code></pre>
<p> (*) readX(), writeX():</p>
<pre><code> Whether these are guaranteed to be fully ordered and uncombined with
 respect to each other on the issuing CPU depends on the characteristics
 defined for the memory window through which they&#39;re accessing. On later
 i386 architecture machines, for example, this is controlled by way of the
 MTRR registers.

 Ordinarily, these will be guaranteed to be fully ordered and uncombined,
 provided they&#39;re not accessing a prefetchable device.

 However, intermediary hardware (such as a PCI bridge) may indulge in
 deferral if it so wishes; to flush a store, a load from the same location
 is preferred[*], but a load from the same device or from configuration
 space should suffice for PCI.

 [*] NOTE! attempting to load from the same location as was written to may
      cause a malfunction - consider the 16550 Rx/Tx serial registers for
      example.

 Used with prefetchable I/O memory, an mmiowb() barrier may be required to
 force stores to be ordered.

 Please refer to the PCI specification for more information on interactions
 between PCI transactions.
</code></pre>
<p> (*) readX_relaxed()</p>
<pre><code> These are similar to readX(), but are not guaranteed to be ordered in any
 way. Be aware that there is no I/O read barrier available.
</code></pre>
<p> (*) ioreadX(), iowriteX()</p>
<pre><code> These will perform appropriately for the type of access they&#39;re actually
 doing, be it inX()/outX() or readX()/writeX().
</code></pre>
<p>========================================<br>ASSUMED MINIMUM EXECUTION ORDERING MODEL<br>========================================</p>
<p>It has to be assumed that the conceptual CPU is weakly-ordered but that it will<br>maintain the appearance of program causality with respect to itself.  Some CPUs<br>(such as i386 or x86_64) are more constrained than others (such as powerpc or<br>frv), and so the most relaxed case (namely DEC Alpha) must be assumed outside<br>of arch-specific code.</p>
<p>This means that it must be considered that the CPU will execute its instruction<br>stream in any order it feels like - or even in parallel - provided that if an<br>instruction in the stream depends on an earlier instruction, then that<br>earlier instruction must be sufficiently complete[*] before the later<br>instruction may proceed; in other words: provided that the appearance of<br>causality is maintained.</p>
<p> [*] Some instructions have more than one effect - such as changing the<br>     condition codes, changing registers or changing memory - and different<br>     instructions may depend on different effects.</p>
<p>A CPU may also discard any instruction sequence that winds up having no<br>ultimate effect.  For example, if two adjacent instructions both load an<br>immediate value into the same register, the first may be discarded.</p>
<p>Similarly, it has to be assumed that compiler might reorder the instruction<br>stream in any way it sees fit, again provided the appearance of causality is<br>maintained.</p>
<p>============================<br>THE EFFECTS OF THE CPU CACHE<br>============================</p>
<p>The way cached memory operations are perceived across the system is affected to<br>a certain extent by the caches that lie between CPUs and memory, and by the<br>memory coherence system that maintains the consistency of state in the system.</p>
<p>As far as the way a CPU interacts with another part of the system through the<br>caches goes, the memory system has to include the CPU’s caches, and memory<br>barriers for the most part act at the interface between the CPU and its cache<br>(memory barriers logically act on the dotted line in the following diagram):</p>
<pre><code>    &lt;--- CPU ---&gt;         :       &lt;----------- Memory -----------&gt;
                          :
+--------+    +--------+  :   +--------+    +-----------+
|        |    |        |  :   |        |    |           |    +--------+
|  CPU   |    | Memory |  :   | CPU    |    |           |    |          |
|  Core  |---&gt;| Access |-----&gt;| Cache  |&lt;--&gt;|           |    |          |
|        |    | Queue  |  :   |        |    |           |---&gt;| Memory |
|        |    |        |  :   |        |    |           |    |          |
+--------+    +--------+  :   +--------+    |           |    |           |
                          :                 | Cache     |    +--------+
                          :                 | Coherency |
                          :                 | Mechanism |    +--------+
+--------+    +--------+  :   +--------+    |           |    |          |
|        |    |        |  :   |        |    |           |    |        |
|  CPU   |    | Memory |  :   | CPU    |    |           |---&gt;| Device |
|  Core  |---&gt;| Access |-----&gt;| Cache  |&lt;--&gt;|           |    |           |
|        |    | Queue  |  :   |        |    |           |    |           |
|        |    |        |  :   |        |    |           |    +--------+
+--------+    +--------+  :   +--------+    +-----------+
                          :
                          :
</code></pre>
<p>Although any particular load or store may not actually appear outside of the<br>CPU that issued it since it may have been satisfied within the CPU’s own cache,<br>it will still appear as if the full memory access had taken place as far as the<br>other CPUs are concerned since the cache coherency mechanisms will migrate the<br>cacheline over to the accessing CPU and propagate the effects upon conflict.</p>
<p>The CPU core may execute instructions in any order it deems fit, provided the<br>expected program causality appears to be maintained.  Some of the instructions<br>generate load and store operations which then go into the queue of memory<br>accesses to be performed.  The core may place these in the queue in any order<br>it wishes, and continue execution until it is forced to wait for an instruction<br>to complete.</p>
<p>What memory barriers are concerned with is controlling the order in which<br>accesses cross from the CPU side of things to the memory side of things, and<br>the order in which the effects are perceived to happen by the other observers<br>in the system.</p>
<p>[!] Memory barriers are <em>not</em> needed within a given CPU, as CPUs always see<br>their own loads and stores as if they had happened in program order.</p>
<p>[!] MMIO or other device accesses may bypass the cache system.  This depends on<br>the properties of the memory window through which devices are accessed and/or<br>the use of any special device communication instructions the CPU may have.</p>
<h2 id="CACHE-COHERENCY"><a href="#CACHE-COHERENCY" class="headerlink" title="CACHE COHERENCY"></a>CACHE COHERENCY</h2><p>Life isn’t quite as simple as it may appear above, however: for while the<br>caches are expected to be coherent, there’s no guarantee that that coherency<br>will be ordered.  This means that whilst changes made on one CPU will<br>eventually become visible on all CPUs, there’s no guarantee that they will<br>become apparent in the same order on those other CPUs.</p>
<p>Consider dealing with a system that has a pair of CPUs (1 &amp; 2), each of which<br>has a pair of parallel data caches (CPU 1 has A/B, and CPU 2 has C/D):</p>
<pre><code>            :
            :                          +--------+
            :      +---------+         |        |
+--------+  : +---&gt;| Cache A |&lt;-------&gt;|        |
|        |  : |    +---------+         |        |
|  CPU 1 |&lt;---+                        |        |
|        |  : |    +---------+         |        |
+--------+  : +---&gt;| Cache B |&lt;-------&gt;|        |
            :      +---------+         |        |
            :                          | Memory |
            :      +---------+         | System |
+--------+  : +---&gt;| Cache C |&lt;-------&gt;|        |
|        |  : |    +---------+         |        |
|  CPU 2 |&lt;---+                        |        |
|        |  : |    +---------+         |        |
+--------+  : +---&gt;| Cache D |&lt;-------&gt;|        |
            :      +---------+         |        |
            :                          +--------+
            :
</code></pre>
<p>Imagine the system has the following properties:</p>
<p> (*) an odd-numbered cache line may be in cache A, cache C or it may still be<br>     resident in memory;</p>
<p> (*) an even-numbered cache line may be in cache B, cache D or it may still be<br>     resident in memory;</p>
<p> (*) whilst the CPU core is interrogating one cache, the other cache may be<br>     making use of the bus to access the rest of the system - perhaps to<br>     displace a dirty cacheline or to do a speculative load;</p>
<p> (*) each cache has a queue of operations that need to be applied to that cache<br>     to maintain coherency with the rest of the system;</p>
<p> (*) the coherency queue is not flushed by normal loads to lines already<br>     present in the cache, even though the contents of the queue may<br>     potentially affect those loads.</p>
<p>Imagine, then, that two writes are made on the first CPU, with a write barrier<br>between them to guarantee that they will appear to reach that CPU’s caches in<br>the requisite order:</p>
<pre><code>CPU 1        CPU 2        COMMENT
===============    ===============    =======================================
                u == 0, v == 1 and p == &amp;u, q == &amp;u
v = 2;
smp_wmb();            Make sure change to v is visible before
                 change to p
&lt;A:modify v=2&gt;            v is now in cache A exclusively
p = &amp;v;
&lt;B:modify p=&amp;v&gt;            p is now in cache B exclusively
</code></pre>
<p>The write memory barrier forces the other CPUs in the system to perceive that<br>the local CPU’s caches have apparently been updated in the correct order.  But<br>now imagine that the second CPU wants to read those values:</p>
<pre><code>CPU 1        CPU 2        COMMENT
===============    ===============    =======================================
...
        q = p;
        x = *q;
</code></pre>
<p>The above pair of reads may then fail to happen in the expected order, as the<br>cacheline holding p may get updated in one of the second CPU’s caches whilst<br>the update to the cacheline holding v is delayed in the other of the second<br>CPU’s caches by some other cache event:</p>
<pre><code>CPU 1        CPU 2        COMMENT
===============    ===============    =======================================
                u == 0, v == 1 and p == &amp;u, q == &amp;u
v = 2;
smp_wmb();
&lt;A:modify v=2&gt;    &lt;C:busy&gt;
        &lt;C:queue v=2&gt;
p = &amp;v;        q = p;
        &lt;D:request p&gt;
&lt;B:modify p=&amp;v&gt;    &lt;D:commit p=&amp;v&gt;
          &lt;D:read p&gt;
        x = *q;
        &lt;C:read *q&gt;    Reads from v before v updated in cache
        &lt;C:unbusy&gt;
        &lt;C:commit v=2&gt;
</code></pre>
<p>Basically, whilst both cachelines will be updated on CPU 2 eventually, there’s<br>no guarantee that, without intervention, the order of update will be the same<br>as that committed on CPU 1.</p>
<p>To intervene, we need to interpolate a data dependency barrier or a read<br>barrier between the loads.  This will force the cache to commit its coherency<br>queue before processing any further requests:</p>
<pre><code>CPU 1        CPU 2        COMMENT
===============    ===============    =======================================
                u == 0, v == 1 and p == &amp;u, q == &amp;u
v = 2;
smp_wmb();
&lt;A:modify v=2&gt;    &lt;C:busy&gt;
        &lt;C:queue v=2&gt;
p = &amp;v;        q = p;
        &lt;D:request p&gt;
&lt;B:modify p=&amp;v&gt;    &lt;D:commit p=&amp;v&gt;
          &lt;D:read p&gt;
        smp_read_barrier_depends()
        &lt;C:unbusy&gt;
        &lt;C:commit v=2&gt;
        x = *q;
        &lt;C:read *q&gt;    Reads from v after v updated in cache
</code></pre>
<p>This sort of problem can be encountered on DEC Alpha processors as they have a<br>split cache that improves performance by making better use of the data bus.<br>Whilst most CPUs do imply a data dependency barrier on the read when a memory<br>access depends on a read, not all do, so it may not be relied on.</p>
<p>Other CPUs may also have split caches, but must coordinate between the various<br>cachelets for normal memory accesses.  The semantics of the Alpha removes the<br>need for coordination in the absence of memory barriers.</p>
<h2 id="CACHE-COHERENCY-VS-DMA"><a href="#CACHE-COHERENCY-VS-DMA" class="headerlink" title="CACHE COHERENCY VS DMA"></a>CACHE COHERENCY VS DMA</h2><p>Not all systems maintain cache coherency with respect to devices doing DMA.  In<br>such cases, a device attempting DMA may obtain stale data from RAM because<br>dirty cache lines may be resident in the caches of various CPUs, and may not<br>have been written back to RAM yet.  To deal with this, the appropriate part of<br>the kernel must flush the overlapping bits of cache on each CPU (and maybe<br>invalidate them as well).</p>
<p>In addition, the data DMA’d to RAM by a device may be overwritten by dirty<br>cache lines being written back to RAM from a CPU’s cache after the device has<br>installed its own data, or cache lines present in the CPU’s cache may simply<br>obscure the fact that RAM has been updated, until at such time as the cacheline<br>is discarded from the CPU’s cache and reloaded.  To deal with this, the<br>appropriate part of the kernel must invalidate the overlapping bits of the<br>cache on each CPU.</p>
<p>See Documentation/cachetlb.txt for more information on cache management.</p>
<h2 id="CACHE-COHERENCY-VS-MMIO"><a href="#CACHE-COHERENCY-VS-MMIO" class="headerlink" title="CACHE COHERENCY VS MMIO"></a>CACHE COHERENCY VS MMIO</h2><p>Memory mapped I/O usually takes place through memory locations that are part of<br>a window in the CPU’s memory space that has different properties assigned than<br>the usual RAM directed window.</p>
<p>Amongst these properties is usually the fact that such accesses bypass the<br>caching entirely and go directly to the device buses.  This means MMIO accesses<br>may, in effect, overtake accesses to cached memory that were emitted earlier.<br>A memory barrier isn’t sufficient in such a case, but rather the cache must be<br>flushed between the cached memory write and the MMIO access if the two are in<br>any way dependent.</p>
<p>=========================<br>THE THINGS CPUS GET UP TO<br>=========================</p>
<p>A programmer might take it for granted that the CPU will perform memory<br>operations in exactly the order specified, so that if the CPU is, for example,<br>given the following piece of code to execute:</p>
<pre><code>a = *A;
*B = b;
c = *C;
d = *D;
*E = e;
</code></pre>
<p>they would then expect that the CPU will complete the memory operation for each<br>instruction before moving on to the next one, leading to a definite sequence of<br>operations as seen by external observers in the system:</p>
<pre><code>LOAD *A, STORE *B, LOAD *C, LOAD *D, STORE *E.
</code></pre>
<p>Reality is, of course, much messier.  With many CPUs and compilers, the above<br>assumption doesn’t hold because:</p>
<p> (*) loads are more likely to need to be completed immediately to permit<br>     execution progress, whereas stores can often be deferred without a<br>     problem;</p>
<p> (*) loads may be done speculatively, and the result discarded should it prove<br>     to have been unnecessary;</p>
<p> (*) loads may be done speculatively, leading to the result having been fetched<br>     at the wrong time in the expected sequence of events;</p>
<p> (*) the order of the memory accesses may be rearranged to promote better use<br>     of the CPU buses and caches;</p>
<p> (*) loads and stores may be combined to improve performance when talking to<br>     memory or I/O hardware that can do batched accesses of adjacent locations,<br>     thus cutting down on transaction setup costs (memory and PCI devices may<br>     both be able to do this); and</p>
<p> (*) the CPU’s data cache may affect the ordering, and whilst cache-coherency<br>     mechanisms may alleviate this - once the store has actually hit the cache<br>     - there’s no guarantee that the coherency management will be propagated in<br>     order to other CPUs.</p>
<p>So what another CPU, say, might actually observe from the above piece of code<br>is:</p>
<pre><code>LOAD *A, ..., LOAD &#123;*C,*D&#125;, STORE *E, STORE *B

(Where &quot;LOAD &#123;*C,*D&#125;&quot; is a combined load)
</code></pre>
<p>However, it is guaranteed that a CPU will be self-consistent: it will see its<br><em>own</em> accesses appear to be correctly ordered, without the need for a memory<br>barrier.  For instance with the following code:</p>
<pre><code>U = *A;
*A = V;
*A = W;
X = *A;
*A = Y;
Z = *A;
</code></pre>
<p>and assuming no intervention by an external influence, it can be assumed that<br>the final result will appear to be:</p>
<pre><code>U == the original value of *A
X == W
Z == Y
*A == Y
</code></pre>
<p>The code above may cause the CPU to generate the full sequence of memory<br>accesses:</p>
<pre><code>U=LOAD *A, STORE *A=V, STORE *A=W, X=LOAD *A, STORE *A=Y, Z=LOAD *A
</code></pre>
<p>in that order, but, without intervention, the sequence may have almost any<br>combination of elements combined or discarded, provided the program’s view of<br>the world remains consistent.</p>
<p>The compiler may also combine, discard or defer elements of the sequence before<br>the CPU even sees them.</p>
<p>For instance:</p>
<pre><code>*A = V;
*A = W;
</code></pre>
<p>may be reduced to:</p>
<pre><code>*A = W;
</code></pre>
<p>since, without a write barrier, it can be assumed that the effect of the<br>storage of V to *A is lost.  Similarly:</p>
<pre><code>*A = Y;
Z = *A;
</code></pre>
<p>may, without a memory barrier, be reduced to:</p>
<pre><code>*A = Y;
Z = Y;
</code></pre>
<p>and the LOAD operation never appear outside of the CPU.</p>
<h2 id="AND-THEN-THERE’S-THE-ALPHA"><a href="#AND-THEN-THERE’S-THE-ALPHA" class="headerlink" title="AND THEN THERE’S THE ALPHA"></a>AND THEN THERE’S THE ALPHA</h2><p>The DEC Alpha CPU is one of the most relaxed CPUs there is.  Not only that,<br>some versions of the Alpha CPU have a split data cache, permitting them to have<br>two semantically-related cache lines updated at separate times.  This is where<br>the data dependency barrier really becomes necessary as this synchronises both<br>caches with the memory coherence system, thus making it seem like pointer<br>changes vs new data occur in the right order.</p>
<p>The Alpha defines the Linux kernel’s memory barrier model.</p>
<p>See the subsection on “Cache Coherency” above.</p>
<p>============<br>EXAMPLE USES<br>============</p>
<h2 id="CIRCULAR-BUFFERS"><a href="#CIRCULAR-BUFFERS" class="headerlink" title="CIRCULAR BUFFERS"></a>CIRCULAR BUFFERS</h2><p>Memory barriers can be used to implement circular buffering without the need<br>of a lock to serialise the producer with the consumer.  See:</p>
<pre><code>Documentation/circular-buffers.txt
</code></pre>
<p>for details.</p>
<p>==========<br>REFERENCES<br>==========</p>
<p>Alpha AXP Architecture Reference Manual, Second Edition (Sites &amp; Witek,<br>Digital Press)<br>    Chapter 5.2: Physical Address Space Characteristics<br>    Chapter 5.4: Caches and Write Buffers<br>    Chapter 5.5: Data Sharing<br>    Chapter 5.6: Read/Write Ordering</p>
<p>AMD64 Architecture Programmer’s Manual Volume 2: System Programming<br>    Chapter 7.1: Memory-Access Ordering<br>    Chapter 7.4: Buffering and Combining Memory Writes</p>
<p>IA-32 Intel Architecture Software Developer’s Manual, Volume 3:<br>System Programming Guide<br>    Chapter 7.1: Locked Atomic Operations<br>    Chapter 7.2: Memory Ordering<br>    Chapter 7.4: Serializing Instructions</p>
<p>The SPARC Architecture Manual, Version 9<br>    Chapter 8: Memory Models<br>    Appendix D: Formal Specification of the Memory Models<br>    Appendix J: Programming with the Memory Models</p>
<p>UltraSPARC Programmer Reference Manual<br>    Chapter 5: Memory Accesses and Cacheability<br>    Chapter 15: Sparc-V9 Memory Models</p>
<p>UltraSPARC III Cu User’s Manual<br>    Chapter 9: Memory Models</p>
<p>UltraSPARC IIIi Processor User’s Manual<br>    Chapter 8: Memory Models</p>
<p>UltraSPARC Architecture 2005<br>    Chapter 9: Memory<br>    Appendix D: Formal Specifications of the Memory Models</p>
<p>UltraSPARC T1 Supplement to the UltraSPARC Architecture 2005<br>    Chapter 8: Memory Models<br>    Appendix F: Caches and Cache Coherency</p>
<p>Solaris Internals, Core Kernel Architecture, p63-68:<br>    Chapter 3.3: Hardware Considerations for Locks and<br>            Synchronization</p>
<p>Unix Systems for Modern Architectures, Symmetric Multiprocessing and Caching<br>for Kernel Programmers:<br>    Chapter 13: Other Memory Models</p>
<p>Intel Itanium Architecture Software Developer’s Manual: Volume 1:<br>    Section 2.6: Speculation<br>    Section 4.4: Memory Access</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_memory-barriers/" title="Kernel-3.10.0-957.el7_memory-barriers" target="_blank" rel="external">http://www.oostech.com/2021/03/13/Kernel-3.10.0-957.el7_memory-barriers/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="" target="_blank"><span class="text-dark">oosTech by Sam Lee</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    

  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_Debugging390/" title="Kernel-3.10.0-957.el7_Debugging390"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/03/13/Kernel-3.10.0-957.el7_proc/" title="Kernel-3.10.0-957.el7_proc"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,wechat"></div>
    
  </div>
  </div>
    <div class="container" align="left">
    <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
      <img src="/images/wechatp.png" itemprop="contentUrl">
      <span>欢迎关注公众号</span>
    </div>
    </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>您能有收获就是我们最大的动力</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码捐赠</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">不管多少都是对分享的肯定</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码捐赠</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>




</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://google.com/" target="_blank" title="Google" data-toggle=tooltip data-placement=top><i class="icon icon-google"></i></a></li>
        
        <li><a href="https://twitter.com/" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
	<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" text-align: center >粤ICP备2021024811号</a>
        </div>
<!--    
    <div>
     <img src="/images/logo.png" width="140" height="140">
    </div>
-->
    </div>


        <!-- 不蒜子统计    //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <!--<span id="busuanzi_container_site_pv" style="display:inline;">-->本站总访问量<span id="busuanzi_value_site_pv" style="display:inline;></span>次</span>
        <span class="post-meta-divider">|</span>
  
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>







   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>











</body>
</html>